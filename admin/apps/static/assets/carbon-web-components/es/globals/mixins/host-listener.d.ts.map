{"version":3,"sources":["globals/mixins/host-listener.ts"],"names":[],"mappings":"AAAA;;;;;;;GAOG;AAGH,OAAO,MAAM,MAAM,oBAAoB,CAAC;AAOxC;;;GAGG;AACH,QAAA,MAAM,iBAAiB;;QAKnB;;;WAGG;kBACO,GAAG,CAAC,MAAM,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA6CrB;;;OAGG;;;;;;;;KAWN,CAAC;AAEF,eAAe,iBAAiB,CAAC","file":"host-listener.d.ts","sourcesContent":["/**\n * @license\n *\n * Copyright IBM Corp. 2019, 2020\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport on from 'carbon-components/es/globals/js/misc/on';\nimport Handle from '../internal/handle';\n\n/**\n * The format for the event name used by `@HostListener` decorator.\n */\nconst EVENT_NAME_FORMAT = /^((document|window|parentRoot|shadowRoot):)?([\\w-]+)$/;\n\n/**\n * @param Base The base class.\n * @returns A mix-in that sets up and cleans up event listeners defined by `@HostListener` decorator.\n */\nconst HostListenerMixin = <T extends Constructor<HTMLElement>>(Base: T) => {\n  /**\n   * A mix-in class that sets up and cleans up event listeners defined by `@HostListener` decorator.\n   */\n  class HostListenerMixinImpl extends Base {\n    /**\n     * The list of handles managed by this mix-in.\n     * @private\n     */\n    _handles: Set<Handle> = new Set(); // Not using TypeScript `private` due to: microsoft/TypeScript#17744\n\n    connectedCallback() {\n      // @ts-ignore: Until `connectedCallback` is added to `HTMLElement` definition\n      super.connectedCallback();\n      const hostListeners = (this.constructor as typeof HostListenerMixinImpl)._hostListeners;\n      Object.keys(hostListeners).forEach(listenerName => {\n        Object.keys(hostListeners[listenerName]).forEach(type => {\n          // Parses `document:click`/`window:click` format\n          const tokens = EVENT_NAME_FORMAT.exec(type);\n          if (!tokens) {\n            throw new Error(`Could not parse the event name: ${listenerName}`);\n          }\n          const [, , targetName, unprefixedType] = tokens;\n          const target: EventTarget =\n            {\n              document: this.ownerDocument,\n              window: this.ownerDocument!.defaultView,\n              parentRoot: this.getRootNode(),\n              shadowRoot: this.shadowRoot,\n            }[targetName] || this;\n\n          const { options } = hostListeners[listenerName][type];\n\n          this._handles.add(\n            on(\n              target,\n              ((this.constructor as typeof Base)[unprefixedType] ?? unprefixedType) as keyof HTMLElementEventMap,\n              this[listenerName],\n              options\n            )\n          );\n        });\n      });\n    }\n\n    disconnectedCallback() {\n      this._handles.forEach(handle => {\n        handle.release();\n        this._handles.delete(handle);\n      });\n      // @ts-ignore: Until `disconnectedCallback` is added to `HTMLElement` definition\n      super.disconnectedCallback();\n    }\n\n    /**\n     * The map, keyed by method name, of event listeners that should be attached to host element or host document.\n     * @private\n     */\n    static _hostListeners: {\n      [listenerName: string]: {\n        [type: string]: {\n          options?: boolean | AddEventListenerOptions;\n        };\n      };\n    } = {}; // Not using TypeScript `private` due to: microsoft/TypeScript#17744\n  }\n\n  return HostListenerMixinImpl;\n};\n\nexport default HostListenerMixin;\n"]}