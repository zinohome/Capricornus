{"version":3,"sources":["globals/internal/radio-group-manager.ts"],"names":["NAVIGATION_DIRECTION","RadioGroupManager","constructor","document","_instances","set","shouldBeFocusable","radio","checked","name","group","_groups","hasSelectedItemInGroup","Array","from","some","item","isFirstInGroup","size","getSortedGroup","sort","lhs","rhs","comparisonResult","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","DOCUMENT_POSITION_CONTAINED_BY","DOCUMENT_POSITION_PRECEDING","DOCUMENT_POSITION_CONTAINS","add","groups","Set","delete","select","tabIndex","focus","forEach","navigate","direction","sortedGroup","newIndex","indexOf","length","get","found","WeakMap"],"mappings":"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","sourcesContent":["/**\n * @license\n *\n * Copyright IBM Corp. 2019\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * The navigation direction.\n */\nexport enum NAVIGATION_DIRECTION {\n  /**\n   * Navigating backward.\n   */\n  BACKWARD = -1,\n\n  /**\n   * Navigating forward.\n   */\n  FORWARD = 1,\n}\n\nexport interface ManagedRadioButtonDelegate {\n  /**\n   * `true` if this radio button is selected.\n   */\n  checked: boolean;\n\n  /**\n   * The tab index.\n   */\n  tabIndex: number;\n\n  /**\n   * The name of the radio group.\n   */\n  name: string;\n\n  /**\n   * @param other A node to compare this radio button's DOM position in document with.\n   * @returns\n   *   An integer value, the same format as `Node.compareDocumentPosition` does,\n   *   whose bits represent the calling this radio button's relationship to the given node within the document.\n   */\n  compareDocumentPosition(other: ManagedRadioButtonDelegate): number;\n\n  /**\n   * Focuses on the radio button.\n   */\n  focus(): void;\n}\n\ntype ManagedRadioButton = HTMLInputElement | ManagedRadioButtonDelegate;\n\n/**\n * An object that manages radio groups in a document.\n * There must be only one instance for one document.\n */\nclass RadioGroupManager {\n  /**\n   * Radio groups, keyed by their names.\n   */\n  private _groups: { [name: string]: Set<ManagedRadioButton> } = {};\n\n  private constructor(document: Document) {\n    (this.constructor as typeof RadioGroupManager)._instances.set(document, this);\n  }\n\n  /**\n   * @param radio A radio button.\n   * @returns\n   *   `true` if the given radio button should be focusable, which is either:\n   *   - The radio button is selected\n   *   - No radio button is selected and the radio button is first one in the radio group\n   */\n  shouldBeFocusable(radio: ManagedRadioButton) {\n    if (radio.checked) {\n      return true;\n    }\n    const { name } = radio;\n    const group = this._groups[name];\n    const hasSelectedItemInGroup = group && Array.from(group).some(item => item.checked);\n    if (hasSelectedItemInGroup) {\n      return false;\n    }\n    const isFirstInGroup = !group || group.size === 1 || this.getSortedGroup(radio)[0] === radio;\n    return isFirstInGroup;\n  }\n\n  /**\n   * @param radio A radio button.\n   * @returns The sorted radio group the given radio button is in.\n   */\n  getSortedGroup(radio: ManagedRadioButton) {\n    const group = this._groups[radio.name];\n    return (\n      group &&\n      Array.from(group).sort((lhs, rhs) => {\n        const comparisonResult = (lhs as ManagedRadioButtonDelegate).compareDocumentPosition(rhs as ManagedRadioButtonDelegate);\n        // eslint-disable-next-line no-bitwise\n        if (comparisonResult & Node.DOCUMENT_POSITION_FOLLOWING || comparisonResult & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n          return -1;\n        }\n        // eslint-disable-next-line no-bitwise\n        if (comparisonResult & Node.DOCUMENT_POSITION_PRECEDING || comparisonResult & Node.DOCUMENT_POSITION_CONTAINS) {\n          return 1;\n        }\n        return 0;\n      })\n    );\n  }\n\n  /**\n   * Manages a radio button.\n   * @param radio The radio button to manage.\n   * @returns This object.\n   */\n  add(radio: ManagedRadioButton) {\n    const { name } = radio;\n    if (name) {\n      const groups = this._groups;\n      if (!groups[name]) {\n        groups[name] = new Set<ManagedRadioButton>();\n      }\n      groups[name].add(radio);\n    }\n    return this;\n  }\n\n  /**\n   * Unmanages a radio button.\n   * @param radio The radio button to unmanage.\n   * @param name The old name of the radio button to unmanage.\n   * @returns `true` if `element` was actually managed.\n   */\n  delete(radio: ManagedRadioButton, name: string = radio.name) {\n    const group = this._groups[name];\n    return !group ? false : group.delete(radio);\n  }\n\n  /**\n   * Selects or focuses on a radio button.\n   * @param radio The radio button to select.\n   */\n  select(radio: ManagedRadioButton) {\n    const group = this._groups[radio.name];\n    if (group) {\n      // Updates the state of the one being selected up-front to avoid the state of no radio button is selected\n      radio.checked = true;\n      radio.tabIndex = 0;\n      radio.focus();\n      group.forEach(item => {\n        if (radio !== item) {\n          item.checked = false;\n          item.tabIndex = -1;\n        }\n      });\n    }\n  }\n\n  /**\n   * @param radio The currently selected radio button.\n   * @param direction The direction to navigate to.\n   * @returns The radio button that should be selected next.\n   */\n  navigate(radio: ManagedRadioButton, direction: NAVIGATION_DIRECTION) {\n    const sortedGroup = this.getSortedGroup(radio);\n    let newIndex = sortedGroup.indexOf(radio) + direction;\n    if (newIndex < 0) {\n      newIndex = sortedGroup.length - 1;\n    } else if (newIndex >= sortedGroup.length) {\n      newIndex = 0;\n    }\n    return sortedGroup[newIndex];\n  }\n\n  /**\n   * `RadioGroupManager` instances associated with documents.\n   */\n  private static _instances = new WeakMap();\n\n  /**\n   * @param document A document element.\n   * @returns The `RadioGroupManager` instance associated with the given document.\n   */\n  static get(document: Document) {\n    const found = this._instances.get(document);\n    return found || new RadioGroupManager(document);\n  }\n}\n\nexport default RadioGroupManager;\n"],"file":"radio-group-manager.js"}