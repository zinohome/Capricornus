/*!
 * vuerd
 * @version 2.2.10 | Tue Nov 09 2021
 * @author dineug <dineug2@gmail.com>
 * @license MIT
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.vuerd = {}));
}(this, (function (exports) { 'use strict';

    /**
     * The Ease class provides a collection of easing functions for use with tween.js.
     */
    var Easing = {
        Linear: {
            None: function (amount) {
                return amount;
            },
        },
        Quadratic: {
            In: function (amount) {
                return amount * amount;
            },
            Out: function (amount) {
                return amount * (2 - amount);
            },
            InOut: function (amount) {
                if ((amount *= 2) < 1) {
                    return 0.5 * amount * amount;
                }
                return -0.5 * (--amount * (amount - 2) - 1);
            },
        },
        Cubic: {
            In: function (amount) {
                return amount * amount * amount;
            },
            Out: function (amount) {
                return --amount * amount * amount + 1;
            },
            InOut: function (amount) {
                if ((amount *= 2) < 1) {
                    return 0.5 * amount * amount * amount;
                }
                return 0.5 * ((amount -= 2) * amount * amount + 2);
            },
        },
        Quartic: {
            In: function (amount) {
                return amount * amount * amount * amount;
            },
            Out: function (amount) {
                return 1 - --amount * amount * amount * amount;
            },
            InOut: function (amount) {
                if ((amount *= 2) < 1) {
                    return 0.5 * amount * amount * amount * amount;
                }
                return -0.5 * ((amount -= 2) * amount * amount * amount - 2);
            },
        },
        Quintic: {
            In: function (amount) {
                return amount * amount * amount * amount * amount;
            },
            Out: function (amount) {
                return --amount * amount * amount * amount * amount + 1;
            },
            InOut: function (amount) {
                if ((amount *= 2) < 1) {
                    return 0.5 * amount * amount * amount * amount * amount;
                }
                return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);
            },
        },
        Sinusoidal: {
            In: function (amount) {
                return 1 - Math.cos((amount * Math.PI) / 2);
            },
            Out: function (amount) {
                return Math.sin((amount * Math.PI) / 2);
            },
            InOut: function (amount) {
                return 0.5 * (1 - Math.cos(Math.PI * amount));
            },
        },
        Exponential: {
            In: function (amount) {
                return amount === 0 ? 0 : Math.pow(1024, amount - 1);
            },
            Out: function (amount) {
                return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);
            },
            InOut: function (amount) {
                if (amount === 0) {
                    return 0;
                }
                if (amount === 1) {
                    return 1;
                }
                if ((amount *= 2) < 1) {
                    return 0.5 * Math.pow(1024, amount - 1);
                }
                return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);
            },
        },
        Circular: {
            In: function (amount) {
                return 1 - Math.sqrt(1 - amount * amount);
            },
            Out: function (amount) {
                return Math.sqrt(1 - --amount * amount);
            },
            InOut: function (amount) {
                if ((amount *= 2) < 1) {
                    return -0.5 * (Math.sqrt(1 - amount * amount) - 1);
                }
                return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);
            },
        },
        Elastic: {
            In: function (amount) {
                if (amount === 0) {
                    return 0;
                }
                if (amount === 1) {
                    return 1;
                }
                return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
            },
            Out: function (amount) {
                if (amount === 0) {
                    return 0;
                }
                if (amount === 1) {
                    return 1;
                }
                return Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1;
            },
            InOut: function (amount) {
                if (amount === 0) {
                    return 0;
                }
                if (amount === 1) {
                    return 1;
                }
                amount *= 2;
                if (amount < 1) {
                    return -0.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
                }
                return 0.5 * Math.pow(2, -10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI) + 1;
            },
        },
        Back: {
            In: function (amount) {
                var s = 1.70158;
                return amount * amount * ((s + 1) * amount - s);
            },
            Out: function (amount) {
                var s = 1.70158;
                return --amount * amount * ((s + 1) * amount + s) + 1;
            },
            InOut: function (amount) {
                var s = 1.70158 * 1.525;
                if ((amount *= 2) < 1) {
                    return 0.5 * (amount * amount * ((s + 1) * amount - s));
                }
                return 0.5 * ((amount -= 2) * amount * ((s + 1) * amount + s) + 2);
            },
        },
        Bounce: {
            In: function (amount) {
                return 1 - Easing.Bounce.Out(1 - amount);
            },
            Out: function (amount) {
                if (amount < 1 / 2.75) {
                    return 7.5625 * amount * amount;
                }
                else if (amount < 2 / 2.75) {
                    return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;
                }
                else if (amount < 2.5 / 2.75) {
                    return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;
                }
                else {
                    return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;
                }
            },
            InOut: function (amount) {
                if (amount < 0.5) {
                    return Easing.Bounce.In(amount * 2) * 0.5;
                }
                return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;
            },
        },
    };

    var now$1;
    // Include a performance.now polyfill.
    // In node.js, use process.hrtime.
    // eslint-disable-next-line
    // @ts-ignore
    if (typeof self === 'undefined' && typeof process !== 'undefined' && process.hrtime) {
        now$1 = function () {
            // eslint-disable-next-line
            // @ts-ignore
            var time = process.hrtime();
            // Convert [seconds, nanoseconds] to milliseconds.
            return time[0] * 1000 + time[1] / 1000000;
        };
    }
    // In a browser, use self.performance.now if it is available.
    else if (typeof self !== 'undefined' && self.performance !== undefined && self.performance.now !== undefined) {
        // This must be bound, because directly assigning this function
        // leads to an invocation exception in Chrome.
        now$1 = self.performance.now.bind(self.performance);
    }
    // Use Date.now if it is available.
    else if (Date.now !== undefined) {
        now$1 = Date.now;
    }
    // Otherwise, use 'new Date().getTime()'.
    else {
        now$1 = function () {
            return new Date().getTime();
        };
    }
    var now$1$1 = now$1;

    /**
     * Controlling groups of tweens
     *
     * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
     * In these cases, you may want to create your own smaller groups of tween
     */
    var Group = /** @class */ (function () {
        function Group() {
            this._tweens = {};
            this._tweensAddedDuringUpdate = {};
        }
        Group.prototype.getAll = function () {
            var _this = this;
            return Object.keys(this._tweens).map(function (tweenId) {
                return _this._tweens[tweenId];
            });
        };
        Group.prototype.removeAll = function () {
            this._tweens = {};
        };
        Group.prototype.add = function (tween) {
            this._tweens[tween.getId()] = tween;
            this._tweensAddedDuringUpdate[tween.getId()] = tween;
        };
        Group.prototype.remove = function (tween) {
            delete this._tweens[tween.getId()];
            delete this._tweensAddedDuringUpdate[tween.getId()];
        };
        Group.prototype.update = function (time, preserve) {
            if (time === void 0) { time = now$1$1(); }
            if (preserve === void 0) { preserve = false; }
            var tweenIds = Object.keys(this._tweens);
            if (tweenIds.length === 0) {
                return false;
            }
            // Tweens are updated in "batches". If you add a new tween during an
            // update, then the new tween will be updated in the next batch.
            // If you remove a tween during an update, it may or may not be updated.
            // However, if the removed tween was added during the current batch,
            // then it will not be updated.
            while (tweenIds.length > 0) {
                this._tweensAddedDuringUpdate = {};
                for (var i = 0; i < tweenIds.length; i++) {
                    var tween = this._tweens[tweenIds[i]];
                    var autoStart = !preserve;
                    if (tween && tween.update(time, autoStart) === false && !preserve) {
                        delete this._tweens[tweenIds[i]];
                    }
                }
                tweenIds = Object.keys(this._tweensAddedDuringUpdate);
            }
            return true;
        };
        return Group;
    }());

    /**
     *
     */
    var Interpolation = {
        Linear: function (v, k) {
            var m = v.length - 1;
            var f = m * k;
            var i = Math.floor(f);
            var fn = Interpolation.Utils.Linear;
            if (k < 0) {
                return fn(v[0], v[1], f);
            }
            if (k > 1) {
                return fn(v[m], v[m - 1], m - f);
            }
            return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
        },
        Bezier: function (v, k) {
            var b = 0;
            var n = v.length - 1;
            var pw = Math.pow;
            var bn = Interpolation.Utils.Bernstein;
            for (var i = 0; i <= n; i++) {
                b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
            }
            return b;
        },
        CatmullRom: function (v, k) {
            var m = v.length - 1;
            var f = m * k;
            var i = Math.floor(f);
            var fn = Interpolation.Utils.CatmullRom;
            if (v[0] === v[m]) {
                if (k < 0) {
                    i = Math.floor((f = m * (1 + k)));
                }
                return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
            }
            else {
                if (k < 0) {
                    return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
                }
                if (k > 1) {
                    return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
                }
                return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
            }
        },
        Utils: {
            Linear: function (p0, p1, t) {
                return (p1 - p0) * t + p0;
            },
            Bernstein: function (n, i) {
                var fc = Interpolation.Utils.Factorial;
                return fc(n) / fc(i) / fc(n - i);
            },
            Factorial: (function () {
                var a = [1];
                return function (n) {
                    var s = 1;
                    if (a[n]) {
                        return a[n];
                    }
                    for (var i = n; i > 1; i--) {
                        s *= i;
                    }
                    a[n] = s;
                    return s;
                };
            })(),
            CatmullRom: function (p0, p1, p2, p3, t) {
                var v0 = (p2 - p0) * 0.5;
                var v1 = (p3 - p1) * 0.5;
                var t2 = t * t;
                var t3 = t * t2;
                return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
            },
        },
    };

    /**
     * Utils
     */
    var Sequence = /** @class */ (function () {
        function Sequence() {
        }
        Sequence.nextId = function () {
            return Sequence._nextId++;
        };
        Sequence._nextId = 0;
        return Sequence;
    }());

    var mainGroup = new Group();

    /**
     * Tween.js - Licensed under the MIT license
     * https://github.com/tweenjs/tween.js
     * ----------------------------------------------
     *
     * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
     * Thank you all, you're awesome!
     */
    var Tween = /** @class */ (function () {
        function Tween(_object, _group) {
            if (_group === void 0) { _group = mainGroup; }
            this._object = _object;
            this._group = _group;
            this._isPaused = false;
            this._pauseStart = 0;
            this._valuesStart = {};
            this._valuesEnd = {};
            this._valuesStartRepeat = {};
            this._duration = 1000;
            this._initialRepeat = 0;
            this._repeat = 0;
            this._yoyo = false;
            this._isPlaying = false;
            this._reversed = false;
            this._delayTime = 0;
            this._startTime = 0;
            this._easingFunction = Easing.Linear.None;
            this._interpolationFunction = Interpolation.Linear;
            this._chainedTweens = [];
            this._onStartCallbackFired = false;
            this._id = Sequence.nextId();
            this._isChainStopped = false;
            this._goToEnd = false;
        }
        Tween.prototype.getId = function () {
            return this._id;
        };
        Tween.prototype.isPlaying = function () {
            return this._isPlaying;
        };
        Tween.prototype.isPaused = function () {
            return this._isPaused;
        };
        Tween.prototype.to = function (properties, duration) {
            // TODO? restore this, then update the 07_dynamic_to example to set fox
            // tween's to on each update. That way the behavior is opt-in (there's
            // currently no opt-out).
            // for (const prop in properties) this._valuesEnd[prop] = properties[prop]
            this._valuesEnd = Object.create(properties);
            if (duration !== undefined) {
                this._duration = duration;
            }
            return this;
        };
        Tween.prototype.duration = function (d) {
            this._duration = d;
            return this;
        };
        Tween.prototype.start = function (time) {
            if (this._isPlaying) {
                return this;
            }
            // eslint-disable-next-line
            this._group && this._group.add(this);
            this._repeat = this._initialRepeat;
            if (this._reversed) {
                // If we were reversed (f.e. using the yoyo feature) then we need to
                // flip the tween direction back to forward.
                this._reversed = false;
                for (var property in this._valuesStartRepeat) {
                    this._swapEndStartRepeatValues(property);
                    this._valuesStart[property] = this._valuesStartRepeat[property];
                }
            }
            this._isPlaying = true;
            this._isPaused = false;
            this._onStartCallbackFired = false;
            this._isChainStopped = false;
            this._startTime = time !== undefined ? (typeof time === 'string' ? now$1$1() + parseFloat(time) : time) : now$1$1();
            this._startTime += this._delayTime;
            this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat);
            return this;
        };
        Tween.prototype._setupProperties = function (_object, _valuesStart, _valuesEnd, _valuesStartRepeat) {
            for (var property in _valuesEnd) {
                var startValue = _object[property];
                var startValueIsArray = Array.isArray(startValue);
                var propType = startValueIsArray ? 'array' : typeof startValue;
                var isInterpolationList = !startValueIsArray && Array.isArray(_valuesEnd[property]);
                // If `to()` specifies a property that doesn't exist in the source object,
                // we should not set that property in the object
                if (propType === 'undefined' || propType === 'function') {
                    continue;
                }
                // Check if an Array was provided as property value
                if (isInterpolationList) {
                    var endValues = _valuesEnd[property];
                    if (endValues.length === 0) {
                        continue;
                    }
                    // handle an array of relative values
                    endValues = endValues.map(this._handleRelativeValue.bind(this, startValue));
                    // Create a local copy of the Array with the start value at the front
                    _valuesEnd[property] = [startValue].concat(endValues);
                }
                // handle the deepness of the values
                if ((propType === 'object' || startValueIsArray) && startValue && !isInterpolationList) {
                    _valuesStart[property] = startValueIsArray ? [] : {};
                    // eslint-disable-next-line
                    for (var prop in startValue) {
                        // eslint-disable-next-line
                        // @ts-ignore FIXME?
                        _valuesStart[property][prop] = startValue[prop];
                    }
                    _valuesStartRepeat[property] = startValueIsArray ? [] : {}; // TODO? repeat nested values? And yoyo? And array values?
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    this._setupProperties(startValue, _valuesStart[property], _valuesEnd[property], _valuesStartRepeat[property]);
                }
                else {
                    // Save the starting value, but only once.
                    if (typeof _valuesStart[property] === 'undefined') {
                        _valuesStart[property] = startValue;
                    }
                    if (!startValueIsArray) {
                        // eslint-disable-next-line
                        // @ts-ignore FIXME?
                        _valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings
                    }
                    if (isInterpolationList) {
                        // eslint-disable-next-line
                        // @ts-ignore FIXME?
                        _valuesStartRepeat[property] = _valuesEnd[property].slice().reverse();
                    }
                    else {
                        _valuesStartRepeat[property] = _valuesStart[property] || 0;
                    }
                }
            }
        };
        Tween.prototype.stop = function () {
            if (!this._isChainStopped) {
                this._isChainStopped = true;
                this.stopChainedTweens();
            }
            if (!this._isPlaying) {
                return this;
            }
            // eslint-disable-next-line
            this._group && this._group.remove(this);
            this._isPlaying = false;
            this._isPaused = false;
            if (this._onStopCallback) {
                this._onStopCallback(this._object);
            }
            return this;
        };
        Tween.prototype.end = function () {
            this._goToEnd = true;
            this.update(Infinity);
            return this;
        };
        Tween.prototype.pause = function (time) {
            if (time === void 0) { time = now$1$1(); }
            if (this._isPaused || !this._isPlaying) {
                return this;
            }
            this._isPaused = true;
            this._pauseStart = time;
            // eslint-disable-next-line
            this._group && this._group.remove(this);
            return this;
        };
        Tween.prototype.resume = function (time) {
            if (time === void 0) { time = now$1$1(); }
            if (!this._isPaused || !this._isPlaying) {
                return this;
            }
            this._isPaused = false;
            this._startTime += time - this._pauseStart;
            this._pauseStart = 0;
            // eslint-disable-next-line
            this._group && this._group.add(this);
            return this;
        };
        Tween.prototype.stopChainedTweens = function () {
            for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
                this._chainedTweens[i].stop();
            }
            return this;
        };
        Tween.prototype.group = function (group) {
            this._group = group;
            return this;
        };
        Tween.prototype.delay = function (amount) {
            this._delayTime = amount;
            return this;
        };
        Tween.prototype.repeat = function (times) {
            this._initialRepeat = times;
            this._repeat = times;
            return this;
        };
        Tween.prototype.repeatDelay = function (amount) {
            this._repeatDelayTime = amount;
            return this;
        };
        Tween.prototype.yoyo = function (yoyo) {
            this._yoyo = yoyo;
            return this;
        };
        Tween.prototype.easing = function (easingFunction) {
            this._easingFunction = easingFunction;
            return this;
        };
        Tween.prototype.interpolation = function (interpolationFunction) {
            this._interpolationFunction = interpolationFunction;
            return this;
        };
        Tween.prototype.chain = function () {
            var tweens = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                tweens[_i] = arguments[_i];
            }
            this._chainedTweens = tweens;
            return this;
        };
        Tween.prototype.onStart = function (callback) {
            this._onStartCallback = callback;
            return this;
        };
        Tween.prototype.onUpdate = function (callback) {
            this._onUpdateCallback = callback;
            return this;
        };
        Tween.prototype.onRepeat = function (callback) {
            this._onRepeatCallback = callback;
            return this;
        };
        Tween.prototype.onComplete = function (callback) {
            this._onCompleteCallback = callback;
            return this;
        };
        Tween.prototype.onStop = function (callback) {
            this._onStopCallback = callback;
            return this;
        };
        /**
         * @returns true if the tween is still playing after the update, false
         * otherwise (calling update on a paused tween still returns true because
         * it is still playing, just paused).
         */
        Tween.prototype.update = function (time, autoStart) {
            if (time === void 0) { time = now$1$1(); }
            if (autoStart === void 0) { autoStart = true; }
            if (this._isPaused)
                return true;
            var property;
            var elapsed;
            var endTime = this._startTime + this._duration;
            if (!this._goToEnd && !this._isPlaying) {
                if (time > endTime)
                    return false;
                if (autoStart)
                    this.start(time);
            }
            this._goToEnd = false;
            if (time < this._startTime) {
                return true;
            }
            if (this._onStartCallbackFired === false) {
                if (this._onStartCallback) {
                    this._onStartCallback(this._object);
                }
                this._onStartCallbackFired = true;
            }
            elapsed = (time - this._startTime) / this._duration;
            elapsed = this._duration === 0 || elapsed > 1 ? 1 : elapsed;
            var value = this._easingFunction(elapsed);
            // properties transformations
            this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value);
            if (this._onUpdateCallback) {
                this._onUpdateCallback(this._object, elapsed);
            }
            if (elapsed === 1) {
                if (this._repeat > 0) {
                    if (isFinite(this._repeat)) {
                        this._repeat--;
                    }
                    // Reassign starting values, restart by making startTime = now
                    for (property in this._valuesStartRepeat) {
                        if (!this._yoyo && typeof this._valuesEnd[property] === 'string') {
                            this._valuesStartRepeat[property] =
                                // eslint-disable-next-line
                                // @ts-ignore FIXME?
                                this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);
                        }
                        if (this._yoyo) {
                            this._swapEndStartRepeatValues(property);
                        }
                        this._valuesStart[property] = this._valuesStartRepeat[property];
                    }
                    if (this._yoyo) {
                        this._reversed = !this._reversed;
                    }
                    if (this._repeatDelayTime !== undefined) {
                        this._startTime = time + this._repeatDelayTime;
                    }
                    else {
                        this._startTime = time + this._delayTime;
                    }
                    if (this._onRepeatCallback) {
                        this._onRepeatCallback(this._object);
                    }
                    return true;
                }
                else {
                    if (this._onCompleteCallback) {
                        this._onCompleteCallback(this._object);
                    }
                    for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
                        // Make the chained tweens start exactly at the time they should,
                        // even if the `update()` method was called way past the duration of the tween
                        this._chainedTweens[i].start(this._startTime + this._duration);
                    }
                    this._isPlaying = false;
                    return false;
                }
            }
            return true;
        };
        Tween.prototype._updateProperties = function (_object, _valuesStart, _valuesEnd, value) {
            for (var property in _valuesEnd) {
                // Don't update properties that do not exist in the source object
                if (_valuesStart[property] === undefined) {
                    continue;
                }
                var start = _valuesStart[property] || 0;
                var end = _valuesEnd[property];
                var startIsArray = Array.isArray(_object[property]);
                var endIsArray = Array.isArray(end);
                var isInterpolationList = !startIsArray && endIsArray;
                if (isInterpolationList) {
                    _object[property] = this._interpolationFunction(end, value);
                }
                else if (typeof end === 'object' && end) {
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    this._updateProperties(_object[property], start, end, value);
                }
                else {
                    // Parses relative end values with start as base (e.g.: +10, -3)
                    end = this._handleRelativeValue(start, end);
                    // Protect against non numeric properties.
                    if (typeof end === 'number') {
                        // eslint-disable-next-line
                        // @ts-ignore FIXME?
                        _object[property] = start + (end - start) * value;
                    }
                }
            }
        };
        Tween.prototype._handleRelativeValue = function (start, end) {
            if (typeof end !== 'string') {
                return end;
            }
            if (end.charAt(0) === '+' || end.charAt(0) === '-') {
                return start + parseFloat(end);
            }
            else {
                return parseFloat(end);
            }
        };
        Tween.prototype._swapEndStartRepeatValues = function (property) {
            var tmp = this._valuesStartRepeat[property];
            var endValue = this._valuesEnd[property];
            if (typeof endValue === 'string') {
                this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(endValue);
            }
            else {
                this._valuesStartRepeat[property] = this._valuesEnd[property];
            }
            this._valuesEnd[property] = tmp;
        };
        return Tween;
    }());

    var VERSION = '18.6.4';

    /**
     * Tween.js - Licensed under the MIT license
     * https://github.com/tweenjs/tween.js
     * ----------------------------------------------
     *
     * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
     * Thank you all, you're awesome!
     */
    var nextId = Sequence.nextId;
    /**
     * Controlling groups of tweens
     *
     * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
     * In these cases, you may want to create your own smaller groups of tweens.
     */
    var TWEEN = mainGroup;
    // This is the best way to export things in a way that's compatible with both ES
    // Modules and CommonJS, without build hacks, and so as not to break the
    // existing API.
    // https://github.com/rollup/rollup/issues/1961#issuecomment-423037881
    var getAll = TWEEN.getAll.bind(TWEEN);
    var removeAll$1 = TWEEN.removeAll.bind(TWEEN);
    var add$1 = TWEEN.add.bind(TWEEN);
    var remove$3 = TWEEN.remove.bind(TWEEN);
    var update$2 = TWEEN.update.bind(TWEEN);
    var exports$1 = {
        Easing: Easing,
        Group: Group,
        Interpolation: Interpolation,
        now: now$1$1,
        Sequence: Sequence,
        nextId: nextId,
        Tween: Tween,
        VERSION: VERSION,
        getAll: getAll,
        removeAll: removeAll$1,
        add: add$1,
        remove: remove$3,
        update: update$2,
    };

    function animate(time) {
        requestAnimationFrame(animate);
        exports$1.update(time);
    }
    requestAnimationFrame(animate);

    var commonjsGlobal$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function deepFreeze(obj) {
        if (obj instanceof Map) {
            obj.clear = obj.delete = obj.set = function () {
                throw new Error('map is read-only');
            };
        } else if (obj instanceof Set) {
            obj.add = obj.clear = obj.delete = function () {
                throw new Error('set is read-only');
            };
        }

        // Freeze self
        Object.freeze(obj);

        Object.getOwnPropertyNames(obj).forEach(function (name) {
            var prop = obj[name];

            // Freeze prop if it is an object
            if (typeof prop == 'object' && !Object.isFrozen(prop)) {
                deepFreeze(prop);
            }
        });

        return obj;
    }

    var deepFreezeEs6 = deepFreeze;
    var _default = deepFreeze;
    deepFreezeEs6.default = _default;

    /** @implements CallbackResponse */
    class Response {
      /**
       * @param {CompiledMode} mode
       */
      constructor(mode) {
        // eslint-disable-next-line no-undefined
        if (mode.data === undefined) mode.data = {};

        this.data = mode.data;
        this.isMatchIgnored = false;
      }

      ignoreMatch() {
        this.isMatchIgnored = true;
      }
    }

    /**
     * @param {string} value
     * @returns {string}
     */
    function escapeHTML(value) {
      return value
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#x27;');
    }

    /**
     * performs a shallow merge of multiple objects into one
     *
     * @template T
     * @param {T} original
     * @param {Record<string,any>[]} objects
     * @returns {T} a single new object
     */
    function inherit$1(original, ...objects) {
      /** @type Record<string,any> */
      const result = Object.create(null);

      for (const key in original) {
        result[key] = original[key];
      }
      objects.forEach(function(obj) {
        for (const key in obj) {
          result[key] = obj[key];
        }
      });
      return /** @type {T} */ (result);
    }

    /**
     * @typedef {object} Renderer
     * @property {(text: string) => void} addText
     * @property {(node: Node) => void} openNode
     * @property {(node: Node) => void} closeNode
     * @property {() => string} value
     */

    /** @typedef {{kind?: string, sublanguage?: boolean}} Node */
    /** @typedef {{walk: (r: Renderer) => void}} Tree */
    /** */

    const SPAN_CLOSE = '</span>';

    /**
     * Determines if a node needs to be wrapped in <span>
     *
     * @param {Node} node */
    const emitsWrappingTags = (node) => {
      return !!node.kind;
    };

    /** @type {Renderer} */
    class HTMLRenderer {
      /**
       * Creates a new HTMLRenderer
       *
       * @param {Tree} parseTree - the parse tree (must support `walk` API)
       * @param {{classPrefix: string}} options
       */
      constructor(parseTree, options) {
        this.buffer = "";
        this.classPrefix = options.classPrefix;
        parseTree.walk(this);
      }

      /**
       * Adds texts to the output stream
       *
       * @param {string} text */
      addText(text) {
        this.buffer += escapeHTML(text);
      }

      /**
       * Adds a node open to the output stream (if needed)
       *
       * @param {Node} node */
      openNode(node) {
        if (!emitsWrappingTags(node)) return;

        let className = node.kind;
        if (!node.sublanguage) {
          className = `${this.classPrefix}${className}`;
        }
        this.span(className);
      }

      /**
       * Adds a node close to the output stream (if needed)
       *
       * @param {Node} node */
      closeNode(node) {
        if (!emitsWrappingTags(node)) return;

        this.buffer += SPAN_CLOSE;
      }

      /**
       * returns the accumulated buffer
      */
      value() {
        return this.buffer;
      }

      // helpers

      /**
       * Builds a span element
       *
       * @param {string} className */
      span(className) {
        this.buffer += `<span class="${className}">`;
      }
    }

    /** @typedef {{kind?: string, sublanguage?: boolean, children: Node[]} | string} Node */
    /** @typedef {{kind?: string, sublanguage?: boolean, children: Node[]} } DataNode */
    /**  */

    class TokenTree {
      constructor() {
        /** @type DataNode */
        this.rootNode = { children: [] };
        this.stack = [this.rootNode];
      }

      get top() {
        return this.stack[this.stack.length - 1];
      }

      get root() { return this.rootNode; }

      /** @param {Node} node */
      add(node) {
        this.top.children.push(node);
      }

      /** @param {string} kind */
      openNode(kind) {
        /** @type Node */
        const node = { kind, children: [] };
        this.add(node);
        this.stack.push(node);
      }

      closeNode() {
        if (this.stack.length > 1) {
          return this.stack.pop();
        }
        // eslint-disable-next-line no-undefined
        return undefined;
      }

      closeAllNodes() {
        while (this.closeNode());
      }

      toJSON() {
        return JSON.stringify(this.rootNode, null, 4);
      }

      /**
       * @typedef { import("./html_renderer").Renderer } Renderer
       * @param {Renderer} builder
       */
      walk(builder) {
        // this does not
        return this.constructor._walk(builder, this.rootNode);
        // this works
        // return TokenTree._walk(builder, this.rootNode);
      }

      /**
       * @param {Renderer} builder
       * @param {Node} node
       */
      static _walk(builder, node) {
        if (typeof node === "string") {
          builder.addText(node);
        } else if (node.children) {
          builder.openNode(node);
          node.children.forEach((child) => this._walk(builder, child));
          builder.closeNode(node);
        }
        return builder;
      }

      /**
       * @param {Node} node
       */
      static _collapse(node) {
        if (typeof node === "string") return;
        if (!node.children) return;

        if (node.children.every(el => typeof el === "string")) {
          // node.text = node.children.join("");
          // delete node.children;
          node.children = [node.children.join("")];
        } else {
          node.children.forEach((child) => {
            TokenTree._collapse(child);
          });
        }
      }
    }

    /**
      Currently this is all private API, but this is the minimal API necessary
      that an Emitter must implement to fully support the parser.

      Minimal interface:

      - addKeyword(text, kind)
      - addText(text)
      - addSublanguage(emitter, subLanguageName)
      - finalize()
      - openNode(kind)
      - closeNode()
      - closeAllNodes()
      - toHTML()

    */

    /**
     * @implements {Emitter}
     */
    class TokenTreeEmitter extends TokenTree {
      /**
       * @param {*} options
       */
      constructor(options) {
        super();
        this.options = options;
      }

      /**
       * @param {string} text
       * @param {string} kind
       */
      addKeyword(text, kind) {
        if (text === "") { return; }

        this.openNode(kind);
        this.addText(text);
        this.closeNode();
      }

      /**
       * @param {string} text
       */
      addText(text) {
        if (text === "") { return; }

        this.add(text);
      }

      /**
       * @param {Emitter & {root: DataNode}} emitter
       * @param {string} name
       */
      addSublanguage(emitter, name) {
        /** @type DataNode */
        const node = emitter.root;
        node.kind = name;
        node.sublanguage = true;
        this.add(node);
      }

      toHTML() {
        const renderer = new HTMLRenderer(this, this.options);
        return renderer.value();
      }

      finalize() {
        return true;
      }
    }

    /**
     * @param {string} value
     * @returns {RegExp}
     * */
    function escape(value) {
      return new RegExp(value.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&'), 'm');
    }

    /**
     * @param {RegExp | string } re
     * @returns {string}
     */
    function source$2(re) {
      if (!re) return null;
      if (typeof re === "string") return re;

      return re.source;
    }

    /**
     * @param {...(RegExp | string) } args
     * @returns {string}
     */
    function concat$2(...args) {
      const joined = args.map((x) => source$2(x)).join("");
      return joined;
    }

    /**
     * Any of the passed expresssions may match
     *
     * Creates a huge this | this | that | that match
     * @param {(RegExp | string)[] } args
     * @returns {string}
     */
    function either$1(...args) {
      const joined = '(' + args.map((x) => source$2(x)).join("|") + ")";
      return joined;
    }

    /**
     * @param {RegExp} re
     * @returns {number}
     */
    function countMatchGroups(re) {
      return (new RegExp(re.toString() + '|')).exec('').length - 1;
    }

    /**
     * Does lexeme start with a regular expression match at the beginning
     * @param {RegExp} re
     * @param {string} lexeme
     */
    function startsWith(re, lexeme) {
      const match = re && re.exec(lexeme);
      return match && match.index === 0;
    }

    // BACKREF_RE matches an open parenthesis or backreference. To avoid
    // an incorrect parse, it additionally matches the following:
    // - [...] elements, where the meaning of parentheses and escapes change
    // - other escape sequences, so we do not misparse escape sequences as
    //   interesting elements
    // - non-matching or lookahead parentheses, which do not capture. These
    //   follow the '(' with a '?'.
    const BACKREF_RE = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;

    // join logically computes regexps.join(separator), but fixes the
    // backreferences so they continue to match.
    // it also places each individual regular expression into it's own
    // match group, keeping track of the sequencing of those match groups
    // is currently an exercise for the caller. :-)
    /**
     * @param {(string | RegExp)[]} regexps
     * @param {string} separator
     * @returns {string}
     */
    function join(regexps, separator = "|") {
      let numCaptures = 0;

      return regexps.map((regex) => {
        numCaptures += 1;
        const offset = numCaptures;
        let re = source$2(regex);
        let out = '';

        while (re.length > 0) {
          const match = BACKREF_RE.exec(re);
          if (!match) {
            out += re;
            break;
          }
          out += re.substring(0, match.index);
          re = re.substring(match.index + match[0].length);
          if (match[0][0] === '\\' && match[1]) {
            // Adjust the backreference.
            out += '\\' + String(Number(match[1]) + offset);
          } else {
            out += match[0];
            if (match[0] === '(') {
              numCaptures++;
            }
          }
        }
        return out;
      }).map(re => `(${re})`).join(separator);
    }

    // Common regexps
    const MATCH_NOTHING_RE = /\b\B/;
    const IDENT_RE$1 = '[a-zA-Z]\\w*';
    const UNDERSCORE_IDENT_RE = '[a-zA-Z_]\\w*';
    const NUMBER_RE = '\\b\\d+(\\.\\d+)?';
    const C_NUMBER_RE = '(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)'; // 0x..., 0..., decimal, float
    const BINARY_NUMBER_RE = '\\b(0b[01]+)'; // 0b...
    const RE_STARTERS_RE = '!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~';

    /**
    * @param { Partial<Mode> & {binary?: string | RegExp} } opts
    */
    const SHEBANG = (opts = {}) => {
      const beginShebang = /^#![ ]*\//;
      if (opts.binary) {
        opts.begin = concat$2(
          beginShebang,
          /.*\b/,
          opts.binary,
          /\b.*/);
      }
      return inherit$1({
        className: 'meta',
        begin: beginShebang,
        end: /$/,
        relevance: 0,
        /** @type {ModeCallback} */
        "on:begin": (m, resp) => {
          if (m.index !== 0) resp.ignoreMatch();
        }
      }, opts);
    };

    // Common modes
    const BACKSLASH_ESCAPE = {
      begin: '\\\\[\\s\\S]', relevance: 0
    };
    const APOS_STRING_MODE = {
      className: 'string',
      begin: '\'',
      end: '\'',
      illegal: '\\n',
      contains: [BACKSLASH_ESCAPE]
    };
    const QUOTE_STRING_MODE = {
      className: 'string',
      begin: '"',
      end: '"',
      illegal: '\\n',
      contains: [BACKSLASH_ESCAPE]
    };
    const PHRASAL_WORDS_MODE = {
      begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
    };
    /**
     * Creates a comment mode
     *
     * @param {string | RegExp} begin
     * @param {string | RegExp} end
     * @param {Mode | {}} [modeOptions]
     * @returns {Partial<Mode>}
     */
    const COMMENT = function(begin, end, modeOptions = {}) {
      const mode = inherit$1(
        {
          className: 'comment',
          begin,
          end,
          contains: []
        },
        modeOptions
      );
      mode.contains.push(PHRASAL_WORDS_MODE);
      mode.contains.push({
        className: 'doctag',
        begin: '(?:TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):',
        relevance: 0
      });
      return mode;
    };
    const C_LINE_COMMENT_MODE = COMMENT('//', '$');
    const C_BLOCK_COMMENT_MODE = COMMENT('/\\*', '\\*/');
    const HASH_COMMENT_MODE = COMMENT('#', '$');
    const NUMBER_MODE = {
      className: 'number',
      begin: NUMBER_RE,
      relevance: 0
    };
    const C_NUMBER_MODE = {
      className: 'number',
      begin: C_NUMBER_RE,
      relevance: 0
    };
    const BINARY_NUMBER_MODE = {
      className: 'number',
      begin: BINARY_NUMBER_RE,
      relevance: 0
    };
    const CSS_NUMBER_MODE = {
      className: 'number',
      begin: NUMBER_RE + '(' +
        '%|em|ex|ch|rem' +
        '|vw|vh|vmin|vmax' +
        '|cm|mm|in|pt|pc|px' +
        '|deg|grad|rad|turn' +
        '|s|ms' +
        '|Hz|kHz' +
        '|dpi|dpcm|dppx' +
        ')?',
      relevance: 0
    };
    const REGEXP_MODE = {
      // this outer rule makes sure we actually have a WHOLE regex and not simply
      // an expression such as:
      //
      //     3 / something
      //
      // (which will then blow up when regex's `illegal` sees the newline)
      begin: /(?=\/[^/\n]*\/)/,
      contains: [{
        className: 'regexp',
        begin: /\//,
        end: /\/[gimuy]*/,
        illegal: /\n/,
        contains: [
          BACKSLASH_ESCAPE,
          {
            begin: /\[/,
            end: /\]/,
            relevance: 0,
            contains: [BACKSLASH_ESCAPE]
          }
        ]
      }]
    };
    const TITLE_MODE = {
      className: 'title',
      begin: IDENT_RE$1,
      relevance: 0
    };
    const UNDERSCORE_TITLE_MODE = {
      className: 'title',
      begin: UNDERSCORE_IDENT_RE,
      relevance: 0
    };
    const METHOD_GUARD = {
      // excludes method names from keyword processing
      begin: '\\.\\s*' + UNDERSCORE_IDENT_RE,
      relevance: 0
    };

    /**
     * Adds end same as begin mechanics to a mode
     *
     * Your mode must include at least a single () match group as that first match
     * group is what is used for comparison
     * @param {Partial<Mode>} mode
     */
    const END_SAME_AS_BEGIN = function(mode) {
      return Object.assign(mode,
        {
          /** @type {ModeCallback} */
          'on:begin': (m, resp) => { resp.data._beginMatch = m[1]; },
          /** @type {ModeCallback} */
          'on:end': (m, resp) => { if (resp.data._beginMatch !== m[1]) resp.ignoreMatch(); }
        });
    };

    var MODES = /*#__PURE__*/Object.freeze({
        __proto__: null,
        MATCH_NOTHING_RE: MATCH_NOTHING_RE,
        IDENT_RE: IDENT_RE$1,
        UNDERSCORE_IDENT_RE: UNDERSCORE_IDENT_RE,
        NUMBER_RE: NUMBER_RE,
        C_NUMBER_RE: C_NUMBER_RE,
        BINARY_NUMBER_RE: BINARY_NUMBER_RE,
        RE_STARTERS_RE: RE_STARTERS_RE,
        SHEBANG: SHEBANG,
        BACKSLASH_ESCAPE: BACKSLASH_ESCAPE,
        APOS_STRING_MODE: APOS_STRING_MODE,
        QUOTE_STRING_MODE: QUOTE_STRING_MODE,
        PHRASAL_WORDS_MODE: PHRASAL_WORDS_MODE,
        COMMENT: COMMENT,
        C_LINE_COMMENT_MODE: C_LINE_COMMENT_MODE,
        C_BLOCK_COMMENT_MODE: C_BLOCK_COMMENT_MODE,
        HASH_COMMENT_MODE: HASH_COMMENT_MODE,
        NUMBER_MODE: NUMBER_MODE,
        C_NUMBER_MODE: C_NUMBER_MODE,
        BINARY_NUMBER_MODE: BINARY_NUMBER_MODE,
        CSS_NUMBER_MODE: CSS_NUMBER_MODE,
        REGEXP_MODE: REGEXP_MODE,
        TITLE_MODE: TITLE_MODE,
        UNDERSCORE_TITLE_MODE: UNDERSCORE_TITLE_MODE,
        METHOD_GUARD: METHOD_GUARD,
        END_SAME_AS_BEGIN: END_SAME_AS_BEGIN
    });

    // Grammar extensions / plugins
    // See: https://github.com/highlightjs/highlight.js/issues/2833

    // Grammar extensions allow "syntactic sugar" to be added to the grammar modes
    // without requiring any underlying changes to the compiler internals.

    // `compileMatch` being the perfect small example of now allowing a grammar
    // author to write `match` when they desire to match a single expression rather
    // than being forced to use `begin`.  The extension then just moves `match` into
    // `begin` when it runs.  Ie, no features have been added, but we've just made
    // the experience of writing (and reading grammars) a little bit nicer.

    // ------

    // TODO: We need negative look-behind support to do this properly
    /**
     * Skip a match if it has a preceding dot
     *
     * This is used for `beginKeywords` to prevent matching expressions such as
     * `bob.keyword.do()`. The mode compiler automatically wires this up as a
     * special _internal_ 'on:begin' callback for modes with `beginKeywords`
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    function skipIfhasPrecedingDot(match, response) {
      const before = match.input[match.index - 1];
      if (before === ".") {
        response.ignoreMatch();
      }
    }


    /**
     * `beginKeywords` syntactic sugar
     * @type {CompilerExt}
     */
    function beginKeywords(mode, parent) {
      if (!parent) return;
      if (!mode.beginKeywords) return;

      // for languages with keywords that include non-word characters checking for
      // a word boundary is not sufficient, so instead we check for a word boundary
      // or whitespace - this does no harm in any case since our keyword engine
      // doesn't allow spaces in keywords anyways and we still check for the boundary
      // first
      mode.begin = '\\b(' + mode.beginKeywords.split(' ').join('|') + ')(?!\\.)(?=\\b|\\s)';
      mode.__beforeBegin = skipIfhasPrecedingDot;
      mode.keywords = mode.keywords || mode.beginKeywords;
      delete mode.beginKeywords;

      // prevents double relevance, the keywords themselves provide
      // relevance, the mode doesn't need to double it
      // eslint-disable-next-line no-undefined
      if (mode.relevance === undefined) mode.relevance = 0;
    }

    /**
     * Allow `illegal` to contain an array of illegal values
     * @type {CompilerExt}
     */
    function compileIllegal(mode, _parent) {
      if (!Array.isArray(mode.illegal)) return;

      mode.illegal = either$1(...mode.illegal);
    }

    /**
     * `match` to match a single expression for readability
     * @type {CompilerExt}
     */
    function compileMatch(mode, _parent) {
      if (!mode.match) return;
      if (mode.begin || mode.end) throw new Error("begin & end are not supported with match");

      mode.begin = mode.match;
      delete mode.match;
    }

    /**
     * provides the default 1 relevance to all modes
     * @type {CompilerExt}
     */
    function compileRelevance(mode, _parent) {
      // eslint-disable-next-line no-undefined
      if (mode.relevance === undefined) mode.relevance = 1;
    }

    // keywords that should have no default relevance value
    const COMMON_KEYWORDS = [
      'of',
      'and',
      'for',
      'in',
      'not',
      'or',
      'if',
      'then',
      'parent', // common variable name
      'list', // common variable name
      'value' // common variable name
    ];

    const DEFAULT_KEYWORD_CLASSNAME = "keyword";

    /**
     * Given raw keywords from a language definition, compile them.
     *
     * @param {string | Record<string,string|string[]> | Array<string>} rawKeywords
     * @param {boolean} caseInsensitive
     */
    function compileKeywords(rawKeywords, caseInsensitive, className = DEFAULT_KEYWORD_CLASSNAME) {
      /** @type KeywordDict */
      const compiledKeywords = {};

      // input can be a string of keywords, an array of keywords, or a object with
      // named keys representing className (which can then point to a string or array)
      if (typeof rawKeywords === 'string') {
        compileList(className, rawKeywords.split(" "));
      } else if (Array.isArray(rawKeywords)) {
        compileList(className, rawKeywords);
      } else {
        Object.keys(rawKeywords).forEach(function(className) {
          // collapse all our objects back into the parent object
          Object.assign(
            compiledKeywords,
            compileKeywords(rawKeywords[className], caseInsensitive, className)
          );
        });
      }
      return compiledKeywords;

      // ---

      /**
       * Compiles an individual list of keywords
       *
       * Ex: "for if when while|5"
       *
       * @param {string} className
       * @param {Array<string>} keywordList
       */
      function compileList(className, keywordList) {
        if (caseInsensitive) {
          keywordList = keywordList.map(x => x.toLowerCase());
        }
        keywordList.forEach(function(keyword) {
          const pair = keyword.split('|');
          compiledKeywords[pair[0]] = [className, scoreForKeyword(pair[0], pair[1])];
        });
      }
    }

    /**
     * Returns the proper score for a given keyword
     *
     * Also takes into account comment keywords, which will be scored 0 UNLESS
     * another score has been manually assigned.
     * @param {string} keyword
     * @param {string} [providedScore]
     */
    function scoreForKeyword(keyword, providedScore) {
      // manual scores always win over common keywords
      // so you can force a score of 1 if you really insist
      if (providedScore) {
        return Number(providedScore);
      }

      return commonKeyword(keyword) ? 0 : 1;
    }

    /**
     * Determines if a given keyword is common or not
     *
     * @param {string} keyword */
    function commonKeyword(keyword) {
      return COMMON_KEYWORDS.includes(keyword.toLowerCase());
    }

    // compilation

    /**
     * Compiles a language definition result
     *
     * Given the raw result of a language definition (Language), compiles this so
     * that it is ready for highlighting code.
     * @param {Language} language
     * @param {{plugins: HLJSPlugin[]}} opts
     * @returns {CompiledLanguage}
     */
    function compileLanguage(language, { plugins }) {
      /**
       * Builds a regex with the case sensativility of the current language
       *
       * @param {RegExp | string} value
       * @param {boolean} [global]
       */
      function langRe(value, global) {
        return new RegExp(
          source$2(value),
          'm' + (language.case_insensitive ? 'i' : '') + (global ? 'g' : '')
        );
      }

      /**
        Stores multiple regular expressions and allows you to quickly search for
        them all in a string simultaneously - returning the first match.  It does
        this by creating a huge (a|b|c) regex - each individual item wrapped with ()
        and joined by `|` - using match groups to track position.  When a match is
        found checking which position in the array has content allows us to figure
        out which of the original regexes / match groups triggered the match.

        The match object itself (the result of `Regex.exec`) is returned but also
        enhanced by merging in any meta-data that was registered with the regex.
        This is how we keep track of which mode matched, and what type of rule
        (`illegal`, `begin`, end, etc).
      */
      class MultiRegex {
        constructor() {
          this.matchIndexes = {};
          // @ts-ignore
          this.regexes = [];
          this.matchAt = 1;
          this.position = 0;
        }

        // @ts-ignore
        addRule(re, opts) {
          opts.position = this.position++;
          // @ts-ignore
          this.matchIndexes[this.matchAt] = opts;
          this.regexes.push([opts, re]);
          this.matchAt += countMatchGroups(re) + 1;
        }

        compile() {
          if (this.regexes.length === 0) {
            // avoids the need to check length every time exec is called
            // @ts-ignore
            this.exec = () => null;
          }
          const terminators = this.regexes.map(el => el[1]);
          this.matcherRe = langRe(join(terminators), true);
          this.lastIndex = 0;
        }

        /** @param {string} s */
        exec(s) {
          this.matcherRe.lastIndex = this.lastIndex;
          const match = this.matcherRe.exec(s);
          if (!match) { return null; }

          // eslint-disable-next-line no-undefined
          const i = match.findIndex((el, i) => i > 0 && el !== undefined);
          // @ts-ignore
          const matchData = this.matchIndexes[i];
          // trim off any earlier non-relevant match groups (ie, the other regex
          // match groups that make up the multi-matcher)
          match.splice(0, i);

          return Object.assign(match, matchData);
        }
      }

      /*
        Created to solve the key deficiently with MultiRegex - there is no way to
        test for multiple matches at a single location.  Why would we need to do
        that?  In the future a more dynamic engine will allow certain matches to be
        ignored.  An example: if we matched say the 3rd regex in a large group but
        decided to ignore it - we'd need to started testing again at the 4th
        regex... but MultiRegex itself gives us no real way to do that.

        So what this class creates MultiRegexs on the fly for whatever search
        position they are needed.

        NOTE: These additional MultiRegex objects are created dynamically.  For most
        grammars most of the time we will never actually need anything more than the
        first MultiRegex - so this shouldn't have too much overhead.

        Say this is our search group, and we match regex3, but wish to ignore it.

          regex1 | regex2 | regex3 | regex4 | regex5    ' ie, startAt = 0

        What we need is a new MultiRegex that only includes the remaining
        possibilities:

          regex4 | regex5                               ' ie, startAt = 3

        This class wraps all that complexity up in a simple API... `startAt` decides
        where in the array of expressions to start doing the matching. It
        auto-increments, so if a match is found at position 2, then startAt will be
        set to 3.  If the end is reached startAt will return to 0.

        MOST of the time the parser will be setting startAt manually to 0.
      */
      class ResumableMultiRegex {
        constructor() {
          // @ts-ignore
          this.rules = [];
          // @ts-ignore
          this.multiRegexes = [];
          this.count = 0;

          this.lastIndex = 0;
          this.regexIndex = 0;
        }

        // @ts-ignore
        getMatcher(index) {
          if (this.multiRegexes[index]) return this.multiRegexes[index];

          const matcher = new MultiRegex();
          this.rules.slice(index).forEach(([re, opts]) => matcher.addRule(re, opts));
          matcher.compile();
          this.multiRegexes[index] = matcher;
          return matcher;
        }

        resumingScanAtSamePosition() {
          return this.regexIndex !== 0;
        }

        considerAll() {
          this.regexIndex = 0;
        }

        // @ts-ignore
        addRule(re, opts) {
          this.rules.push([re, opts]);
          if (opts.type === "begin") this.count++;
        }

        /** @param {string} s */
        exec(s) {
          const m = this.getMatcher(this.regexIndex);
          m.lastIndex = this.lastIndex;
          let result = m.exec(s);

          // The following is because we have no easy way to say "resume scanning at the
          // existing position but also skip the current rule ONLY". What happens is
          // all prior rules are also skipped which can result in matching the wrong
          // thing. Example of matching "booger":

          // our matcher is [string, "booger", number]
          //
          // ....booger....

          // if "booger" is ignored then we'd really need a regex to scan from the
          // SAME position for only: [string, number] but ignoring "booger" (if it
          // was the first match), a simple resume would scan ahead who knows how
          // far looking only for "number", ignoring potential string matches (or
          // future "booger" matches that might be valid.)

          // So what we do: We execute two matchers, one resuming at the same
          // position, but the second full matcher starting at the position after:

          //     /--- resume first regex match here (for [number])
          //     |/---- full match here for [string, "booger", number]
          //     vv
          // ....booger....

          // Which ever results in a match first is then used. So this 3-4 step
          // process essentially allows us to say "match at this position, excluding
          // a prior rule that was ignored".
          //
          // 1. Match "booger" first, ignore. Also proves that [string] does non match.
          // 2. Resume matching for [number]
          // 3. Match at index + 1 for [string, "booger", number]
          // 4. If #2 and #3 result in matches, which came first?
          if (this.resumingScanAtSamePosition()) {
            if (result && result.index === this.lastIndex) ; else { // use the second matcher result
              const m2 = this.getMatcher(0);
              m2.lastIndex = this.lastIndex + 1;
              result = m2.exec(s);
            }
          }

          if (result) {
            this.regexIndex += result.position + 1;
            if (this.regexIndex === this.count) {
              // wrap-around to considering all matches again
              this.considerAll();
            }
          }

          return result;
        }
      }

      /**
       * Given a mode, builds a huge ResumableMultiRegex that can be used to walk
       * the content and find matches.
       *
       * @param {CompiledMode} mode
       * @returns {ResumableMultiRegex}
       */
      function buildModeRegex(mode) {
        const mm = new ResumableMultiRegex();

        mode.contains.forEach(term => mm.addRule(term.begin, { rule: term, type: "begin" }));

        if (mode.terminatorEnd) {
          mm.addRule(mode.terminatorEnd, { type: "end" });
        }
        if (mode.illegal) {
          mm.addRule(mode.illegal, { type: "illegal" });
        }

        return mm;
      }

      /** skip vs abort vs ignore
       *
       * @skip   - The mode is still entered and exited normally (and contains rules apply),
       *           but all content is held and added to the parent buffer rather than being
       *           output when the mode ends.  Mostly used with `sublanguage` to build up
       *           a single large buffer than can be parsed by sublanguage.
       *
       *             - The mode begin ands ends normally.
       *             - Content matched is added to the parent mode buffer.
       *             - The parser cursor is moved forward normally.
       *
       * @abort  - A hack placeholder until we have ignore.  Aborts the mode (as if it
       *           never matched) but DOES NOT continue to match subsequent `contains`
       *           modes.  Abort is bad/suboptimal because it can result in modes
       *           farther down not getting applied because an earlier rule eats the
       *           content but then aborts.
       *
       *             - The mode does not begin.
       *             - Content matched by `begin` is added to the mode buffer.
       *             - The parser cursor is moved forward accordingly.
       *
       * @ignore - Ignores the mode (as if it never matched) and continues to match any
       *           subsequent `contains` modes.  Ignore isn't technically possible with
       *           the current parser implementation.
       *
       *             - The mode does not begin.
       *             - Content matched by `begin` is ignored.
       *             - The parser cursor is not moved forward.
       */

      /**
       * Compiles an individual mode
       *
       * This can raise an error if the mode contains certain detectable known logic
       * issues.
       * @param {Mode} mode
       * @param {CompiledMode | null} [parent]
       * @returns {CompiledMode | never}
       */
      function compileMode(mode, parent) {
        const cmode = /** @type CompiledMode */ (mode);
        if (mode.isCompiled) return cmode;

        [
          // do this early so compiler extensions generally don't have to worry about
          // the distinction between match/begin
          compileMatch
        ].forEach(ext => ext(mode, parent));

        language.compilerExtensions.forEach(ext => ext(mode, parent));

        // __beforeBegin is considered private API, internal use only
        mode.__beforeBegin = null;

        [
          beginKeywords,
          // do this later so compiler extensions that come earlier have access to the
          // raw array if they wanted to perhaps manipulate it, etc.
          compileIllegal,
          // default to 1 relevance if not specified
          compileRelevance
        ].forEach(ext => ext(mode, parent));

        mode.isCompiled = true;

        let keywordPattern = null;
        if (typeof mode.keywords === "object") {
          keywordPattern = mode.keywords.$pattern;
          delete mode.keywords.$pattern;
        }

        if (mode.keywords) {
          mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);
        }

        // both are not allowed
        if (mode.lexemes && keywordPattern) {
          throw new Error("ERR: Prefer `keywords.$pattern` to `mode.lexemes`, BOTH are not allowed. (see mode reference) ");
        }

        // `mode.lexemes` was the old standard before we added and now recommend
        // using `keywords.$pattern` to pass the keyword pattern
        keywordPattern = keywordPattern || mode.lexemes || /\w+/;
        cmode.keywordPatternRe = langRe(keywordPattern, true);

        if (parent) {
          if (!mode.begin) mode.begin = /\B|\b/;
          cmode.beginRe = langRe(mode.begin);
          if (mode.endSameAsBegin) mode.end = mode.begin;
          if (!mode.end && !mode.endsWithParent) mode.end = /\B|\b/;
          if (mode.end) cmode.endRe = langRe(mode.end);
          cmode.terminatorEnd = source$2(mode.end) || '';
          if (mode.endsWithParent && parent.terminatorEnd) {
            cmode.terminatorEnd += (mode.end ? '|' : '') + parent.terminatorEnd;
          }
        }
        if (mode.illegal) cmode.illegalRe = langRe(/** @type {RegExp | string} */ (mode.illegal));
        if (!mode.contains) mode.contains = [];

        mode.contains = [].concat(...mode.contains.map(function(c) {
          return expandOrCloneMode(c === 'self' ? mode : c);
        }));
        mode.contains.forEach(function(c) { compileMode(/** @type Mode */ (c), cmode); });

        if (mode.starts) {
          compileMode(mode.starts, parent);
        }

        cmode.matcher = buildModeRegex(cmode);
        return cmode;
      }

      if (!language.compilerExtensions) language.compilerExtensions = [];

      // self is not valid at the top-level
      if (language.contains && language.contains.includes('self')) {
        throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
      }

      // we need a null object, which inherit will guarantee
      language.classNameAliases = inherit$1(language.classNameAliases || {});

      return compileMode(/** @type Mode */ (language));
    }

    /**
     * Determines if a mode has a dependency on it's parent or not
     *
     * If a mode does have a parent dependency then often we need to clone it if
     * it's used in multiple places so that each copy points to the correct parent,
     * where-as modes without a parent can often safely be re-used at the bottom of
     * a mode chain.
     *
     * @param {Mode | null} mode
     * @returns {boolean} - is there a dependency on the parent?
     * */
    function dependencyOnParent(mode) {
      if (!mode) return false;

      return mode.endsWithParent || dependencyOnParent(mode.starts);
    }

    /**
     * Expands a mode or clones it if necessary
     *
     * This is necessary for modes with parental dependenceis (see notes on
     * `dependencyOnParent`) and for nodes that have `variants` - which must then be
     * exploded into their own individual modes at compile time.
     *
     * @param {Mode} mode
     * @returns {Mode | Mode[]}
     * */
    function expandOrCloneMode(mode) {
      if (mode.variants && !mode.cachedVariants) {
        mode.cachedVariants = mode.variants.map(function(variant) {
          return inherit$1(mode, { variants: null }, variant);
        });
      }

      // EXPAND
      // if we have variants then essentially "replace" the mode with the variants
      // this happens in compileMode, where this function is called from
      if (mode.cachedVariants) {
        return mode.cachedVariants;
      }

      // CLONE
      // if we have dependencies on parents then we need a unique
      // instance of ourselves, so we can be reused with many
      // different parents without issue
      if (dependencyOnParent(mode)) {
        return inherit$1(mode, { starts: mode.starts ? inherit$1(mode.starts) : null });
      }

      if (Object.isFrozen(mode)) {
        return inherit$1(mode);
      }

      // no special dependency issues, just return ourselves
      return mode;
    }

    var version = "10.7.3";

    // @ts-nocheck

    function hasValueOrEmptyAttribute(value) {
      return Boolean(value || value === "");
    }

    function BuildVuePlugin(hljs) {
      const Component = {
        props: ["language", "code", "autodetect"],
        data: function() {
          return {
            detectedLanguage: "",
            unknownLanguage: false
          };
        },
        computed: {
          className() {
            if (this.unknownLanguage) return "";

            return "hljs " + this.detectedLanguage;
          },
          highlighted() {
            // no idea what language to use, return raw code
            if (!this.autoDetect && !hljs.getLanguage(this.language)) {
              console.warn(`The language "${this.language}" you specified could not be found.`);
              this.unknownLanguage = true;
              return escapeHTML(this.code);
            }

            let result = {};
            if (this.autoDetect) {
              result = hljs.highlightAuto(this.code);
              this.detectedLanguage = result.language;
            } else {
              result = hljs.highlight(this.language, this.code, this.ignoreIllegals);
              this.detectedLanguage = this.language;
            }
            return result.value;
          },
          autoDetect() {
            return !this.language || hasValueOrEmptyAttribute(this.autodetect);
          },
          ignoreIllegals() {
            return true;
          }
        },
        // this avoids needing to use a whole Vue compilation pipeline just
        // to build Highlight.js
        render(createElement) {
          return createElement("pre", {}, [
            createElement("code", {
              class: this.className,
              domProps: { innerHTML: this.highlighted }
            })
          ]);
        }
        // template: `<pre><code :class="className" v-html="highlighted"></code></pre>`
      };

      const VuePlugin = {
        install(Vue) {
          Vue.component('highlightjs', Component);
        }
      };

      return { Component, VuePlugin };
    }

    /* plugin itself */

    /** @type {HLJSPlugin} */
    const mergeHTMLPlugin = {
      "after:highlightElement": ({ el, result, text }) => {
        const originalStream = nodeStream(el);
        if (!originalStream.length) return;

        const resultNode = document.createElement('div');
        resultNode.innerHTML = result.value;
        result.value = mergeStreams(originalStream, nodeStream(resultNode), text);
      }
    };

    /* Stream merging support functions */

    /**
     * @typedef Event
     * @property {'start'|'stop'} event
     * @property {number} offset
     * @property {Node} node
     */

    /**
     * @param {Node} node
     */
    function tag(node) {
      return node.nodeName.toLowerCase();
    }

    /**
     * @param {Node} node
     */
    function nodeStream(node) {
      /** @type Event[] */
      const result = [];
      (function _nodeStream(node, offset) {
        for (let child = node.firstChild; child; child = child.nextSibling) {
          if (child.nodeType === 3) {
            offset += child.nodeValue.length;
          } else if (child.nodeType === 1) {
            result.push({
              event: 'start',
              offset: offset,
              node: child
            });
            offset = _nodeStream(child, offset);
            // Prevent void elements from having an end tag that would actually
            // double them in the output. There are more void elements in HTML
            // but we list only those realistically expected in code display.
            if (!tag(child).match(/br|hr|img|input/)) {
              result.push({
                event: 'stop',
                offset: offset,
                node: child
              });
            }
          }
        }
        return offset;
      })(node, 0);
      return result;
    }

    /**
     * @param {any} original - the original stream
     * @param {any} highlighted - stream of the highlighted source
     * @param {string} value - the original source itself
     */
    function mergeStreams(original, highlighted, value) {
      let processed = 0;
      let result = '';
      const nodeStack = [];

      function selectStream() {
        if (!original.length || !highlighted.length) {
          return original.length ? original : highlighted;
        }
        if (original[0].offset !== highlighted[0].offset) {
          return (original[0].offset < highlighted[0].offset) ? original : highlighted;
        }

        /*
        To avoid starting the stream just before it should stop the order is
        ensured that original always starts first and closes last:

        if (event1 == 'start' && event2 == 'start')
          return original;
        if (event1 == 'start' && event2 == 'stop')
          return highlighted;
        if (event1 == 'stop' && event2 == 'start')
          return original;
        if (event1 == 'stop' && event2 == 'stop')
          return highlighted;

        ... which is collapsed to:
        */
        return highlighted[0].event === 'start' ? original : highlighted;
      }

      /**
       * @param {Node} node
       */
      function open(node) {
        /** @param {Attr} attr */
        function attributeString(attr) {
          return ' ' + attr.nodeName + '="' + escapeHTML(attr.value) + '"';
        }
        // @ts-ignore
        result += '<' + tag(node) + [].map.call(node.attributes, attributeString).join('') + '>';
      }

      /**
       * @param {Node} node
       */
      function close(node) {
        result += '</' + tag(node) + '>';
      }

      /**
       * @param {Event} event
       */
      function render(event) {
        (event.event === 'start' ? open : close)(event.node);
      }

      while (original.length || highlighted.length) {
        let stream = selectStream();
        result += escapeHTML(value.substring(processed, stream[0].offset));
        processed = stream[0].offset;
        if (stream === original) {
          /*
          On any opening or closing tag of the original markup we first close
          the entire highlighted node stack, then render the original tag along
          with all the following original tags at the same offset and then
          reopen all the tags on the highlighted stack.
          */
          nodeStack.reverse().forEach(close);
          do {
            render(stream.splice(0, 1)[0]);
            stream = selectStream();
          } while (stream === original && stream.length && stream[0].offset === processed);
          nodeStack.reverse().forEach(open);
        } else {
          if (stream[0].event === 'start') {
            nodeStack.push(stream[0].node);
          } else {
            nodeStack.pop();
          }
          render(stream.splice(0, 1)[0]);
        }
      }
      return result + escapeHTML(value.substr(processed));
    }

    /*

    For the reasoning behind this please see:
    https://github.com/highlightjs/highlight.js/issues/2880#issuecomment-747275419

    */

    /**
     * @type {Record<string, boolean>}
     */
    const seenDeprecations = {};

    /**
     * @param {string} message
     */
    const error = (message) => {
      console.error(message);
    };

    /**
     * @param {string} message
     * @param {any} args
     */
    const warn = (message, ...args) => {
      console.log(`WARN: ${message}`, ...args);
    };

    /**
     * @param {string} version
     * @param {string} message
     */
    const deprecated = (version, message) => {
      if (seenDeprecations[`${version}/${message}`]) return;

      console.log(`Deprecated as of ${version}. ${message}`);
      seenDeprecations[`${version}/${message}`] = true;
    };

    /*
    Syntax highlighting with language autodetection.
    https://highlightjs.org/
    */

    const escape$1 = escapeHTML;
    const inherit$1$1 = inherit$1;
    const NO_MATCH = Symbol("nomatch");

    /**
     * @param {any} hljs - object that is extended (legacy)
     * @returns {HLJSApi}
     */
    const HLJS = function(hljs) {
      // Global internal variables used within the highlight.js library.
      /** @type {Record<string, Language>} */
      const languages = Object.create(null);
      /** @type {Record<string, string>} */
      const aliases = Object.create(null);
      /** @type {HLJSPlugin[]} */
      const plugins = [];

      // safe/production mode - swallows more errors, tries to keep running
      // even if a single syntax or parse hits a fatal error
      let SAFE_MODE = true;
      const fixMarkupRe = /(^(<[^>]+>|\t|)+|\n)/gm;
      const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
      /** @type {Language} */
      const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: 'Plain text', contains: [] };

      // Global options used when within external APIs. This is modified when
      // calling the `hljs.configure` function.
      /** @type HLJSOptions */
      let options = {
        noHighlightRe: /^(no-?highlight)$/i,
        languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
        classPrefix: 'hljs-',
        tabReplace: null,
        useBR: false,
        languages: null,
        // beta configuration options, subject to change, welcome to discuss
        // https://github.com/highlightjs/highlight.js/issues/1086
        __emitter: TokenTreeEmitter
      };

      /* Utility functions */

      /**
       * Tests a language name to see if highlighting should be skipped
       * @param {string} languageName
       */
      function shouldNotHighlight(languageName) {
        return options.noHighlightRe.test(languageName);
      }

      /**
       * @param {HighlightedHTMLElement} block - the HTML element to determine language for
       */
      function blockLanguage(block) {
        let classes = block.className + ' ';

        classes += block.parentNode ? block.parentNode.className : '';

        // language-* takes precedence over non-prefixed class names.
        const match = options.languageDetectRe.exec(classes);
        if (match) {
          const language = getLanguage(match[1]);
          if (!language) {
            warn(LANGUAGE_NOT_FOUND.replace("{}", match[1]));
            warn("Falling back to no-highlight mode for this block.", block);
          }
          return language ? match[1] : 'no-highlight';
        }

        return classes
          .split(/\s+/)
          .find((_class) => shouldNotHighlight(_class) || getLanguage(_class));
      }

      /**
       * Core highlighting function.
       *
       * OLD API
       * highlight(lang, code, ignoreIllegals, continuation)
       *
       * NEW API
       * highlight(code, {lang, ignoreIllegals})
       *
       * @param {string} codeOrlanguageName - the language to use for highlighting
       * @param {string | HighlightOptions} optionsOrCode - the code to highlight
       * @param {boolean} [ignoreIllegals] - whether to ignore illegal matches, default is to bail
       * @param {CompiledMode} [continuation] - current continuation mode, if any
       *
       * @returns {HighlightResult} Result - an object that represents the result
       * @property {string} language - the language name
       * @property {number} relevance - the relevance score
       * @property {string} value - the highlighted HTML code
       * @property {string} code - the original raw code
       * @property {CompiledMode} top - top of the current mode stack
       * @property {boolean} illegal - indicates whether any illegal matches were found
      */
      function highlight(codeOrlanguageName, optionsOrCode, ignoreIllegals, continuation) {
        let code = "";
        let languageName = "";
        if (typeof optionsOrCode === "object") {
          code = codeOrlanguageName;
          ignoreIllegals = optionsOrCode.ignoreIllegals;
          languageName = optionsOrCode.language;
          // continuation not supported at all via the new API
          // eslint-disable-next-line no-undefined
          continuation = undefined;
        } else {
          // old API
          deprecated("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
          deprecated("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
          languageName = codeOrlanguageName;
          code = optionsOrCode;
        }

        /** @type {BeforeHighlightContext} */
        const context = {
          code,
          language: languageName
        };
        // the plugin can change the desired language or the code to be highlighted
        // just be changing the object it was passed
        fire("before:highlight", context);

        // a before plugin can usurp the result completely by providing it's own
        // in which case we don't even need to call highlight
        const result = context.result
          ? context.result
          : _highlight(context.language, context.code, ignoreIllegals, continuation);

        result.code = context.code;
        // the plugin can change anything in result to suite it
        fire("after:highlight", result);

        return result;
      }

      /**
       * private highlight that's used internally and does not fire callbacks
       *
       * @param {string} languageName - the language to use for highlighting
       * @param {string} codeToHighlight - the code to highlight
       * @param {boolean?} [ignoreIllegals] - whether to ignore illegal matches, default is to bail
       * @param {CompiledMode?} [continuation] - current continuation mode, if any
       * @returns {HighlightResult} - result of the highlight operation
      */
      function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
        /**
         * Return keyword data if a match is a keyword
         * @param {CompiledMode} mode - current mode
         * @param {RegExpMatchArray} match - regexp match data
         * @returns {KeywordData | false}
         */
        function keywordData(mode, match) {
          const matchText = language.case_insensitive ? match[0].toLowerCase() : match[0];
          return Object.prototype.hasOwnProperty.call(mode.keywords, matchText) && mode.keywords[matchText];
        }

        function processKeywords() {
          if (!top.keywords) {
            emitter.addText(modeBuffer);
            return;
          }

          let lastIndex = 0;
          top.keywordPatternRe.lastIndex = 0;
          let match = top.keywordPatternRe.exec(modeBuffer);
          let buf = "";

          while (match) {
            buf += modeBuffer.substring(lastIndex, match.index);
            const data = keywordData(top, match);
            if (data) {
              const [kind, keywordRelevance] = data;
              emitter.addText(buf);
              buf = "";

              relevance += keywordRelevance;
              if (kind.startsWith("_")) {
                // _ implied for relevance only, do not highlight
                // by applying a class name
                buf += match[0];
              } else {
                const cssClass = language.classNameAliases[kind] || kind;
                emitter.addKeyword(match[0], cssClass);
              }
            } else {
              buf += match[0];
            }
            lastIndex = top.keywordPatternRe.lastIndex;
            match = top.keywordPatternRe.exec(modeBuffer);
          }
          buf += modeBuffer.substr(lastIndex);
          emitter.addText(buf);
        }

        function processSubLanguage() {
          if (modeBuffer === "") return;
          /** @type HighlightResult */
          let result = null;

          if (typeof top.subLanguage === 'string') {
            if (!languages[top.subLanguage]) {
              emitter.addText(modeBuffer);
              return;
            }
            result = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);
            continuations[top.subLanguage] = /** @type {CompiledMode} */ (result.top);
          } else {
            result = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);
          }

          // Counting embedded language score towards the host language may be disabled
          // with zeroing the containing mode relevance. Use case in point is Markdown that
          // allows XML everywhere and makes every XML snippet to have a much larger Markdown
          // score.
          if (top.relevance > 0) {
            relevance += result.relevance;
          }
          emitter.addSublanguage(result.emitter, result.language);
        }

        function processBuffer() {
          if (top.subLanguage != null) {
            processSubLanguage();
          } else {
            processKeywords();
          }
          modeBuffer = '';
        }

        /**
         * @param {Mode} mode - new mode to start
         */
        function startNewMode(mode) {
          if (mode.className) {
            emitter.openNode(language.classNameAliases[mode.className] || mode.className);
          }
          top = Object.create(mode, { parent: { value: top } });
          return top;
        }

        /**
         * @param {CompiledMode } mode - the mode to potentially end
         * @param {RegExpMatchArray} match - the latest match
         * @param {string} matchPlusRemainder - match plus remainder of content
         * @returns {CompiledMode | void} - the next mode, or if void continue on in current mode
         */
        function endOfMode(mode, match, matchPlusRemainder) {
          let matched = startsWith(mode.endRe, matchPlusRemainder);

          if (matched) {
            if (mode["on:end"]) {
              const resp = new Response(mode);
              mode["on:end"](match, resp);
              if (resp.isMatchIgnored) matched = false;
            }

            if (matched) {
              while (mode.endsParent && mode.parent) {
                mode = mode.parent;
              }
              return mode;
            }
          }
          // even if on:end fires an `ignore` it's still possible
          // that we might trigger the end node because of a parent mode
          if (mode.endsWithParent) {
            return endOfMode(mode.parent, match, matchPlusRemainder);
          }
        }

        /**
         * Handle matching but then ignoring a sequence of text
         *
         * @param {string} lexeme - string containing full match text
         */
        function doIgnore(lexeme) {
          if (top.matcher.regexIndex === 0) {
            // no more regexs to potentially match here, so we move the cursor forward one
            // space
            modeBuffer += lexeme[0];
            return 1;
          } else {
            // no need to move the cursor, we still have additional regexes to try and
            // match at this very spot
            resumeScanAtSamePosition = true;
            return 0;
          }
        }

        /**
         * Handle the start of a new potential mode match
         *
         * @param {EnhancedMatch} match - the current match
         * @returns {number} how far to advance the parse cursor
         */
        function doBeginMatch(match) {
          const lexeme = match[0];
          const newMode = match.rule;

          const resp = new Response(newMode);
          // first internal before callbacks, then the public ones
          const beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
          for (const cb of beforeCallbacks) {
            if (!cb) continue;
            cb(match, resp);
            if (resp.isMatchIgnored) return doIgnore(lexeme);
          }

          if (newMode && newMode.endSameAsBegin) {
            newMode.endRe = escape(lexeme);
          }

          if (newMode.skip) {
            modeBuffer += lexeme;
          } else {
            if (newMode.excludeBegin) {
              modeBuffer += lexeme;
            }
            processBuffer();
            if (!newMode.returnBegin && !newMode.excludeBegin) {
              modeBuffer = lexeme;
            }
          }
          startNewMode(newMode);
          // if (mode["after:begin"]) {
          //   let resp = new Response(mode);
          //   mode["after:begin"](match, resp);
          // }
          return newMode.returnBegin ? 0 : lexeme.length;
        }

        /**
         * Handle the potential end of mode
         *
         * @param {RegExpMatchArray} match - the current match
         */
        function doEndMatch(match) {
          const lexeme = match[0];
          const matchPlusRemainder = codeToHighlight.substr(match.index);

          const endMode = endOfMode(top, match, matchPlusRemainder);
          if (!endMode) { return NO_MATCH; }

          const origin = top;
          if (origin.skip) {
            modeBuffer += lexeme;
          } else {
            if (!(origin.returnEnd || origin.excludeEnd)) {
              modeBuffer += lexeme;
            }
            processBuffer();
            if (origin.excludeEnd) {
              modeBuffer = lexeme;
            }
          }
          do {
            if (top.className) {
              emitter.closeNode();
            }
            if (!top.skip && !top.subLanguage) {
              relevance += top.relevance;
            }
            top = top.parent;
          } while (top !== endMode.parent);
          if (endMode.starts) {
            if (endMode.endSameAsBegin) {
              endMode.starts.endRe = endMode.endRe;
            }
            startNewMode(endMode.starts);
          }
          return origin.returnEnd ? 0 : lexeme.length;
        }

        function processContinuations() {
          const list = [];
          for (let current = top; current !== language; current = current.parent) {
            if (current.className) {
              list.unshift(current.className);
            }
          }
          list.forEach(item => emitter.openNode(item));
        }

        /** @type {{type?: MatchType, index?: number, rule?: Mode}}} */
        let lastMatch = {};

        /**
         *  Process an individual match
         *
         * @param {string} textBeforeMatch - text preceeding the match (since the last match)
         * @param {EnhancedMatch} [match] - the match itself
         */
        function processLexeme(textBeforeMatch, match) {
          const lexeme = match && match[0];

          // add non-matched text to the current mode buffer
          modeBuffer += textBeforeMatch;

          if (lexeme == null) {
            processBuffer();
            return 0;
          }

          // we've found a 0 width match and we're stuck, so we need to advance
          // this happens when we have badly behaved rules that have optional matchers to the degree that
          // sometimes they can end up matching nothing at all
          // Ref: https://github.com/highlightjs/highlight.js/issues/2140
          if (lastMatch.type === "begin" && match.type === "end" && lastMatch.index === match.index && lexeme === "") {
            // spit the "skipped" character that our regex choked on back into the output sequence
            modeBuffer += codeToHighlight.slice(match.index, match.index + 1);
            if (!SAFE_MODE) {
              /** @type {AnnotatedError} */
              const err = new Error('0 width match regex');
              err.languageName = languageName;
              err.badRule = lastMatch.rule;
              throw err;
            }
            return 1;
          }
          lastMatch = match;

          if (match.type === "begin") {
            return doBeginMatch(match);
          } else if (match.type === "illegal" && !ignoreIllegals) {
            // illegal match, we do not continue processing
            /** @type {AnnotatedError} */
            const err = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.className || '<unnamed>') + '"');
            err.mode = top;
            throw err;
          } else if (match.type === "end") {
            const processed = doEndMatch(match);
            if (processed !== NO_MATCH) {
              return processed;
            }
          }

          // edge case for when illegal matches $ (end of line) which is technically
          // a 0 width match but not a begin/end match so it's not caught by the
          // first handler (when ignoreIllegals is true)
          if (match.type === "illegal" && lexeme === "") {
            // advance so we aren't stuck in an infinite loop
            return 1;
          }

          // infinite loops are BAD, this is a last ditch catch all. if we have a
          // decent number of iterations yet our index (cursor position in our
          // parsing) still 3x behind our index then something is very wrong
          // so we bail
          if (iterations > 100000 && iterations > match.index * 3) {
            const err = new Error('potential infinite loop, way more iterations than matches');
            throw err;
          }

          /*
          Why might be find ourselves here?  Only one occasion now.  An end match that was
          triggered but could not be completed.  When might this happen?  When an `endSameasBegin`
          rule sets the end rule to a specific match.  Since the overall mode termination rule that's
          being used to scan the text isn't recompiled that means that any match that LOOKS like
          the end (but is not, because it is not an exact match to the beginning) will
          end up here.  A definite end match, but when `doEndMatch` tries to "reapply"
          the end rule and fails to match, we wind up here, and just silently ignore the end.

          This causes no real harm other than stopping a few times too many.
          */

          modeBuffer += lexeme;
          return lexeme.length;
        }

        const language = getLanguage(languageName);
        if (!language) {
          error(LANGUAGE_NOT_FOUND.replace("{}", languageName));
          throw new Error('Unknown language: "' + languageName + '"');
        }

        const md = compileLanguage(language, { plugins });
        let result = '';
        /** @type {CompiledMode} */
        let top = continuation || md;
        /** @type Record<string,CompiledMode> */
        const continuations = {}; // keep continuations for sub-languages
        const emitter = new options.__emitter(options);
        processContinuations();
        let modeBuffer = '';
        let relevance = 0;
        let index = 0;
        let iterations = 0;
        let resumeScanAtSamePosition = false;

        try {
          top.matcher.considerAll();

          for (;;) {
            iterations++;
            if (resumeScanAtSamePosition) {
              // only regexes not matched previously will now be
              // considered for a potential match
              resumeScanAtSamePosition = false;
            } else {
              top.matcher.considerAll();
            }
            top.matcher.lastIndex = index;

            const match = top.matcher.exec(codeToHighlight);
            // console.log("match", match[0], match.rule && match.rule.begin)

            if (!match) break;

            const beforeMatch = codeToHighlight.substring(index, match.index);
            const processedCount = processLexeme(beforeMatch, match);
            index = match.index + processedCount;
          }
          processLexeme(codeToHighlight.substr(index));
          emitter.closeAllNodes();
          emitter.finalize();
          result = emitter.toHTML();

          return {
            // avoid possible breakage with v10 clients expecting
            // this to always be an integer
            relevance: Math.floor(relevance),
            value: result,
            language: languageName,
            illegal: false,
            emitter: emitter,
            top: top
          };
        } catch (err) {
          if (err.message && err.message.includes('Illegal')) {
            return {
              illegal: true,
              illegalBy: {
                msg: err.message,
                context: codeToHighlight.slice(index - 100, index + 100),
                mode: err.mode
              },
              sofar: result,
              relevance: 0,
              value: escape$1(codeToHighlight),
              emitter: emitter
            };
          } else if (SAFE_MODE) {
            return {
              illegal: false,
              relevance: 0,
              value: escape$1(codeToHighlight),
              emitter: emitter,
              language: languageName,
              top: top,
              errorRaised: err
            };
          } else {
            throw err;
          }
        }
      }

      /**
       * returns a valid highlight result, without actually doing any actual work,
       * auto highlight starts with this and it's possible for small snippets that
       * auto-detection may not find a better match
       * @param {string} code
       * @returns {HighlightResult}
       */
      function justTextHighlightResult(code) {
        const result = {
          relevance: 0,
          emitter: new options.__emitter(options),
          value: escape$1(code),
          illegal: false,
          top: PLAINTEXT_LANGUAGE
        };
        result.emitter.addText(code);
        return result;
      }

      /**
      Highlighting with language detection. Accepts a string with the code to
      highlight. Returns an object with the following properties:

      - language (detected language)
      - relevance (int)
      - value (an HTML string with highlighting markup)
      - second_best (object with the same structure for second-best heuristically
        detected language, may be absent)

        @param {string} code
        @param {Array<string>} [languageSubset]
        @returns {AutoHighlightResult}
      */
      function highlightAuto(code, languageSubset) {
        languageSubset = languageSubset || options.languages || Object.keys(languages);
        const plaintext = justTextHighlightResult(code);

        const results = languageSubset.filter(getLanguage).filter(autoDetection).map(name =>
          _highlight(name, code, false)
        );
        results.unshift(plaintext); // plaintext is always an option

        const sorted = results.sort((a, b) => {
          // sort base on relevance
          if (a.relevance !== b.relevance) return b.relevance - a.relevance;

          // always award the tie to the base language
          // ie if C++ and Arduino are tied, it's more likely to be C++
          if (a.language && b.language) {
            if (getLanguage(a.language).supersetOf === b.language) {
              return 1;
            } else if (getLanguage(b.language).supersetOf === a.language) {
              return -1;
            }
          }

          // otherwise say they are equal, which has the effect of sorting on
          // relevance while preserving the original ordering - which is how ties
          // have historically been settled, ie the language that comes first always
          // wins in the case of a tie
          return 0;
        });

        const [best, secondBest] = sorted;

        /** @type {AutoHighlightResult} */
        const result = best;
        result.second_best = secondBest;

        return result;
      }

      /**
      Post-processing of the highlighted markup:

      - replace TABs with something more useful
      - replace real line-breaks with '<br>' for non-pre containers

        @param {string} html
        @returns {string}
      */
      function fixMarkup(html) {
        if (!(options.tabReplace || options.useBR)) {
          return html;
        }

        return html.replace(fixMarkupRe, match => {
          if (match === '\n') {
            return options.useBR ? '<br>' : match;
          } else if (options.tabReplace) {
            return match.replace(/\t/g, options.tabReplace);
          }
          return match;
        });
      }

      /**
       * Builds new class name for block given the language name
       *
       * @param {HTMLElement} element
       * @param {string} [currentLang]
       * @param {string} [resultLang]
       */
      function updateClassName(element, currentLang, resultLang) {
        const language = currentLang ? aliases[currentLang] : resultLang;

        element.classList.add("hljs");
        if (language) element.classList.add(language);
      }

      /** @type {HLJSPlugin} */
      const brPlugin = {
        "before:highlightElement": ({ el }) => {
          if (options.useBR) {
            el.innerHTML = el.innerHTML.replace(/\n/g, '').replace(/<br[ /]*>/g, '\n');
          }
        },
        "after:highlightElement": ({ result }) => {
          if (options.useBR) {
            result.value = result.value.replace(/\n/g, "<br>");
          }
        }
      };

      const TAB_REPLACE_RE = /^(<[^>]+>|\t)+/gm;
      /** @type {HLJSPlugin} */
      const tabReplacePlugin = {
        "after:highlightElement": ({ result }) => {
          if (options.tabReplace) {
            result.value = result.value.replace(TAB_REPLACE_RE, (m) =>
              m.replace(/\t/g, options.tabReplace)
            );
          }
        }
      };

      /**
       * Applies highlighting to a DOM node containing code. Accepts a DOM node and
       * two optional parameters for fixMarkup.
       *
       * @param {HighlightedHTMLElement} element - the HTML element to highlight
      */
      function highlightElement(element) {
        /** @type HTMLElement */
        let node = null;
        const language = blockLanguage(element);

        if (shouldNotHighlight(language)) return;

        // support for v10 API
        fire("before:highlightElement",
          { el: element, language: language });

        node = element;
        const text = node.textContent;
        const result = language ? highlight(text, { language, ignoreIllegals: true }) : highlightAuto(text);

        // support for v10 API
        fire("after:highlightElement", { el: element, result, text });

        element.innerHTML = result.value;
        updateClassName(element, language, result.language);
        element.result = {
          language: result.language,
          // TODO: remove with version 11.0
          re: result.relevance,
          relavance: result.relevance
        };
        if (result.second_best) {
          element.second_best = {
            language: result.second_best.language,
            // TODO: remove with version 11.0
            re: result.second_best.relevance,
            relavance: result.second_best.relevance
          };
        }
      }

      /**
       * Updates highlight.js global options with the passed options
       *
       * @param {Partial<HLJSOptions>} userOptions
       */
      function configure(userOptions) {
        if (userOptions.useBR) {
          deprecated("10.3.0", "'useBR' will be removed entirely in v11.0");
          deprecated("10.3.0", "Please see https://github.com/highlightjs/highlight.js/issues/2559");
        }
        options = inherit$1$1(options, userOptions);
      }

      /**
       * Highlights to all <pre><code> blocks on a page
       *
       * @type {Function & {called?: boolean}}
       */
      // TODO: remove v12, deprecated
      const initHighlighting = () => {
        if (initHighlighting.called) return;
        initHighlighting.called = true;

        deprecated("10.6.0", "initHighlighting() is deprecated.  Use highlightAll() instead.");

        const blocks = document.querySelectorAll('pre code');
        blocks.forEach(highlightElement);
      };

      // Higlights all when DOMContentLoaded fires
      // TODO: remove v12, deprecated
      function initHighlightingOnLoad() {
        deprecated("10.6.0", "initHighlightingOnLoad() is deprecated.  Use highlightAll() instead.");
        wantsHighlight = true;
      }

      let wantsHighlight = false;

      /**
       * auto-highlights all pre>code elements on the page
       */
      function highlightAll() {
        // if we are called too early in the loading process
        if (document.readyState === "loading") {
          wantsHighlight = true;
          return;
        }

        const blocks = document.querySelectorAll('pre code');
        blocks.forEach(highlightElement);
      }

      function boot() {
        // if a highlight was requested before DOM was loaded, do now
        if (wantsHighlight) highlightAll();
      }

      // make sure we are in the browser environment
      if (typeof window !== 'undefined' && window.addEventListener) {
        window.addEventListener('DOMContentLoaded', boot, false);
      }

      /**
       * Register a language grammar module
       *
       * @param {string} languageName
       * @param {LanguageFn} languageDefinition
       */
      function registerLanguage(languageName, languageDefinition) {
        let lang = null;
        try {
          lang = languageDefinition(hljs);
        } catch (error$1) {
          error("Language definition for '{}' could not be registered.".replace("{}", languageName));
          // hard or soft error
          if (!SAFE_MODE) { throw error$1; } else { error(error$1); }
          // languages that have serious errors are replaced with essentially a
          // "plaintext" stand-in so that the code blocks will still get normal
          // css classes applied to them - and one bad language won't break the
          // entire highlighter
          lang = PLAINTEXT_LANGUAGE;
        }
        // give it a temporary name if it doesn't have one in the meta-data
        if (!lang.name) lang.name = languageName;
        languages[languageName] = lang;
        lang.rawDefinition = languageDefinition.bind(null, hljs);

        if (lang.aliases) {
          registerAliases(lang.aliases, { languageName });
        }
      }

      /**
       * Remove a language grammar module
       *
       * @param {string} languageName
       */
      function unregisterLanguage(languageName) {
        delete languages[languageName];
        for (const alias of Object.keys(aliases)) {
          if (aliases[alias] === languageName) {
            delete aliases[alias];
          }
        }
      }

      /**
       * @returns {string[]} List of language internal names
       */
      function listLanguages() {
        return Object.keys(languages);
      }

      /**
        intended usage: When one language truly requires another

        Unlike `getLanguage`, this will throw when the requested language
        is not available.

        @param {string} name - name of the language to fetch/require
        @returns {Language | never}
      */
      function requireLanguage(name) {
        deprecated("10.4.0", "requireLanguage will be removed entirely in v11.");
        deprecated("10.4.0", "Please see https://github.com/highlightjs/highlight.js/pull/2844");

        const lang = getLanguage(name);
        if (lang) { return lang; }

        const err = new Error('The \'{}\' language is required, but not loaded.'.replace('{}', name));
        throw err;
      }

      /**
       * @param {string} name - name of the language to retrieve
       * @returns {Language | undefined}
       */
      function getLanguage(name) {
        name = (name || '').toLowerCase();
        return languages[name] || languages[aliases[name]];
      }

      /**
       *
       * @param {string|string[]} aliasList - single alias or list of aliases
       * @param {{languageName: string}} opts
       */
      function registerAliases(aliasList, { languageName }) {
        if (typeof aliasList === 'string') {
          aliasList = [aliasList];
        }
        aliasList.forEach(alias => { aliases[alias.toLowerCase()] = languageName; });
      }

      /**
       * Determines if a given language has auto-detection enabled
       * @param {string} name - name of the language
       */
      function autoDetection(name) {
        const lang = getLanguage(name);
        return lang && !lang.disableAutodetect;
      }

      /**
       * Upgrades the old highlightBlock plugins to the new
       * highlightElement API
       * @param {HLJSPlugin} plugin
       */
      function upgradePluginAPI(plugin) {
        // TODO: remove with v12
        if (plugin["before:highlightBlock"] && !plugin["before:highlightElement"]) {
          plugin["before:highlightElement"] = (data) => {
            plugin["before:highlightBlock"](
              Object.assign({ block: data.el }, data)
            );
          };
        }
        if (plugin["after:highlightBlock"] && !plugin["after:highlightElement"]) {
          plugin["after:highlightElement"] = (data) => {
            plugin["after:highlightBlock"](
              Object.assign({ block: data.el }, data)
            );
          };
        }
      }

      /**
       * @param {HLJSPlugin} plugin
       */
      function addPlugin(plugin) {
        upgradePluginAPI(plugin);
        plugins.push(plugin);
      }

      /**
       *
       * @param {PluginEvent} event
       * @param {any} args
       */
      function fire(event, args) {
        const cb = event;
        plugins.forEach(function(plugin) {
          if (plugin[cb]) {
            plugin[cb](args);
          }
        });
      }

      /**
      Note: fixMarkup is deprecated and will be removed entirely in v11

      @param {string} arg
      @returns {string}
      */
      function deprecateFixMarkup(arg) {
        deprecated("10.2.0", "fixMarkup will be removed entirely in v11.0");
        deprecated("10.2.0", "Please see https://github.com/highlightjs/highlight.js/issues/2534");

        return fixMarkup(arg);
      }

      /**
       *
       * @param {HighlightedHTMLElement} el
       */
      function deprecateHighlightBlock(el) {
        deprecated("10.7.0", "highlightBlock will be removed entirely in v12.0");
        deprecated("10.7.0", "Please use highlightElement now.");

        return highlightElement(el);
      }

      /* Interface definition */
      Object.assign(hljs, {
        highlight,
        highlightAuto,
        highlightAll,
        fixMarkup: deprecateFixMarkup,
        highlightElement,
        // TODO: Remove with v12 API
        highlightBlock: deprecateHighlightBlock,
        configure,
        initHighlighting,
        initHighlightingOnLoad,
        registerLanguage,
        unregisterLanguage,
        listLanguages,
        getLanguage,
        registerAliases,
        requireLanguage,
        autoDetection,
        inherit: inherit$1$1,
        addPlugin,
        // plugins for frameworks
        vuePlugin: BuildVuePlugin(hljs).VuePlugin
      });

      hljs.debugMode = function() { SAFE_MODE = false; };
      hljs.safeMode = function() { SAFE_MODE = true; };
      hljs.versionString = version;

      for (const key in MODES) {
        // @ts-ignore
        if (typeof MODES[key] === "object") {
          // @ts-ignore
          deepFreezeEs6(MODES[key]);
        }
      }

      // merge all the modes/regexs into our main object
      Object.assign(hljs, MODES);

      // built-in plugins, likely to be moved out of core in the future
      hljs.addPlugin(brPlugin); // slated to be removed in v11
      hljs.addPlugin(mergeHTMLPlugin);
      hljs.addPlugin(tabReplacePlugin);
      return hljs;
    };

    // export an "instance" of the highlighter
    var highlight = HLJS({});

    var core = highlight;

    /*
    Language: C#
    Author: Jason Diamond <jason@diamond.name>
    Contributor: Nicolas LLOBERA <nllobera@gmail.com>, Pieter Vantorre <pietervantorre@gmail.com>, David Pine <david.pine@microsoft.com>
    Website: https://docs.microsoft.com/en-us/dotnet/csharp/
    Category: common
    */

    /** @type LanguageFn */
    function csharp(hljs) {
      const BUILT_IN_KEYWORDS = [
        'bool',
        'byte',
        'char',
        'decimal',
        'delegate',
        'double',
        'dynamic',
        'enum',
        'float',
        'int',
        'long',
        'nint',
        'nuint',
        'object',
        'sbyte',
        'short',
        'string',
        'ulong',
        'uint',
        'ushort'
      ];
      const FUNCTION_MODIFIERS = [
        'public',
        'private',
        'protected',
        'static',
        'internal',
        'protected',
        'abstract',
        'async',
        'extern',
        'override',
        'unsafe',
        'virtual',
        'new',
        'sealed',
        'partial'
      ];
      const LITERAL_KEYWORDS = [
        'default',
        'false',
        'null',
        'true'
      ];
      const NORMAL_KEYWORDS = [
        'abstract',
        'as',
        'base',
        'break',
        'case',
        'class',
        'const',
        'continue',
        'do',
        'else',
        'event',
        'explicit',
        'extern',
        'finally',
        'fixed',
        'for',
        'foreach',
        'goto',
        'if',
        'implicit',
        'in',
        'interface',
        'internal',
        'is',
        'lock',
        'namespace',
        'new',
        'operator',
        'out',
        'override',
        'params',
        'private',
        'protected',
        'public',
        'readonly',
        'record',
        'ref',
        'return',
        'sealed',
        'sizeof',
        'stackalloc',
        'static',
        'struct',
        'switch',
        'this',
        'throw',
        'try',
        'typeof',
        'unchecked',
        'unsafe',
        'using',
        'virtual',
        'void',
        'volatile',
        'while'
      ];
      const CONTEXTUAL_KEYWORDS = [
        'add',
        'alias',
        'and',
        'ascending',
        'async',
        'await',
        'by',
        'descending',
        'equals',
        'from',
        'get',
        'global',
        'group',
        'init',
        'into',
        'join',
        'let',
        'nameof',
        'not',
        'notnull',
        'on',
        'or',
        'orderby',
        'partial',
        'remove',
        'select',
        'set',
        'unmanaged',
        'value|0',
        'var',
        'when',
        'where',
        'with',
        'yield'
      ];

      const KEYWORDS = {
        keyword: NORMAL_KEYWORDS.concat(CONTEXTUAL_KEYWORDS),
        built_in: BUILT_IN_KEYWORDS,
        literal: LITERAL_KEYWORDS
      };
      const TITLE_MODE = hljs.inherit(hljs.TITLE_MODE, {
        begin: '[a-zA-Z](\\.?\\w)*'
      });
      const NUMBERS = {
        className: 'number',
        variants: [
          {
            begin: '\\b(0b[01\']+)'
          },
          {
            begin: '(-?)\\b([\\d\']+(\\.[\\d\']*)?|\\.[\\d\']+)(u|U|l|L|ul|UL|f|F|b|B)'
          },
          {
            begin: '(-?)(\\b0[xX][a-fA-F0-9\']+|(\\b[\\d\']+(\\.[\\d\']*)?|\\.[\\d\']+)([eE][-+]?[\\d\']+)?)'
          }
        ],
        relevance: 0
      };
      const VERBATIM_STRING = {
        className: 'string',
        begin: '@"',
        end: '"',
        contains: [
          {
            begin: '""'
          }
        ]
      };
      const VERBATIM_STRING_NO_LF = hljs.inherit(VERBATIM_STRING, {
        illegal: /\n/
      });
      const SUBST = {
        className: 'subst',
        begin: /\{/,
        end: /\}/,
        keywords: KEYWORDS
      };
      const SUBST_NO_LF = hljs.inherit(SUBST, {
        illegal: /\n/
      });
      const INTERPOLATED_STRING = {
        className: 'string',
        begin: /\$"/,
        end: '"',
        illegal: /\n/,
        contains: [
          {
            begin: /\{\{/
          },
          {
            begin: /\}\}/
          },
          hljs.BACKSLASH_ESCAPE,
          SUBST_NO_LF
        ]
      };
      const INTERPOLATED_VERBATIM_STRING = {
        className: 'string',
        begin: /\$@"/,
        end: '"',
        contains: [
          {
            begin: /\{\{/
          },
          {
            begin: /\}\}/
          },
          {
            begin: '""'
          },
          SUBST
        ]
      };
      const INTERPOLATED_VERBATIM_STRING_NO_LF = hljs.inherit(INTERPOLATED_VERBATIM_STRING, {
        illegal: /\n/,
        contains: [
          {
            begin: /\{\{/
          },
          {
            begin: /\}\}/
          },
          {
            begin: '""'
          },
          SUBST_NO_LF
        ]
      });
      SUBST.contains = [
        INTERPOLATED_VERBATIM_STRING,
        INTERPOLATED_STRING,
        VERBATIM_STRING,
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE,
        NUMBERS,
        hljs.C_BLOCK_COMMENT_MODE
      ];
      SUBST_NO_LF.contains = [
        INTERPOLATED_VERBATIM_STRING_NO_LF,
        INTERPOLATED_STRING,
        VERBATIM_STRING_NO_LF,
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE,
        NUMBERS,
        hljs.inherit(hljs.C_BLOCK_COMMENT_MODE, {
          illegal: /\n/
        })
      ];
      const STRING = {
        variants: [
          INTERPOLATED_VERBATIM_STRING,
          INTERPOLATED_STRING,
          VERBATIM_STRING,
          hljs.APOS_STRING_MODE,
          hljs.QUOTE_STRING_MODE
        ]
      };

      const GENERIC_MODIFIER = {
        begin: "<",
        end: ">",
        contains: [
          {
            beginKeywords: "in out"
          },
          TITLE_MODE
        ]
      };
      const TYPE_IDENT_RE = hljs.IDENT_RE + '(<' + hljs.IDENT_RE + '(\\s*,\\s*' + hljs.IDENT_RE + ')*>)?(\\[\\])?';
      const AT_IDENTIFIER = {
        // prevents expressions like `@class` from incorrect flagging
        // `class` as a keyword
        begin: "@" + hljs.IDENT_RE,
        relevance: 0
      };

      return {
        name: 'C#',
        aliases: [
          'cs',
          'c#'
        ],
        keywords: KEYWORDS,
        illegal: /::/,
        contains: [
          hljs.COMMENT(
            '///',
            '$',
            {
              returnBegin: true,
              contains: [
                {
                  className: 'doctag',
                  variants: [
                    {
                      begin: '///',
                      relevance: 0
                    },
                    {
                      begin: '<!--|-->'
                    },
                    {
                      begin: '</?',
                      end: '>'
                    }
                  ]
                }
              ]
            }
          ),
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE,
          {
            className: 'meta',
            begin: '#',
            end: '$',
            keywords: {
              'meta-keyword': 'if else elif endif define undef warning error line region endregion pragma checksum'
            }
          },
          STRING,
          NUMBERS,
          {
            beginKeywords: 'class interface',
            relevance: 0,
            end: /[{;=]/,
            illegal: /[^\s:,]/,
            contains: [
              {
                beginKeywords: "where class"
              },
              TITLE_MODE,
              GENERIC_MODIFIER,
              hljs.C_LINE_COMMENT_MODE,
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            beginKeywords: 'namespace',
            relevance: 0,
            end: /[{;=]/,
            illegal: /[^\s:]/,
            contains: [
              TITLE_MODE,
              hljs.C_LINE_COMMENT_MODE,
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            beginKeywords: 'record',
            relevance: 0,
            end: /[{;=]/,
            illegal: /[^\s:]/,
            contains: [
              TITLE_MODE,
              GENERIC_MODIFIER,
              hljs.C_LINE_COMMENT_MODE,
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            // [Attributes("")]
            className: 'meta',
            begin: '^\\s*\\[',
            excludeBegin: true,
            end: '\\]',
            excludeEnd: true,
            contains: [
              {
                className: 'meta-string',
                begin: /"/,
                end: /"/
              }
            ]
          },
          {
            // Expression keywords prevent 'keyword Name(...)' from being
            // recognized as a function definition
            beginKeywords: 'new return throw await else',
            relevance: 0
          },
          {
            className: 'function',
            begin: '(' + TYPE_IDENT_RE + '\\s+)+' + hljs.IDENT_RE + '\\s*(<.+>\\s*)?\\(',
            returnBegin: true,
            end: /\s*[{;=]/,
            excludeEnd: true,
            keywords: KEYWORDS,
            contains: [
              // prevents these from being highlighted `title`
              {
                beginKeywords: FUNCTION_MODIFIERS.join(" "),
                relevance: 0
              },
              {
                begin: hljs.IDENT_RE + '\\s*(<.+>\\s*)?\\(',
                returnBegin: true,
                contains: [
                  hljs.TITLE_MODE,
                  GENERIC_MODIFIER
                ],
                relevance: 0
              },
              {
                className: 'params',
                begin: /\(/,
                end: /\)/,
                excludeBegin: true,
                excludeEnd: true,
                keywords: KEYWORDS,
                relevance: 0,
                contains: [
                  STRING,
                  NUMBERS,
                  hljs.C_BLOCK_COMMENT_MODE
                ]
              },
              hljs.C_LINE_COMMENT_MODE,
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          AT_IDENTIFIER
        ]
      };
    }

    var csharp_1 = csharp;

    // https://docs.oracle.com/javase/specs/jls/se15/html/jls-3.html#jls-3.10
    var decimalDigits$1 = '[0-9](_*[0-9])*';
    var frac$1 = `\\.(${decimalDigits$1})`;
    var hexDigits$1 = '[0-9a-fA-F](_*[0-9a-fA-F])*';
    var NUMERIC$1 = {
      className: 'number',
      variants: [
        // DecimalFloatingPointLiteral
        // including ExponentPart
        { begin: `(\\b(${decimalDigits$1})((${frac$1})|\\.)?|(${frac$1}))` +
          `[eE][+-]?(${decimalDigits$1})[fFdD]?\\b` },
        // excluding ExponentPart
        { begin: `\\b(${decimalDigits$1})((${frac$1})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
        { begin: `(${frac$1})[fFdD]?\\b` },
        { begin: `\\b(${decimalDigits$1})[fFdD]\\b` },

        // HexadecimalFloatingPointLiteral
        { begin: `\\b0[xX]((${hexDigits$1})\\.?|(${hexDigits$1})?\\.(${hexDigits$1}))` +
          `[pP][+-]?(${decimalDigits$1})[fFdD]?\\b` },

        // DecimalIntegerLiteral
        { begin: '\\b(0|[1-9](_*[0-9])*)[lL]?\\b' },

        // HexIntegerLiteral
        { begin: `\\b0[xX](${hexDigits$1})[lL]?\\b` },

        // OctalIntegerLiteral
        { begin: '\\b0(_*[0-7])*[lL]?\\b' },

        // BinaryIntegerLiteral
        { begin: '\\b0[bB][01](_*[01])*[lL]?\\b' },
      ],
      relevance: 0
    };

    /*
    Language: Java
    Author: Vsevolod Solovyov <vsevolod.solovyov@gmail.com>
    Category: common, enterprise
    Website: https://www.java.com/
    */

    function java(hljs) {
      var JAVA_IDENT_RE = '[\u00C0-\u02B8a-zA-Z_$][\u00C0-\u02B8a-zA-Z_$0-9]*';
      var GENERIC_IDENT_RE = JAVA_IDENT_RE + '(<' + JAVA_IDENT_RE + '(\\s*,\\s*' + JAVA_IDENT_RE + ')*>)?';
      var KEYWORDS = 'false synchronized int abstract float private char boolean var static null if const ' +
        'for true while long strictfp finally protected import native final void ' +
        'enum else break transient catch instanceof byte super volatile case assert short ' +
        'package default double public try this switch continue throws protected public private ' +
        'module requires exports do';

      var ANNOTATION = {
        className: 'meta',
        begin: '@' + JAVA_IDENT_RE,
        contains: [
          {
            begin: /\(/,
            end: /\)/,
            contains: ["self"] // allow nested () inside our annotation
          },
        ]
      };
      const NUMBER = NUMERIC$1;

      return {
        name: 'Java',
        aliases: ['jsp'],
        keywords: KEYWORDS,
        illegal: /<\/|#/,
        contains: [
          hljs.COMMENT(
            '/\\*\\*',
            '\\*/',
            {
              relevance: 0,
              contains: [
                {
                  // eat up @'s in emails to prevent them to be recognized as doctags
                  begin: /\w+@/, relevance: 0
                },
                {
                  className: 'doctag',
                  begin: '@[A-Za-z]+'
                }
              ]
            }
          ),
          // relevance boost
          {
            begin: /import java\.[a-z]+\./,
            keywords: "import",
            relevance: 2
          },
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE,
          hljs.APOS_STRING_MODE,
          hljs.QUOTE_STRING_MODE,
          {
            className: 'class',
            beginKeywords: 'class interface enum', end: /[{;=]/, excludeEnd: true,
            // TODO: can this be removed somehow?
            // an extra boost because Java is more popular than other languages with
            // this same syntax feature (this is just to preserve our tests passing
            // for now)
            relevance: 1,
            keywords: 'class interface enum',
            illegal: /[:"\[\]]/,
            contains: [
              { beginKeywords: 'extends implements' },
              hljs.UNDERSCORE_TITLE_MODE
            ]
          },
          {
            // Expression keywords prevent 'keyword Name(...)' from being
            // recognized as a function definition
            beginKeywords: 'new throw return else',
            relevance: 0
          },
          {
            className: 'class',
            begin: 'record\\s+' + hljs.UNDERSCORE_IDENT_RE + '\\s*\\(',
            returnBegin: true,
            excludeEnd: true,
            end: /[{;=]/,
            keywords: KEYWORDS,
            contains: [
              { beginKeywords: "record" },
              {
                begin: hljs.UNDERSCORE_IDENT_RE + '\\s*\\(',
                returnBegin: true,
                relevance: 0,
                contains: [hljs.UNDERSCORE_TITLE_MODE]
              },
              {
                className: 'params',
                begin: /\(/, end: /\)/,
                keywords: KEYWORDS,
                relevance: 0,
                contains: [
                  hljs.C_BLOCK_COMMENT_MODE
                ]
              },
              hljs.C_LINE_COMMENT_MODE,
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            className: 'function',
            begin: '(' + GENERIC_IDENT_RE + '\\s+)+' + hljs.UNDERSCORE_IDENT_RE + '\\s*\\(', returnBegin: true, end: /[{;=]/,
            excludeEnd: true,
            keywords: KEYWORDS,
            contains: [
              {
                begin: hljs.UNDERSCORE_IDENT_RE + '\\s*\\(', returnBegin: true,
                relevance: 0,
                contains: [hljs.UNDERSCORE_TITLE_MODE]
              },
              {
                className: 'params',
                begin: /\(/, end: /\)/,
                keywords: KEYWORDS,
                relevance: 0,
                contains: [
                  ANNOTATION,
                  hljs.APOS_STRING_MODE,
                  hljs.QUOTE_STRING_MODE,
                  NUMBER,
                  hljs.C_BLOCK_COMMENT_MODE
                ]
              },
              hljs.C_LINE_COMMENT_MODE,
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          NUMBER,
          ANNOTATION
        ]
      };
    }

    var java_1 = java;

    // https://docs.oracle.com/javase/specs/jls/se15/html/jls-3.html#jls-3.10
    var decimalDigits = '[0-9](_*[0-9])*';
    var frac = `\\.(${decimalDigits})`;
    var hexDigits = '[0-9a-fA-F](_*[0-9a-fA-F])*';
    var NUMERIC = {
      className: 'number',
      variants: [
        // DecimalFloatingPointLiteral
        // including ExponentPart
        { begin: `(\\b(${decimalDigits})((${frac})|\\.)?|(${frac}))` +
          `[eE][+-]?(${decimalDigits})[fFdD]?\\b` },
        // excluding ExponentPart
        { begin: `\\b(${decimalDigits})((${frac})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
        { begin: `(${frac})[fFdD]?\\b` },
        { begin: `\\b(${decimalDigits})[fFdD]\\b` },

        // HexadecimalFloatingPointLiteral
        { begin: `\\b0[xX]((${hexDigits})\\.?|(${hexDigits})?\\.(${hexDigits}))` +
          `[pP][+-]?(${decimalDigits})[fFdD]?\\b` },

        // DecimalIntegerLiteral
        { begin: '\\b(0|[1-9](_*[0-9])*)[lL]?\\b' },

        // HexIntegerLiteral
        { begin: `\\b0[xX](${hexDigits})[lL]?\\b` },

        // OctalIntegerLiteral
        { begin: '\\b0(_*[0-7])*[lL]?\\b' },

        // BinaryIntegerLiteral
        { begin: '\\b0[bB][01](_*[01])*[lL]?\\b' },
      ],
      relevance: 0
    };

    /*
     Language: Kotlin
     Description: Kotlin is an OSS statically typed programming language that targets the JVM, Android, JavaScript and Native.
     Author: Sergey Mashkov <cy6erGn0m@gmail.com>
     Website: https://kotlinlang.org
     Category: common
     */

    function kotlin(hljs) {
      const KEYWORDS = {
        keyword:
          'abstract as val var vararg get set class object open private protected public noinline ' +
          'crossinline dynamic final enum if else do while for when throw try catch finally ' +
          'import package is in fun override companion reified inline lateinit init ' +
          'interface annotation data sealed internal infix operator out by constructor super ' +
          'tailrec where const inner suspend typealias external expect actual',
        built_in:
          'Byte Short Char Int Long Boolean Float Double Void Unit Nothing',
        literal:
          'true false null'
      };
      const KEYWORDS_WITH_LABEL = {
        className: 'keyword',
        begin: /\b(break|continue|return|this)\b/,
        starts: {
          contains: [
            {
              className: 'symbol',
              begin: /@\w+/
            }
          ]
        }
      };
      const LABEL = {
        className: 'symbol',
        begin: hljs.UNDERSCORE_IDENT_RE + '@'
      };

      // for string templates
      const SUBST = {
        className: 'subst',
        begin: /\$\{/,
        end: /\}/,
        contains: [ hljs.C_NUMBER_MODE ]
      };
      const VARIABLE = {
        className: 'variable',
        begin: '\\$' + hljs.UNDERSCORE_IDENT_RE
      };
      const STRING = {
        className: 'string',
        variants: [
          {
            begin: '"""',
            end: '"""(?=[^"])',
            contains: [
              VARIABLE,
              SUBST
            ]
          },
          // Can't use built-in modes easily, as we want to use STRING in the meta
          // context as 'meta-string' and there's no syntax to remove explicitly set
          // classNames in built-in modes.
          {
            begin: '\'',
            end: '\'',
            illegal: /\n/,
            contains: [ hljs.BACKSLASH_ESCAPE ]
          },
          {
            begin: '"',
            end: '"',
            illegal: /\n/,
            contains: [
              hljs.BACKSLASH_ESCAPE,
              VARIABLE,
              SUBST
            ]
          }
        ]
      };
      SUBST.contains.push(STRING);

      const ANNOTATION_USE_SITE = {
        className: 'meta',
        begin: '@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*' + hljs.UNDERSCORE_IDENT_RE + ')?'
      };
      const ANNOTATION = {
        className: 'meta',
        begin: '@' + hljs.UNDERSCORE_IDENT_RE,
        contains: [
          {
            begin: /\(/,
            end: /\)/,
            contains: [
              hljs.inherit(STRING, {
                className: 'meta-string'
              })
            ]
          }
        ]
      };

      // https://kotlinlang.org/docs/reference/whatsnew11.html#underscores-in-numeric-literals
      // According to the doc above, the number mode of kotlin is the same as java 8,
      // so the code below is copied from java.js
      const KOTLIN_NUMBER_MODE = NUMERIC;
      const KOTLIN_NESTED_COMMENT = hljs.COMMENT(
        '/\\*', '\\*/',
        {
          contains: [ hljs.C_BLOCK_COMMENT_MODE ]
        }
      );
      const KOTLIN_PAREN_TYPE = {
        variants: [
          {
            className: 'type',
            begin: hljs.UNDERSCORE_IDENT_RE
          },
          {
            begin: /\(/,
            end: /\)/,
            contains: [] // defined later
          }
        ]
      };
      const KOTLIN_PAREN_TYPE2 = KOTLIN_PAREN_TYPE;
      KOTLIN_PAREN_TYPE2.variants[1].contains = [ KOTLIN_PAREN_TYPE ];
      KOTLIN_PAREN_TYPE.variants[1].contains = [ KOTLIN_PAREN_TYPE2 ];

      return {
        name: 'Kotlin',
        aliases: [ 'kt', 'kts' ],
        keywords: KEYWORDS,
        contains: [
          hljs.COMMENT(
            '/\\*\\*',
            '\\*/',
            {
              relevance: 0,
              contains: [
                {
                  className: 'doctag',
                  begin: '@[A-Za-z]+'
                }
              ]
            }
          ),
          hljs.C_LINE_COMMENT_MODE,
          KOTLIN_NESTED_COMMENT,
          KEYWORDS_WITH_LABEL,
          LABEL,
          ANNOTATION_USE_SITE,
          ANNOTATION,
          {
            className: 'function',
            beginKeywords: 'fun',
            end: '[(]|$',
            returnBegin: true,
            excludeEnd: true,
            keywords: KEYWORDS,
            relevance: 5,
            contains: [
              {
                begin: hljs.UNDERSCORE_IDENT_RE + '\\s*\\(',
                returnBegin: true,
                relevance: 0,
                contains: [ hljs.UNDERSCORE_TITLE_MODE ]
              },
              {
                className: 'type',
                begin: /</,
                end: />/,
                keywords: 'reified',
                relevance: 0
              },
              {
                className: 'params',
                begin: /\(/,
                end: /\)/,
                endsParent: true,
                keywords: KEYWORDS,
                relevance: 0,
                contains: [
                  {
                    begin: /:/,
                    end: /[=,\/]/,
                    endsWithParent: true,
                    contains: [
                      KOTLIN_PAREN_TYPE,
                      hljs.C_LINE_COMMENT_MODE,
                      KOTLIN_NESTED_COMMENT
                    ],
                    relevance: 0
                  },
                  hljs.C_LINE_COMMENT_MODE,
                  KOTLIN_NESTED_COMMENT,
                  ANNOTATION_USE_SITE,
                  ANNOTATION,
                  STRING,
                  hljs.C_NUMBER_MODE
                ]
              },
              KOTLIN_NESTED_COMMENT
            ]
          },
          {
            className: 'class',
            beginKeywords: 'class interface trait', // remove 'trait' when removed from KEYWORDS
            end: /[:\{(]|$/,
            excludeEnd: true,
            illegal: 'extends implements',
            contains: [
              {
                beginKeywords: 'public protected internal private constructor'
              },
              hljs.UNDERSCORE_TITLE_MODE,
              {
                className: 'type',
                begin: /</,
                end: />/,
                excludeBegin: true,
                excludeEnd: true,
                relevance: 0
              },
              {
                className: 'type',
                begin: /[,:]\s*/,
                end: /[<\(,]|$/,
                excludeBegin: true,
                returnEnd: true
              },
              ANNOTATION_USE_SITE,
              ANNOTATION
            ]
          },
          STRING,
          {
            className: 'meta',
            begin: "^#!/usr/bin/env",
            end: '$',
            illegal: '\n'
          },
          KOTLIN_NUMBER_MODE
        ]
      };
    }

    var kotlin_1 = kotlin;

    /*
    Language: Scala
    Category: functional
    Author: Jan Berkel <jan.berkel@gmail.com>
    Contributors: Erik Osheim <d_m@plastic-idolatry.com>
    Website: https://www.scala-lang.org
    */

    function scala(hljs) {
      const ANNOTATION = {
        className: 'meta',
        begin: '@[A-Za-z]+'
      };

      // used in strings for escaping/interpolation/substitution
      const SUBST = {
        className: 'subst',
        variants: [
          {
            begin: '\\$[A-Za-z0-9_]+'
          },
          {
            begin: /\$\{/,
            end: /\}/
          }
        ]
      };

      const STRING = {
        className: 'string',
        variants: [
          {
            begin: '"""',
            end: '"""'
          },
          {
            begin: '"',
            end: '"',
            illegal: '\\n',
            contains: [ hljs.BACKSLASH_ESCAPE ]
          },
          {
            begin: '[a-z]+"',
            end: '"',
            illegal: '\\n',
            contains: [
              hljs.BACKSLASH_ESCAPE,
              SUBST
            ]
          },
          {
            className: 'string',
            begin: '[a-z]+"""',
            end: '"""',
            contains: [ SUBST ],
            relevance: 10
          }
        ]

      };

      const SYMBOL = {
        className: 'symbol',
        begin: '\'\\w[\\w\\d_]*(?!\')'
      };

      const TYPE = {
        className: 'type',
        begin: '\\b[A-Z][A-Za-z0-9_]*',
        relevance: 0
      };

      const NAME = {
        className: 'title',
        begin: /[^0-9\n\t "'(),.`{}\[\]:;][^\n\t "'(),.`{}\[\]:;]+|[^0-9\n\t "'(),.`{}\[\]:;=]/,
        relevance: 0
      };

      const CLASS = {
        className: 'class',
        beginKeywords: 'class object trait type',
        end: /[:={\[\n;]/,
        excludeEnd: true,
        contains: [
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE,
          {
            beginKeywords: 'extends with',
            relevance: 10
          },
          {
            begin: /\[/,
            end: /\]/,
            excludeBegin: true,
            excludeEnd: true,
            relevance: 0,
            contains: [ TYPE ]
          },
          {
            className: 'params',
            begin: /\(/,
            end: /\)/,
            excludeBegin: true,
            excludeEnd: true,
            relevance: 0,
            contains: [ TYPE ]
          },
          NAME
        ]
      };

      const METHOD = {
        className: 'function',
        beginKeywords: 'def',
        end: /[:={\[(\n;]/,
        excludeEnd: true,
        contains: [ NAME ]
      };

      return {
        name: 'Scala',
        keywords: {
          literal: 'true false null',
          keyword: 'type yield lazy override def with val var sealed abstract private trait object if forSome for while throw finally protected extends import final return else break new catch super class case package default try this match continue throws implicit'
        },
        contains: [
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE,
          STRING,
          SYMBOL,
          TYPE,
          METHOD,
          CLASS,
          hljs.C_NUMBER_MODE,
          ANNOTATION
        ]
      };
    }

    var scala_1 = scala;

    /**
     * @param {string} value
     * @returns {RegExp}
     * */

    /**
     * @param {RegExp | string } re
     * @returns {string}
     */
    function source$1(re) {
      if (!re) return null;
      if (typeof re === "string") return re;

      return re.source;
    }

    /**
     * @param {...(RegExp | string) } args
     * @returns {string}
     */
    function concat$1(...args) {
      const joined = args.map((x) => source$1(x)).join("");
      return joined;
    }

    /**
     * Any of the passed expresssions may match
     *
     * Creates a huge this | this | that | that match
     * @param {(RegExp | string)[] } args
     * @returns {string}
     */
    function either(...args) {
      const joined = '(' + args.map((x) => source$1(x)).join("|") + ")";
      return joined;
    }

    /*
     Language: SQL
     Website: https://en.wikipedia.org/wiki/SQL
     Category: common, database
     */

    function sql(hljs) {
      const COMMENT_MODE = hljs.COMMENT('--', '$');
      const STRING = {
        className: 'string',
        variants: [
          {
            begin: /'/,
            end: /'/,
            contains: [
              {begin: /''/ }
            ]
          }
        ]
      };
      const QUOTED_IDENTIFIER = {
        begin: /"/,
        end: /"/,
        contains: [ { begin: /""/ } ]
      };

      const LITERALS = [
        "true",
        "false",
        // Not sure it's correct to call NULL literal, and clauses like IS [NOT] NULL look strange that way.
        // "null",
        "unknown"
      ];

      const MULTI_WORD_TYPES = [
        "double precision",
        "large object",
        "with timezone",
        "without timezone"
      ];

      const TYPES = [
        'bigint',
        'binary',
        'blob',
        'boolean',
        'char',
        'character',
        'clob',
        'date',
        'dec',
        'decfloat',
        'decimal',
        'float',
        'int',
        'integer',
        'interval',
        'nchar',
        'nclob',
        'national',
        'numeric',
        'real',
        'row',
        'smallint',
        'time',
        'timestamp',
        'varchar',
        'varying', // modifier (character varying)
        'varbinary'
      ];

      const NON_RESERVED_WORDS = [
        "add",
        "asc",
        "collation",
        "desc",
        "final",
        "first",
        "last",
        "view"
      ];

      // https://jakewheat.github.io/sql-overview/sql-2016-foundation-grammar.html#reserved-word
      const RESERVED_WORDS = [
        "abs",
        "acos",
        "all",
        "allocate",
        "alter",
        "and",
        "any",
        "are",
        "array",
        "array_agg",
        "array_max_cardinality",
        "as",
        "asensitive",
        "asin",
        "asymmetric",
        "at",
        "atan",
        "atomic",
        "authorization",
        "avg",
        "begin",
        "begin_frame",
        "begin_partition",
        "between",
        "bigint",
        "binary",
        "blob",
        "boolean",
        "both",
        "by",
        "call",
        "called",
        "cardinality",
        "cascaded",
        "case",
        "cast",
        "ceil",
        "ceiling",
        "char",
        "char_length",
        "character",
        "character_length",
        "check",
        "classifier",
        "clob",
        "close",
        "coalesce",
        "collate",
        "collect",
        "column",
        "commit",
        "condition",
        "connect",
        "constraint",
        "contains",
        "convert",
        "copy",
        "corr",
        "corresponding",
        "cos",
        "cosh",
        "count",
        "covar_pop",
        "covar_samp",
        "create",
        "cross",
        "cube",
        "cume_dist",
        "current",
        "current_catalog",
        "current_date",
        "current_default_transform_group",
        "current_path",
        "current_role",
        "current_row",
        "current_schema",
        "current_time",
        "current_timestamp",
        "current_path",
        "current_role",
        "current_transform_group_for_type",
        "current_user",
        "cursor",
        "cycle",
        "date",
        "day",
        "deallocate",
        "dec",
        "decimal",
        "decfloat",
        "declare",
        "default",
        "define",
        "delete",
        "dense_rank",
        "deref",
        "describe",
        "deterministic",
        "disconnect",
        "distinct",
        "double",
        "drop",
        "dynamic",
        "each",
        "element",
        "else",
        "empty",
        "end",
        "end_frame",
        "end_partition",
        "end-exec",
        "equals",
        "escape",
        "every",
        "except",
        "exec",
        "execute",
        "exists",
        "exp",
        "external",
        "extract",
        "false",
        "fetch",
        "filter",
        "first_value",
        "float",
        "floor",
        "for",
        "foreign",
        "frame_row",
        "free",
        "from",
        "full",
        "function",
        "fusion",
        "get",
        "global",
        "grant",
        "group",
        "grouping",
        "groups",
        "having",
        "hold",
        "hour",
        "identity",
        "in",
        "indicator",
        "initial",
        "inner",
        "inout",
        "insensitive",
        "insert",
        "int",
        "integer",
        "intersect",
        "intersection",
        "interval",
        "into",
        "is",
        "join",
        "json_array",
        "json_arrayagg",
        "json_exists",
        "json_object",
        "json_objectagg",
        "json_query",
        "json_table",
        "json_table_primitive",
        "json_value",
        "lag",
        "language",
        "large",
        "last_value",
        "lateral",
        "lead",
        "leading",
        "left",
        "like",
        "like_regex",
        "listagg",
        "ln",
        "local",
        "localtime",
        "localtimestamp",
        "log",
        "log10",
        "lower",
        "match",
        "match_number",
        "match_recognize",
        "matches",
        "max",
        "member",
        "merge",
        "method",
        "min",
        "minute",
        "mod",
        "modifies",
        "module",
        "month",
        "multiset",
        "national",
        "natural",
        "nchar",
        "nclob",
        "new",
        "no",
        "none",
        "normalize",
        "not",
        "nth_value",
        "ntile",
        "null",
        "nullif",
        "numeric",
        "octet_length",
        "occurrences_regex",
        "of",
        "offset",
        "old",
        "omit",
        "on",
        "one",
        "only",
        "open",
        "or",
        "order",
        "out",
        "outer",
        "over",
        "overlaps",
        "overlay",
        "parameter",
        "partition",
        "pattern",
        "per",
        "percent",
        "percent_rank",
        "percentile_cont",
        "percentile_disc",
        "period",
        "portion",
        "position",
        "position_regex",
        "power",
        "precedes",
        "precision",
        "prepare",
        "primary",
        "procedure",
        "ptf",
        "range",
        "rank",
        "reads",
        "real",
        "recursive",
        "ref",
        "references",
        "referencing",
        "regr_avgx",
        "regr_avgy",
        "regr_count",
        "regr_intercept",
        "regr_r2",
        "regr_slope",
        "regr_sxx",
        "regr_sxy",
        "regr_syy",
        "release",
        "result",
        "return",
        "returns",
        "revoke",
        "right",
        "rollback",
        "rollup",
        "row",
        "row_number",
        "rows",
        "running",
        "savepoint",
        "scope",
        "scroll",
        "search",
        "second",
        "seek",
        "select",
        "sensitive",
        "session_user",
        "set",
        "show",
        "similar",
        "sin",
        "sinh",
        "skip",
        "smallint",
        "some",
        "specific",
        "specifictype",
        "sql",
        "sqlexception",
        "sqlstate",
        "sqlwarning",
        "sqrt",
        "start",
        "static",
        "stddev_pop",
        "stddev_samp",
        "submultiset",
        "subset",
        "substring",
        "substring_regex",
        "succeeds",
        "sum",
        "symmetric",
        "system",
        "system_time",
        "system_user",
        "table",
        "tablesample",
        "tan",
        "tanh",
        "then",
        "time",
        "timestamp",
        "timezone_hour",
        "timezone_minute",
        "to",
        "trailing",
        "translate",
        "translate_regex",
        "translation",
        "treat",
        "trigger",
        "trim",
        "trim_array",
        "true",
        "truncate",
        "uescape",
        "union",
        "unique",
        "unknown",
        "unnest",
        "update   ",
        "upper",
        "user",
        "using",
        "value",
        "values",
        "value_of",
        "var_pop",
        "var_samp",
        "varbinary",
        "varchar",
        "varying",
        "versioning",
        "when",
        "whenever",
        "where",
        "width_bucket",
        "window",
        "with",
        "within",
        "without",
        "year",
      ];

      // these are reserved words we have identified to be functions
      // and should only be highlighted in a dispatch-like context
      // ie, array_agg(...), etc.
      const RESERVED_FUNCTIONS = [
        "abs",
        "acos",
        "array_agg",
        "asin",
        "atan",
        "avg",
        "cast",
        "ceil",
        "ceiling",
        "coalesce",
        "corr",
        "cos",
        "cosh",
        "count",
        "covar_pop",
        "covar_samp",
        "cume_dist",
        "dense_rank",
        "deref",
        "element",
        "exp",
        "extract",
        "first_value",
        "floor",
        "json_array",
        "json_arrayagg",
        "json_exists",
        "json_object",
        "json_objectagg",
        "json_query",
        "json_table",
        "json_table_primitive",
        "json_value",
        "lag",
        "last_value",
        "lead",
        "listagg",
        "ln",
        "log",
        "log10",
        "lower",
        "max",
        "min",
        "mod",
        "nth_value",
        "ntile",
        "nullif",
        "percent_rank",
        "percentile_cont",
        "percentile_disc",
        "position",
        "position_regex",
        "power",
        "rank",
        "regr_avgx",
        "regr_avgy",
        "regr_count",
        "regr_intercept",
        "regr_r2",
        "regr_slope",
        "regr_sxx",
        "regr_sxy",
        "regr_syy",
        "row_number",
        "sin",
        "sinh",
        "sqrt",
        "stddev_pop",
        "stddev_samp",
        "substring",
        "substring_regex",
        "sum",
        "tan",
        "tanh",
        "translate",
        "translate_regex",
        "treat",
        "trim",
        "trim_array",
        "unnest",
        "upper",
        "value_of",
        "var_pop",
        "var_samp",
        "width_bucket",
      ];

      // these functions can
      const POSSIBLE_WITHOUT_PARENS = [
        "current_catalog",
        "current_date",
        "current_default_transform_group",
        "current_path",
        "current_role",
        "current_schema",
        "current_transform_group_for_type",
        "current_user",
        "session_user",
        "system_time",
        "system_user",
        "current_time",
        "localtime",
        "current_timestamp",
        "localtimestamp"
      ];

      // those exist to boost relevance making these very
      // "SQL like" keyword combos worth +1 extra relevance
      const COMBOS = [
        "create table",
        "insert into",
        "primary key",
        "foreign key",
        "not null",
        "alter table",
        "add constraint",
        "grouping sets",
        "on overflow",
        "character set",
        "respect nulls",
        "ignore nulls",
        "nulls first",
        "nulls last",
        "depth first",
        "breadth first"
      ];

      const FUNCTIONS = RESERVED_FUNCTIONS;

      const KEYWORDS = [...RESERVED_WORDS, ...NON_RESERVED_WORDS].filter((keyword) => {
        return !RESERVED_FUNCTIONS.includes(keyword);
      });

      const VARIABLE = {
        className: "variable",
        begin: /@[a-z0-9]+/,
      };

      const OPERATOR = {
        className: "operator",
        begin: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,
        relevance: 0,
      };

      const FUNCTION_CALL = {
        begin: concat$1(/\b/, either(...FUNCTIONS), /\s*\(/),
        keywords: {
          built_in: FUNCTIONS
        }
      };

      // keywords with less than 3 letters are reduced in relevancy
      function reduceRelevancy(list, {exceptions, when} = {}) {
        const qualifyFn = when;
        exceptions = exceptions || [];
        return list.map((item) => {
          if (item.match(/\|\d+$/) || exceptions.includes(item)) {
            return item;
          } else if (qualifyFn(item)) {
            return `${item}|0`;
          } else {
            return item;
          }
        });
      }

      return {
        name: 'SQL',
        case_insensitive: true,
        // does not include {} or HTML tags `</`
        illegal: /[{}]|<\//,
        keywords: {
          $pattern: /\b[\w\.]+/,
          keyword:
            reduceRelevancy(KEYWORDS, { when: (x) => x.length < 3 }),
          literal: LITERALS,
          type: TYPES,
          built_in: POSSIBLE_WITHOUT_PARENS
        },
        contains: [
          {
            begin: either(...COMBOS),
            keywords: {
              $pattern: /[\w\.]+/,
              keyword: KEYWORDS.concat(COMBOS),
              literal: LITERALS,
              type: TYPES
            },
          },
          {
            className: "type",
            begin: either(...MULTI_WORD_TYPES)
          },
          FUNCTION_CALL,
          VARIABLE,
          STRING,
          QUOTED_IDENTIFIER,
          hljs.C_NUMBER_MODE,
          hljs.C_BLOCK_COMMENT_MODE,
          COMMENT_MODE,
          OPERATOR
        ]
      };
    }

    var sql_1 = sql;

    const IDENT_RE = '[A-Za-z$_][0-9A-Za-z$_]*';
    const KEYWORDS = [
      "as", // for exports
      "in",
      "of",
      "if",
      "for",
      "while",
      "finally",
      "var",
      "new",
      "function",
      "do",
      "return",
      "void",
      "else",
      "break",
      "catch",
      "instanceof",
      "with",
      "throw",
      "case",
      "default",
      "try",
      "switch",
      "continue",
      "typeof",
      "delete",
      "let",
      "yield",
      "const",
      "class",
      // JS handles these with a special rule
      // "get",
      // "set",
      "debugger",
      "async",
      "await",
      "static",
      "import",
      "from",
      "export",
      "extends"
    ];
    const LITERALS = [
      "true",
      "false",
      "null",
      "undefined",
      "NaN",
      "Infinity"
    ];

    const TYPES = [
      "Intl",
      "DataView",
      "Number",
      "Math",
      "Date",
      "String",
      "RegExp",
      "Object",
      "Function",
      "Boolean",
      "Error",
      "Symbol",
      "Set",
      "Map",
      "WeakSet",
      "WeakMap",
      "Proxy",
      "Reflect",
      "JSON",
      "Promise",
      "Float64Array",
      "Int16Array",
      "Int32Array",
      "Int8Array",
      "Uint16Array",
      "Uint32Array",
      "Float32Array",
      "Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "ArrayBuffer",
      "BigInt64Array",
      "BigUint64Array",
      "BigInt"
    ];

    const ERROR_TYPES = [
      "EvalError",
      "InternalError",
      "RangeError",
      "ReferenceError",
      "SyntaxError",
      "TypeError",
      "URIError"
    ];

    const BUILT_IN_GLOBALS = [
      "setInterval",
      "setTimeout",
      "clearInterval",
      "clearTimeout",

      "require",
      "exports",

      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "unescape"
    ];

    const BUILT_IN_VARIABLES = [
      "arguments",
      "this",
      "super",
      "console",
      "window",
      "document",
      "localStorage",
      "module",
      "global" // Node.js
    ];

    const BUILT_INS = [].concat(
      BUILT_IN_GLOBALS,
      BUILT_IN_VARIABLES,
      TYPES,
      ERROR_TYPES
    );

    /**
     * @param {string} value
     * @returns {RegExp}
     * */

    /**
     * @param {RegExp | string } re
     * @returns {string}
     */
    function source(re) {
      if (!re) return null;
      if (typeof re === "string") return re;

      return re.source;
    }

    /**
     * @param {RegExp | string } re
     * @returns {string}
     */
    function lookahead(re) {
      return concat('(?=', re, ')');
    }

    /**
     * @param {...(RegExp | string) } args
     * @returns {string}
     */
    function concat(...args) {
      const joined = args.map((x) => source(x)).join("");
      return joined;
    }

    /*
    Language: JavaScript
    Description: JavaScript (JS) is a lightweight, interpreted, or just-in-time compiled programming language with first-class functions.
    Category: common, scripting
    Website: https://developer.mozilla.org/en-US/docs/Web/JavaScript
    */

    /** @type LanguageFn */
    function javascript(hljs) {
      /**
       * Takes a string like "<Booger" and checks to see
       * if we can find a matching "</Booger" later in the
       * content.
       * @param {RegExpMatchArray} match
       * @param {{after:number}} param1
       */
      const hasClosingTag = (match, { after }) => {
        const tag = "</" + match[0].slice(1);
        const pos = match.input.indexOf(tag, after);
        return pos !== -1;
      };

      const IDENT_RE$1 = IDENT_RE;
      const FRAGMENT = {
        begin: '<>',
        end: '</>'
      };
      const XML_TAG = {
        begin: /<[A-Za-z0-9\\._:-]+/,
        end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
        /**
         * @param {RegExpMatchArray} match
         * @param {CallbackResponse} response
         */
        isTrulyOpeningTag: (match, response) => {
          const afterMatchIndex = match[0].length + match.index;
          const nextChar = match.input[afterMatchIndex];
          // nested type?
          // HTML should not include another raw `<` inside a tag
          // But a type might: `<Array<Array<number>>`, etc.
          if (nextChar === "<") {
            response.ignoreMatch();
            return;
          }
          // <something>
          // This is now either a tag or a type.
          if (nextChar === ">") {
            // if we cannot find a matching closing tag, then we
            // will ignore it
            if (!hasClosingTag(match, { after: afterMatchIndex })) {
              response.ignoreMatch();
            }
          }
        }
      };
      const KEYWORDS$1 = {
        $pattern: IDENT_RE,
        keyword: KEYWORDS,
        literal: LITERALS,
        built_in: BUILT_INS
      };

      // https://tc39.es/ecma262/#sec-literals-numeric-literals
      const decimalDigits = '[0-9](_?[0-9])*';
      const frac = `\\.(${decimalDigits})`;
      // DecimalIntegerLiteral, including Annex B NonOctalDecimalIntegerLiteral
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
      const NUMBER = {
        className: 'number',
        variants: [
          // DecimalLiteral
          { begin: `(\\b(${decimalInteger})((${frac})|\\.)?|(${frac}))` +
            `[eE][+-]?(${decimalDigits})\\b` },
          { begin: `\\b(${decimalInteger})\\b((${frac})\\b|\\.)?|(${frac})\\b` },

          // DecimalBigIntegerLiteral
          { begin: `\\b(0|[1-9](_?[0-9])*)n\\b` },

          // NonDecimalIntegerLiteral
          { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
          { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
          { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },

          // LegacyOctalIntegerLiteral (does not include underscore separators)
          // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
          { begin: "\\b0[0-7]+n?\\b" },
        ],
        relevance: 0
      };

      const SUBST = {
        className: 'subst',
        begin: '\\$\\{',
        end: '\\}',
        keywords: KEYWORDS$1,
        contains: [] // defined later
      };
      const HTML_TEMPLATE = {
        begin: 'html`',
        end: '',
        starts: {
          end: '`',
          returnEnd: false,
          contains: [
            hljs.BACKSLASH_ESCAPE,
            SUBST
          ],
          subLanguage: 'xml'
        }
      };
      const CSS_TEMPLATE = {
        begin: 'css`',
        end: '',
        starts: {
          end: '`',
          returnEnd: false,
          contains: [
            hljs.BACKSLASH_ESCAPE,
            SUBST
          ],
          subLanguage: 'css'
        }
      };
      const TEMPLATE_STRING = {
        className: 'string',
        begin: '`',
        end: '`',
        contains: [
          hljs.BACKSLASH_ESCAPE,
          SUBST
        ]
      };
      const JSDOC_COMMENT = hljs.COMMENT(
        /\/\*\*(?!\/)/,
        '\\*/',
        {
          relevance: 0,
          contains: [
            {
              className: 'doctag',
              begin: '@[A-Za-z]+',
              contains: [
                {
                  className: 'type',
                  begin: '\\{',
                  end: '\\}',
                  relevance: 0
                },
                {
                  className: 'variable',
                  begin: IDENT_RE$1 + '(?=\\s*(-)|$)',
                  endsParent: true,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        }
      );
      const COMMENT = {
        className: "comment",
        variants: [
          JSDOC_COMMENT,
          hljs.C_BLOCK_COMMENT_MODE,
          hljs.C_LINE_COMMENT_MODE
        ]
      };
      const SUBST_INTERNALS = [
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE,
        HTML_TEMPLATE,
        CSS_TEMPLATE,
        TEMPLATE_STRING,
        NUMBER,
        hljs.REGEXP_MODE
      ];
      SUBST.contains = SUBST_INTERNALS
        .concat({
          // we need to pair up {} inside our subst to prevent
          // it from ending too early by matching another }
          begin: /\{/,
          end: /\}/,
          keywords: KEYWORDS$1,
          contains: [
            "self"
          ].concat(SUBST_INTERNALS)
        });
      const SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains);
      const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
        // eat recursive parens in sub expressions
        {
          begin: /\(/,
          end: /\)/,
          keywords: KEYWORDS$1,
          contains: ["self"].concat(SUBST_AND_COMMENTS)
        }
      ]);
      const PARAMS = {
        className: 'params',
        begin: /\(/,
        end: /\)/,
        excludeBegin: true,
        excludeEnd: true,
        keywords: KEYWORDS$1,
        contains: PARAMS_CONTAINS
      };

      return {
        name: 'Javascript',
        aliases: ['js', 'jsx', 'mjs', 'cjs'],
        keywords: KEYWORDS$1,
        // this will be extended by TypeScript
        exports: { PARAMS_CONTAINS },
        illegal: /#(?![$_A-z])/,
        contains: [
          hljs.SHEBANG({
            label: "shebang",
            binary: "node",
            relevance: 5
          }),
          {
            label: "use_strict",
            className: 'meta',
            relevance: 10,
            begin: /^\s*['"]use (strict|asm)['"]/
          },
          hljs.APOS_STRING_MODE,
          hljs.QUOTE_STRING_MODE,
          HTML_TEMPLATE,
          CSS_TEMPLATE,
          TEMPLATE_STRING,
          COMMENT,
          NUMBER,
          { // object attr container
            begin: concat(/[{,\n]\s*/,
              // we need to look ahead to make sure that we actually have an
              // attribute coming up so we don't steal a comma from a potential
              // "value" container
              //
              // NOTE: this might not work how you think.  We don't actually always
              // enter this mode and stay.  Instead it might merely match `,
              // <comments up next>` and then immediately end after the , because it
              // fails to find any actual attrs. But this still does the job because
              // it prevents the value contain rule from grabbing this instead and
              // prevening this rule from firing when we actually DO have keys.
              lookahead(concat(
                // we also need to allow for multiple possible comments inbetween
                // the first key:value pairing
                /(((\/\/.*$)|(\/\*(\*[^/]|[^*])*\*\/))\s*)*/,
                IDENT_RE$1 + '\\s*:'))),
            relevance: 0,
            contains: [
              {
                className: 'attr',
                begin: IDENT_RE$1 + lookahead('\\s*:'),
                relevance: 0
              }
            ]
          },
          { // "value" container
            begin: '(' + hljs.RE_STARTERS_RE + '|\\b(case|return|throw)\\b)\\s*',
            keywords: 'return throw case',
            contains: [
              COMMENT,
              hljs.REGEXP_MODE,
              {
                className: 'function',
                // we have to count the parens to make sure we actually have the
                // correct bounding ( ) before the =>.  There could be any number of
                // sub-expressions inside also surrounded by parens.
                begin: '(\\(' +
                '[^()]*(\\(' +
                '[^()]*(\\(' +
                '[^()]*' +
                '\\)[^()]*)*' +
                '\\)[^()]*)*' +
                '\\)|' + hljs.UNDERSCORE_IDENT_RE + ')\\s*=>',
                returnBegin: true,
                end: '\\s*=>',
                contains: [
                  {
                    className: 'params',
                    variants: [
                      {
                        begin: hljs.UNDERSCORE_IDENT_RE,
                        relevance: 0
                      },
                      {
                        className: null,
                        begin: /\(\s*\)/,
                        skip: true
                      },
                      {
                        begin: /\(/,
                        end: /\)/,
                        excludeBegin: true,
                        excludeEnd: true,
                        keywords: KEYWORDS$1,
                        contains: PARAMS_CONTAINS
                      }
                    ]
                  }
                ]
              },
              { // could be a comma delimited list of params to a function call
                begin: /,/, relevance: 0
              },
              {
                className: '',
                begin: /\s/,
                end: /\s*/,
                skip: true
              },
              { // JSX
                variants: [
                  { begin: FRAGMENT.begin, end: FRAGMENT.end },
                  {
                    begin: XML_TAG.begin,
                    // we carefully check the opening tag to see if it truly
                    // is a tag and not a false positive
                    'on:begin': XML_TAG.isTrulyOpeningTag,
                    end: XML_TAG.end
                  }
                ],
                subLanguage: 'xml',
                contains: [
                  {
                    begin: XML_TAG.begin,
                    end: XML_TAG.end,
                    skip: true,
                    contains: ['self']
                  }
                ]
              }
            ],
            relevance: 0
          },
          {
            className: 'function',
            beginKeywords: 'function',
            end: /[{;]/,
            excludeEnd: true,
            keywords: KEYWORDS$1,
            contains: [
              'self',
              hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1 }),
              PARAMS
            ],
            illegal: /%/
          },
          {
            // prevent this from getting swallowed up by function
            // since they appear "function like"
            beginKeywords: "while if switch catch for"
          },
          {
            className: 'function',
            // we have to count the parens to make sure we actually have the correct
            // bounding ( ).  There could be any number of sub-expressions inside
            // also surrounded by parens.
            begin: hljs.UNDERSCORE_IDENT_RE +
              '\\(' + // first parens
              '[^()]*(\\(' +
                '[^()]*(\\(' +
                  '[^()]*' +
                '\\)[^()]*)*' +
              '\\)[^()]*)*' +
              '\\)\\s*\\{', // end parens
            returnBegin:true,
            contains: [
              PARAMS,
              hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1 }),
            ]
          },
          // hack: prevents detection of keywords in some circumstances
          // .keyword()
          // $keyword = x
          {
            variants: [
              { begin: '\\.' + IDENT_RE$1 },
              { begin: '\\$' + IDENT_RE$1 }
            ],
            relevance: 0
          },
          { // ES6 class
            className: 'class',
            beginKeywords: 'class',
            end: /[{;=]/,
            excludeEnd: true,
            illegal: /[:"[\]]/,
            contains: [
              { beginKeywords: 'extends' },
              hljs.UNDERSCORE_TITLE_MODE
            ]
          },
          {
            begin: /\b(?=constructor)/,
            end: /[{;]/,
            excludeEnd: true,
            contains: [
              hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1 }),
              'self',
              PARAMS
            ]
          },
          {
            begin: '(get|set)\\s+(?=' + IDENT_RE$1 + '\\()',
            end: /\{/,
            keywords: "get set",
            contains: [
              hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1 }),
              { begin: /\(\)/ }, // eat to avoid empty params
              PARAMS
            ]
          },
          {
            begin: /\$[(.]/ // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
          }
        ]
      };
    }

    /*
    Language: TypeScript
    Author: Panu Horsmalahti <panu.horsmalahti@iki.fi>
    Contributors: Ike Ku <dempfi@yahoo.com>
    Description: TypeScript is a strict superset of JavaScript
    Website: https://www.typescriptlang.org
    Category: common, scripting
    */

    /** @type LanguageFn */
    function typescript(hljs) {
      const IDENT_RE$1 = IDENT_RE;
      const NAMESPACE = {
        beginKeywords: 'namespace', end: /\{/, excludeEnd: true
      };
      const INTERFACE = {
        beginKeywords: 'interface', end: /\{/, excludeEnd: true,
        keywords: 'interface extends'
      };
      const USE_STRICT = {
        className: 'meta',
        relevance: 10,
        begin: /^\s*['"]use strict['"]/
      };
      const TYPES = [
        "any",
        "void",
        "number",
        "boolean",
        "string",
        "object",
        "never",
        "enum"
      ];
      const TS_SPECIFIC_KEYWORDS = [
        "type",
        "namespace",
        "typedef",
        "interface",
        "public",
        "private",
        "protected",
        "implements",
        "declare",
        "abstract",
        "readonly"
      ];
      const KEYWORDS$1 = {
        $pattern: IDENT_RE,
        keyword: KEYWORDS.concat(TS_SPECIFIC_KEYWORDS),
        literal: LITERALS,
        built_in: BUILT_INS.concat(TYPES)
      };
      const DECORATOR = {
        className: 'meta',
        begin: '@' + IDENT_RE$1,
      };

      const swapMode = (mode, label, replacement) => {
        const indx = mode.contains.findIndex(m => m.label === label);
        if (indx === -1) { throw new Error("can not find mode to replace"); }
        mode.contains.splice(indx, 1, replacement);
      };

      const tsLanguage = javascript(hljs);

      // this should update anywhere keywords is used since
      // it will be the same actual JS object
      Object.assign(tsLanguage.keywords, KEYWORDS$1);

      tsLanguage.exports.PARAMS_CONTAINS.push(DECORATOR);
      tsLanguage.contains = tsLanguage.contains.concat([
        DECORATOR,
        NAMESPACE,
        INTERFACE,
      ]);

      // TS gets a simpler shebang rule than JS
      swapMode(tsLanguage, "shebang", hljs.SHEBANG());
      // JS use strict rule purposely excludes `asm` which makes no sense
      swapMode(tsLanguage, "use_strict", USE_STRICT);

      const functionDeclaration = tsLanguage.contains.find(m => m.className === "function");
      functionDeclaration.relevance = 0; // () => {} is more typical in TypeScript

      Object.assign(tsLanguage, {
        name: 'TypeScript',
        aliases: ['ts', 'tsx']
      });

      return tsLanguage;
    }

    var typescript_1 = typescript;

    var graphql$1 = {exports: {}};

    /**
     * Highlight.js GraphQL syntax highlighting definition
     *
     * @see https://github.com/isagalaev/highlight.js
     *
     * @package: highlightjs-graphql
     * @author:  David Peek <mail@dpeek.com>
     */

    function hljsDefineGraphQL(hljs) {
      return {
        aliases: ["gql"],
        keywords: {
          keyword:
            "query mutation subscription|10 input schema implements type interface union scalar fragment|10 enum on ...",
          literal: "ID ID! String Float Int Boolean",
          variable: "true false null"
        },
        contains: [
          hljs.HASH_COMMENT_MODE,
          hljs.QUOTE_STRING_MODE,
          hljs.NUMBER_MODE,
          {
            className: "literal",
            begin: "[^\\w][A-Z][a-z]",
            end: "\\W",
            excludeEnd: true
          },
          {
            className: "literal",
            begin: ":\\s\\[",
            end: "[\\]!]{1,3}",
            excludeBegin: true,
            excludeEnd: true
          },
          {
            className: "type",
            begin: "[^\\w](?!ID)[A-Z][A-Z]",
            end: "\\W",
            excludeEnd: true
          },
          {
            className: "name",
            begin: "\\$",
            end: "\\W",
            excludeEnd: true
          },
          {
            className: "meta",
            begin: "@",
            end: "\\W",
            excludeEnd: true
          }
        ],
        illegal: /([;<']|BEGIN)/
      };
    }

    graphql$1.exports = function(hljs) {
      hljs.registerLanguage("graphql", hljsDefineGraphQL);
    };

    graphql$1.exports.definer = hljsDefineGraphQL;

    var graphql = graphql$1.exports;

    // @ts-ignore
    core.registerLanguage('sql', sql_1);
    core.registerLanguage('csharp', csharp_1);
    core.registerLanguage('java', java_1);
    core.registerLanguage('kotlin', kotlin_1);
    core.registerLanguage('typescript', typescript_1);
    core.registerLanguage('scala', scala_1);
    graphql(core);

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    const directives = new WeakMap();
    /**
     * Brands a function as a directive factory function so that lit-html will call
     * the function during template rendering, rather than passing as a value.
     *
     * A _directive_ is a function that takes a Part as an argument. It has the
     * signature: `(part: Part) => void`.
     *
     * A directive _factory_ is a function that takes arguments for data and
     * configuration and returns a directive. Users of directive usually refer to
     * the directive factory as the directive. For example, "The repeat directive".
     *
     * Usually a template author will invoke a directive factory in their template
     * with relevant arguments, which will then return a directive function.
     *
     * Here's an example of using the `repeat()` directive factory that takes an
     * array and a function to render an item:
     *
     * ```js
     * html`<ul><${repeat(items, (item) => html`<li>${item}</li>`)}</ul>`
     * ```
     *
     * When `repeat` is invoked, it returns a directive function that closes over
     * `items` and the template function. When the outer template is rendered, the
     * return directive function is called with the Part for the expression.
     * `repeat` then performs it's custom logic to render multiple items.
     *
     * @param f The directive factory function. Must be a function that returns a
     * function of the signature `(part: Part) => void`. The returned function will
     * be called with the part object.
     *
     * @example
     *
     * import {directive, html} from 'lit-html';
     *
     * const immutable = directive((v) => (part) => {
     *   if (part.value !== v) {
     *     part.setValue(v)
     *   }
     * });
     */
    const directive = (f) => ((...args) => {
        const d = f(...args);
        directives.set(d, true);
        return d;
    });
    const isDirective = (o) => {
        return typeof o === 'function' && directives.has(o);
    };

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * True if the custom elements polyfill is in use.
     */
    const isCEPolyfill = typeof window !== 'undefined' &&
        window.customElements != null &&
        window.customElements.polyfillWrapFlushCallback !==
            undefined;
    /**
     * Reparents nodes, starting from `start` (inclusive) to `end` (exclusive),
     * into another container (could be the same container), before `before`. If
     * `before` is null, it appends the nodes to the container.
     */
    const reparentNodes = (container, start, end = null, before = null) => {
        while (start !== end) {
            const n = start.nextSibling;
            container.insertBefore(start, before);
            start = n;
        }
    };
    /**
     * Removes nodes, starting from `start` (inclusive) to `end` (exclusive), from
     * `container`.
     */
    const removeNodes = (container, start, end = null) => {
        while (start !== end) {
            const n = start.nextSibling;
            container.removeChild(start);
            start = n;
        }
    };

    /**
     * @license
     * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * A sentinel value that signals that a value was handled by a directive and
     * should not be written to the DOM.
     */
    const noChange = {};
    /**
     * A sentinel value that signals a NodePart to fully clear its content.
     */
    const nothing = {};

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * An expression marker with embedded unique key to avoid collision with
     * possible text in templates.
     */
    const marker = `{{lit-${String(Math.random()).slice(2)}}}`;
    /**
     * An expression marker used text-positions, multi-binding attributes, and
     * attributes with markup-like text values.
     */
    const nodeMarker = `<!--${marker}-->`;
    const markerRegex = new RegExp(`${marker}|${nodeMarker}`);
    /**
     * Suffix appended to all bound attribute names.
     */
    const boundAttributeSuffix = '$lit$';
    /**
     * An updatable Template that tracks the location of dynamic parts.
     */
    class Template {
        constructor(result, element) {
            this.parts = [];
            this.element = element;
            const nodesToRemove = [];
            const stack = [];
            // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null
            const walker = document.createTreeWalker(element.content, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);
            // Keeps track of the last index associated with a part. We try to delete
            // unnecessary nodes, but we never want to associate two different parts
            // to the same index. They must have a constant node between.
            let lastPartIndex = 0;
            let index = -1;
            let partIndex = 0;
            const { strings, values: { length } } = result;
            while (partIndex < length) {
                const node = walker.nextNode();
                if (node === null) {
                    // We've exhausted the content inside a nested template element.
                    // Because we still have parts (the outer for-loop), we know:
                    // - There is a template in the stack
                    // - The walker will find a nextNode outside the template
                    walker.currentNode = stack.pop();
                    continue;
                }
                index++;
                if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {
                    if (node.hasAttributes()) {
                        const attributes = node.attributes;
                        const { length } = attributes;
                        // Per
                        // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,
                        // attributes are not guaranteed to be returned in document order.
                        // In particular, Edge/IE can return them out of order, so we cannot
                        // assume a correspondence between part index and attribute index.
                        let count = 0;
                        for (let i = 0; i < length; i++) {
                            if (endsWith(attributes[i].name, boundAttributeSuffix)) {
                                count++;
                            }
                        }
                        while (count-- > 0) {
                            // Get the template literal section leading up to the first
                            // expression in this attribute
                            const stringForPart = strings[partIndex];
                            // Find the attribute name
                            const name = lastAttributeNameRegex.exec(stringForPart)[2];
                            // Find the corresponding attribute
                            // All bound attributes have had a suffix added in
                            // TemplateResult#getHTML to opt out of special attribute
                            // handling. To look up the attribute value we also need to add
                            // the suffix.
                            const attributeLookupName = name.toLowerCase() + boundAttributeSuffix;
                            const attributeValue = node.getAttribute(attributeLookupName);
                            node.removeAttribute(attributeLookupName);
                            const statics = attributeValue.split(markerRegex);
                            this.parts.push({ type: 'attribute', index, name, strings: statics });
                            partIndex += statics.length - 1;
                        }
                    }
                    if (node.tagName === 'TEMPLATE') {
                        stack.push(node);
                        walker.currentNode = node.content;
                    }
                }
                else if (node.nodeType === 3 /* Node.TEXT_NODE */) {
                    const data = node.data;
                    if (data.indexOf(marker) >= 0) {
                        const parent = node.parentNode;
                        const strings = data.split(markerRegex);
                        const lastIndex = strings.length - 1;
                        // Generate a new text node for each literal section
                        // These nodes are also used as the markers for node parts
                        for (let i = 0; i < lastIndex; i++) {
                            let insert;
                            let s = strings[i];
                            if (s === '') {
                                insert = createMarker();
                            }
                            else {
                                const match = lastAttributeNameRegex.exec(s);
                                if (match !== null && endsWith(match[2], boundAttributeSuffix)) {
                                    s = s.slice(0, match.index) + match[1] +
                                        match[2].slice(0, -boundAttributeSuffix.length) + match[3];
                                }
                                insert = document.createTextNode(s);
                            }
                            parent.insertBefore(insert, node);
                            this.parts.push({ type: 'node', index: ++index });
                        }
                        // If there's no text, we must insert a comment to mark our place.
                        // Else, we can trust it will stick around after cloning.
                        if (strings[lastIndex] === '') {
                            parent.insertBefore(createMarker(), node);
                            nodesToRemove.push(node);
                        }
                        else {
                            node.data = strings[lastIndex];
                        }
                        // We have a part for each match found
                        partIndex += lastIndex;
                    }
                }
                else if (node.nodeType === 8 /* Node.COMMENT_NODE */) {
                    if (node.data === marker) {
                        const parent = node.parentNode;
                        // Add a new marker node to be the startNode of the Part if any of
                        // the following are true:
                        //  * We don't have a previousSibling
                        //  * The previousSibling is already the start of a previous part
                        if (node.previousSibling === null || index === lastPartIndex) {
                            index++;
                            parent.insertBefore(createMarker(), node);
                        }
                        lastPartIndex = index;
                        this.parts.push({ type: 'node', index });
                        // If we don't have a nextSibling, keep this node so we have an end.
                        // Else, we can remove it to save future costs.
                        if (node.nextSibling === null) {
                            node.data = '';
                        }
                        else {
                            nodesToRemove.push(node);
                            index--;
                        }
                        partIndex++;
                    }
                    else {
                        let i = -1;
                        while ((i = node.data.indexOf(marker, i + 1)) !== -1) {
                            // Comment node has a binding marker inside, make an inactive part
                            // The binding won't work, but subsequent bindings will
                            // TODO (justinfagnani): consider whether it's even worth it to
                            // make bindings in comments work
                            this.parts.push({ type: 'node', index: -1 });
                            partIndex++;
                        }
                    }
                }
            }
            // Remove text binding nodes after the walk to not disturb the TreeWalker
            for (const n of nodesToRemove) {
                n.parentNode.removeChild(n);
            }
        }
    }
    const endsWith = (str, suffix) => {
        const index = str.length - suffix.length;
        return index >= 0 && str.slice(index) === suffix;
    };
    const isTemplatePartActive = (part) => part.index !== -1;
    // Allows `document.createComment('')` to be renamed for a
    // small manual size-savings.
    const createMarker = () => document.createComment('');
    /**
     * This regex extracts the attribute name preceding an attribute-position
     * expression. It does this by matching the syntax allowed for attributes
     * against the string literal directly preceding the expression, assuming that
     * the expression is in an attribute-value position.
     *
     * See attributes in the HTML spec:
     * https://www.w3.org/TR/html5/syntax.html#elements-attributes
     *
     * " \x09\x0a\x0c\x0d" are HTML space characters:
     * https://www.w3.org/TR/html5/infrastructure.html#space-characters
     *
     * "\0-\x1F\x7F-\x9F" are Unicode control characters, which includes every
     * space character except " ".
     *
     * So an attribute is:
     *  * The name: any character except a control character, space character, ('),
     *    ("), ">", "=", or "/"
     *  * Followed by zero or more space characters
     *  * Followed by "="
     *  * Followed by zero or more space characters
     *  * Followed by:
     *    * Any character except space, ('), ("), "<", ">", "=", (`), or
     *    * (") then any non-("), or
     *    * (') then any non-(')
     */
    const lastAttributeNameRegex = 
    // eslint-disable-next-line no-control-regex
    /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * An instance of a `Template` that can be attached to the DOM and updated
     * with new values.
     */
    class TemplateInstance {
        constructor(template, processor, options) {
            this.__parts = [];
            this.template = template;
            this.processor = processor;
            this.options = options;
        }
        update(values) {
            let i = 0;
            for (const part of this.__parts) {
                if (part !== undefined) {
                    part.setValue(values[i]);
                }
                i++;
            }
            for (const part of this.__parts) {
                if (part !== undefined) {
                    part.commit();
                }
            }
        }
        _clone() {
            // There are a number of steps in the lifecycle of a template instance's
            // DOM fragment:
            //  1. Clone - create the instance fragment
            //  2. Adopt - adopt into the main document
            //  3. Process - find part markers and create parts
            //  4. Upgrade - upgrade custom elements
            //  5. Update - set node, attribute, property, etc., values
            //  6. Connect - connect to the document. Optional and outside of this
            //     method.
            //
            // We have a few constraints on the ordering of these steps:
            //  * We need to upgrade before updating, so that property values will pass
            //    through any property setters.
            //  * We would like to process before upgrading so that we're sure that the
            //    cloned fragment is inert and not disturbed by self-modifying DOM.
            //  * We want custom elements to upgrade even in disconnected fragments.
            //
            // Given these constraints, with full custom elements support we would
            // prefer the order: Clone, Process, Adopt, Upgrade, Update, Connect
            //
            // But Safari does not implement CustomElementRegistry#upgrade, so we
            // can not implement that order and still have upgrade-before-update and
            // upgrade disconnected fragments. So we instead sacrifice the
            // process-before-upgrade constraint, since in Custom Elements v1 elements
            // must not modify their light DOM in the constructor. We still have issues
            // when co-existing with CEv0 elements like Polymer 1, and with polyfills
            // that don't strictly adhere to the no-modification rule because shadow
            // DOM, which may be created in the constructor, is emulated by being placed
            // in the light DOM.
            //
            // The resulting order is on native is: Clone, Adopt, Upgrade, Process,
            // Update, Connect. document.importNode() performs Clone, Adopt, and Upgrade
            // in one step.
            //
            // The Custom Elements v1 polyfill supports upgrade(), so the order when
            // polyfilled is the more ideal: Clone, Process, Adopt, Upgrade, Update,
            // Connect.
            const fragment = isCEPolyfill ?
                this.template.element.content.cloneNode(true) :
                document.importNode(this.template.element.content, true);
            const stack = [];
            const parts = this.template.parts;
            // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null
            const walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);
            let partIndex = 0;
            let nodeIndex = 0;
            let part;
            let node = walker.nextNode();
            // Loop through all the nodes and parts of a template
            while (partIndex < parts.length) {
                part = parts[partIndex];
                if (!isTemplatePartActive(part)) {
                    this.__parts.push(undefined);
                    partIndex++;
                    continue;
                }
                // Progress the tree walker until we find our next part's node.
                // Note that multiple parts may share the same node (attribute parts
                // on a single element), so this loop may not run at all.
                while (nodeIndex < part.index) {
                    nodeIndex++;
                    if (node.nodeName === 'TEMPLATE') {
                        stack.push(node);
                        walker.currentNode = node.content;
                    }
                    if ((node = walker.nextNode()) === null) {
                        // We've exhausted the content inside a nested template element.
                        // Because we still have parts (the outer for-loop), we know:
                        // - There is a template in the stack
                        // - The walker will find a nextNode outside the template
                        walker.currentNode = stack.pop();
                        node = walker.nextNode();
                    }
                }
                // We've arrived at our part's node.
                if (part.type === 'node') {
                    const part = this.processor.handleTextExpression(this.options);
                    part.insertAfterNode(node.previousSibling);
                    this.__parts.push(part);
                }
                else {
                    this.__parts.push(...this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options));
                }
                partIndex++;
            }
            if (isCEPolyfill) {
                document.adoptNode(fragment);
                customElements.upgrade(fragment);
            }
            return fragment;
        }
    }

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * Our TrustedTypePolicy for HTML which is declared using the html template
     * tag function.
     *
     * That HTML is a developer-authored constant, and is parsed with innerHTML
     * before any untrusted expressions have been mixed in. Therefor it is
     * considered safe by construction.
     */
    const policy = window.trustedTypes &&
        trustedTypes.createPolicy('lit-html', { createHTML: (s) => s });
    const commentMarker = ` ${marker} `;
    /**
     * The return type of `html`, which holds a Template and the values from
     * interpolated expressions.
     */
    class TemplateResult {
        constructor(strings, values, type, processor) {
            this.strings = strings;
            this.values = values;
            this.type = type;
            this.processor = processor;
        }
        /**
         * Returns a string of HTML used to create a `<template>` element.
         */
        getHTML() {
            const l = this.strings.length - 1;
            let html = '';
            let isCommentBinding = false;
            for (let i = 0; i < l; i++) {
                const s = this.strings[i];
                // For each binding we want to determine the kind of marker to insert
                // into the template source before it's parsed by the browser's HTML
                // parser. The marker type is based on whether the expression is in an
                // attribute, text, or comment position.
                //   * For node-position bindings we insert a comment with the marker
                //     sentinel as its text content, like <!--{{lit-guid}}-->.
                //   * For attribute bindings we insert just the marker sentinel for the
                //     first binding, so that we support unquoted attribute bindings.
                //     Subsequent bindings can use a comment marker because multi-binding
                //     attributes must be quoted.
                //   * For comment bindings we insert just the marker sentinel so we don't
                //     close the comment.
                //
                // The following code scans the template source, but is *not* an HTML
                // parser. We don't need to track the tree structure of the HTML, only
                // whether a binding is inside a comment, and if not, if it appears to be
                // the first binding in an attribute.
                const commentOpen = s.lastIndexOf('<!--');
                // We're in comment position if we have a comment open with no following
                // comment close. Because <-- can appear in an attribute value there can
                // be false positives.
                isCommentBinding = (commentOpen > -1 || isCommentBinding) &&
                    s.indexOf('-->', commentOpen + 1) === -1;
                // Check to see if we have an attribute-like sequence preceding the
                // expression. This can match "name=value" like structures in text,
                // comments, and attribute values, so there can be false-positives.
                const attributeMatch = lastAttributeNameRegex.exec(s);
                if (attributeMatch === null) {
                    // We're only in this branch if we don't have a attribute-like
                    // preceding sequence. For comments, this guards against unusual
                    // attribute values like <div foo="<!--${'bar'}">. Cases like
                    // <!-- foo=${'bar'}--> are handled correctly in the attribute branch
                    // below.
                    html += s + (isCommentBinding ? commentMarker : nodeMarker);
                }
                else {
                    // For attributes we use just a marker sentinel, and also append a
                    // $lit$ suffix to the name to opt-out of attribute-specific parsing
                    // that IE and Edge do for style and certain SVG attributes.
                    html += s.substr(0, attributeMatch.index) + attributeMatch[1] +
                        attributeMatch[2] + boundAttributeSuffix + attributeMatch[3] +
                        marker;
                }
            }
            html += this.strings[l];
            return html;
        }
        getTemplateElement() {
            const template = document.createElement('template');
            let value = this.getHTML();
            if (policy !== undefined) {
                // this is secure because `this.strings` is a TemplateStringsArray.
                // TODO: validate this when
                // https://github.com/tc39/proposal-array-is-template-object is
                // implemented.
                value = policy.createHTML(value);
            }
            template.innerHTML = value;
            return template;
        }
    }
    /**
     * A TemplateResult for SVG fragments.
     *
     * This class wraps HTML in an `<svg>` tag in order to parse its contents in the
     * SVG namespace, then modifies the template to remove the `<svg>` tag so that
     * clones only container the original fragment.
     */
    class SVGTemplateResult extends TemplateResult {
        getHTML() {
            return `<svg>${super.getHTML()}</svg>`;
        }
        getTemplateElement() {
            const template = super.getTemplateElement();
            const content = template.content;
            const svgElement = content.firstChild;
            content.removeChild(svgElement);
            reparentNodes(content, svgElement.firstChild);
            return template;
        }
    }

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    const isPrimitive = (value) => {
        return (value === null ||
            !(typeof value === 'object' || typeof value === 'function'));
    };
    const isIterable$1 = (value) => {
        return Array.isArray(value) ||
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            !!(value && value[Symbol.iterator]);
    };
    /**
     * Writes attribute values to the DOM for a group of AttributeParts bound to a
     * single attribute. The value is only set once even if there are multiple parts
     * for an attribute.
     */
    class AttributeCommitter {
        constructor(element, name, strings) {
            this.dirty = true;
            this.element = element;
            this.name = name;
            this.strings = strings;
            this.parts = [];
            for (let i = 0; i < strings.length - 1; i++) {
                this.parts[i] = this._createPart();
            }
        }
        /**
         * Creates a single part. Override this to create a differnt type of part.
         */
        _createPart() {
            return new AttributePart(this);
        }
        _getValue() {
            const strings = this.strings;
            const l = strings.length - 1;
            const parts = this.parts;
            // If we're assigning an attribute via syntax like:
            //    attr="${foo}"  or  attr=${foo}
            // but not
            //    attr="${foo} ${bar}" or attr="${foo} baz"
            // then we don't want to coerce the attribute value into one long
            // string. Instead we want to just return the value itself directly,
            // so that sanitizeDOMValue can get the actual value rather than
            // String(value)
            // The exception is if v is an array, in which case we do want to smash
            // it together into a string without calling String() on the array.
            //
            // This also allows trusted values (when using TrustedTypes) being
            // assigned to DOM sinks without being stringified in the process.
            if (l === 1 && strings[0] === '' && strings[1] === '') {
                const v = parts[0].value;
                if (typeof v === 'symbol') {
                    return String(v);
                }
                if (typeof v === 'string' || !isIterable$1(v)) {
                    return v;
                }
            }
            let text = '';
            for (let i = 0; i < l; i++) {
                text += strings[i];
                const part = parts[i];
                if (part !== undefined) {
                    const v = part.value;
                    if (isPrimitive(v) || !isIterable$1(v)) {
                        text += typeof v === 'string' ? v : String(v);
                    }
                    else {
                        for (const t of v) {
                            text += typeof t === 'string' ? t : String(t);
                        }
                    }
                }
            }
            text += strings[l];
            return text;
        }
        commit() {
            if (this.dirty) {
                this.dirty = false;
                this.element.setAttribute(this.name, this._getValue());
            }
        }
    }
    /**
     * A Part that controls all or part of an attribute value.
     */
    class AttributePart {
        constructor(committer) {
            this.value = undefined;
            this.committer = committer;
        }
        setValue(value) {
            if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {
                this.value = value;
                // If the value is a not a directive, dirty the committer so that it'll
                // call setAttribute. If the value is a directive, it'll dirty the
                // committer if it calls setValue().
                if (!isDirective(value)) {
                    this.committer.dirty = true;
                }
            }
        }
        commit() {
            while (isDirective(this.value)) {
                const directive = this.value;
                this.value = noChange;
                directive(this);
            }
            if (this.value === noChange) {
                return;
            }
            this.committer.commit();
        }
    }
    /**
     * A Part that controls a location within a Node tree. Like a Range, NodePart
     * has start and end locations and can set and update the Nodes between those
     * locations.
     *
     * NodeParts support several value types: primitives, Nodes, TemplateResults,
     * as well as arrays and iterables of those types.
     */
    class NodePart {
        constructor(options) {
            this.value = undefined;
            this.__pendingValue = undefined;
            this.options = options;
        }
        /**
         * Appends this part into a container.
         *
         * This part must be empty, as its contents are not automatically moved.
         */
        appendInto(container) {
            this.startNode = container.appendChild(createMarker());
            this.endNode = container.appendChild(createMarker());
        }
        /**
         * Inserts this part after the `ref` node (between `ref` and `ref`'s next
         * sibling). Both `ref` and its next sibling must be static, unchanging nodes
         * such as those that appear in a literal section of a template.
         *
         * This part must be empty, as its contents are not automatically moved.
         */
        insertAfterNode(ref) {
            this.startNode = ref;
            this.endNode = ref.nextSibling;
        }
        /**
         * Appends this part into a parent part.
         *
         * This part must be empty, as its contents are not automatically moved.
         */
        appendIntoPart(part) {
            part.__insert(this.startNode = createMarker());
            part.__insert(this.endNode = createMarker());
        }
        /**
         * Inserts this part after the `ref` part.
         *
         * This part must be empty, as its contents are not automatically moved.
         */
        insertAfterPart(ref) {
            ref.__insert(this.startNode = createMarker());
            this.endNode = ref.endNode;
            ref.endNode = this.startNode;
        }
        setValue(value) {
            this.__pendingValue = value;
        }
        commit() {
            if (this.startNode.parentNode === null) {
                return;
            }
            while (isDirective(this.__pendingValue)) {
                const directive = this.__pendingValue;
                this.__pendingValue = noChange;
                directive(this);
            }
            const value = this.__pendingValue;
            if (value === noChange) {
                return;
            }
            if (isPrimitive(value)) {
                if (value !== this.value) {
                    this.__commitText(value);
                }
            }
            else if (value instanceof TemplateResult) {
                this.__commitTemplateResult(value);
            }
            else if (value instanceof Node) {
                this.__commitNode(value);
            }
            else if (isIterable$1(value)) {
                this.__commitIterable(value);
            }
            else if (value === nothing) {
                this.value = nothing;
                this.clear();
            }
            else {
                // Fallback, will render the string representation
                this.__commitText(value);
            }
        }
        __insert(node) {
            this.endNode.parentNode.insertBefore(node, this.endNode);
        }
        __commitNode(value) {
            if (this.value === value) {
                return;
            }
            this.clear();
            this.__insert(value);
            this.value = value;
        }
        __commitText(value) {
            const node = this.startNode.nextSibling;
            value = value == null ? '' : value;
            // If `value` isn't already a string, we explicitly convert it here in case
            // it can't be implicitly converted - i.e. it's a symbol.
            const valueAsString = typeof value === 'string' ? value : String(value);
            if (node === this.endNode.previousSibling &&
                node.nodeType === 3 /* Node.TEXT_NODE */) {
                // If we only have a single text node between the markers, we can just
                // set its value, rather than replacing it.
                // TODO(justinfagnani): Can we just check if this.value is primitive?
                node.data = valueAsString;
            }
            else {
                this.__commitNode(document.createTextNode(valueAsString));
            }
            this.value = value;
        }
        __commitTemplateResult(value) {
            const template = this.options.templateFactory(value);
            if (this.value instanceof TemplateInstance &&
                this.value.template === template) {
                this.value.update(value.values);
            }
            else {
                // Make sure we propagate the template processor from the TemplateResult
                // so that we use its syntax extension, etc. The template factory comes
                // from the render function options so that it can control template
                // caching and preprocessing.
                const instance = new TemplateInstance(template, value.processor, this.options);
                const fragment = instance._clone();
                instance.update(value.values);
                this.__commitNode(fragment);
                this.value = instance;
            }
        }
        __commitIterable(value) {
            // For an Iterable, we create a new InstancePart per item, then set its
            // value to the item. This is a little bit of overhead for every item in
            // an Iterable, but it lets us recurse easily and efficiently update Arrays
            // of TemplateResults that will be commonly returned from expressions like:
            // array.map((i) => html`${i}`), by reusing existing TemplateInstances.
            // If _value is an array, then the previous render was of an
            // iterable and _value will contain the NodeParts from the previous
            // render. If _value is not an array, clear this part and make a new
            // array for NodeParts.
            if (!Array.isArray(this.value)) {
                this.value = [];
                this.clear();
            }
            // Lets us keep track of how many items we stamped so we can clear leftover
            // items from a previous render
            const itemParts = this.value;
            let partIndex = 0;
            let itemPart;
            for (const item of value) {
                // Try to reuse an existing part
                itemPart = itemParts[partIndex];
                // If no existing part, create a new one
                if (itemPart === undefined) {
                    itemPart = new NodePart(this.options);
                    itemParts.push(itemPart);
                    if (partIndex === 0) {
                        itemPart.appendIntoPart(this);
                    }
                    else {
                        itemPart.insertAfterPart(itemParts[partIndex - 1]);
                    }
                }
                itemPart.setValue(item);
                itemPart.commit();
                partIndex++;
            }
            if (partIndex < itemParts.length) {
                // Truncate the parts array so _value reflects the current state
                itemParts.length = partIndex;
                this.clear(itemPart && itemPart.endNode);
            }
        }
        clear(startNode = this.startNode) {
            removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);
        }
    }
    /**
     * Implements a boolean attribute, roughly as defined in the HTML
     * specification.
     *
     * If the value is truthy, then the attribute is present with a value of
     * ''. If the value is falsey, the attribute is removed.
     */
    class BooleanAttributePart {
        constructor(element, name, strings) {
            this.value = undefined;
            this.__pendingValue = undefined;
            if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {
                throw new Error('Boolean attributes can only contain a single expression');
            }
            this.element = element;
            this.name = name;
            this.strings = strings;
        }
        setValue(value) {
            this.__pendingValue = value;
        }
        commit() {
            while (isDirective(this.__pendingValue)) {
                const directive = this.__pendingValue;
                this.__pendingValue = noChange;
                directive(this);
            }
            if (this.__pendingValue === noChange) {
                return;
            }
            const value = !!this.__pendingValue;
            if (this.value !== value) {
                if (value) {
                    this.element.setAttribute(this.name, '');
                }
                else {
                    this.element.removeAttribute(this.name);
                }
                this.value = value;
            }
            this.__pendingValue = noChange;
        }
    }
    /**
     * Sets attribute values for PropertyParts, so that the value is only set once
     * even if there are multiple parts for a property.
     *
     * If an expression controls the whole property value, then the value is simply
     * assigned to the property under control. If there are string literals or
     * multiple expressions, then the strings are expressions are interpolated into
     * a string first.
     */
    class PropertyCommitter extends AttributeCommitter {
        constructor(element, name, strings) {
            super(element, name, strings);
            this.single =
                (strings.length === 2 && strings[0] === '' && strings[1] === '');
        }
        _createPart() {
            return new PropertyPart(this);
        }
        _getValue() {
            if (this.single) {
                return this.parts[0].value;
            }
            return super._getValue();
        }
        commit() {
            if (this.dirty) {
                this.dirty = false;
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                this.element[this.name] = this._getValue();
            }
        }
    }
    class PropertyPart extends AttributePart {
    }
    // Detect event listener options support. If the `capture` property is read
    // from the options object, then options are supported. If not, then the third
    // argument to add/removeEventListener is interpreted as the boolean capture
    // value so we should only pass the `capture` property.
    let eventOptionsSupported = false;
    // Wrap into an IIFE because MS Edge <= v41 does not support having try/catch
    // blocks right into the body of a module
    (() => {
        try {
            const options = {
                get capture() {
                    eventOptionsSupported = true;
                    return false;
                }
            };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            window.addEventListener('test', options, options);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            window.removeEventListener('test', options, options);
        }
        catch (_e) {
            // event options not supported
        }
    })();
    class EventPart {
        constructor(element, eventName, eventContext) {
            this.value = undefined;
            this.__pendingValue = undefined;
            this.element = element;
            this.eventName = eventName;
            this.eventContext = eventContext;
            this.__boundHandleEvent = (e) => this.handleEvent(e);
        }
        setValue(value) {
            this.__pendingValue = value;
        }
        commit() {
            while (isDirective(this.__pendingValue)) {
                const directive = this.__pendingValue;
                this.__pendingValue = noChange;
                directive(this);
            }
            if (this.__pendingValue === noChange) {
                return;
            }
            const newListener = this.__pendingValue;
            const oldListener = this.value;
            const shouldRemoveListener = newListener == null ||
                oldListener != null &&
                    (newListener.capture !== oldListener.capture ||
                        newListener.once !== oldListener.once ||
                        newListener.passive !== oldListener.passive);
            const shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);
            if (shouldRemoveListener) {
                this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);
            }
            if (shouldAddListener) {
                this.__options = getOptions(newListener);
                this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);
            }
            this.value = newListener;
            this.__pendingValue = noChange;
        }
        handleEvent(event) {
            if (typeof this.value === 'function') {
                this.value.call(this.eventContext || this.element, event);
            }
            else {
                this.value.handleEvent(event);
            }
        }
    }
    // We copy options because of the inconsistent behavior of browsers when reading
    // the third argument of add/removeEventListener. IE11 doesn't support options
    // at all. Chrome 41 only reads `capture` if the argument is an object.
    const getOptions = (o) => o &&
        (eventOptionsSupported ?
            { capture: o.capture, passive: o.passive, once: o.once } :
            o.capture);

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * Creates Parts when a template is instantiated.
     */
    class DefaultTemplateProcessor {
        /**
         * Create parts for an attribute-position binding, given the event, attribute
         * name, and string literals.
         *
         * @param element The element containing the binding
         * @param name  The attribute name
         * @param strings The string literals. There are always at least two strings,
         *   event for fully-controlled bindings with a single expression.
         */
        handleAttributeExpressions(element, name, strings, options) {
            const prefix = name[0];
            if (prefix === '.') {
                const committer = new PropertyCommitter(element, name.slice(1), strings);
                return committer.parts;
            }
            if (prefix === '@') {
                return [new EventPart(element, name.slice(1), options.eventContext)];
            }
            if (prefix === '?') {
                return [new BooleanAttributePart(element, name.slice(1), strings)];
            }
            const committer = new AttributeCommitter(element, name, strings);
            return committer.parts;
        }
        /**
         * Create parts for a text-position binding.
         * @param templateFactory
         */
        handleTextExpression(options) {
            return new NodePart(options);
        }
    }
    const defaultTemplateProcessor = new DefaultTemplateProcessor();

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * The default TemplateFactory which caches Templates keyed on
     * result.type and result.strings.
     */
    function templateFactory(result) {
        let templateCache = templateCaches$1.get(result.type);
        if (templateCache === undefined) {
            templateCache = {
                stringsArray: new WeakMap(),
                keyString: new Map()
            };
            templateCaches$1.set(result.type, templateCache);
        }
        let template = templateCache.stringsArray.get(result.strings);
        if (template !== undefined) {
            return template;
        }
        // If the TemplateStringsArray is new, generate a key from the strings
        // This key is shared between all templates with identical content
        const key = result.strings.join(marker);
        // Check if we already have a Template for this key
        template = templateCache.keyString.get(key);
        if (template === undefined) {
            // If we have not seen this key before, create a new Template
            template = new Template(result, result.getTemplateElement());
            // Cache the Template for this key
            templateCache.keyString.set(key, template);
        }
        // Cache all future queries for this TemplateStringsArray
        templateCache.stringsArray.set(result.strings, template);
        return template;
    }
    const templateCaches$1 = new Map();

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    const parts = new WeakMap();
    /**
     * Renders a template result or other value to a container.
     *
     * To update a container with new values, reevaluate the template literal and
     * call `render` with the new result.
     *
     * @param result Any value renderable by NodePart - typically a TemplateResult
     *     created by evaluating a template tag like `html` or `svg`.
     * @param container A DOM parent to render to. The entire contents are either
     *     replaced, or efficiently updated if the same result type was previous
     *     rendered there.
     * @param options RenderOptions for the entire render tree rendered to this
     *     container. Render options must *not* change between renders to the same
     *     container, as those changes will not effect previously rendered DOM.
     */
    const render$1 = (result, container, options) => {
        let part = parts.get(container);
        if (part === undefined) {
            removeNodes(container, container.firstChild);
            parts.set(container, part = new NodePart(Object.assign({ templateFactory }, options)));
            part.appendInto(container);
        }
        part.setValue(result);
        part.commit();
    };

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    // IMPORTANT: do not change the property name or the assignment expression.
    // This line will be used in regexes to search for lit-html usage.
    // TODO(justinfagnani): inject version number at build time
    if (typeof window !== 'undefined') {
        (window['litHtmlVersions'] || (window['litHtmlVersions'] = [])).push('1.4.1');
    }
    /**
     * Interprets a template literal as an HTML template that can efficiently
     * render to and update a container.
     */
    const html = (strings, ...values) => new TemplateResult(strings, values, 'html', defaultTemplateProcessor);
    /**
     * Interprets a template literal as an SVG template that can efficiently
     * render to and update a container.
     */
    const svg = (strings, ...values) => new SVGTemplateResult(strings, values, 'svg', defaultTemplateProcessor);

    /*!
     * @vuerd/lit-observable
     * @version 0.2.2 | Fri Nov 05 2021
     * @author dineug <dineug2@gmail.com>
     * @license MIT
     */

    const isObject$5 = (obj) => !!obj && typeof obj === 'object';
    const isArray$2$1 = (obj) => Array.isArray(obj);
    const isUndefined$2 = (value) => value === undefined;
    const closestElement = (selector, el, target = el && el.closest(selector)) => !el || el === document || el === window
        ? null
        : target
            ? target
            : closestElement(selector, el.getRootNode().host);
    const queryShadowSelector = (selectors, el) => selectors.length
        ? selectors.reduce((element, selector) => {
            var _a;
            const target = element === null || element === void 0 ? void 0 : element.querySelector(selector);
            return target ? target : (_a = element === null || element === void 0 ? void 0 : element.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector(selector);
        }, el)
        : null;

    function getContext(selector, el) {
        const provider = closestElement(selector, el);
        return provider.value;
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    /** Detect free variable `global` from Node.js. */

    var freeGlobal$1$1 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

    var _freeGlobal$1 = freeGlobal$1$1;

    var freeGlobal$2 = _freeGlobal$1;

    /** Detect free variable `self`. */
    var freeSelf$1 = typeof self == 'object' && self && self.Object === Object && self;

    /** Used as a reference to the global object. */
    var root$1$1 = freeGlobal$2 || freeSelf$1 || Function('return this')();

    var _root$1 = root$1$1;

    var root$b = _root$1;

    /** Built-in value references. */
    var Symbol$4$1 = root$b.Symbol;

    var _Symbol$1 = Symbol$4$1;

    /**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */

    function arrayMap$1$1(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    var _arrayMap$1 = arrayMap$1$1;

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */

    var isArray$1$1 = Array.isArray;

    var isArray_1$1 = isArray$1$1;

    var Symbol$3$1 = _Symbol$1;

    /** Used for built-in method references. */
    var objectProto$1$1 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$9 = objectProto$1$1.hasOwnProperty;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString$1$1 = objectProto$1$1.toString;

    /** Built-in value references. */
    var symToStringTag$1$1 = Symbol$3$1 ? Symbol$3$1.toStringTag : undefined;

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag$1$1(value) {
      var isOwn = hasOwnProperty$9.call(value, symToStringTag$1$1),
          tag = value[symToStringTag$1$1];

      try {
        value[symToStringTag$1$1] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString$1$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1$1] = tag;
        } else {
          delete value[symToStringTag$1$1];
        }
      }
      return result;
    }

    var _getRawTag$1 = getRawTag$1$1;

    /** Used for built-in method references. */

    var objectProto$c = Object.prototype;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString$2 = objectProto$c.toString;

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString$1$1(value) {
      return nativeObjectToString$2.call(value);
    }

    var _objectToString$1 = objectToString$1$1;

    var Symbol$2$1 = _Symbol$1,
        getRawTag$2 = _getRawTag$1,
        objectToString$2 = _objectToString$1;

    /** `Object#toString` result references. */
    var nullTag$1 = '[object Null]',
        undefinedTag$1 = '[object Undefined]';

    /** Built-in value references. */
    var symToStringTag$2 = Symbol$2$1 ? Symbol$2$1.toStringTag : undefined;

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag$1$1(value) {
      if (value == null) {
        return value === undefined ? undefinedTag$1 : nullTag$1;
      }
      return (symToStringTag$2 && symToStringTag$2 in Object(value))
        ? getRawTag$2(value)
        : objectToString$2(value);
    }

    var _baseGetTag$1 = baseGetTag$1$1;

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */

    function isObjectLike$1$1(value) {
      return value != null && typeof value == 'object';
    }

    var isObjectLike_1$1 = isObjectLike$1$1;

    var baseGetTag$6 = _baseGetTag$1,
        isObjectLike$6 = isObjectLike_1$1;

    /** `Object#toString` result references. */
    var symbolTag$2 = '[object Symbol]';

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol$1$1(value) {
      return typeof value == 'symbol' ||
        (isObjectLike$6(value) && baseGetTag$6(value) == symbolTag$2);
    }

    var isSymbol_1$1 = isSymbol$1$1;

    var Symbol$1$1 = _Symbol$1,
        arrayMap$2 = _arrayMap$1,
        isArray$7 = isArray_1$1,
        isSymbol$3 = isSymbol_1$1;

    /** Used as references for various `Number` constants. */
    var INFINITY$2 = 1 / 0;

    /** Used to convert symbols to primitives and strings. */
    var symbolProto$2 = Symbol$1$1 ? Symbol$1$1.prototype : undefined,
        symbolToString$1 = symbolProto$2 ? symbolProto$2.toString : undefined;

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString$1$1(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray$7(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap$2(value, baseToString$1$1) + '';
      }
      if (isSymbol$3(value)) {
        return symbolToString$1 ? symbolToString$1.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY$2) ? '-0' : result;
    }

    var _baseToString$1 = baseToString$1$1;

    var baseToString$2 = _baseToString$1;

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString$4$1(value) {
      return value == null ? '' : baseToString$2(value);
    }

    var toString_1$1 = toString$4$1;

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */

    function baseSlice$1$1(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    var _baseSlice$1 = baseSlice$1$1;

    var baseSlice$2 = _baseSlice$1;

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice$1$1(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : baseSlice$2(array, start, end);
    }

    var _castSlice$1 = castSlice$1$1;

    /** Used to compose unicode character classes. */

    var rsAstralRange$2$1 = '\\ud800-\\udfff',
        rsComboMarksRange$3$1 = '\\u0300-\\u036f',
        reComboHalfMarksRange$3$1 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$3$1 = '\\u20d0-\\u20ff',
        rsComboRange$3$1 = rsComboMarksRange$3$1 + reComboHalfMarksRange$3$1 + rsComboSymbolsRange$3$1,
        rsVarRange$2$1 = '\\ufe0e\\ufe0f';

    /** Used to compose unicode capture groups. */
    var rsZWJ$2$1 = '\\u200d';

    /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
    var reHasUnicode$1 = RegExp('[' + rsZWJ$2$1 + rsAstralRange$2$1  + rsComboRange$3$1 + rsVarRange$2$1 + ']');

    /**
     * Checks if `string` contains Unicode symbols.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {boolean} Returns `true` if a symbol is found, else `false`.
     */
    function hasUnicode$2$1(string) {
      return reHasUnicode$1.test(string);
    }

    var _hasUnicode$1 = hasUnicode$2$1;

    /**
     * Converts an ASCII `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */

    function asciiToArray$1$1(string) {
      return string.split('');
    }

    var _asciiToArray$1 = asciiToArray$1$1;

    /** Used to compose unicode character classes. */

    var rsAstralRange$1$1 = '\\ud800-\\udfff',
        rsComboMarksRange$2$1 = '\\u0300-\\u036f',
        reComboHalfMarksRange$2$1 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$2$1 = '\\u20d0-\\u20ff',
        rsComboRange$2$1 = rsComboMarksRange$2$1 + reComboHalfMarksRange$2$1 + rsComboSymbolsRange$2$1,
        rsVarRange$1$1 = '\\ufe0e\\ufe0f';

    /** Used to compose unicode capture groups. */
    var rsAstral$1 = '[' + rsAstralRange$1$1 + ']',
        rsCombo$2$1 = '[' + rsComboRange$2$1 + ']',
        rsFitz$1$1 = '\\ud83c[\\udffb-\\udfff]',
        rsModifier$1$1 = '(?:' + rsCombo$2$1 + '|' + rsFitz$1$1 + ')',
        rsNonAstral$1$1 = '[^' + rsAstralRange$1$1 + ']',
        rsRegional$1$1 = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        rsSurrPair$1$1 = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        rsZWJ$1$1 = '\\u200d';

    /** Used to compose unicode regexes. */
    var reOptMod$1$1 = rsModifier$1$1 + '?',
        rsOptVar$1$1 = '[' + rsVarRange$1$1 + ']?',
        rsOptJoin$1$1 = '(?:' + rsZWJ$1$1 + '(?:' + [rsNonAstral$1$1, rsRegional$1$1, rsSurrPair$1$1].join('|') + ')' + rsOptVar$1$1 + reOptMod$1$1 + ')*',
        rsSeq$1$1 = rsOptVar$1$1 + reOptMod$1$1 + rsOptJoin$1$1,
        rsSymbol$1 = '(?:' + [rsNonAstral$1$1 + rsCombo$2$1 + '?', rsCombo$2$1, rsRegional$1$1, rsSurrPair$1$1, rsAstral$1].join('|') + ')';

    /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
    var reUnicode$1 = RegExp(rsFitz$1$1 + '(?=' + rsFitz$1$1 + ')|' + rsSymbol$1 + rsSeq$1$1, 'g');

    /**
     * Converts a Unicode `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function unicodeToArray$1$1(string) {
      return string.match(reUnicode$1) || [];
    }

    var _unicodeToArray$1 = unicodeToArray$1$1;

    var asciiToArray$2 = _asciiToArray$1,
        hasUnicode$1$1 = _hasUnicode$1,
        unicodeToArray$2 = _unicodeToArray$1;

    /**
     * Converts `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function stringToArray$1$1(string) {
      return hasUnicode$1$1(string)
        ? unicodeToArray$2(string)
        : asciiToArray$2(string);
    }

    var _stringToArray$1 = stringToArray$1$1;

    var castSlice$2 = _castSlice$1,
        hasUnicode$3 = _hasUnicode$1,
        stringToArray$2 = _stringToArray$1,
        toString$3$1 = toString_1$1;

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst$1$1(methodName) {
      return function(string) {
        string = toString$3$1(string);

        var strSymbols = hasUnicode$3(string)
          ? stringToArray$2(string)
          : undefined;

        var chr = strSymbols
          ? strSymbols[0]
          : string.charAt(0);

        var trailing = strSymbols
          ? castSlice$2(strSymbols, 1).join('')
          : string.slice(1);

        return chr[methodName]() + trailing;
      };
    }

    var _createCaseFirst$1 = createCaseFirst$1$1;

    var createCaseFirst$2 = _createCaseFirst$1;

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst$1$1 = createCaseFirst$2('toUpperCase');

    var upperFirst_1$1 = upperFirst$1$1;

    var toString$2$1 = toString_1$1,
        upperFirst$2 = upperFirst_1$1;

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize$1$1(string) {
      return upperFirst$2(toString$2$1(string).toLowerCase());
    }

    var capitalize_1$1 = capitalize$1$1;

    /**
     * A specialized version of `_.reduce` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initAccum] Specify using the first element of `array` as
     *  the initial value.
     * @returns {*} Returns the accumulated value.
     */

    function arrayReduce$1$1(array, iteratee, accumulator, initAccum) {
      var index = -1,
          length = array == null ? 0 : array.length;

      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }

    var _arrayReduce$2 = arrayReduce$1$1;

    /**
     * The base implementation of `_.propertyOf` without support for deep paths.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     */

    function basePropertyOf$1$1(object) {
      return function(key) {
        return object == null ? undefined : object[key];
      };
    }

    var _basePropertyOf$1 = basePropertyOf$1$1;

    var basePropertyOf$2 = _basePropertyOf$1;

    /** Used to map Latin Unicode letters to basic Latin letters. */
    var deburredLetters$1 = {
      // Latin-1 Supplement block.
      '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
      '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
      '\xc7': 'C',  '\xe7': 'c',
      '\xd0': 'D',  '\xf0': 'd',
      '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
      '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
      '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
      '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
      '\xd1': 'N',  '\xf1': 'n',
      '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
      '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
      '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
      '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
      '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
      '\xc6': 'Ae', '\xe6': 'ae',
      '\xde': 'Th', '\xfe': 'th',
      '\xdf': 'ss',
      // Latin Extended-A block.
      '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
      '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
      '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
      '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
      '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
      '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
      '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
      '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
      '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
      '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
      '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
      '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
      '\u0134': 'J',  '\u0135': 'j',
      '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
      '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
      '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
      '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
      '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
      '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
      '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
      '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
      '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
      '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
      '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
      '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
      '\u0163': 't',  '\u0165': 't', '\u0167': 't',
      '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
      '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
      '\u0174': 'W',  '\u0175': 'w',
      '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
      '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
      '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
      '\u0132': 'IJ', '\u0133': 'ij',
      '\u0152': 'Oe', '\u0153': 'oe',
      '\u0149': "'n", '\u017f': 's'
    };

    /**
     * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
     * letters to basic Latin letters.
     *
     * @private
     * @param {string} letter The matched letter to deburr.
     * @returns {string} Returns the deburred letter.
     */
    var deburrLetter$1$1 = basePropertyOf$2(deburredLetters$1);

    var _deburrLetter$1 = deburrLetter$1$1;

    var deburrLetter$2 = _deburrLetter$1,
        toString$1$1 = toString_1$1;

    /** Used to match Latin Unicode letters (excluding mathematical operators). */
    var reLatin$1 = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

    /** Used to compose unicode character classes. */
    var rsComboMarksRange$1$1 = '\\u0300-\\u036f',
        reComboHalfMarksRange$1$1 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$1$1 = '\\u20d0-\\u20ff',
        rsComboRange$1$1 = rsComboMarksRange$1$1 + reComboHalfMarksRange$1$1 + rsComboSymbolsRange$1$1;

    /** Used to compose unicode capture groups. */
    var rsCombo$1$1 = '[' + rsComboRange$1$1 + ']';

    /**
     * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
     * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
     */
    var reComboMark$1 = RegExp(rsCombo$1$1, 'g');

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dj vu');
     * // => 'deja vu'
     */
    function deburr$1$1(string) {
      string = toString$1$1(string);
      return string && string.replace(reLatin$1, deburrLetter$2).replace(reComboMark$1, '');
    }

    var deburr_1$1 = deburr$1$1;

    /** Used to match words composed of alphanumeric characters. */

    var reAsciiWord$1 = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

    /**
     * Splits an ASCII `string` into an array of its words.
     *
     * @private
     * @param {string} The string to inspect.
     * @returns {Array} Returns the words of `string`.
     */
    function asciiWords$1$1(string) {
      return string.match(reAsciiWord$1) || [];
    }

    var _asciiWords$1 = asciiWords$1$1;

    /** Used to detect strings that need a more robust regexp to match words. */

    var reHasUnicodeWord$1 = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

    /**
     * Checks if `string` contains a word composed of Unicode symbols.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {boolean} Returns `true` if a word is found, else `false`.
     */
    function hasUnicodeWord$1$1(string) {
      return reHasUnicodeWord$1.test(string);
    }

    var _hasUnicodeWord$1 = hasUnicodeWord$1$1;

    /** Used to compose unicode character classes. */

    var rsAstralRange$3 = '\\ud800-\\udfff',
        rsComboMarksRange$4 = '\\u0300-\\u036f',
        reComboHalfMarksRange$4 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$4 = '\\u20d0-\\u20ff',
        rsComboRange$4 = rsComboMarksRange$4 + reComboHalfMarksRange$4 + rsComboSymbolsRange$4,
        rsDingbatRange$1 = '\\u2700-\\u27bf',
        rsLowerRange$1 = 'a-z\\xdf-\\xf6\\xf8-\\xff',
        rsMathOpRange$1 = '\\xac\\xb1\\xd7\\xf7',
        rsNonCharRange$1 = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
        rsPunctuationRange$1 = '\\u2000-\\u206f',
        rsSpaceRange$1 = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
        rsUpperRange$1 = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
        rsVarRange$3 = '\\ufe0e\\ufe0f',
        rsBreakRange$1 = rsMathOpRange$1 + rsNonCharRange$1 + rsPunctuationRange$1 + rsSpaceRange$1;

    /** Used to compose unicode capture groups. */
    var rsApos$1$1 = "['\u2019]",
        rsBreak$1 = '[' + rsBreakRange$1 + ']',
        rsCombo$3 = '[' + rsComboRange$4 + ']',
        rsDigits$1 = '\\d+',
        rsDingbat$1 = '[' + rsDingbatRange$1 + ']',
        rsLower$1 = '[' + rsLowerRange$1 + ']',
        rsMisc$1 = '[^' + rsAstralRange$3 + rsBreakRange$1 + rsDigits$1 + rsDingbatRange$1 + rsLowerRange$1 + rsUpperRange$1 + ']',
        rsFitz$2 = '\\ud83c[\\udffb-\\udfff]',
        rsModifier$2 = '(?:' + rsCombo$3 + '|' + rsFitz$2 + ')',
        rsNonAstral$2 = '[^' + rsAstralRange$3 + ']',
        rsRegional$2 = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        rsSurrPair$2 = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        rsUpper$1 = '[' + rsUpperRange$1 + ']',
        rsZWJ$3 = '\\u200d';

    /** Used to compose unicode regexes. */
    var rsMiscLower$1 = '(?:' + rsLower$1 + '|' + rsMisc$1 + ')',
        rsMiscUpper$1 = '(?:' + rsUpper$1 + '|' + rsMisc$1 + ')',
        rsOptContrLower$1 = '(?:' + rsApos$1$1 + '(?:d|ll|m|re|s|t|ve))?',
        rsOptContrUpper$1 = '(?:' + rsApos$1$1 + '(?:D|LL|M|RE|S|T|VE))?',
        reOptMod$2 = rsModifier$2 + '?',
        rsOptVar$2 = '[' + rsVarRange$3 + ']?',
        rsOptJoin$2 = '(?:' + rsZWJ$3 + '(?:' + [rsNonAstral$2, rsRegional$2, rsSurrPair$2].join('|') + ')' + rsOptVar$2 + reOptMod$2 + ')*',
        rsOrdLower$1 = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
        rsOrdUpper$1 = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
        rsSeq$2 = rsOptVar$2 + reOptMod$2 + rsOptJoin$2,
        rsEmoji$1 = '(?:' + [rsDingbat$1, rsRegional$2, rsSurrPair$2].join('|') + ')' + rsSeq$2;

    /** Used to match complex or compound words. */
    var reUnicodeWord$1 = RegExp([
      rsUpper$1 + '?' + rsLower$1 + '+' + rsOptContrLower$1 + '(?=' + [rsBreak$1, rsUpper$1, '$'].join('|') + ')',
      rsMiscUpper$1 + '+' + rsOptContrUpper$1 + '(?=' + [rsBreak$1, rsUpper$1 + rsMiscLower$1, '$'].join('|') + ')',
      rsUpper$1 + '?' + rsMiscLower$1 + '+' + rsOptContrLower$1,
      rsUpper$1 + '+' + rsOptContrUpper$1,
      rsOrdUpper$1,
      rsOrdLower$1,
      rsDigits$1,
      rsEmoji$1
    ].join('|'), 'g');

    /**
     * Splits a Unicode `string` into an array of its words.
     *
     * @private
     * @param {string} The string to inspect.
     * @returns {Array} Returns the words of `string`.
     */
    function unicodeWords$1$1(string) {
      return string.match(reUnicodeWord$1) || [];
    }

    var _unicodeWords$1 = unicodeWords$1$1;

    var asciiWords$2 = _asciiWords$1,
        hasUnicodeWord$2 = _hasUnicodeWord$1,
        toString$7 = toString_1$1,
        unicodeWords$2 = _unicodeWords$1;

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words$1$1(string, pattern, guard) {
      string = toString$7(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return hasUnicodeWord$2(string) ? unicodeWords$2(string) : asciiWords$2(string);
      }
      return string.match(pattern) || [];
    }

    var words_1$1 = words$1$1;

    var arrayReduce$2 = _arrayReduce$2,
        deburr$2 = deburr_1$1,
        words$2 = words_1$1;

    /** Used to compose unicode capture groups. */
    var rsApos$2 = "['\u2019]";

    /** Used to match apostrophes. */
    var reApos$1 = RegExp(rsApos$2, 'g');

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder$2$1(callback) {
      return function(string) {
        return arrayReduce$2(words$2(deburr$2(string).replace(reApos$1, '')), callback, '');
      };
    }

    var _createCompounder$1 = createCompounder$2$1;

    var capitalize$2 = capitalize_1$1,
        createCompounder$1$1 = _createCompounder$1;

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase$1 = createCompounder$1$1(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize$2(word) : word);
    });

    var camelCase_1$1 = camelCase$1;

    var createCompounder$4 = _createCompounder$1;

    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase$1 = createCompounder$4(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    var kebabCase_1$1 = kebabCase$1;

    const rawToProxy = new WeakMap();
    const rawToObservers = new WeakMap();
    const proxyToRaw = new WeakMap();
    const proxyToSubject = new WeakMap();
    const observerToTriggers = new WeakMap();
    const queue = [];
    const nextQueue = [];
    let currentObserver = null;
    let batch = false;
    let nextBatch = false;
    function observer(f) {
        currentObserver = f;
        f();
        currentObserver = null;
        return () => unobserve(f);
    }
    function unobserve(observer) {
        const triggers = observerToTriggers.get(observer);
        triggers === null || triggers === void 0 ? void 0 : triggers.forEach(({ raw }) => {
            const observers = rawToObservers.get(raw);
            observers &&
                observers.includes(observer) &&
                observers.splice(observers.indexOf(observer), 1);
        });
        triggers && observerToTriggers.delete(observer);
    }
    function addObserver(raw) {
        if (!currentObserver)
            return;
        const observers = rawToObservers.get(raw);
        if (!observers) {
            rawToObservers.set(raw, [currentObserver]);
        }
        else if (!observers.includes(currentObserver)) {
            observers.push(currentObserver);
        }
    }
    function addTrigger(raw, p) {
        if (!currentObserver)
            return;
        const triggers = observerToTriggers.get(currentObserver);
        if (triggers) {
            const trigger = triggers.find(trigger => trigger.raw === raw);
            if (!trigger) {
                triggers.push({ raw, keys: [p] });
            }
            else if (!trigger.keys.includes(p)) {
                trigger.keys.push(p);
            }
        }
        else {
            observerToTriggers.set(currentObserver, [{ raw, keys: [p] }]);
        }
    }
    function isTrigger(raw, p, observer) {
        const triggers = observerToTriggers.get(observer);
        return triggers
            ? triggers.some(trigger => trigger.raw === raw && trigger.keys.includes(p))
            : false;
    }
    const effect$3 = (raw, p) => {
        var _a;
        return (_a = rawToObservers.get(raw)) === null || _a === void 0 ? void 0 : _a.forEach(observer => {
            if (!isTrigger(raw, p, observer))
                return;
            queue.includes(observer) || queue.push(observer);
            if (!batch) {
                queueMicrotask(execute);
                batch = true;
            }
        });
    };
    function execute() {
        while (queue.length) {
            const target = queue.shift();
            unobserve(target);
            observer(target);
        }
        batch = false;
    }
    function observable$1(raw) {
        const proxy = new Proxy(raw, {
            get(target, p, receiver) {
                const value = Reflect.get(target, p, receiver);
                if (value instanceof RegExp) {
                    return value;
                }
                addObserver(raw);
                addTrigger(raw, p);
                if (isObject$5(value) && !proxyToRaw.has(value)) {
                    if (rawToProxy.has(value))
                        return rawToProxy.get(value);
                    return observable$1(value);
                }
                return value;
            },
            set(target, p, value, receiver) {
                const oldValue = Reflect.get(target, p, receiver);
                const res = Reflect.set(target, p, value, receiver);
                if (!isArray$2$1(target) && oldValue !== value) {
                    effect$3(target, p);
                    nextEffect(target, p);
                }
                else if (p === 'length') {
                    effect$3(target, p);
                    nextEffect(target, p);
                }
                return res;
            },
        });
        rawToProxy.set(raw, proxy);
        proxyToRaw.set(proxy, raw);
        return proxy;
    }
    function nextEffect(raw, p) {
        const proxy = rawToProxy.get(raw);
        if (!proxy)
            return;
        const subject = proxyToSubject.get(proxy);
        if (!subject)
            return;
        const trigger = nextQueue.find(trigger => trigger.proxy === proxy);
        if (!trigger) {
            nextQueue.push({ proxy, keys: [p] });
        }
        else if (!trigger.keys.includes(p)) {
            trigger.keys.push(p);
        }
        if (!nextBatch) {
            queueMicrotask(nextExecute);
            nextBatch = true;
        }
    }
    function nextExecute() {
        while (nextQueue.length) {
            const trigger = nextQueue.shift();
            const subject = proxyToSubject.get(trigger.proxy);
            trigger.keys.forEach(key => subject === null || subject === void 0 ? void 0 : subject.next(key));
        }
        nextBatch = false;
    }
    function createSubject() {
        const observers = [];
        const next = (value) => observers.forEach(observer => observer(value));
        const subscribe = (observer) => {
            observers.push(observer);
            return () => {
                observers.includes(observer) &&
                    observers.splice(observers.indexOf(observer), 1);
            };
        };
        return {
            next,
            subscribe,
        };
    }
    function watch(proxy, observer) {
        let subject = proxyToSubject.get(proxy);
        if (!subject) {
            subject = createSubject();
            proxyToSubject.set(proxy, subject);
        }
        return subject.subscribe(observer);
    }

    const supportsAdoptingStyleSheets = window.ShadowRoot &&
        'adoptedStyleSheets' in Document.prototype &&
        'replace' in CSSStyleSheet.prototype;
    const isSheet = (options) => supportsAdoptingStyleSheets && !!options.shadow && !!options.style;
    const isStyle = (options) => !isSheet(options) && !!options.style;

    const BEFORE_MOUNT = Symbol('beforeMount');
    const MOUNTED = Symbol('mounted');
    const UNMOUNTED = Symbol('unmounted');
    const BEFORE_FIRST_UPDATE = Symbol('beforeFirstUpdate');
    const FIRST_UPDATED = Symbol('firstUpdated');
    const BEFORE_UPDATE = Symbol('beforeUpdate');
    const UPDATED = Symbol('updated');
    const QUERY = Symbol('query');
    const QUERY_ALL = Symbol('queryAll');
    const UNSUBSCRIBE = Symbol('unsubscribe');
    const RENDER_ROOT = Symbol('renderRoot');
    const TEMPLATE = Symbol('template');
    const STYLE = Symbol('style');
    const PROPS = Symbol('props');
    let currentInstance = null;
    const createLifecycle = (name) => (f) => {
        var _a;
        currentInstance &&
            ((_a = currentInstance[name]) !== null && _a !== void 0 ? _a : (currentInstance[name] = [])).push(f);
    };
    const createQuery = (name) => (selector) => {
        var _a;
        const ref = { value: null };
        if (currentInstance) {
            const renderRoot = currentInstance[RENDER_ROOT];
            const f = () => (ref.value =
                name === QUERY
                    ? renderRoot.querySelector(selector)
                    : [...renderRoot.querySelectorAll(selector)]);
            ((_a = currentInstance[QUERY]) !== null && _a !== void 0 ? _a : (currentInstance[QUERY] = [])).push(f);
        }
        return ref;
    };
    const beforeMount = createLifecycle(BEFORE_MOUNT);
    const mounted = createLifecycle(MOUNTED);
    const unmounted = createLifecycle(UNMOUNTED);
    const beforeFirstUpdate = createLifecycle(BEFORE_FIRST_UPDATE);
    const firstUpdated = createLifecycle(FIRST_UPDATED);
    const beforeUpdate = createLifecycle(BEFORE_UPDATE);
    const updated = createLifecycle(UPDATED);
    const query = createQuery(QUERY);
    const queryAll = createQuery(QUERY_ALL);
    function defineComponent(name, options) {
        var _a, _b;
        var _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        (_a = options.shadow) !== null && _a !== void 0 ? _a : (options.shadow = 'open');
        const observedProps = (_b = options.observedProps) !== null && _b !== void 0 ? _b : [];
        const observedPropNames = observedProps.map(prop => isObject$5(prop) ? prop.name : prop);
        const observedPropsOptions = observedProps.filter(prop => isObject$5(prop));
        const sheet = isSheet(options) ? new CSSStyleSheet() : null;
        sheet && sheet.replaceSync(options.style || '');
        const C = (_q = class extends HTMLElement {
                constructor() {
                    super();
                    this[_c] = null;
                    this[_d] = null;
                    this[_e] = null;
                    this[_f] = null;
                    this[_g] = null;
                    this[_h] = null;
                    this[_j] = null;
                    this[_k] = null;
                    this[_l] = [];
                    this[_m] = this;
                    this[_o] = null;
                    this[_p] = observable$1({});
                    observedPropsOptions.forEach(propOptions => isUndefined$2(propOptions.default) ||
                        Reflect.set(this[PROPS], camelCase_1$1(propOptions.name), propOptions.default));
                    options.shadow &&
                        (this[RENDER_ROOT] = this.attachShadow({ mode: options.shadow }));
                    if (isStyle(options)) {
                        const style = document.createElement('style');
                        style.textContent = options.style || '';
                        this[STYLE] = style;
                    }
                    sheet && (this[RENDER_ROOT].adoptedStyleSheets = [sheet]);
                    currentInstance = this;
                    this[TEMPLATE] = options.render.call(this, this[PROPS], this);
                    currentInstance = null;
                }
                static get observedAttributes() {
                    return Array.from(new Set([
                        ...observedPropNames,
                        ...observedPropNames.map(propName => kebabCase_1$1(propName)),
                    ]));
                }
                connectedCallback() {
                    var _a, _b;
                    options.styleMap && Object.assign(this.style, options.styleMap);
                    (_a = this[BEFORE_MOUNT]) === null || _a === void 0 ? void 0 : _a.forEach(f => f());
                    let isMounted = false;
                    this[UNSUBSCRIBE].push(observer(() => {
                        var _a, _b, _q, _r, _s;
                        isMounted
                            ? (_a = this[BEFORE_UPDATE]) === null || _a === void 0 ? void 0 : _a.forEach(f => f())
                            : (_b = this[BEFORE_FIRST_UPDATE]) === null || _b === void 0 ? void 0 : _b.forEach(f => f());
                        render$1(html `${this[STYLE]}${this[TEMPLATE]()}`, this[RENDER_ROOT]);
                        (_q = this[QUERY]) === null || _q === void 0 ? void 0 : _q.forEach(f => f());
                        if (isMounted) {
                            (_r = this[UPDATED]) === null || _r === void 0 ? void 0 : _r.forEach(f => f());
                        }
                        else {
                            (_s = this[FIRST_UPDATED]) === null || _s === void 0 ? void 0 : _s.forEach(f => f());
                            isMounted = true;
                        }
                    }));
                    (_b = this[MOUNTED]) === null || _b === void 0 ? void 0 : _b.forEach(f => f());
                }
                disconnectedCallback() {
                    var _a;
                    this[UNSUBSCRIBE].forEach(f => f());
                    this[UNSUBSCRIBE] = [];
                    (_a = this[UNMOUNTED]) === null || _a === void 0 ? void 0 : _a.forEach(f => f());
                }
                attributeChangedCallback(propName, oldValue, newValue) {
                    const propOptions = observedProps.find(prop => isObject$5(prop) &&
                        camelCase_1$1(prop.name) === camelCase_1$1(propName));
                    propOptions && propOptions.type
                        ? Reflect.set(this[PROPS], camelCase_1$1(propName), propOptions.type === Boolean
                            ? newValue === 'true' || newValue === ''
                            : propOptions.type(newValue))
                        : Reflect.set(this[PROPS], camelCase_1$1(propName), newValue);
                }
            },
            _c = BEFORE_MOUNT,
            _d = MOUNTED,
            _e = UNMOUNTED,
            _f = BEFORE_FIRST_UPDATE,
            _g = FIRST_UPDATED,
            _h = BEFORE_UPDATE,
            _j = UPDATED,
            _k = QUERY,
            _l = UNSUBSCRIBE,
            _m = RENDER_ROOT,
            _o = STYLE,
            _p = PROPS,
            _q);
        observedPropNames.forEach(propName => {
            Object.defineProperty(C.prototype, propName, {
                get() {
                    return Reflect.get(this[PROPS], propName);
                },
                set(value) {
                    Reflect.set(this[PROPS], propName, value);
                },
            });
        });
        customElements.define(name, C);
    }

    const RATIO_WIDTH = 16;
    const RATIO_HEIGHT = 9;
    const DEFAULT_WIDTH = 1200;
    const DEFAULT_HEIGHT = (DEFAULT_WIDTH / RATIO_WIDTH) * RATIO_HEIGHT;
    const SIZE_FONT = 13;
    const SIZE_MIN_WIDTH = 60;
    const SIZE_BORDER_BOTTOM = 1.5;
    const SIZE_COLUMN_OPTION_AI = 15;
    const SIZE_COLUMN_OPTION_UQ = 22;
    const SIZE_COLUMN_OPTION_NN = 34;
    const SIZE_COLUMN_CLOSE = 9;
    const SIZE_COLUMN_KEY = 12;
    const SIZE_COLUMN_MARGIN_RIGHT = 5;
    const SIZE_INPUT_EDIT_HEIGHT = 19;
    const SIZE_COLUMN_HEIGHT = SIZE_INPUT_EDIT_HEIGHT + SIZE_BORDER_BOTTOM;
    const SIZE_TABLE_BORDER = 1;
    const SIZE_TABLE_PADDING = 10;
    const SIZE_TABLE_HEADER_HEIGHT = 47;
    const SIZE_TABLE_HEADER_BODY_HEIGHT = 30;
    const SIZE_START_X = 200;
    const SIZE_START_Y = 100;
    const SIZE_START_ADD = 50;
    const SIZE_MEMO_WIDTH = 127;
    const SIZE_MEMO_HEIGHT = 100;
    const SIZE_MEMO_PADDING = 10;
    const SIZE_SASH = 5;
    const SIZE_CONTEXTMENU_HEIGHT = 40;
    const SIZE_MINIMAP_WIDTH = 150;
    const SIZE_MINIMAP_MARGIN = 20;
    const SIZE_MENUBAR_HEIGHT = 30;
    const SIZE_CANVAS_MIN = 2000;
    const SIZE_CANVAS_MAX = 20000;
    const SIZE_CANVAS_ZOOM_MAX = 1;
    const SIZE_CANVAS_ZOOM_MIN = 0.1;
    const SIZE_MAX_WIDTH_COMMENT = 120;

    /**
     * A specialized version of `_.reduce` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initAccum] Specify using the first element of `array` as
     *  the initial value.
     * @returns {*} Returns the accumulated value.
     */

    function arrayReduce$1(array, iteratee, accumulator, initAccum) {
      var index = -1,
          length = array == null ? 0 : array.length;

      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }

    var _arrayReduce$1 = arrayReduce$1;

    /**
     * The base implementation of `_.propertyOf` without support for deep paths.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     */

    function basePropertyOf$1(object) {
      return function(key) {
        return object == null ? undefined : object[key];
      };
    }

    var _basePropertyOf = basePropertyOf$1;

    var basePropertyOf = _basePropertyOf;

    /** Used to map Latin Unicode letters to basic Latin letters. */
    var deburredLetters = {
      // Latin-1 Supplement block.
      '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
      '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
      '\xc7': 'C',  '\xe7': 'c',
      '\xd0': 'D',  '\xf0': 'd',
      '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
      '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
      '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
      '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
      '\xd1': 'N',  '\xf1': 'n',
      '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
      '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
      '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
      '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
      '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
      '\xc6': 'Ae', '\xe6': 'ae',
      '\xde': 'Th', '\xfe': 'th',
      '\xdf': 'ss',
      // Latin Extended-A block.
      '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
      '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
      '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
      '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
      '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
      '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
      '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
      '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
      '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
      '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
      '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
      '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
      '\u0134': 'J',  '\u0135': 'j',
      '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
      '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
      '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
      '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
      '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
      '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
      '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
      '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
      '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
      '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
      '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
      '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
      '\u0163': 't',  '\u0165': 't', '\u0167': 't',
      '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
      '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
      '\u0174': 'W',  '\u0175': 'w',
      '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
      '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
      '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
      '\u0132': 'IJ', '\u0133': 'ij',
      '\u0152': 'Oe', '\u0153': 'oe',
      '\u0149': "'n", '\u017f': 's'
    };

    /**
     * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
     * letters to basic Latin letters.
     *
     * @private
     * @param {string} letter The matched letter to deburr.
     * @returns {string} Returns the deburred letter.
     */
    var deburrLetter$1 = basePropertyOf(deburredLetters);

    var _deburrLetter = deburrLetter$1;

    /** Detect free variable `global` from Node.js. */

    var freeGlobal$1 = typeof commonjsGlobal$1 == 'object' && commonjsGlobal$1 && commonjsGlobal$1.Object === Object && commonjsGlobal$1;

    var _freeGlobal = freeGlobal$1;

    var freeGlobal = _freeGlobal;

    /** Detect free variable `self`. */
    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

    /** Used as a reference to the global object. */
    var root$a = freeGlobal || freeSelf || Function('return this')();

    var _root = root$a;

    var root$9 = _root;

    /** Built-in value references. */
    var Symbol$5 = root$9.Symbol;

    var _Symbol = Symbol$5;

    /**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */

    function arrayMap$1(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    var _arrayMap = arrayMap$1;

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */

    var isArray$6 = Array.isArray;

    var isArray_1 = isArray$6;

    var Symbol$4 = _Symbol;

    /** Used for built-in method references. */
    var objectProto$b = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$8 = objectProto$b.hasOwnProperty;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString$1 = objectProto$b.toString;

    /** Built-in value references. */
    var symToStringTag$1 = Symbol$4 ? Symbol$4.toStringTag : undefined;

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag$1(value) {
      var isOwn = hasOwnProperty$8.call(value, symToStringTag$1),
          tag = value[symToStringTag$1];

      try {
        value[symToStringTag$1] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }

    var _getRawTag = getRawTag$1;

    /** Used for built-in method references. */

    var objectProto$a = Object.prototype;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto$a.toString;

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString$1(value) {
      return nativeObjectToString.call(value);
    }

    var _objectToString = objectToString$1;

    var Symbol$3 = _Symbol,
        getRawTag = _getRawTag,
        objectToString = _objectToString;

    /** `Object#toString` result references. */
    var nullTag = '[object Null]',
        undefinedTag = '[object Undefined]';

    /** Built-in value references. */
    var symToStringTag = Symbol$3 ? Symbol$3.toStringTag : undefined;

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag$5(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    var _baseGetTag = baseGetTag$5;

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */

    function isObjectLike$5(value) {
      return value != null && typeof value == 'object';
    }

    var isObjectLike_1 = isObjectLike$5;

    var baseGetTag$4 = _baseGetTag,
        isObjectLike$4 = isObjectLike_1;

    /** `Object#toString` result references. */
    var symbolTag$1 = '[object Symbol]';

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol$2(value) {
      return typeof value == 'symbol' ||
        (isObjectLike$4(value) && baseGetTag$4(value) == symbolTag$1);
    }

    var isSymbol_1 = isSymbol$2;

    var Symbol$2 = _Symbol,
        arrayMap = _arrayMap,
        isArray$5 = isArray_1,
        isSymbol$1 = isSymbol_1;

    /** Used as references for various `Number` constants. */
    var INFINITY$1 = 1 / 0;

    /** Used to convert symbols to primitives and strings. */
    var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : undefined,
        symbolToString = symbolProto$1 ? symbolProto$1.toString : undefined;

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString$1(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray$5(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap(value, baseToString$1) + '';
      }
      if (isSymbol$1(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
    }

    var _baseToString = baseToString$1;

    var baseToString = _baseToString;

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString$6(value) {
      return value == null ? '' : baseToString(value);
    }

    var toString_1 = toString$6;

    var deburrLetter = _deburrLetter,
        toString$5 = toString_1;

    /** Used to match Latin Unicode letters (excluding mathematical operators). */
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

    /** Used to compose unicode character classes. */
    var rsComboMarksRange$3 = '\\u0300-\\u036f',
        reComboHalfMarksRange$3 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$3 = '\\u20d0-\\u20ff',
        rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3;

    /** Used to compose unicode capture groups. */
    var rsCombo$2 = '[' + rsComboRange$3 + ']';

    /**
     * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
     * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
     */
    var reComboMark = RegExp(rsCombo$2, 'g');

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dj vu');
     * // => 'deja vu'
     */
    function deburr$1(string) {
      string = toString$5(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
    }

    var deburr_1 = deburr$1;

    /** Used to match words composed of alphanumeric characters. */

    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

    /**
     * Splits an ASCII `string` into an array of its words.
     *
     * @private
     * @param {string} The string to inspect.
     * @returns {Array} Returns the words of `string`.
     */
    function asciiWords$1(string) {
      return string.match(reAsciiWord) || [];
    }

    var _asciiWords = asciiWords$1;

    /** Used to detect strings that need a more robust regexp to match words. */

    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

    /**
     * Checks if `string` contains a word composed of Unicode symbols.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {boolean} Returns `true` if a word is found, else `false`.
     */
    function hasUnicodeWord$1(string) {
      return reHasUnicodeWord.test(string);
    }

    var _hasUnicodeWord = hasUnicodeWord$1;

    /** Used to compose unicode character classes. */

    var rsAstralRange$2 = '\\ud800-\\udfff',
        rsComboMarksRange$2 = '\\u0300-\\u036f',
        reComboHalfMarksRange$2 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$2 = '\\u20d0-\\u20ff',
        rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2,
        rsDingbatRange = '\\u2700-\\u27bf',
        rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
        rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
        rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
        rsPunctuationRange = '\\u2000-\\u206f',
        rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
        rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
        rsVarRange$2 = '\\ufe0e\\ufe0f',
        rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

    /** Used to compose unicode capture groups. */
    var rsApos$1 = "['\u2019]",
        rsBreak = '[' + rsBreakRange + ']',
        rsCombo$1 = '[' + rsComboRange$2 + ']',
        rsDigits = '\\d+',
        rsDingbat = '[' + rsDingbatRange + ']',
        rsLower = '[' + rsLowerRange + ']',
        rsMisc = '[^' + rsAstralRange$2 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
        rsFitz$1 = '\\ud83c[\\udffb-\\udfff]',
        rsModifier$1 = '(?:' + rsCombo$1 + '|' + rsFitz$1 + ')',
        rsNonAstral$1 = '[^' + rsAstralRange$2 + ']',
        rsRegional$1 = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        rsSurrPair$1 = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        rsUpper = '[' + rsUpperRange + ']',
        rsZWJ$2 = '\\u200d';

    /** Used to compose unicode regexes. */
    var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
        rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
        rsOptContrLower = '(?:' + rsApos$1 + '(?:d|ll|m|re|s|t|ve))?',
        rsOptContrUpper = '(?:' + rsApos$1 + '(?:D|LL|M|RE|S|T|VE))?',
        reOptMod$1 = rsModifier$1 + '?',
        rsOptVar$1 = '[' + rsVarRange$2 + ']?',
        rsOptJoin$1 = '(?:' + rsZWJ$2 + '(?:' + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsOptVar$1 + reOptMod$1 + ')*',
        rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
        rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
        rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1,
        rsEmoji = '(?:' + [rsDingbat, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsSeq$1;

    /** Used to match complex or compound words. */
    var reUnicodeWord = RegExp([
      rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
      rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
      rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
      rsUpper + '+' + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join('|'), 'g');

    /**
     * Splits a Unicode `string` into an array of its words.
     *
     * @private
     * @param {string} The string to inspect.
     * @returns {Array} Returns the words of `string`.
     */
    function unicodeWords$1(string) {
      return string.match(reUnicodeWord) || [];
    }

    var _unicodeWords = unicodeWords$1;

    var asciiWords = _asciiWords,
        hasUnicodeWord = _hasUnicodeWord,
        toString$4 = toString_1,
        unicodeWords = _unicodeWords;

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words$1(string, pattern, guard) {
      string = toString$4(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }

    var words_1 = words$1;

    var arrayReduce = _arrayReduce$1,
        deburr = deburr_1,
        words = words_1;

    /** Used to compose unicode capture groups. */
    var rsApos = "['\u2019]";

    /** Used to match apostrophes. */
    var reApos = RegExp(rsApos, 'g');

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder$3(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
      };
    }

    var _createCompounder = createCompounder$3;

    var createCompounder$2 = _createCompounder;

    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder$2(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    var kebabCase_1 = kebabCase;

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */

    function baseSlice$1(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    var _baseSlice = baseSlice$1;

    var baseSlice = _baseSlice;

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice$1(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : baseSlice(array, start, end);
    }

    var _castSlice = castSlice$1;

    /** Used to compose unicode character classes. */

    var rsAstralRange$1 = '\\ud800-\\udfff',
        rsComboMarksRange$1 = '\\u0300-\\u036f',
        reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$1 = '\\u20d0-\\u20ff',
        rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1,
        rsVarRange$1 = '\\ufe0e\\ufe0f';

    /** Used to compose unicode capture groups. */
    var rsZWJ$1 = '\\u200d';

    /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
    var reHasUnicode = RegExp('[' + rsZWJ$1 + rsAstralRange$1  + rsComboRange$1 + rsVarRange$1 + ']');

    /**
     * Checks if `string` contains Unicode symbols.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {boolean} Returns `true` if a symbol is found, else `false`.
     */
    function hasUnicode$2(string) {
      return reHasUnicode.test(string);
    }

    var _hasUnicode = hasUnicode$2;

    /**
     * Converts an ASCII `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */

    function asciiToArray$1(string) {
      return string.split('');
    }

    var _asciiToArray = asciiToArray$1;

    /** Used to compose unicode character classes. */

    var rsAstralRange = '\\ud800-\\udfff',
        rsComboMarksRange = '\\u0300-\\u036f',
        reComboHalfMarksRange = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange = '\\u20d0-\\u20ff',
        rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
        rsVarRange = '\\ufe0e\\ufe0f';

    /** Used to compose unicode capture groups. */
    var rsAstral = '[' + rsAstralRange + ']',
        rsCombo = '[' + rsComboRange + ']',
        rsFitz = '\\ud83c[\\udffb-\\udfff]',
        rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
        rsNonAstral = '[^' + rsAstralRange + ']',
        rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        rsZWJ = '\\u200d';

    /** Used to compose unicode regexes. */
    var reOptMod = rsModifier + '?',
        rsOptVar = '[' + rsVarRange + ']?',
        rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
        rsSeq = rsOptVar + reOptMod + rsOptJoin,
        rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

    /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
    var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

    /**
     * Converts a Unicode `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function unicodeToArray$1(string) {
      return string.match(reUnicode) || [];
    }

    var _unicodeToArray = unicodeToArray$1;

    var asciiToArray = _asciiToArray,
        hasUnicode$1 = _hasUnicode,
        unicodeToArray = _unicodeToArray;

    /**
     * Converts `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function stringToArray$1(string) {
      return hasUnicode$1(string)
        ? unicodeToArray(string)
        : asciiToArray(string);
    }

    var _stringToArray = stringToArray$1;

    var castSlice = _castSlice,
        hasUnicode = _hasUnicode,
        stringToArray = _stringToArray,
        toString$3 = toString_1;

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst$1(methodName) {
      return function(string) {
        string = toString$3(string);

        var strSymbols = hasUnicode(string)
          ? stringToArray(string)
          : undefined;

        var chr = strSymbols
          ? strSymbols[0]
          : string.charAt(0);

        var trailing = strSymbols
          ? castSlice(strSymbols, 1).join('')
          : string.slice(1);

        return chr[methodName]() + trailing;
      };
    }

    var _createCaseFirst = createCaseFirst$1;

    var createCaseFirst = _createCaseFirst;

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst$1 = createCaseFirst('toUpperCase');

    var upperFirst_1 = upperFirst$1;

    var toString$2 = toString_1,
        upperFirst = upperFirst_1;

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize$1(string) {
      return upperFirst(toString$2(string).toLowerCase());
    }

    var capitalize_1 = capitalize$1;

    var capitalize = capitalize_1,
        createCompounder$1 = _createCompounder;

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder$1(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });

    var camelCase_1 = camelCase;

    function _isPlaceholder(a) {
      return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
    }

    /**
     * Optimized internal one-arity curry function.
     *
     * @private
     * @category Function
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */

    function _curry1(fn) {
      return function f1(a) {
        if (arguments.length === 0 || _isPlaceholder(a)) {
          return f1;
        } else {
          return fn.apply(this, arguments);
        }
      };
    }

    /**
     * Optimized internal two-arity curry function.
     *
     * @private
     * @category Function
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */

    function _curry2(fn) {
      return function f2(a, b) {
        switch (arguments.length) {
          case 0:
            return f2;

          case 1:
            return _isPlaceholder(a) ? f2 : _curry1(function (_b) {
              return fn(a, _b);
            });

          default:
            return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {
              return fn(_a, b);
            }) : _isPlaceholder(b) ? _curry1(function (_b) {
              return fn(a, _b);
            }) : fn(a, b);
        }
      };
    }

    /**
     * Private `concat` function to merge two array-like objects.
     *
     * @private
     * @param {Array|Arguments} [set1=[]] An array-like object.
     * @param {Array|Arguments} [set2=[]] An array-like object.
     * @return {Array} A new, merged array.
     * @example
     *
     *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
     */
    function _concat(set1, set2) {
      set1 = set1 || [];
      set2 = set2 || [];
      var idx;
      var len1 = set1.length;
      var len2 = set2.length;
      var result = [];
      idx = 0;

      while (idx < len1) {
        result[result.length] = set1[idx];
        idx += 1;
      }

      idx = 0;

      while (idx < len2) {
        result[result.length] = set2[idx];
        idx += 1;
      }

      return result;
    }

    function _arity(n, fn) {
      /* eslint-disable no-unused-vars */
      switch (n) {
        case 0:
          return function () {
            return fn.apply(this, arguments);
          };

        case 1:
          return function (a0) {
            return fn.apply(this, arguments);
          };

        case 2:
          return function (a0, a1) {
            return fn.apply(this, arguments);
          };

        case 3:
          return function (a0, a1, a2) {
            return fn.apply(this, arguments);
          };

        case 4:
          return function (a0, a1, a2, a3) {
            return fn.apply(this, arguments);
          };

        case 5:
          return function (a0, a1, a2, a3, a4) {
            return fn.apply(this, arguments);
          };

        case 6:
          return function (a0, a1, a2, a3, a4, a5) {
            return fn.apply(this, arguments);
          };

        case 7:
          return function (a0, a1, a2, a3, a4, a5, a6) {
            return fn.apply(this, arguments);
          };

        case 8:
          return function (a0, a1, a2, a3, a4, a5, a6, a7) {
            return fn.apply(this, arguments);
          };

        case 9:
          return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
            return fn.apply(this, arguments);
          };

        case 10:
          return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            return fn.apply(this, arguments);
          };

        default:
          throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
      }
    }

    /**
     * Internal curryN function.
     *
     * @private
     * @category Function
     * @param {Number} length The arity of the curried function.
     * @param {Array} received An array of arguments received thus far.
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */

    function _curryN(length, received, fn) {
      return function () {
        var combined = [];
        var argsIdx = 0;
        var left = length;
        var combinedIdx = 0;

        while (combinedIdx < received.length || argsIdx < arguments.length) {
          var result;

          if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
            result = received[combinedIdx];
          } else {
            result = arguments[argsIdx];
            argsIdx += 1;
          }

          combined[combinedIdx] = result;

          if (!_isPlaceholder(result)) {
            left -= 1;
          }

          combinedIdx += 1;
        }

        return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
      };
    }

    /**
     * Returns a curried equivalent of the provided function, with the specified
     * arity. The curried function has two unusual capabilities. First, its
     * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
     * following are equivalent:
     *
     *   - `g(1)(2)(3)`
     *   - `g(1)(2, 3)`
     *   - `g(1, 2)(3)`
     *   - `g(1, 2, 3)`
     *
     * Secondly, the special placeholder value [`R.__`](#__) may be used to specify
     * "gaps", allowing partial application of any combination of arguments,
     * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),
     * the following are equivalent:
     *
     *   - `g(1, 2, 3)`
     *   - `g(_, 2, 3)(1)`
     *   - `g(_, _, 3)(1)(2)`
     *   - `g(_, _, 3)(1, 2)`
     *   - `g(_, 2)(1)(3)`
     *   - `g(_, 2)(1, 3)`
     *   - `g(_, 2)(_, 3)(1)`
     *
     * @func
     * @memberOf R
     * @since v0.5.0
     * @category Function
     * @sig Number -> (* -> a) -> (* -> a)
     * @param {Number} length The arity for the returned function.
     * @param {Function} fn The function to curry.
     * @return {Function} A new, curried function.
     * @see R.curry
     * @example
     *
     *      const sumArgs = (...args) => R.sum(args);
     *
     *      const curriedAddFourNumbers = R.curryN(4, sumArgs);
     *      const f = curriedAddFourNumbers(1, 2);
     *      const g = f(3);
     *      g(4); //=> 10
     */

    var curryN =
    /*#__PURE__*/
    _curry2(function curryN(length, fn) {
      if (length === 1) {
        return _curry1(fn);
      }

      return _arity(length, _curryN(length, [], fn));
    });

    var curryN$1 = curryN;

    /**
     * Optimized internal three-arity curry function.
     *
     * @private
     * @category Function
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */

    function _curry3(fn) {
      return function f3(a, b, c) {
        switch (arguments.length) {
          case 0:
            return f3;

          case 1:
            return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {
              return fn(a, _b, _c);
            });

          case 2:
            return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {
              return fn(_a, b, _c);
            }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {
              return fn(a, _b, _c);
            }) : _curry1(function (_c) {
              return fn(a, b, _c);
            });

          default:
            return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {
              return fn(_a, _b, c);
            }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {
              return fn(_a, b, _c);
            }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {
              return fn(a, _b, _c);
            }) : _isPlaceholder(a) ? _curry1(function (_a) {
              return fn(_a, b, c);
            }) : _isPlaceholder(b) ? _curry1(function (_b) {
              return fn(a, _b, c);
            }) : _isPlaceholder(c) ? _curry1(function (_c) {
              return fn(a, b, _c);
            }) : fn(a, b, c);
        }
      };
    }

    /**
     * Applies a function to the value at the given index of an array, returning a
     * new copy of the array with the element at the given index replaced with the
     * result of the function application.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category List
     * @sig Number -> (a -> a) -> [a] -> [a]
     * @param {Number} idx The index.
     * @param {Function} fn The function to apply.
     * @param {Array|Arguments} list An array-like object whose value
     *        at the supplied index will be replaced.
     * @return {Array} A copy of the supplied array-like object with
     *         the element at index `idx` replaced with the value
     *         returned by applying `fn` to the existing element.
     * @see R.update
     * @example
     *
     *      R.adjust(1, R.toUpper, ['a', 'b', 'c', 'd']);      //=> ['a', 'B', 'c', 'd']
     *      R.adjust(-1, R.toUpper, ['a', 'b', 'c', 'd']);     //=> ['a', 'b', 'c', 'D']
     * @symb R.adjust(-1, f, [a, b]) = [a, f(b)]
     * @symb R.adjust(0, f, [a, b]) = [f(a), b]
     */

    var adjust =
    /*#__PURE__*/
    _curry3(function adjust(idx, fn, list) {
      if (idx >= list.length || idx < -list.length) {
        return list;
      }

      var start = idx < 0 ? list.length : 0;

      var _idx = start + idx;

      var _list = _concat(list);

      _list[_idx] = fn(list[_idx]);
      return _list;
    });

    var adjust$1 = adjust;

    /**
     * Tests whether or not an object is an array.
     *
     * @private
     * @param {*} val The object to test.
     * @return {Boolean} `true` if `val` is an array, `false` otherwise.
     * @example
     *
     *      _isArray([]); //=> true
     *      _isArray(null); //=> false
     *      _isArray({}); //=> false
     */
    var _isArray = Array.isArray || function _isArray(val) {
      return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
    };

    function _isTransformer(obj) {
      return obj != null && typeof obj['@@transducer/step'] === 'function';
    }

    /**
     * Returns a function that dispatches with different strategies based on the
     * object in list position (last argument). If it is an array, executes [fn].
     * Otherwise, if it has a function with one of the given method names, it will
     * execute that function (functor case). Otherwise, if it is a transformer,
     * uses transducer [xf] to return a new transformer (transducer case).
     * Otherwise, it will default to executing [fn].
     *
     * @private
     * @param {Array} methodNames properties to check for a custom implementation
     * @param {Function} xf transducer to initialize if object is transformer
     * @param {Function} fn default ramda implementation
     * @return {Function} A function that dispatches on object in list position
     */

    function _dispatchable(methodNames, xf, fn) {
      return function () {
        if (arguments.length === 0) {
          return fn();
        }

        var args = Array.prototype.slice.call(arguments, 0);
        var obj = args.pop();

        if (!_isArray(obj)) {
          var idx = 0;

          while (idx < methodNames.length) {
            if (typeof obj[methodNames[idx]] === 'function') {
              return obj[methodNames[idx]].apply(obj, args);
            }

            idx += 1;
          }

          if (_isTransformer(obj)) {
            var transducer = xf.apply(null, args);
            return transducer(obj);
          }
        }

        return fn.apply(this, arguments);
      };
    }

    function _reduced(x) {
      return x && x['@@transducer/reduced'] ? x : {
        '@@transducer/value': x,
        '@@transducer/reduced': true
      };
    }

    var _xfBase = {
      init: function () {
        return this.xf['@@transducer/init']();
      },
      result: function (result) {
        return this.xf['@@transducer/result'](result);
      }
    };

    function _isString(x) {
      return Object.prototype.toString.call(x) === '[object String]';
    }

    /**
     * Tests whether or not an object is similar to an array.
     *
     * @private
     * @category Type
     * @category List
     * @sig * -> Boolean
     * @param {*} x The object to test.
     * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
     * @example
     *
     *      _isArrayLike([]); //=> true
     *      _isArrayLike(true); //=> false
     *      _isArrayLike({}); //=> false
     *      _isArrayLike({length: 10}); //=> false
     *      _isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
     */

    var _isArrayLike =
    /*#__PURE__*/
    _curry1(function isArrayLike(x) {
      if (_isArray(x)) {
        return true;
      }

      if (!x) {
        return false;
      }

      if (typeof x !== 'object') {
        return false;
      }

      if (_isString(x)) {
        return false;
      }

      if (x.nodeType === 1) {
        return !!x.length;
      }

      if (x.length === 0) {
        return true;
      }

      if (x.length > 0) {
        return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
      }

      return false;
    });

    var _isArrayLike$1 = _isArrayLike;

    var XWrap =
    /*#__PURE__*/
    function () {
      function XWrap(fn) {
        this.f = fn;
      }

      XWrap.prototype['@@transducer/init'] = function () {
        throw new Error('init not implemented on XWrap');
      };

      XWrap.prototype['@@transducer/result'] = function (acc) {
        return acc;
      };

      XWrap.prototype['@@transducer/step'] = function (acc, x) {
        return this.f(acc, x);
      };

      return XWrap;
    }();

    function _xwrap(fn) {
      return new XWrap(fn);
    }

    /**
     * Creates a function that is bound to a context.
     * Note: `R.bind` does not provide the additional argument-binding capabilities of
     * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
     *
     * @func
     * @memberOf R
     * @since v0.6.0
     * @category Function
     * @category Object
     * @sig (* -> *) -> {*} -> (* -> *)
     * @param {Function} fn The function to bind to context
     * @param {Object} thisObj The context to bind `fn` to
     * @return {Function} A function that will execute in the context of `thisObj`.
     * @see R.partial
     * @example
     *
     *      const log = R.bind(console.log, console);
     *      R.pipe(R.assoc('a', 2), R.tap(log), R.assoc('a', 3))({a: 1}); //=> {a: 3}
     *      // logs {a: 2}
     * @symb R.bind(f, o)(a, b) = f.call(o, a, b)
     */

    var bind =
    /*#__PURE__*/
    _curry2(function bind(fn, thisObj) {
      return _arity(fn.length, function () {
        return fn.apply(thisObj, arguments);
      });
    });

    var bind$1 = bind;

    function _arrayReduce(xf, acc, list) {
      var idx = 0;
      var len = list.length;

      while (idx < len) {
        acc = xf['@@transducer/step'](acc, list[idx]);

        if (acc && acc['@@transducer/reduced']) {
          acc = acc['@@transducer/value'];
          break;
        }

        idx += 1;
      }

      return xf['@@transducer/result'](acc);
    }

    function _iterableReduce(xf, acc, iter) {
      var step = iter.next();

      while (!step.done) {
        acc = xf['@@transducer/step'](acc, step.value);

        if (acc && acc['@@transducer/reduced']) {
          acc = acc['@@transducer/value'];
          break;
        }

        step = iter.next();
      }

      return xf['@@transducer/result'](acc);
    }

    function _methodReduce(xf, acc, obj, methodName) {
      return xf['@@transducer/result'](obj[methodName](bind$1(xf['@@transducer/step'], xf), acc));
    }

    var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
    function _reduce(fn, acc, list) {
      if (typeof fn === 'function') {
        fn = _xwrap(fn);
      }

      if (_isArrayLike$1(list)) {
        return _arrayReduce(fn, acc, list);
      }

      if (typeof list['fantasy-land/reduce'] === 'function') {
        return _methodReduce(fn, acc, list, 'fantasy-land/reduce');
      }

      if (list[symIterator] != null) {
        return _iterableReduce(fn, acc, list[symIterator]());
      }

      if (typeof list.next === 'function') {
        return _iterableReduce(fn, acc, list);
      }

      if (typeof list.reduce === 'function') {
        return _methodReduce(fn, acc, list, 'reduce');
      }

      throw new TypeError('reduce: list must be array or iterable');
    }

    function _has(prop, obj) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }

    var toString$1 = Object.prototype.toString;

    var _isArguments =
    /*#__PURE__*/
    function () {
      return toString$1.call(arguments) === '[object Arguments]' ? function _isArguments(x) {
        return toString$1.call(x) === '[object Arguments]';
      } : function _isArguments(x) {
        return _has('callee', x);
      };
    }();

    var _isArguments$1 = _isArguments;

    var hasEnumBug = !
    /*#__PURE__*/
    {
      toString: null
    }.propertyIsEnumerable('toString');
    var nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString']; // Safari bug

    var hasArgsEnumBug =
    /*#__PURE__*/
    function () {

      return arguments.propertyIsEnumerable('length');
    }();

    var contains$1 = function contains(list, item) {
      var idx = 0;

      while (idx < list.length) {
        if (list[idx] === item) {
          return true;
        }

        idx += 1;
      }

      return false;
    };
    /**
     * Returns a list containing the names of all the enumerable own properties of
     * the supplied object.
     * Note that the order of the output array is not guaranteed to be consistent
     * across different JS platforms.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig {k: v} -> [k]
     * @param {Object} obj The object to extract properties from
     * @return {Array} An array of the object's own properties.
     * @see R.keysIn, R.values
     * @example
     *
     *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
     */


    var keys$2 = typeof Object.keys === 'function' && !hasArgsEnumBug ?
    /*#__PURE__*/
    _curry1(function keys(obj) {
      return Object(obj) !== obj ? [] : Object.keys(obj);
    }) :
    /*#__PURE__*/
    _curry1(function keys(obj) {
      if (Object(obj) !== obj) {
        return [];
      }

      var prop, nIdx;
      var ks = [];

      var checkArgsLength = hasArgsEnumBug && _isArguments$1(obj);

      for (prop in obj) {
        if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {
          ks[ks.length] = prop;
        }
      }

      if (hasEnumBug) {
        nIdx = nonEnumerableProps.length - 1;

        while (nIdx >= 0) {
          prop = nonEnumerableProps[nIdx];

          if (_has(prop, obj) && !contains$1(ks, prop)) {
            ks[ks.length] = prop;
          }

          nIdx -= 1;
        }
      }

      return ks;
    });
    var keys$3 = keys$2;

    /**
     * Determine if the passed argument is an integer.
     *
     * @private
     * @param {*} n
     * @category Type
     * @return {Boolean}
     */
    var _isInteger = Number.isInteger || function _isInteger(n) {
      return n << 0 === n;
    };

    /**
     * Returns a single item by iterating through the list, successively calling
     * the iterator function and passing it an accumulator value and the current
     * value from the array, and then passing the result to the next call.
     *
     * The iterator function receives two values: *(acc, value)*. It may use
     * [`R.reduced`](#reduced) to shortcut the iteration.
     *
     * The arguments' order of [`reduceRight`](#reduceRight)'s iterator function
     * is *(value, acc)*.
     *
     * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
     * arrays), unlike the native `Array.prototype.reduce` method. For more details
     * on this behavior, see:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
     *
     * Dispatches to the `reduce` method of the third argument, if present. When
     * doing so, it is up to the user to handle the [`R.reduced`](#reduced)
     * shortcuting, as this is not implemented by `reduce`.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig ((a, b) -> a) -> a -> [b] -> a
     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
     *        current element from the array.
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @see R.reduced, R.addIndex, R.reduceRight
     * @example
     *
     *      R.reduce(R.subtract, 0, [1, 2, 3, 4]) // => ((((0 - 1) - 2) - 3) - 4) = -10
     *      //          -               -10
     *      //         / \              / \
     *      //        -   4           -6   4
     *      //       / \              / \
     *      //      -   3   ==>     -3   3
     *      //     / \              / \
     *      //    -   2           -1   2
     *      //   / \              / \
     *      //  0   1            0   1
     *
     * @symb R.reduce(f, a, [b, c, d]) = f(f(f(a, b), c), d)
     */

    var reduce =
    /*#__PURE__*/
    _curry3(_reduce);

    var reduce$1 = reduce;

    /**
     * Returns a function that always returns the given value. Note that for
     * non-primitives the value returned is a reference to the original value.
     *
     * This function is known as `const`, `constant`, or `K` (for K combinator) in
     * other languages and libraries.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig a -> (* -> a)
     * @param {*} val The value to wrap in a function
     * @return {Function} A Function :: * -> val.
     * @example
     *
     *      const t = R.always('Tee');
     *      t(); //=> 'Tee'
     */

    var always =
    /*#__PURE__*/
    _curry1(function always(val) {
      return function () {
        return val;
      };
    });

    var always$1 = always;

    /**
     * Makes a shallow clone of an object, setting or overriding the specified
     * property with the given value. Note that this copies and flattens prototype
     * properties onto the new object as well. All non-primitive properties are
     * copied by reference.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Object
     * @sig String -> a -> {k: v} -> {k: v}
     * @param {String} prop The property name to set
     * @param {*} val The new value
     * @param {Object} obj The object to clone
     * @return {Object} A new object equivalent to the original except for the changed property.
     * @see R.dissoc, R.pick
     * @example
     *
     *      R.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}
     */

    var assoc =
    /*#__PURE__*/
    _curry3(function assoc(prop, val, obj) {
      var result = {};

      for (var p in obj) {
        result[p] = obj[p];
      }

      result[prop] = val;
      return result;
    });

    var assoc$1 = assoc;

    /**
     * Returns a curried equivalent of the provided function. The curried function
     * has two unusual capabilities. First, its arguments needn't be provided one
     * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the
     * following are equivalent:
     *
     *   - `g(1)(2)(3)`
     *   - `g(1)(2, 3)`
     *   - `g(1, 2)(3)`
     *   - `g(1, 2, 3)`
     *
     * Secondly, the special placeholder value [`R.__`](#__) may be used to specify
     * "gaps", allowing partial application of any combination of arguments,
     * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),
     * the following are equivalent:
     *
     *   - `g(1, 2, 3)`
     *   - `g(_, 2, 3)(1)`
     *   - `g(_, _, 3)(1)(2)`
     *   - `g(_, _, 3)(1, 2)`
     *   - `g(_, 2)(1)(3)`
     *   - `g(_, 2)(1, 3)`
     *   - `g(_, 2)(_, 3)(1)`
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (* -> a) -> (* -> a)
     * @param {Function} fn The function to curry.
     * @return {Function} A new, curried function.
     * @see R.curryN, R.partial
     * @example
     *
     *      const addFourNumbers = (a, b, c, d) => a + b + c + d;
     *
     *      const curriedAddFourNumbers = R.curry(addFourNumbers);
     *      const f = curriedAddFourNumbers(1, 2);
     *      const g = f(3);
     *      g(4); //=> 10
     */

    var curry =
    /*#__PURE__*/
    _curry1(function curry(fn) {
      return curryN$1(fn.length, fn);
    });

    var curry$1 = curry;

    /**
     * Gives a single-word string description of the (native) type of a value,
     * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not
     * attempt to distinguish user Object types any further, reporting them all as
     * 'Object'.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Type
     * @sig (* -> {*}) -> String
     * @param {*} val The value to test
     * @return {String}
     * @example
     *
     *      R.type({}); //=> "Object"
     *      R.type(1); //=> "Number"
     *      R.type(false); //=> "Boolean"
     *      R.type('s'); //=> "String"
     *      R.type(null); //=> "Null"
     *      R.type([]); //=> "Array"
     *      R.type(/[A-z]/); //=> "RegExp"
     *      R.type(() => {}); //=> "Function"
     *      R.type(undefined); //=> "Undefined"
     */

    var type =
    /*#__PURE__*/
    _curry1(function type(val) {
      return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
    });

    var type$1 = type;

    function _pipe(f, g) {
      return function () {
        return g.call(this, f.apply(this, arguments));
      };
    }

    /**
     * This checks whether a function has a [methodname] function. If it isn't an
     * array it will execute that function otherwise it will default to the ramda
     * implementation.
     *
     * @private
     * @param {Function} fn ramda implemtation
     * @param {String} methodname property to check for a custom implementation
     * @return {Object} Whatever the return value of the method is.
     */

    function _checkForMethod(methodname, fn) {
      return function () {
        var length = arguments.length;

        if (length === 0) {
          return fn();
        }

        var obj = arguments[length - 1];
        return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length - 1));
      };
    }

    /**
     * Returns the elements of the given list or string (or object with a `slice`
     * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
     *
     * Dispatches to the `slice` method of the third argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.4
     * @category List
     * @sig Number -> Number -> [a] -> [a]
     * @sig Number -> Number -> String -> String
     * @param {Number} fromIndex The start index (inclusive).
     * @param {Number} toIndex The end index (exclusive).
     * @param {*} list
     * @return {*}
     * @example
     *
     *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
     *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
     *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
     *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
     *      R.slice(0, 3, 'ramda');                     //=> 'ram'
     */

    var slice =
    /*#__PURE__*/
    _curry3(
    /*#__PURE__*/
    _checkForMethod('slice', function slice(fromIndex, toIndex, list) {
      return Array.prototype.slice.call(list, fromIndex, toIndex);
    }));

    var slice$1 = slice;

    /**
     * Returns all but the first element of the given list or string (or object
     * with a `tail` method).
     *
     * Dispatches to the `slice` method of the first argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [a]
     * @sig String -> String
     * @param {*} list
     * @return {*}
     * @see R.head, R.init, R.last
     * @example
     *
     *      R.tail([1, 2, 3]);  //=> [2, 3]
     *      R.tail([1, 2]);     //=> [2]
     *      R.tail([1]);        //=> []
     *      R.tail([]);         //=> []
     *
     *      R.tail('abc');  //=> 'bc'
     *      R.tail('ab');   //=> 'b'
     *      R.tail('a');    //=> ''
     *      R.tail('');     //=> ''
     */

    var tail =
    /*#__PURE__*/
    _curry1(
    /*#__PURE__*/
    _checkForMethod('tail',
    /*#__PURE__*/
    slice$1(1, Infinity)));

    var tail$1 = tail;

    /**
     * Performs left-to-right function composition. The first argument may have
     * any arity; the remaining arguments must be unary.
     *
     * In some libraries this function is named `sequence`.
     *
     * **Note:** The result of pipe is not automatically curried.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)
     * @param {...Function} functions
     * @return {Function}
     * @see R.compose
     * @example
     *
     *      const f = R.pipe(Math.pow, R.negate, R.inc);
     *
     *      f(3, 4); // -(3^4) + 1
     * @symb R.pipe(f, g, h)(a, b) = h(g(f(a, b)))
     */

    function pipe() {
      if (arguments.length === 0) {
        throw new Error('pipe requires at least one argument');
      }

      return _arity(arguments[0].length, reduce$1(_pipe, arguments[0], tail$1(arguments)));
    }

    function _identity(x) {
      return x;
    }

    /**
     * A function that does nothing but return the parameter supplied to it. Good
     * as a default or placeholder function.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig a -> a
     * @param {*} x The value to return.
     * @return {*} The input value, `x`.
     * @example
     *
     *      R.identity(1); //=> 1
     *
     *      const obj = {};
     *      R.identity(obj) === obj; //=> true
     * @symb R.identity(a) = a
     */

    var identity$2 =
    /*#__PURE__*/
    _curry1(_identity);

    var identity$3 = identity$2;

    function _arrayFromIterator(iter) {
      var list = [];
      var next;

      while (!(next = iter.next()).done) {
        list.push(next.value);
      }

      return list;
    }

    function _includesWith(pred, x, list) {
      var idx = 0;
      var len = list.length;

      while (idx < len) {
        if (pred(x, list[idx])) {
          return true;
        }

        idx += 1;
      }

      return false;
    }

    function _functionName(f) {
      // String(x => x) evaluates to "x => x", so the pattern may not match.
      var match = String(f).match(/^function (\w*)/);
      return match == null ? '' : match[1];
    }

    // Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
    function _objectIs(a, b) {
      // SameValue algorithm
      if (a === b) {
        // Steps 1-5, 7-10
        // Steps 6.b-6.e: +0 != -0
        return a !== 0 || 1 / a === 1 / b;
      } else {
        // Step 6.a: NaN == NaN
        return a !== a && b !== b;
      }
    }

    var _objectIs$1 = typeof Object.is === 'function' ? Object.is : _objectIs;

    /**
     * private _uniqContentEquals function.
     * That function is checking equality of 2 iterator contents with 2 assumptions
     * - iterators lengths are the same
     * - iterators values are unique
     *
     * false-positive result will be returned for comparision of, e.g.
     * - [1,2,3] and [1,2,3,4]
     * - [1,1,1] and [1,2,3]
     * */

    function _uniqContentEquals(aIterator, bIterator, stackA, stackB) {
      var a = _arrayFromIterator(aIterator);

      var b = _arrayFromIterator(bIterator);

      function eq(_a, _b) {
        return _equals(_a, _b, stackA.slice(), stackB.slice());
      } // if *a* array contains any element that is not included in *b*


      return !_includesWith(function (b, aItem) {
        return !_includesWith(eq, aItem, b);
      }, b, a);
    }

    function _equals(a, b, stackA, stackB) {
      if (_objectIs$1(a, b)) {
        return true;
      }

      var typeA = type$1(a);

      if (typeA !== type$1(b)) {
        return false;
      }

      if (a == null || b == null) {
        return false;
      }

      if (typeof a['fantasy-land/equals'] === 'function' || typeof b['fantasy-land/equals'] === 'function') {
        return typeof a['fantasy-land/equals'] === 'function' && a['fantasy-land/equals'](b) && typeof b['fantasy-land/equals'] === 'function' && b['fantasy-land/equals'](a);
      }

      if (typeof a.equals === 'function' || typeof b.equals === 'function') {
        return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);
      }

      switch (typeA) {
        case 'Arguments':
        case 'Array':
        case 'Object':
          if (typeof a.constructor === 'function' && _functionName(a.constructor) === 'Promise') {
            return a === b;
          }

          break;

        case 'Boolean':
        case 'Number':
        case 'String':
          if (!(typeof a === typeof b && _objectIs$1(a.valueOf(), b.valueOf()))) {
            return false;
          }

          break;

        case 'Date':
          if (!_objectIs$1(a.valueOf(), b.valueOf())) {
            return false;
          }

          break;

        case 'Error':
          return a.name === b.name && a.message === b.message;

        case 'RegExp':
          if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
            return false;
          }

          break;
      }

      var idx = stackA.length - 1;

      while (idx >= 0) {
        if (stackA[idx] === a) {
          return stackB[idx] === b;
        }

        idx -= 1;
      }

      switch (typeA) {
        case 'Map':
          if (a.size !== b.size) {
            return false;
          }

          return _uniqContentEquals(a.entries(), b.entries(), stackA.concat([a]), stackB.concat([b]));

        case 'Set':
          if (a.size !== b.size) {
            return false;
          }

          return _uniqContentEquals(a.values(), b.values(), stackA.concat([a]), stackB.concat([b]));

        case 'Arguments':
        case 'Array':
        case 'Object':
        case 'Boolean':
        case 'Number':
        case 'String':
        case 'Date':
        case 'Error':
        case 'RegExp':
        case 'Int8Array':
        case 'Uint8Array':
        case 'Uint8ClampedArray':
        case 'Int16Array':
        case 'Uint16Array':
        case 'Int32Array':
        case 'Uint32Array':
        case 'Float32Array':
        case 'Float64Array':
        case 'ArrayBuffer':
          break;

        default:
          // Values of other types are only equal if identical.
          return false;
      }

      var keysA = keys$3(a);

      if (keysA.length !== keys$3(b).length) {
        return false;
      }

      var extendedStackA = stackA.concat([a]);
      var extendedStackB = stackB.concat([b]);
      idx = keysA.length - 1;

      while (idx >= 0) {
        var key = keysA[idx];

        if (!(_has(key, b) && _equals(b[key], a[key], extendedStackA, extendedStackB))) {
          return false;
        }

        idx -= 1;
      }

      return true;
    }

    /**
     * Returns `true` if its arguments are equivalent, `false` otherwise. Handles
     * cyclical data structures.
     *
     * Dispatches symmetrically to the `equals` methods of both arguments, if
     * present.
     *
     * @func
     * @memberOf R
     * @since v0.15.0
     * @category Relation
     * @sig a -> b -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @example
     *
     *      R.equals(1, 1); //=> true
     *      R.equals(1, '1'); //=> false
     *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
     *
     *      const a = {}; a.v = a;
     *      const b = {}; b.v = b;
     *      R.equals(a, b); //=> true
     */

    var equals =
    /*#__PURE__*/
    _curry2(function equals(a, b) {
      return _equals(a, b, [], []);
    });

    var equals$1 = equals;

    function _indexOf(list, a, idx) {
      var inf, item; // Array.prototype.indexOf doesn't exist below IE9

      if (typeof list.indexOf === 'function') {
        switch (typeof a) {
          case 'number':
            if (a === 0) {
              // manually crawl the list to distinguish between +0 and -0
              inf = 1 / a;

              while (idx < list.length) {
                item = list[idx];

                if (item === 0 && 1 / item === inf) {
                  return idx;
                }

                idx += 1;
              }

              return -1;
            } else if (a !== a) {
              // NaN
              while (idx < list.length) {
                item = list[idx];

                if (typeof item === 'number' && item !== item) {
                  return idx;
                }

                idx += 1;
              }

              return -1;
            } // non-zero numbers can utilise Set


            return list.indexOf(a, idx);
          // all these types can utilise Set

          case 'string':
          case 'boolean':
          case 'function':
          case 'undefined':
            return list.indexOf(a, idx);

          case 'object':
            if (a === null) {
              // null can utilise Set
              return list.indexOf(a, idx);
            }

        }
      } // anything else not covered above, defer to R.equals


      while (idx < list.length) {
        if (equals$1(list[idx], a)) {
          return idx;
        }

        idx += 1;
      }

      return -1;
    }

    function _includes(a, list) {
      return _indexOf(list, a, 0) >= 0;
    }

    var _Set$1 =
    /*#__PURE__*/
    function () {
      function _Set() {
        /* globals Set */
        this._nativeSet = typeof Set === 'function' ? new Set() : null;
        this._items = {};
      }

      // until we figure out why jsdoc chokes on this
      // @param item The item to add to the Set
      // @returns {boolean} true if the item did not exist prior, otherwise false
      //
      _Set.prototype.add = function (item) {
        return !hasOrAdd(item, true, this);
      }; //
      // @param item The item to check for existence in the Set
      // @returns {boolean} true if the item exists in the Set, otherwise false
      //


      _Set.prototype.has = function (item) {
        return hasOrAdd(item, false, this);
      }; //
      // Combines the logic for checking whether an item is a member of the set and
      // for adding a new item to the set.
      //
      // @param item       The item to check or add to the Set instance.
      // @param shouldAdd  If true, the item will be added to the set if it doesn't
      //                   already exist.
      // @param set        The set instance to check or add to.
      // @return {boolean} true if the item already existed, otherwise false.
      //


      return _Set;
    }();

    function hasOrAdd(item, shouldAdd, set) {
      var type = typeof item;
      var prevSize, newSize;

      switch (type) {
        case 'string':
        case 'number':
          // distinguish between +0 and -0
          if (item === 0 && 1 / item === -Infinity) {
            if (set._items['-0']) {
              return true;
            } else {
              if (shouldAdd) {
                set._items['-0'] = true;
              }

              return false;
            }
          } // these types can all utilise the native Set


          if (set._nativeSet !== null) {
            if (shouldAdd) {
              prevSize = set._nativeSet.size;

              set._nativeSet.add(item);

              newSize = set._nativeSet.size;
              return newSize === prevSize;
            } else {
              return set._nativeSet.has(item);
            }
          } else {
            if (!(type in set._items)) {
              if (shouldAdd) {
                set._items[type] = {};
                set._items[type][item] = true;
              }

              return false;
            } else if (item in set._items[type]) {
              return true;
            } else {
              if (shouldAdd) {
                set._items[type][item] = true;
              }

              return false;
            }
          }

        case 'boolean':
          // set._items['boolean'] holds a two element array
          // representing [ falseExists, trueExists ]
          if (type in set._items) {
            var bIdx = item ? 1 : 0;

            if (set._items[type][bIdx]) {
              return true;
            } else {
              if (shouldAdd) {
                set._items[type][bIdx] = true;
              }

              return false;
            }
          } else {
            if (shouldAdd) {
              set._items[type] = item ? [false, true] : [true, false];
            }

            return false;
          }

        case 'function':
          // compare functions for reference equality
          if (set._nativeSet !== null) {
            if (shouldAdd) {
              prevSize = set._nativeSet.size;

              set._nativeSet.add(item);

              newSize = set._nativeSet.size;
              return newSize === prevSize;
            } else {
              return set._nativeSet.has(item);
            }
          } else {
            if (!(type in set._items)) {
              if (shouldAdd) {
                set._items[type] = [item];
              }

              return false;
            }

            if (!_includes(item, set._items[type])) {
              if (shouldAdd) {
                set._items[type].push(item);
              }

              return false;
            }

            return true;
          }

        case 'undefined':
          if (set._items[type]) {
            return true;
          } else {
            if (shouldAdd) {
              set._items[type] = true;
            }

            return false;
          }

        case 'object':
          if (item === null) {
            if (!set._items['null']) {
              if (shouldAdd) {
                set._items['null'] = true;
              }

              return false;
            }

            return true;
          }

        /* falls through */

        default:
          // reduce the search size of heterogeneous sets by creating buckets
          // for each type.
          type = Object.prototype.toString.call(item);

          if (!(type in set._items)) {
            if (shouldAdd) {
              set._items[type] = [item];
            }

            return false;
          } // scan through all previously applied items


          if (!_includes(item, set._items[type])) {
            if (shouldAdd) {
              set._items[type].push(item);
            }

            return false;
          }

          return true;
      }
    } // A simple Set type that honours R.equals semantics


    var _Set$2 = _Set$1;

    /**
     * Returns a new object that does not contain a `prop` property.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Object
     * @sig String -> {k: v} -> {k: v}
     * @param {String} prop The name of the property to dissociate
     * @param {Object} obj The object to clone
     * @return {Object} A new object equivalent to the original but without the specified property
     * @see R.assoc, R.omit
     * @example
     *
     *      R.dissoc('b', {a: 1, b: 2, c: 3}); //=> {a: 1, c: 3}
     */

    var dissoc =
    /*#__PURE__*/
    _curry2(function dissoc(prop, obj) {
      var result = {};

      for (var p in obj) {
        result[p] = obj[p];
      }

      delete result[prop];
      return result;
    });

    var dissoc$1 = dissoc;

    /**
     * Removes the sub-list of `list` starting at index `start` and containing
     * `count` elements. _Note that this is not destructive_: it returns a copy of
     * the list with the changes.
     * <small>No lists have been harmed in the application of this function.</small>
     *
     * @func
     * @memberOf R
     * @since v0.2.2
     * @category List
     * @sig Number -> Number -> [a] -> [a]
     * @param {Number} start The position to start removing elements
     * @param {Number} count The number of elements to remove
     * @param {Array} list The list to remove from
     * @return {Array} A new Array with `count` elements from `start` removed.
     * @see R.without
     * @example
     *
     *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]
     */

    var remove$1 =
    /*#__PURE__*/
    _curry3(function remove(start, count, list) {
      var result = Array.prototype.slice.call(list, 0);
      result.splice(start, count);
      return result;
    });

    var remove$2 = remove$1;

    /**
     * Returns a new copy of the array with the element at the provided index
     * replaced with the given value.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category List
     * @sig Number -> a -> [a] -> [a]
     * @param {Number} idx The index to update.
     * @param {*} x The value to exist at the given index of the returned array.
     * @param {Array|Arguments} list The source array-like object to be updated.
     * @return {Array} A copy of `list` with the value at index `idx` replaced with `x`.
     * @see R.adjust
     * @example
     *
     *      R.update(1, '_', ['a', 'b', 'c']);      //=> ['a', '_', 'c']
     *      R.update(-1, '_', ['a', 'b', 'c']);     //=> ['a', 'b', '_']
     * @symb R.update(-1, a, [b, c]) = [b, a]
     * @symb R.update(0, a, [b, c]) = [a, c]
     * @symb R.update(1, a, [b, c]) = [b, a]
     */

    var update =
    /*#__PURE__*/
    _curry3(function update(idx, x, list) {
      return adjust$1(idx, always$1(x), list);
    });

    var update$1 = update;

    /**
     * Makes a shallow clone of an object, omitting the property at the given path.
     * Note that this copies and flattens prototype properties onto the new object
     * as well. All non-primitive properties are copied by reference.
     *
     * @func
     * @memberOf R
     * @since v0.11.0
     * @category Object
     * @typedefn Idx = String | Int
     * @sig [Idx] -> {k: v} -> {k: v}
     * @param {Array} path The path to the value to omit
     * @param {Object} obj The object to clone
     * @return {Object} A new object without the property at path
     * @see R.assocPath
     * @example
     *
     *      R.dissocPath(['a', 'b', 'c'], {a: {b: {c: 42}}}); //=> {a: {b: {}}}
     */

    var dissocPath =
    /*#__PURE__*/
    _curry2(function dissocPath(path, obj) {
      switch (path.length) {
        case 0:
          return obj;

        case 1:
          return _isInteger(path[0]) && _isArray(obj) ? remove$2(path[0], 1, obj) : dissoc$1(path[0], obj);

        default:
          var head = path[0];
          var tail = Array.prototype.slice.call(path, 1);

          if (obj[head] == null) {
            return obj;
          } else if (_isInteger(head) && _isArray(obj)) {
            return update$1(head, dissocPath(tail, obj[head]), obj);
          } else {
            return assoc$1(head, dissocPath(tail, obj[head]), obj);
          }

      }
    });

    var dissocPath$1 = dissocPath;

    var XFindIndex =
    /*#__PURE__*/
    function () {
      function XFindIndex(f, xf) {
        this.xf = xf;
        this.f = f;
        this.idx = -1;
        this.found = false;
      }

      XFindIndex.prototype['@@transducer/init'] = _xfBase.init;

      XFindIndex.prototype['@@transducer/result'] = function (result) {
        if (!this.found) {
          result = this.xf['@@transducer/step'](result, -1);
        }

        return this.xf['@@transducer/result'](result);
      };

      XFindIndex.prototype['@@transducer/step'] = function (result, input) {
        this.idx += 1;

        if (this.f(input)) {
          this.found = true;
          result = _reduced(this.xf['@@transducer/step'](result, this.idx));
        }

        return result;
      };

      return XFindIndex;
    }();

    var _xfindIndex =
    /*#__PURE__*/
    _curry2(function _xfindIndex(f, xf) {
      return new XFindIndex(f, xf);
    });

    var _xfindIndex$1 = _xfindIndex;

    /**
     * Returns the index of the first element of the list which matches the
     * predicate, or `-1` if no element matches.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category List
     * @sig (a -> Boolean) -> [a] -> Number
     * @param {Function} fn The predicate function used to determine if the element is the
     * desired one.
     * @param {Array} list The array to consider.
     * @return {Number} The index of the element found, or `-1`.
     * @see R.transduce
     * @example
     *
     *      const xs = [{a: 1}, {a: 2}, {a: 3}];
     *      R.findIndex(R.propEq('a', 2))(xs); //=> 1
     *      R.findIndex(R.propEq('a', 4))(xs); //=> -1
     */

    var findIndex$4 =
    /*#__PURE__*/
    _curry2(
    /*#__PURE__*/
    _dispatchable([], _xfindIndex$1, function findIndex(fn, list) {
      var idx = 0;
      var len = list.length;

      while (idx < len) {
        if (fn(list[idx])) {
          return idx;
        }

        idx += 1;
      }

      return -1;
    }));

    var findIndex$5 = findIndex$4;

    /**
     * Returns a new list containing only one copy of each element in the original
     * list, based upon the value returned by applying the supplied function to
     * each list element. Prefers the first item if the supplied function produces
     * the same value on two items. [`R.equals`](#equals) is used for comparison.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig (a -> b) -> [a] -> [a]
     * @param {Function} fn A function used to produce a value to use during comparisons.
     * @param {Array} list The array to consider.
     * @return {Array} The list of unique items.
     * @example
     *
     *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]
     */

    var uniqBy =
    /*#__PURE__*/
    _curry2(function uniqBy(fn, list) {
      var set = new _Set$2();
      var result = [];
      var idx = 0;
      var appliedItem, item;

      while (idx < list.length) {
        item = list[idx];
        appliedItem = fn(item);

        if (set.add(appliedItem)) {
          result.push(item);
        }

        idx += 1;
      }

      return result;
    });

    var uniqBy$1 = uniqBy;

    /**
     * Returns a new list containing only one copy of each element in the original
     * list. [`R.equals`](#equals) is used to determine equality.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [a]
     * @param {Array} list The array to consider.
     * @return {Array} The list of unique items.
     * @example
     *
     *      R.uniq([1, 1, 2, 1]); //=> [1, 2]
     *      R.uniq([1, '1']);     //=> [1, '1']
     *      R.uniq([[42], [42]]); //=> [[42]]
     */

    var uniq =
    /*#__PURE__*/
    uniqBy$1(identity$3);
    var uniq$1 = uniq;

    function _isNumber(x) {
      return Object.prototype.toString.call(x) === '[object Number]';
    }

    /**
     * Returns a partial copy of an object omitting the keys specified.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig [String] -> {String: *} -> {String: *}
     * @param {Array} names an array of String property names to omit from the new object
     * @param {Object} obj The object to copy from
     * @return {Object} A new object with properties from `names` not on it.
     * @see R.pick
     * @example
     *
     *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}
     */

    var omit =
    /*#__PURE__*/
    _curry2(function omit(names, obj) {
      var result = {};
      var index = {};
      var idx = 0;
      var len = names.length;

      while (idx < len) {
        index[names[idx]] = 1;
        idx += 1;
      }

      for (var prop in obj) {
        if (!index.hasOwnProperty(prop)) {
          result[prop] = obj[prop];
        }
      }

      return result;
    });

    var omit$1 = omit;

    /**
     * Returns `true` if the specified object property is equal, in
     * [`R.equals`](#equals) terms, to the given value; `false` otherwise.
     * You can test multiple properties with [`R.whereEq`](#whereEq).
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig String -> a -> Object -> Boolean
     * @param {String} name
     * @param {*} val
     * @param {*} obj
     * @return {Boolean}
     * @see R.whereEq, R.propSatisfies, R.equals
     * @example
     *
     *      const abby = {name: 'Abby', age: 7, hair: 'blond'};
     *      const fred = {name: 'Fred', age: 12, hair: 'brown'};
     *      const rusty = {name: 'Rusty', age: 10, hair: 'brown'};
     *      const alois = {name: 'Alois', age: 15, disposition: 'surly'};
     *      const kids = [abby, fred, rusty, alois];
     *      const hasBrownHair = R.propEq('hair', 'brown');
     *      R.filter(hasBrownHair, kids); //=> [fred, rusty]
     */

    var propEq =
    /*#__PURE__*/
    _curry3(function propEq(name, val, obj) {
      return equals$1(val, obj[name]);
    });

    var propEq$1 = propEq;

    /**
     * Returns a list of numbers from `from` (inclusive) to `to` (exclusive).
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Number -> Number -> [Number]
     * @param {Number} from The first number in the list.
     * @param {Number} to One more than the last number in the list.
     * @return {Array} The list of numbers in the set `[a, b)`.
     * @example
     *
     *      R.range(1, 5);    //=> [1, 2, 3, 4]
     *      R.range(50, 53);  //=> [50, 51, 52]
     */

    var range$1 =
    /*#__PURE__*/
    _curry2(function range(from, to) {
      if (!(_isNumber(from) && _isNumber(to))) {
        throw new TypeError('Both arguments to range must be numbers');
      }

      var result = [];
      var n = from;

      while (n < to) {
        result.push(n);
        n += 1;
      }

      return result;
    });

    var range$2 = range$1;

    var createCompounder = _createCompounder;

    /**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    var snakeCase_1 = snakeCase;

    // Unique ID creation requires a high quality random # generator. In the browser we therefore
    // require the crypto API and do not support built-in fallback to lower quality random number
    // generators (like Math.random()).
    var getRandomValues;
    var rnds8 = new Uint8Array(16);
    function rng() {
      // lazy load so that environments that need to polyfill have a chance to do so
      if (!getRandomValues) {
        // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
        // find the complete implementation of crypto (msCrypto) on IE11.
        getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

        if (!getRandomValues) {
          throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
        }
      }

      return getRandomValues(rnds8);
    }

    var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

    function validate(uuid) {
      return typeof uuid === 'string' && REGEX.test(uuid);
    }

    /**
     * Convert array of 16 byte values to UUID string format of the form:
     * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
     */

    var byteToHex = [];

    for (var i = 0; i < 256; ++i) {
      byteToHex.push((i + 0x100).toString(16).substr(1));
    }

    function stringify(arr) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      // Note: Be careful editing this code!  It's been tuned for performance
      // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
      var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
      // of the following:
      // - One or more input array values don't map to a hex octet (leading to
      // "undefined" in the uuid)
      // - Invalid input values for the RFC `version` or `variant` fields

      if (!validate(uuid)) {
        throw TypeError('Stringified UUID is invalid');
      }

      return uuid;
    }

    function v4(options, buf, offset) {
      options = options || {};
      var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

      rnds[6] = rnds[6] & 0x0f | 0x40;
      rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

      if (buf) {
        offset = offset || 0;

        for (var i = 0; i < 16; ++i) {
          buf[offset + i] = rnds[i];
        }

        return buf;
      }

      return stringify(rnds);
    }

    const pascalCase = pipe(camelCase_1, upperFirst_1);
    function createSubscriptionHelper() {
        const subscriptions = [];
        const push = (...args) => subscriptions.push(...args);
        const destroy = () => {
            while (subscriptions.length) {
                const f = subscriptions.shift();
                isFunction$4(f) ? f() : f.unsubscribe();
            }
        };
        return {
            push,
            destroy,
        };
    }
    const cloneDeep = (value) => JSON.parse(JSON.stringify(value));
    const isArray$4 = (value) => Array.isArray(value);
    const isEmpty = (value) => isNull$1(value) || isUndefined$1(value);
    const isTypeof = curry$1((name, value) => typeof value === name);
    const isObject$4 = (value) => !!value && isTypeof('object', value);
    const isFunction$4 = isTypeof('function');
    const isString$2 = isTypeof('string');
    const isUndefined$1 = isTypeof('undefined');
    const isNumber = isTypeof('number');
    const isBoolean = isTypeof('boolean');
    const isNull$1 = (value) => value === null;
    const isRegExp = curry$1((exclude, key) => exclude.some(regexp => regexp.test(key)));
    const noop$2 = () => { };
    const getData = (list, id) => list.find(data => data.id === id);
    const getIndex = (list, id) => findIndex$5(propEq$1('id', id))(list);
    const range = (a, b) => a < b ? range$2(a, b + 1) : range$2(b, a + 1);
    function* flat(iterator) {
        for (const value of iterator) {
            if (value && value[Symbol.iterator])
                yield* flat(value);
            else
                yield value;
        }
    }
    const createBalanceRange = (min, max) => (num) => Math.min(Math.max(num, min), max);
    function autoName(list, id, name, num = 1) {
        let result = true;
        for (const value of list) {
            if (name === value.name && value.id !== id && name !== '') {
                result = false;
                break;
            }
        }
        if (result) {
            return name;
        }
        return autoName(list, id, name.replace(/[0-9]/g, '') + num, num + 1);
    }

    const createTheme = () => ({
        canvas: '#282828',
        table: '#191919',
        tableActive: '#14496d',
        focus: '#00a9ff',
        keyPK: '#B4B400',
        keyFK: '#dda8b1',
        keyPFK: '#60b9c4',
        font: '#a2a2a2',
        fontActive: 'white',
        fontPlaceholder: '#6D6D6D',
        contextmenu: '#191919',
        contextmenuActive: '#383d41',
        edit: '#ffc107',
        columnSelect: '#232a2f',
        columnActive: '#372908',
        minimapShadow: 'black',
        scrollbarThumb: '#6D6D6D',
        scrollbarThumbActive: '#a2a2a2',
        menubar: 'black',
        visualization: '#191919',
        diffAdd: '#74c56a2a',
        diffModify: '#ebd4703d',
        diffRemove: '#dda8b12a',
    });
    const loadTheme = (theme, newTheme) => Object.keys(theme)
        .filter(key => isString$2(newTheme[key]))
        .forEach(key => (theme[key] = newTheme[key]));
    const themeToString = (theme) => Object.keys(theme)
        .map(key => `--vuerd-color-${kebabCase_1(key)}: var(--vuerd-theme-${kebabCase_1(key)}, ${theme[key]});`)
        .join('');

    defineComponent('vuerd-provider', {
        render: (_, ctx) => () => html `
      <style type="text/css">
        @import url('/static/googlefontscss.css');
        :host {
          --vuerd-font-family: 'Noto Sans', sans-serif;
          font-size: ${SIZE_FONT}px;
          font-family: var(--vuerd-font-family) !important;
          ${themeToString(ctx.value.theme)};
        }
      </style>
      <slot></slot>
    `,
    });
    const getVuerdContext = (ctx) => getContext('vuerd-provider', ctx);

    /**
     * @license
     * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * Stores the StyleInfo object applied to a given AttributePart.
     * Used to unset existing values when a new StyleInfo object is applied.
     */
    const previousStylePropertyCache = new WeakMap();
    /**
     * A directive that applies CSS properties to an element.
     *
     * `styleMap` can only be used in the `style` attribute and must be the only
     * expression in the attribute. It takes the property names in the `styleInfo`
     * object and adds the property values as CSS properties. Property names with
     * dashes (`-`) are assumed to be valid CSS property names and set on the
     * element's style object using `setProperty()`. Names without dashes are
     * assumed to be camelCased JavaScript property names and set on the element's
     * style object using property assignment, allowing the style object to
     * translate JavaScript-style names to CSS property names.
     *
     * For example `styleMap({backgroundColor: 'red', 'border-top': '5px', '--size':
     * '0'})` sets the `background-color`, `border-top` and `--size` properties.
     *
     * @param styleInfo {StyleInfo}
     */
    const styleMap = directive((styleInfo) => (part) => {
        if (!(part instanceof AttributePart) || (part instanceof PropertyPart) ||
            part.committer.name !== 'style' || part.committer.parts.length > 1) {
            throw new Error('The `styleMap` directive must be used in the style attribute ' +
                'and must be the only part in the attribute.');
        }
        const { committer } = part;
        const { style } = committer.element;
        let previousStyleProperties = previousStylePropertyCache.get(part);
        if (previousStyleProperties === undefined) {
            // Write static styles once
            style.cssText = committer.strings.join(' ');
            previousStylePropertyCache.set(part, previousStyleProperties = new Set());
        }
        // Remove old properties that no longer exist in styleInfo
        // We use forEach() instead of for-of so that re don't require down-level
        // iteration.
        previousStyleProperties.forEach((name) => {
            if (!(name in styleInfo)) {
                previousStyleProperties.delete(name);
                if (name.indexOf('-') === -1) {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    style[name] = null;
                }
                else {
                    style.removeProperty(name);
                }
            }
        });
        // Add or update properties
        for (const name in styleInfo) {
            previousStyleProperties.add(name);
            if (name.indexOf('-') === -1) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                style[name] = styleInfo[name];
            }
            else {
                style.setProperty(name, styleInfo[name]);
            }
        }
    });

    /*!
     * Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com
     * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
     */
    var faCheck = {
      prefix: 'fas',
      iconName: 'check',
      icon: [512, 512, [], "f00c", "M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z"]
    };
    var faChevronRight = {
      prefix: 'fas',
      iconName: 'chevron-right',
      icon: [320, 512, [], "f054", "M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z"]
    };
    var faCode = {
      prefix: 'fas',
      iconName: 'code',
      icon: [640, 512, [], "f121", "M278.9 511.5l-61-17.7c-6.4-1.8-10-8.5-8.2-14.9L346.2 8.7c1.8-6.4 8.5-10 14.9-8.2l61 17.7c6.4 1.8 10 8.5 8.2 14.9L293.8 503.3c-1.9 6.4-8.5 10.1-14.9 8.2zm-114-112.2l43.5-46.4c4.6-4.9 4.3-12.7-.8-17.2L117 256l90.6-79.7c5.1-4.5 5.5-12.3.8-17.2l-43.5-46.4c-4.5-4.8-12.1-5.1-17-.5L3.8 247.2c-5.1 4.7-5.1 12.8 0 17.5l144.1 135.1c4.9 4.6 12.5 4.4 17-.5zm327.2.6l144.1-135.1c5.1-4.7 5.1-12.8 0-17.5L492.1 112.1c-4.8-4.5-12.4-4.3-17 .5L431.6 159c-4.6 4.9-4.3 12.7.8 17.2L523 256l-90.6 79.7c-5.1 4.5-5.5 12.3-.8 17.2l43.5 46.4c4.5 4.9 12.1 5.1 17 .6z"]
    };
    var faCog = {
      prefix: 'fas',
      iconName: 'cog',
      icon: [512, 512, [], "f013", "M487.4 315.7l-42.6-24.6c4.3-23.2 4.3-47 0-70.2l42.6-24.6c4.9-2.8 7.1-8.6 5.5-14-11.1-35.6-30-67.8-54.7-94.6-3.8-4.1-10-5.1-14.8-2.3L380.8 110c-17.9-15.4-38.5-27.3-60.8-35.1V25.8c0-5.6-3.9-10.5-9.4-11.7-36.7-8.2-74.3-7.8-109.2 0-5.5 1.2-9.4 6.1-9.4 11.7V75c-22.2 7.9-42.8 19.8-60.8 35.1L88.7 85.5c-4.9-2.8-11-1.9-14.8 2.3-24.7 26.7-43.6 58.9-54.7 94.6-1.7 5.4.6 11.2 5.5 14L67.3 221c-4.3 23.2-4.3 47 0 70.2l-42.6 24.6c-4.9 2.8-7.1 8.6-5.5 14 11.1 35.6 30 67.8 54.7 94.6 3.8 4.1 10 5.1 14.8 2.3l42.6-24.6c17.9 15.4 38.5 27.3 60.8 35.1v49.2c0 5.6 3.9 10.5 9.4 11.7 36.7 8.2 74.3 7.8 109.2 0 5.5-1.2 9.4-6.1 9.4-11.7v-49.2c22.2-7.9 42.8-19.8 60.8-35.1l42.6 24.6c4.9 2.8 11 1.9 14.8-2.3 24.7-26.7 43.6-58.9 54.7-94.6 1.5-5.5-.7-11.3-5.6-14.1zM256 336c-44.1 0-80-35.9-80-80s35.9-80 80-80 80 35.9 80 80-35.9 80-80 80z"]
    };
    var faColumns = {
      prefix: 'fas',
      iconName: 'columns',
      icon: [512, 512, [], "f0db", "M464 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h416c26.51 0 48-21.49 48-48V80c0-26.51-21.49-48-48-48zM224 416H64V160h160v256zm224 0H288V160h160v256z"]
    };
    var faEye = {
      prefix: 'fas',
      iconName: 'eye',
      icon: [576, 512, [], "f06e", "M572.52 241.4C518.29 135.59 410.93 64 288 64S57.68 135.64 3.48 241.41a32.35 32.35 0 0 0 0 29.19C57.71 376.41 165.07 448 288 448s230.32-71.64 284.52-177.41a32.35 32.35 0 0 0 0-29.19zM288 400a144 144 0 1 1 144-144 143.93 143.93 0 0 1-144 144zm0-240a95.31 95.31 0 0 0-25.31 3.79 47.85 47.85 0 0 1-66.9 66.9A95.78 95.78 0 1 0 288 160z"]
    };
    var faEyeSlash = {
      prefix: 'fas',
      iconName: 'eye-slash',
      icon: [640, 512, [], "f070", "M320 400c-75.85 0-137.25-58.71-142.9-133.11L72.2 185.82c-13.79 17.3-26.48 35.59-36.72 55.59a32.35 32.35 0 0 0 0 29.19C89.71 376.41 197.07 448 320 448c26.91 0 52.87-4 77.89-10.46L346 397.39a144.13 144.13 0 0 1-26 2.61zm313.82 58.1l-110.55-85.44a331.25 331.25 0 0 0 81.25-102.07 32.35 32.35 0 0 0 0-29.19C550.29 135.59 442.93 64 320 64a308.15 308.15 0 0 0-147.32 37.7L45.46 3.37A16 16 0 0 0 23 6.18L3.37 31.45A16 16 0 0 0 6.18 53.9l588.36 454.73a16 16 0 0 0 22.46-2.81l19.64-25.27a16 16 0 0 0-2.82-22.45zm-183.72-142l-39.3-30.38A94.75 94.75 0 0 0 416 256a94.76 94.76 0 0 0-121.31-92.21A47.65 47.65 0 0 1 304 192a46.64 46.64 0 0 1-1.54 10l-73.61-56.89A142.31 142.31 0 0 1 320 112a143.92 143.92 0 0 1 144 144c0 21.63-5.29 41.79-13.9 60.11z"]
    };
    var faFileCode = {
      prefix: 'fas',
      iconName: 'file-code',
      icon: [384, 512, [], "f1c9", "M384 121.941V128H256V0h6.059c6.365 0 12.47 2.529 16.971 7.029l97.941 97.941A24.005 24.005 0 0 1 384 121.941zM248 160c-13.2 0-24-10.8-24-24V0H24C10.745 0 0 10.745 0 24v464c0 13.255 10.745 24 24 24h336c13.255 0 24-10.745 24-24V160H248zM123.206 400.505a5.4 5.4 0 0 1-7.633.246l-64.866-60.812a5.4 5.4 0 0 1 0-7.879l64.866-60.812a5.4 5.4 0 0 1 7.633.246l19.579 20.885a5.4 5.4 0 0 1-.372 7.747L101.65 336l40.763 35.874a5.4 5.4 0 0 1 .372 7.747l-19.579 20.884zm51.295 50.479l-27.453-7.97a5.402 5.402 0 0 1-3.681-6.692l61.44-211.626a5.402 5.402 0 0 1 6.692-3.681l27.452 7.97a5.4 5.4 0 0 1 3.68 6.692l-61.44 211.626a5.397 5.397 0 0 1-6.69 3.681zm160.792-111.045l-64.866 60.812a5.4 5.4 0 0 1-7.633-.246l-19.58-20.885a5.4 5.4 0 0 1 .372-7.747L284.35 336l-40.763-35.874a5.4 5.4 0 0 1-.372-7.747l19.58-20.885a5.4 5.4 0 0 1 7.633-.246l64.866 60.812a5.4 5.4 0 0 1-.001 7.879z"]
    };
    var faFileExport = {
      prefix: 'fas',
      iconName: 'file-export',
      icon: [576, 512, [], "f56e", "M384 121.9c0-6.3-2.5-12.4-7-16.9L279.1 7c-4.5-4.5-10.6-7-17-7H256v128h128zM571 308l-95.7-96.4c-10.1-10.1-27.4-3-27.4 11.3V288h-64v64h64v65.2c0 14.3 17.3 21.4 27.4 11.3L571 332c6.6-6.6 6.6-17.4 0-24zm-379 28v-32c0-8.8 7.2-16 16-16h176V160H248c-13.2 0-24-10.8-24-24V0H24C10.7 0 0 10.7 0 24v464c0 13.3 10.7 24 24 24h336c13.3 0 24-10.7 24-24V352H208c-8.8 0-16-7.2-16-16z"]
    };
    var faFileImage = {
      prefix: 'fas',
      iconName: 'file-image',
      icon: [384, 512, [], "f1c5", "M384 121.941V128H256V0h6.059a24 24 0 0 1 16.97 7.029l97.941 97.941a24.002 24.002 0 0 1 7.03 16.971zM248 160c-13.2 0-24-10.8-24-24V0H24C10.745 0 0 10.745 0 24v464c0 13.255 10.745 24 24 24h336c13.255 0 24-10.745 24-24V160H248zm-135.455 16c26.51 0 48 21.49 48 48s-21.49 48-48 48-48-21.49-48-48 21.491-48 48-48zm208 240h-256l.485-48.485L104.545 328c4.686-4.686 11.799-4.201 16.485.485L160.545 368 264.06 264.485c4.686-4.686 12.284-4.686 16.971 0L320.545 304v112z"]
    };
    var faFileImport = {
      prefix: 'fas',
      iconName: 'file-import',
      icon: [512, 512, [], "f56f", "M16 288c-8.8 0-16 7.2-16 16v32c0 8.8 7.2 16 16 16h112v-64zm489-183L407.1 7c-4.5-4.5-10.6-7-17-7H384v128h128v-6.1c0-6.3-2.5-12.4-7-16.9zm-153 31V0H152c-13.3 0-24 10.7-24 24v264h128v-65.2c0-14.3 17.3-21.4 27.4-11.3L379 308c6.6 6.7 6.6 17.4 0 24l-95.7 96.4c-10.1 10.1-27.4 3-27.4-11.3V352H128v136c0 13.3 10.7 24 24 24h336c13.3 0 24-10.7 24-24V160H376c-13.2 0-24-10.8-24-24z"]
    };
    var faFilter = {
      prefix: 'fas',
      iconName: 'filter',
      icon: [512, 512, [], "f0b0", "M487.976 0H24.028C2.71 0-8.047 25.866 7.058 40.971L192 225.941V432c0 7.831 3.821 15.17 10.237 19.662l80 55.98C298.02 518.69 320 507.493 320 487.98V225.941l184.947-184.97C520.021 25.896 509.338 0 487.976 0z"]
    };
    var faKey = {
      prefix: 'fas',
      iconName: 'key',
      icon: [512, 512, [], "f084", "M512 176.001C512 273.203 433.202 352 336 352c-11.22 0-22.19-1.062-32.827-3.069l-24.012 27.014A23.999 23.999 0 0 1 261.223 384H224v40c0 13.255-10.745 24-24 24h-40v40c0 13.255-10.745 24-24 24H24c-13.255 0-24-10.745-24-24v-78.059c0-6.365 2.529-12.47 7.029-16.971l161.802-161.802C163.108 213.814 160 195.271 160 176 160 78.798 238.797.001 335.999 0 433.488-.001 512 78.511 512 176.001zM336 128c0 26.51 21.49 48 48 48s48-21.49 48-48-21.49-48-48-48-48 21.49-48 48z"]
    };
    var faList = {
      prefix: 'fas',
      iconName: 'list',
      icon: [512, 512, [], "f03a", "M80 368H16a16 16 0 0 0-16 16v64a16 16 0 0 0 16 16h64a16 16 0 0 0 16-16v-64a16 16 0 0 0-16-16zm0-320H16A16 16 0 0 0 0 64v64a16 16 0 0 0 16 16h64a16 16 0 0 0 16-16V64a16 16 0 0 0-16-16zm0 160H16a16 16 0 0 0-16 16v64a16 16 0 0 0 16 16h64a16 16 0 0 0 16-16v-64a16 16 0 0 0-16-16zm416 176H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zm0-320H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16V80a16 16 0 0 0-16-16zm0 160H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16z"]
    };
    var faMousePointer = {
      prefix: 'fas',
      iconName: 'mouse-pointer',
      icon: [320, 512, [], "f245", "M302.189 329.126H196.105l55.831 135.993c3.889 9.428-.555 19.999-9.444 23.999l-49.165 21.427c-9.165 4-19.443-.571-23.332-9.714l-53.053-129.136-86.664 89.138C18.729 472.71 0 463.554 0 447.977V18.299C0 1.899 19.921-6.096 30.277 5.443l284.412 292.542c11.472 11.179 3.007 31.141-12.5 31.141z"]
    };
    var faPalette = {
      prefix: 'fas',
      iconName: 'palette',
      icon: [512, 512, [], "f53f", "M204.3 5C104.9 24.4 24.8 104.3 5.2 203.4c-37 187 131.7 326.4 258.8 306.7 41.2-6.4 61.4-54.6 42.5-91.7-23.1-45.4 9.9-98.4 60.9-98.4h79.7c35.8 0 64.8-29.6 64.9-65.3C511.5 97.1 368.1-26.9 204.3 5zM96 320c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm32-128c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm128-64c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm128 64c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32z"]
    };
    var faPlus = {
      prefix: 'fas',
      iconName: 'plus',
      icon: [448, 512, [], "f067", "M416 208H272V64c0-17.67-14.33-32-32-32h-32c-17.67 0-32 14.33-32 32v144H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h144v144c0 17.67 14.33 32 32 32h32c17.67 0 32-14.33 32-32V304h144c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z"]
    };
    var faProjectDiagram = {
      prefix: 'fas',
      iconName: 'project-diagram',
      icon: [640, 512, [], "f542", "M384 320H256c-17.67 0-32 14.33-32 32v128c0 17.67 14.33 32 32 32h128c17.67 0 32-14.33 32-32V352c0-17.67-14.33-32-32-32zM192 32c0-17.67-14.33-32-32-32H32C14.33 0 0 14.33 0 32v128c0 17.67 14.33 32 32 32h95.72l73.16 128.04C211.98 300.98 232.4 288 256 288h.28L192 175.51V128h224V64H192V32zM608 0H480c-17.67 0-32 14.33-32 32v128c0 17.67 14.33 32 32 32h128c17.67 0 32-14.33 32-32V32c0-17.67-14.33-32-32-32z"]
    };
    var faQuestion = {
      prefix: 'fas',
      iconName: 'question',
      icon: [384, 512, [], "f128", "M202.021 0C122.202 0 70.503 32.703 29.914 91.026c-7.363 10.58-5.093 25.086 5.178 32.874l43.138 32.709c10.373 7.865 25.132 6.026 33.253-4.148 25.049-31.381 43.63-49.449 82.757-49.449 30.764 0 68.816 19.799 68.816 49.631 0 22.552-18.617 34.134-48.993 51.164-35.423 19.86-82.299 44.576-82.299 106.405V320c0 13.255 10.745 24 24 24h72.471c13.255 0 24-10.745 24-24v-5.773c0-42.86 125.268-44.645 125.268-160.627C377.504 66.256 286.902 0 202.021 0zM192 373.459c-38.196 0-69.271 31.075-69.271 69.271 0 38.195 31.075 69.27 69.271 69.27s69.271-31.075 69.271-69.271-31.075-69.27-69.271-69.27z"]
    };
    var faRedoAlt = {
      prefix: 'fas',
      iconName: 'redo-alt',
      icon: [512, 512, [], "f2f9", "M256.455 8c66.269.119 126.437 26.233 170.859 68.685l35.715-35.715C478.149 25.851 504 36.559 504 57.941V192c0 13.255-10.745 24-24 24H345.941c-21.382 0-32.09-25.851-16.971-40.971l41.75-41.75c-30.864-28.899-70.801-44.907-113.23-45.273-92.398-.798-170.283 73.977-169.484 169.442C88.764 348.009 162.184 424 256 424c41.127 0 79.997-14.678 110.629-41.556 4.743-4.161 11.906-3.908 16.368.553l39.662 39.662c4.872 4.872 4.631 12.815-.482 17.433C378.202 479.813 319.926 504 256 504 119.034 504 8.001 392.967 8 256.002 7.999 119.193 119.646 7.755 256.455 8z"]
    };
    var faSearch = {
      prefix: 'fas',
      iconName: 'search',
      icon: [512, 512, [], "f002", "M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"]
    };
    var faStickyNote = {
      prefix: 'fas',
      iconName: 'sticky-note',
      icon: [448, 512, [], "f249", "M312 320h136V56c0-13.3-10.7-24-24-24H24C10.7 32 0 42.7 0 56v400c0 13.3 10.7 24 24 24h264V344c0-13.2 10.8-24 24-24zm129 55l-98 98c-4.5 4.5-10.6 7-17 7h-6V352h128v6.1c0 6.3-2.5 12.4-7 16.9z"]
    };
    var faSyncAlt = {
      prefix: 'fas',
      iconName: 'sync-alt',
      icon: [512, 512, [], "f2f1", "M370.72 133.28C339.458 104.008 298.888 87.962 255.848 88c-77.458.068-144.328 53.178-162.791 126.85-1.344 5.363-6.122 9.15-11.651 9.15H24.103c-7.498 0-13.194-6.807-11.807-14.176C33.933 94.924 134.813 8 256 8c66.448 0 126.791 26.136 171.315 68.685L463.03 40.97C478.149 25.851 504 36.559 504 57.941V192c0 13.255-10.745 24-24 24H345.941c-21.382 0-32.09-25.851-16.971-40.971l41.75-41.749zM32 296h134.059c21.382 0 32.09 25.851 16.971 40.971l-41.75 41.75c31.262 29.273 71.835 45.319 114.876 45.28 77.418-.07 144.315-53.144 162.787-126.849 1.344-5.363 6.122-9.15 11.651-9.15h57.304c7.498 0 13.194 6.807 11.807 14.176C478.067 417.076 377.187 504 256 504c-66.448 0-126.791-26.136-171.315-68.685L48.97 471.03C33.851 486.149 8 475.441 8 454.059V320c0-13.255 10.745-24 24-24z"]
    };
    var faTable = {
      prefix: 'fas',
      iconName: 'table',
      icon: [512, 512, [], "f0ce", "M464 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h416c26.51 0 48-21.49 48-48V80c0-26.51-21.49-48-48-48zM224 416H64v-96h160v96zm0-160H64v-96h160v96zm224 160H288v-96h160v96zm0-160H288v-96h160v96z"]
    };
    var faTimes = {
      prefix: 'fas',
      iconName: 'times',
      icon: [352, 512, [], "f00d", "M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"]
    };
    var faTree = {
      prefix: 'fas',
      iconName: 'tree',
      icon: [384, 512, [], "f1bb", "M378.31 378.49L298.42 288h30.63c9.01 0 16.98-5 20.78-13.06 3.8-8.04 2.55-17.26-3.28-24.05L268.42 160h28.89c9.1 0 17.3-5.35 20.86-13.61 3.52-8.13 1.86-17.59-4.24-24.08L203.66 4.83c-6.03-6.45-17.28-6.45-23.32 0L70.06 122.31c-6.1 6.49-7.75 15.95-4.24 24.08C69.38 154.65 77.59 160 86.69 160h28.89l-78.14 90.91c-5.81 6.78-7.06 15.99-3.27 24.04C37.97 283 45.93 288 54.95 288h30.63L5.69 378.49c-6 6.79-7.36 16.09-3.56 24.26 3.75 8.05 12 13.25 21.01 13.25H160v24.45l-30.29 48.4c-5.32 10.64 2.42 23.16 14.31 23.16h95.96c11.89 0 19.63-12.52 14.31-23.16L224 440.45V416h136.86c9.01 0 17.26-5.2 21.01-13.25 3.8-8.17 2.44-17.47-3.56-24.26z"]
    };
    var faUndoAlt = {
      prefix: 'fas',
      iconName: 'undo-alt',
      icon: [512, 512, [], "f2ea", "M255.545 8c-66.269.119-126.438 26.233-170.86 68.685L48.971 40.971C33.851 25.851 8 36.559 8 57.941V192c0 13.255 10.745 24 24 24h134.059c21.382 0 32.09-25.851 16.971-40.971l-41.75-41.75c30.864-28.899 70.801-44.907 113.23-45.273 92.398-.798 170.283 73.977 169.484 169.442C423.236 348.009 349.816 424 256 424c-41.127 0-79.997-14.678-110.63-41.556-4.743-4.161-11.906-3.908-16.368.553L89.34 422.659c-4.872 4.872-4.631 12.815.482 17.433C133.798 479.813 192.074 504 256 504c136.966 0 247.999-111.033 248-247.998C504.001 119.193 392.354 7.755 255.545 8z"]
    };

    // Material Design Icons v5.9.55
    var mdiAtom = "M12,11A1,1 0 0,1 13,12A1,1 0 0,1 12,13A1,1 0 0,1 11,12A1,1 0 0,1 12,11M4.22,4.22C5.65,2.79 8.75,3.43 12,5.56C15.25,3.43 18.35,2.79 19.78,4.22C21.21,5.65 20.57,8.75 18.44,12C20.57,15.25 21.21,18.35 19.78,19.78C18.35,21.21 15.25,20.57 12,18.44C8.75,20.57 5.65,21.21 4.22,19.78C2.79,18.35 3.43,15.25 5.56,12C3.43,8.75 2.79,5.65 4.22,4.22M15.54,8.46C16.15,9.08 16.71,9.71 17.23,10.34C18.61,8.21 19.11,6.38 18.36,5.64C17.62,4.89 15.79,5.39 13.66,6.77C14.29,7.29 14.92,7.85 15.54,8.46M8.46,15.54C7.85,14.92 7.29,14.29 6.77,13.66C5.39,15.79 4.89,17.62 5.64,18.36C6.38,19.11 8.21,18.61 10.34,17.23C9.71,16.71 9.08,16.15 8.46,15.54M5.64,5.64C4.89,6.38 5.39,8.21 6.77,10.34C7.29,9.71 7.85,9.08 8.46,8.46C9.08,7.85 9.71,7.29 10.34,6.77C8.21,5.39 6.38,4.89 5.64,5.64M9.88,14.12C10.58,14.82 11.3,15.46 12,16.03C12.7,15.46 13.42,14.82 14.12,14.12C14.82,13.42 15.46,12.7 16.03,12C15.46,11.3 14.82,10.58 14.12,9.88C13.42,9.18 12.7,8.54 12,7.97C11.3,8.54 10.58,9.18 9.88,9.88C9.18,10.58 8.54,11.3 7.97,12C8.54,12.7 9.18,13.42 9.88,14.12M18.36,18.36C19.11,17.62 18.61,15.79 17.23,13.66C16.71,14.29 16.15,14.92 15.54,15.54C14.92,16.15 14.29,16.71 13.66,17.23C15.79,18.61 17.62,19.11 18.36,18.36Z";
    var mdiChartBubble = "M7.2,11.2C8.97,11.2 10.4,12.63 10.4,14.4C10.4,16.17 8.97,17.6 7.2,17.6C5.43,17.6 4,16.17 4,14.4C4,12.63 5.43,11.2 7.2,11.2M14.8,16A2,2 0 0,1 16.8,18A2,2 0 0,1 14.8,20A2,2 0 0,1 12.8,18A2,2 0 0,1 14.8,16M15.2,4A4.8,4.8 0 0,1 20,8.8C20,11.45 17.85,13.6 15.2,13.6A4.8,4.8 0 0,1 10.4,8.8C10.4,6.15 12.55,4 15.2,4Z";
    var mdiCodeBrackets = "M15,4V6H18V18H15V20H20V4M4,4V20H9V18H6V6H9V4H4Z";
    var mdiCodeJson = "M5,3H7V5H5V10A2,2 0 0,1 3,12A2,2 0 0,1 5,14V19H7V21H5C3.93,20.73 3,20.1 3,19V15A2,2 0 0,0 1,13H0V11H1A2,2 0 0,0 3,9V5A2,2 0 0,1 5,3M19,3A2,2 0 0,1 21,5V9A2,2 0 0,0 23,11H24V13H23A2,2 0 0,0 21,15V19A2,2 0 0,1 19,21H17V19H19V14A2,2 0 0,1 21,12A2,2 0 0,1 19,10V5H17V3H19M12,15A1,1 0 0,1 13,16A1,1 0 0,1 12,17A1,1 0 0,1 11,16A1,1 0 0,1 12,15M8,15A1,1 0 0,1 9,16A1,1 0 0,1 8,17A1,1 0 0,1 7,16A1,1 0 0,1 8,15M16,15A1,1 0 0,1 17,16A1,1 0 0,1 16,17A1,1 0 0,1 15,16A1,1 0 0,1 16,15Z";
    var mdiDatabase = "M12,3C7.58,3 4,4.79 4,7C4,9.21 7.58,11 12,11C16.42,11 20,9.21 20,7C20,4.79 16.42,3 12,3M4,9V12C4,14.21 7.58,16 12,16C16.42,16 20,14.21 20,12V9C20,11.21 16.42,13 12,13C7.58,13 4,11.21 4,9M4,14V17C4,19.21 7.58,21 12,21C16.42,21 20,19.21 20,17V14C20,16.21 16.42,18 12,18C7.58,18 4,16.21 4,14Z";
    var mdiDatabaseExport = "M12,3C7.58,3 4,4.79 4,7C4,9.21 7.58,11 12,11C12.5,11 13,10.97 13.5,10.92V9.5H16.39L15.39,8.5L18.9,5C17.5,3.8 14.94,3 12,3M18.92,7.08L17.5,8.5L20,11H15V13H20L17.5,15.5L18.92,16.92L23.84,12M4,9V12C4,14.21 7.58,16 12,16C13.17,16 14.26,15.85 15.25,15.63L16.38,14.5H13.5V12.92C13,12.97 12.5,13 12,13C7.58,13 4,11.21 4,9M4,14V17C4,19.21 7.58,21 12,21C14.94,21 17.5,20.2 18.9,19L17,17.1C15.61,17.66 13.9,18 12,18C7.58,18 4,16.21 4,14Z";
    var mdiDatabaseImport = "M12,3C8.59,3 5.69,4.07 4.54,5.57L9.79,10.82C10.5,10.93 11.22,11 12,11C16.42,11 20,9.21 20,7C20,4.79 16.42,3 12,3M3.92,7.08L2.5,8.5L5,11H0V13H5L2.5,15.5L3.92,16.92L8.84,12M20,9C20,11.21 16.42,13 12,13C11.34,13 10.7,12.95 10.09,12.87L7.62,15.34C8.88,15.75 10.38,16 12,16C16.42,16 20,14.21 20,12M20,14C20,16.21 16.42,18 12,18C9.72,18 7.67,17.5 6.21,16.75L4.53,18.43C5.68,19.93 8.59,21 12,21C16.42,21 20,19.21 20,17";
    var mdiDotsVertical = "M12,16A2,2 0 0,1 14,18A2,2 0 0,1 12,20A2,2 0 0,1 10,18A2,2 0 0,1 12,16M12,10A2,2 0 0,1 14,12A2,2 0 0,1 12,14A2,2 0 0,1 10,12A2,2 0 0,1 12,10M12,4A2,2 0 0,1 14,6A2,2 0 0,1 12,8A2,2 0 0,1 10,6A2,2 0 0,1 12,4Z";
    var mdiFormatLetterCase = "M20.06,18C20,17.83 19.91,17.54 19.86,17.11C19.19,17.81 18.38,18.16 17.45,18.16C16.62,18.16 15.93,17.92 15.4,17.45C14.87,17 14.6,16.39 14.6,15.66C14.6,14.78 14.93,14.1 15.6,13.61C16.27,13.12 17.21,12.88 18.43,12.88H19.83V12.24C19.83,11.75 19.68,11.36 19.38,11.07C19.08,10.78 18.63,10.64 18.05,10.64C17.53,10.64 17.1,10.76 16.75,11C16.4,11.25 16.23,11.54 16.23,11.89H14.77C14.77,11.46 14.92,11.05 15.22,10.65C15.5,10.25 15.93,9.94 16.44,9.71C16.95,9.5 17.5,9.36 18.13,9.36C19.11,9.36 19.87,9.6 20.42,10.09C20.97,10.58 21.26,11.25 21.28,12.11V16C21.28,16.8 21.38,17.42 21.58,17.88V18H20.06M17.66,16.88C18.11,16.88 18.54,16.77 18.95,16.56C19.35,16.35 19.65,16.07 19.83,15.73V14.16H18.7C16.93,14.16 16.04,14.63 16.04,15.57C16.04,16 16.19,16.3 16.5,16.53C16.8,16.76 17.18,16.88 17.66,16.88M5.46,13.71H9.53L7.5,8.29L5.46,13.71M6.64,6H8.36L13.07,18H11.14L10.17,15.43H4.82L3.86,18H1.93L6.64,6Z";
    var mdiPalette = "M17.5,12A1.5,1.5 0 0,1 16,10.5A1.5,1.5 0 0,1 17.5,9A1.5,1.5 0 0,1 19,10.5A1.5,1.5 0 0,1 17.5,12M14.5,8A1.5,1.5 0 0,1 13,6.5A1.5,1.5 0 0,1 14.5,5A1.5,1.5 0 0,1 16,6.5A1.5,1.5 0 0,1 14.5,8M9.5,8A1.5,1.5 0 0,1 8,6.5A1.5,1.5 0 0,1 9.5,5A1.5,1.5 0 0,1 11,6.5A1.5,1.5 0 0,1 9.5,8M6.5,12A1.5,1.5 0 0,1 5,10.5A1.5,1.5 0 0,1 6.5,9A1.5,1.5 0 0,1 8,10.5A1.5,1.5 0 0,1 6.5,12M12,3A9,9 0 0,0 3,12A9,9 0 0,0 12,21A1.5,1.5 0 0,0 13.5,19.5C13.5,19.11 13.35,18.76 13.11,18.5C12.88,18.23 12.73,17.88 12.73,17.5A1.5,1.5 0 0,1 14.23,16H16A5,5 0 0,0 21,11C21,6.58 16.97,3 12,3Z";
    var mdiTableCog = "M3 3H17C18.11 3 19 3.9 19 5V12.08C17.45 11.82 15.92 12.18 14.68 13H11V17H12.08C11.97 17.68 11.97 18.35 12.08 19H3C1.9 19 1 18.11 1 17V5C1 3.9 1.9 3 3 3M3 7V11H9V7H3M11 7V11H17V7H11M3 13V17H9V13H3M22.78 19.32L21.71 18.5C21.73 18.33 21.75 18.17 21.75 18S21.74 17.67 21.71 17.5L22.77 16.68C22.86 16.6 22.89 16.47 22.83 16.36L21.83 14.63C21.77 14.5 21.64 14.5 21.5 14.5L20.28 15C20 14.82 19.74 14.65 19.43 14.53L19.24 13.21C19.23 13.09 19.12 13 19 13H17C16.88 13 16.77 13.09 16.75 13.21L16.56 14.53C16.26 14.66 15.97 14.82 15.71 15L14.47 14.5C14.36 14.5 14.23 14.5 14.16 14.63L13.16 16.36C13.1 16.47 13.12 16.6 13.22 16.68L14.28 17.5C14.26 17.67 14.25 17.83 14.25 18S14.26 18.33 14.28 18.5L13.22 19.32C13.13 19.4 13.1 19.53 13.16 19.64L14.16 21.37C14.22 21.5 14.35 21.5 14.47 21.5L15.71 21C15.97 21.18 16.25 21.35 16.56 21.47L16.75 22.79C16.77 22.91 16.87 23 17 23H19C19.12 23 19.23 22.91 19.25 22.79L19.44 21.47C19.74 21.34 20 21.18 20.28 21L21.5 21.5C21.64 21.5 21.77 21.5 21.84 21.37L22.84 19.64C22.9 19.53 22.87 19.4 22.78 19.32M18 19.5C17.17 19.5 16.5 18.83 16.5 18S17.18 16.5 18 16.5 19.5 17.17 19.5 18 18.84 19.5 18 19.5Z";
    var mdiVectorLine = "M15,3V7.59L7.59,15H3V21H9V16.42L16.42,9H21V3M17,5H19V7H17M5,17H7V19H5";
    var mdiXml = "M12.89,3L14.85,3.4L11.11,21L9.15,20.6L12.89,3M19.59,12L16,8.41V5.58L22.42,12L16,18.41V15.58L19.59,12M1.58,12L8,5.58V8.41L4.41,12L8,15.58V18.41L1.58,12Z";

    const createMDI = (name, icon) => ({
        prefix: 'mdi',
        iconName: name,
        icon: [24, 24, , , icon],
    });
    const icons = [
        faKey,
        faTable,
        faStickyNote,
        faPlus,
        faTimes,
        faChevronRight,
        faCheck,
        faList,
        faRedoAlt,
        faUndoAlt,
        faSearch,
        faFilter,
        faQuestion,
        faProjectDiagram,
        faFileImage,
        faFileExport,
        faEye,
        faEyeSlash,
        faFileImport,
        faFileCode,
        faCog,
        faMousePointer,
        faCode,
        faSyncAlt,
        faTree,
        faPalette,
        faColumns,
        createMDI('code-json', mdiCodeJson),
        createMDI('database', mdiDatabase),
        createMDI('database-import', mdiDatabaseImport),
        createMDI('database-export', mdiDatabaseExport),
        createMDI('palette', mdiPalette),
        createMDI('format-letter-case', mdiFormatLetterCase),
        createMDI('table-cog', mdiTableCog),
        createMDI('code-brackets', mdiCodeBrackets),
        createMDI('xml', mdiXml),
        createMDI('dots-vertical', mdiDotsVertical),
        createMDI('vector-line', mdiVectorLine),
        createMDI('atom', mdiAtom),
    ];
    const iconMap = observable$1({});
    const setIconMap = (newIcons) => newIcons.reduce((acc, cur) => {
        acc[`${cur.prefix}-${cur.iconName}`] = cur;
        return acc;
    }, iconMap);
    setIconMap(icons);
    const getIcon = (prefix, iconName) => iconMap[`${prefix}-${iconName}`];
    const addIcon = (...newIcons) => {
        icons.push(...newIcons);
        setIconMap(newIcons);
    };
    const base64Icons = {
        ZeroOneN: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTcgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6Q0RFRDI1RjI0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6Q0RFRDI1RjM0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpCQTE2QzQzRDQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpCQTE2QzQzRTQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PnTT5ywAAAJMSURBVHja7Fc9T2JBFB3MZq1IqLSgsRM6G6TcAmK7VNoRK4yBxE6XP/CsNxBohc6G5w+AoCU0aEWpBfAD4AeM55AZMjvvg2dClsRwkxOeb+7ce+6dmTPPmJRSbNP2xJZtR2DrBH6k0+ndEkSxBHAD9AGpMAJc4Lfh1zDGn4GLgHglNb8kqANhSKVSTiaTkY7jyMFgILWNx2PZ7XZluVyW8BkBJWA1PhwO+f7ZinUO9DmH8xl3XfIGnefzuQwzBsvlcjKIAH4PWAh9zCLq9Xp48mq16knGwASTmkaShULBQ0B1ZlSr1TyFtFqtwOS3xWLxH2eyZctUUOKVFTGRtslk4iHAODZZ/k2yLDKIwLsZjJ2gM3Bo+V0wieu6vsvCCu0ucS+RPHC1vId8kp+YrWRwvHsIWaosO7Nun3DDqn1yD+zr+RQiz3WYz+dXz6iCP82g84lKB4jxF0Rv0G7P+Gw2E6ha9Ho9/eoPsRJAucbUzl53Wi79NmwU25QSJuLx+ObugkqlInD+l8+oTsAny1aHxDlKJpOBgzhBot1ui8Vi4R3cwCY8jbIJeap4JOHvAmd6flDQj+l06ncMD/yktdPp+AoW59nEeBqUnjjAzyACd7YQUcnUxL7CyJZWk7QWIs6xdcLQg6cvSzETEl+Q4iyXkAWZBHU3/stlpLvKpaWkm0sb5Tq+19exqfvWdbyU1gjX8SGLIlnKNJ9jPGYRP0gugQLwS717Az6AB+DJ+CC5Vs8vSkEffeIdK79mVALf95swtvvXbEdg2wQ+BRgAvLABcxKvek4AAAAASUVORK5CYII=',
        ZeroOne: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTcgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QkExNkM0M0I0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QkExNkM0M0M0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpCQTE2QzQzOTQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpCQTE2QzQzQTQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PomEhhsAAAKSSURBVHja7FexbhpBED0ipFRI7ixBQwlV0nCUWKJIydEkFSRpHCGQ0iXgBqfBbQrAShXzA4BLJJCdEip3UDoSUFvwAZv30B5a1ncHBiSk2CONdrU3O/N2dt6w+IQQxiHllXFgeQFwcAD+aDT6zDPwBNsjaAoaVtbuoNcee46hOSi5/hd6pRv41vUBXJFJJ4FA4FMymTRCodDy22g0Mnq93gOml8Ph8Mxhb71QKOQYYzqdGq1W6zPsVkHwo5tGIpFvsVhMNJtN4Saz2UwUi0UB299QU9u/tBsMBrS51WN4BrcsS4zHY7GJEKQOYmsAMIzz5GrwyWQiSqWSwDXQkchms6LRaCwyoIPYB4Ar3NdyM+cEhPXv0LC0OYH+ZJZUEASG9fdbA2AAnlI9uQwedwF7waC29Pt92t5sCoCN6FzSZCmsdluq1aoxn8+LqN6+E0uwXoKPKNiQ4j7TNA0w5gRLZRdWraz7QZOyTkU6saXb7XL4taZH3IGSKRs4asVA5s5Vg2AwaOTz+QSmCZ2GniLTuI6uFpyLbcRfq9UeHYcZwL0v5mw8SFsYqb73yMBb9Tel3W4zA4s5gC1G2Yget2Lc8Q99MZ1Ol20AmLMOTjE9c7nT1xgstW4qlQrrhn7LNgACgp8/mN56dkKk84hVb1OLo+T+qUv66wi4QlnSeNc+cAG0y81IvyDfZaf7CE1Av5JubE6qSLDxXQEc05ib9HbLvp/JZARPTc6rQjDMyL5+Cz7wKkDDjapZD74zAOngHbRN57wGJyFAmfa6w/71ndCruyBoB0MHlf4FxZUDJd+o7wF8Z7Vfy/dAx8HFJWies1ng+CABqqe8oMIOL6KHDV5ElPt9APj/HqW+l/+Gzx7APwEGACfjkeXK58xsAAAAAElFTkSuQmCC',
        ZeroN: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTcgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NDc5MkNFMEM0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NDc5MkNFMEQ0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo0NzkyQ0UwQTQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0NzkyQ0UwQjQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PpR0ImIAAALlSURBVHja7Fe/jxJBGF0MyVUk2HgJFJ6NQqUNWEoCkfKWxusozxBI7Eiw8ardKy/hxyVWQqcF8AdA9Eqg8DqwuwJI7Aj8AeN7OEuGhd09tCBRvuTLzA4z37z53rxvF58QQtunPdD2bAcA/mg0+p9nYMf5Qfhz5fnmbwH47iND0PQaTS4QCOiRSGQ1PhgMZmja8OvhcNi/z4aIdc5Ycs1HjQCcHJu9hH/KZrOi0+kIu83nc9FsNkUymRSYZ3jEegqv6bousLHI5/NcU3RbkIa3W62W8DICKZVKDFhziFWMxWKiXq+v1ozHY8Exv0OajpmmSqVyitOtxrvdrjYajZZ90KGlUiktFAot+4ZhcDiHtTOc8L1KHWLoAKiFw+FVrOl0+rvjgNjA5msnJA3MCPxC+hX8DhuvzZN0kDqDfTt1nCPT/w1+tm3zIFPDidYC8oZxc8vcI6ZdBUHKMPadY1YMy0gBY6uxfHhIMBEKAw+BvIUMLB+q1aqG/iXSWnKg6wjND9DzmHQsFgttMploqlpIm2maWr/fv8bj5zUZMrV2KWYymaXTyDMCPgGAOxdpXRQKhQ9I7cZv2FSzDrPVvG44TiLc5CWp0Mnrn5gfxWQDFG8r02nddpwwiAzMXOrLC6d3CtNPWhxLMSjYKKcYe0XZ0OLxOOVHOX1xA6Bybj8MKWg0GjdOFNjTeUL5WNbr9UjDV3jcIf3nVIllrHK8V2xVYxypphr8kbXeidO2ql+WWwnijQrU0rq6mdT4W/gta4ldiuVy2ZJi0Q1AmoHVxTyBDL50/m7XOkETvIxxTL1zHpSwBoJlWBa2mtvNNpky+wmcjJvIk6Vtcc5Y9QjeHovxveRlbiun9tLKVFul1S2W+kJiywx4fg9AXmm+UDD5lIqg3HizwftSYgBHmV1izhXGfnrEeobmHeLkuB7rIj4n+WyTGjwh2xP4rXR+kMx2/BBKyLWzXQD8mx+lvsNfswOAfQP4JcAAK/At0HQvwB8AAAAASUVORK5CYII=',
        OneOnly: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTcgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QUJCNTBCRDA0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QkExNkM0MzQ0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpBQkI1MEJDRTQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpBQkI1MEJDRjQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pur5d4QAAAE1SURBVHjaYvz//z/DQAImhgEGow4YcAewaGpqjvAQoJI5CUAsD2VPB+JXULY4EGcCMSivPwTiBRgOuH79OkU2A6MwITAwcL6UlBSYP3XqVHGgmVlQufqcnJxMUFnz7NkzhvXr1zMA5VAdAZKkBGtoaBw4derUfxgA8v8jycHFQWpAatH1j2bDUQeACqIGaDahGgClfmLlWIDZpJ7SKhmWBUEgOzsbRDVgUwOUswcy7ZHFGf8PcIOABVhwUGwIsCBiQCqIUOSgIQIviNABI7BwaKDQfodFixbZm5qawuIYRDVC5ephJe3p06cZ4uLiDgKZB0ZLwtGCaNg1SBYAs5c9MJExIDVI4GxgtgQ1SBiePn3KgK1BAsqG1GoRKSA54CVaiwgEHtDSAUM3DTCO9g1HvAMAAgwAvvwYPnW1JuQAAAAASUVORK5CYII=',
        OneN: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTcgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QkExNkM0Mzc0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QkExNkM0Mzg0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpCQTE2QzQzNTQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpCQTE2QzQzNjQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pt+BFx8AAAIISURBVHja7Fc9TwJBEF0MLYkdBgot4QdwLSaQSAmNdkCrR61CI9Ud1oCUIB0NYElBtJU/QIkmQKIVgcpqfXPekQNBYu7WM4FJJvs1x87Ovnk7uDjnzEnZYw7LzgHHHXAFAoHtjoDbpt9JQw/1fgX6vsH+CDohdVnlgWAwmE4kElWfz6eNy+Vypd/vX6yx9aK58fv959PplM1mswNGDlhRYOip1+txQzDma+wuoYNSqaTZUYvxnXAHMJag1WQyyYfDITdLJBLhbpEAQ8gVj8eThTBc03weoWeqqrLRaFQREgHoKfQRG3Pc9cKpW60WD4VCZKPS90IiAJA1FEVhkiTN58bjMaNIwNl7yhQA9VlLQ4Qpj9a2J1GWZZbJZBbmkBkMoHtFt6pPxbBvTGNCHZWWNqX7xalXriHkdNfrqZg7XBC4KTxWhSJgENGy0Onb7faPj1He4v7H9Xo9DGRrg1QqpaWY2SEAj+Vyua+0W6ZpQWn4YjCeWYrFIq0NiBWN70U54CWajcfj3LxGQmxIrEjsSCwplIrRP6N1cMI3Qmo2mxohCa0HQDYNNCfASAG8z7rd7nwtGo3+TUECJz6gWfB/DAT1QCAlViSgYq5gBxXXQDZhQrqpIFnlSAdNBwx4BWwUsPk15m7tqgnTepVjOPC2wX5fr4hse4xqv7Sf/J+yfPffcOsd+BRgAOvawAWTC+PMAAAAAElFTkSuQmCC',
        One: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTcgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QUJCNTBCQ0M0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QUJCNTBCQ0Q0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpBQkI1MEJDQTQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpBQkI1MEJDQjQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PnOhfCQAAADcSURBVHjaYvz//z/DQAImhgEGow4YcAewaGpqjvAQoJI5CUAsD2VPB+JXxGpkpLQcAEZhQmBg4HwpKSkwf+rUqdOvX7+eRbQBIAdQgjU0NA6cOnXqPwwA+f9J0T+aDUcdACqIGkBpkZqGAs2sJzobTpky5T+lWRGYDRmkpaXBbKB5JOll/D/ADQIWYMFBsSGgEEAqiEgLAWDB0UCh/Q6LFi2yNzU1hcU/iGocLQlHC6IR1SBZsH79entgQmRAapCQlA2p1SJSQHLAS3o3yRYM2TTAONo3HPEOAAgwAJh583IRUllDAAAAAElFTkSuQmCC',
        N: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTcgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NDc5MkNFMDg0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NDc5MkNFMDk0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDozNDQwRjc3NTQ4M0MxMUU3QkRBMDg1MDlCNjg0QjgzMCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDozNDQwRjc3NjQ4M0MxMUU3QkRBMDg1MDlCNjg0QjgzMCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PkbQDKwAAAGjSURBVHja7Jcxb4JQEMefLl272cjSUbYu0g+gSVemdpPZwKzRRSf4AGg70k8AfACTdqx+ibYJLp2MfoDr/wg0vJp2Al6TeskFeQ+4e/fufvdsEJFQKU2hWE4OKHeg0el0TlugQi6h5+kW1MkBXddbuMw0TRvu93txOBwumjUaH+Hy4jjOcLVaCcuyeHgmOAJVKpLcgAaDwYCSJKGi9Hq9yo273W6XwjCUDCP8NJlMCPP3VRm+hT6xETZWlCiKiJ3CvJfmX8mGW7wqDu16vZYMb7db4m3A/CP0On+HQTRHMpRVCiaS7Mq2bWlwuVyKxWLxjp/BEQkxQWWVYr/fF9/JipALrP5nFJPiA0EagbI+BsAI0zSlMV59HMe/NqN5mYg1DMPyPE+02+2vwc1mI6bTKTvzgNsP6Y0KSnAMfctySxLf97kKXqGj/PmqOJCWI7aDsHrJCaZhVo4BU7JqEt5Bn13XPQIS05GBVEcvOGPqsTE0IQnHtThQcOQGGnP4mYpZL/Bqc6CYpFkvGOcoVsEfPg3tVB7Jdn/nWH76b/jvHfgUYADeZNmzPgOYQQAAAABJRU5ErkJggg==',
    };
    const getBase64Icon = (relationshipType) => base64Icons[relationshipType];

    const SIZE = 24;
    const SIZE_REM = 1.5;
    defineComponent('vuerd-icon', {
        observedProps: [
            {
                name: 'prefix',
                default: 'fas',
            },
            {
                name: 'name',
                default: '',
            },
            {
                name: 'size',
                type: Number,
                default: SIZE,
            },
            {
                name: 'color',
                default: null,
            },
        ],
        shadow: false,
        styleMap: {
            display: 'inline-flex',
            height: '100%',
            alignItems: 'center',
        },
        render: (props, ctx) => () => {
            const icon = getIcon(props.prefix, props.name);
            if (!icon)
                return svg ``;
            const [width, height, , , d] = icon.icon;
            const rem = SIZE_REM * (props.size / SIZE);
            return svg `
      <svg
        class="vuerd-icon"
        style=${styleMap({
            width: `${rem}rem`,
            height: `${rem}rem`,
        })} 
        viewBox="0 0 ${width} ${height}"
      >
        ${props.color
            ? svg `<path d=${d} fill=${props.color}></path>`
            : svg `<path d=${d}></path>`}
      </svg>
    `;
        },
    });

    /**
     * @license
     * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    // IE11 doesn't support classList on SVG elements, so we emulate it with a Set
    class ClassList$1 {
        constructor(element) {
            this.classes = new Set();
            this.changed = false;
            this.element = element;
            const classList = (element.getAttribute('class') || '').split(/\s+/);
            for (const cls of classList) {
                this.classes.add(cls);
            }
        }
        add(cls) {
            this.classes.add(cls);
            this.changed = true;
        }
        remove(cls) {
            this.classes.delete(cls);
            this.changed = true;
        }
        commit() {
            if (this.changed) {
                let classString = '';
                this.classes.forEach((cls) => classString += cls + ' ');
                this.element.setAttribute('class', classString);
            }
        }
    }
    /**
     * Stores the ClassInfo object applied to a given AttributePart.
     * Used to unset existing values when a new ClassInfo object is applied.
     */
    const previousClassesCache = new WeakMap();
    /**
     * A directive that applies CSS classes. This must be used in the `class`
     * attribute and must be the only part used in the attribute. It takes each
     * property in the `classInfo` argument and adds the property name to the
     * element's `class` if the property value is truthy; if the property value is
     * falsey, the property name is removed from the element's `class`. For example
     * `{foo: bar}` applies the class `foo` if the value of `bar` is truthy.
     * @param classInfo {ClassInfo}
     */
    const classMap = directive((classInfo) => (part) => {
        if (!(part instanceof AttributePart) || (part instanceof PropertyPart) ||
            part.committer.name !== 'class' || part.committer.parts.length > 1) {
            throw new Error('The `classMap` directive must be used in the `class` attribute ' +
                'and must be the only part in the attribute.');
        }
        const { committer } = part;
        const { element } = committer;
        let previousClasses = previousClassesCache.get(part);
        if (previousClasses === undefined) {
            // Write static classes once
            // Use setAttribute() because className isn't a string on SVG elements
            element.setAttribute('class', committer.strings.join(' '));
            previousClassesCache.set(part, previousClasses = new Set());
        }
        const classList = (element.classList || new ClassList$1(element));
        // Remove old classes that no longer apply
        // We use forEach() instead of for-of so that re don't require down-level
        // iteration.
        previousClasses.forEach((name) => {
            if (!(name in classInfo)) {
                classList.remove(name);
                previousClasses.delete(name);
            }
        });
        // Add or remove classes based on their classMap value
        for (const name in classInfo) {
            const value = classInfo[name];
            if (value != previousClasses.has(name)) {
                // We explicitly want a loose truthy check of `value` because it seems
                // more convenient that '' and 0 are skipped.
                if (value) {
                    classList.add(name);
                    previousClasses.add(name);
                }
                else {
                    classList.remove(name);
                    previousClasses.delete(name);
                }
            }
        }
        if (typeof classList.commit === 'function') {
            classList.commit();
        }
    });

    function useContext$1(ctx) {
        const ref = { value: null };
        beforeMount(() => (ref.value = getVuerdContext(ctx)));
        return ref;
    }

    const css = (arr, ...values) => arr
        .reduce((acc, cur, i) => {
        var _a;
        i < values.length ? acc.push(cur, (_a = values[i]) !== null && _a !== void 0 ? _a : '') : acc.push(cur);
        return acc;
    }, [])
        .join('');

    const SashStyle = css `
  .vuerd-sash {
    position: absolute;
  }
  .vuerd-sash.vertical {
    width: ${SIZE_SASH}px;
    height: 100%;
    cursor: ew-resize;
  }
  .vuerd-sash.horizontal {
    width: 100%;
    height: ${SIZE_SASH}px;
    cursor: ns-resize;
  }
  .vuerd-sash.edge {
    width: ${SIZE_SASH}px;
    height: ${SIZE_SASH}px;
  }
`;

    const classKeys = ['vertical', 'horizontal', 'edge'];
    const Sash = (props, ctx) => {
        const contextRef = useContext$1(ctx);
        const centerTop = () => props.top === 0 && !props.horizontal && !props.edge
            ? props.top
            : props.top - SIZE_SASH / 2;
        const centerLeft = () => props.left === 0 && !props.vertical && !props.edge
            ? props.left
            : props.left - SIZE_SASH / 2;
        const getClassMap = () => Object.assign({ 'vuerd-sash': true }, classKeys.reduce((map, key) => {
            map[key] = props[key];
            return map;
        }, {}));
        const getStyleMap = () => ({
            top: `${centerTop()}px`,
            left: `${centerLeft()}px`,
            cursor: props.edge ? props.cursor : '',
        });
        const onMousedown = () => {
            const { drag$ } = contextRef.value.globalEvent;
            drag$.subscribe(move => {
                move.event.type === 'mousemove' && move.event.preventDefault();
                ctx.dispatchEvent(new CustomEvent('global-move', {
                    detail: {
                        movementX: move.movementX,
                        movementY: move.movementY,
                        x: move.x,
                        y: move.y,
                    },
                }));
            });
        };
        return () => html `
      <div
        class=${classMap(getClassMap())}
        style=${styleMap(getStyleMap())}
        @mousedown=${onMousedown}
      ></div>
    `;
    };
    defineComponent('vuerd-sash', {
        observedProps: [
            {
                name: 'vertical',
                type: Boolean,
                default: false,
            },
            {
                name: 'horizontal',
                type: Boolean,
                default: false,
            },
            {
                name: 'edge',
                type: Boolean,
                default: false,
            },
            {
                name: 'cursor',
                default: 'default',
            },
            {
                name: 'top',
                type: Number,
                default: 0,
            },
            {
                name: 'left',
                type: Number,
                default: 0,
            },
        ],
        style: SashStyle,
        render: Sash,
    });

    var top = 'top';
    var bottom = 'bottom';
    var right = 'right';
    var left = 'left';
    var auto = 'auto';
    var basePlacements = [top, bottom, right, left];
    var start$1 = 'start';
    var end = 'end';
    var clippingParents = 'clippingParents';
    var viewport = 'viewport';
    var popper = 'popper';
    var reference = 'reference';
    var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
      return acc.concat([placement + "-" + start$1, placement + "-" + end]);
    }, []);
    var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
      return acc.concat([placement, placement + "-" + start$1, placement + "-" + end]);
    }, []); // modifiers that need to read the DOM

    var beforeRead = 'beforeRead';
    var read = 'read';
    var afterRead = 'afterRead'; // pure-logic modifiers

    var beforeMain = 'beforeMain';
    var main = 'main';
    var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

    var beforeWrite = 'beforeWrite';
    var write = 'write';
    var afterWrite = 'afterWrite';
    var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

    function getNodeName(element) {
      return element ? (element.nodeName || '').toLowerCase() : null;
    }

    function getWindow(node) {
      if (node == null) {
        return window;
      }

      if (node.toString() !== '[object Window]') {
        var ownerDocument = node.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView || window : window;
      }

      return node;
    }

    function isElement$1(node) {
      var OwnElement = getWindow(node).Element;
      return node instanceof OwnElement || node instanceof Element;
    }

    function isHTMLElement(node) {
      var OwnElement = getWindow(node).HTMLElement;
      return node instanceof OwnElement || node instanceof HTMLElement;
    }

    function isShadowRoot(node) {
      // IE 11 has no ShadowRoot
      if (typeof ShadowRoot === 'undefined') {
        return false;
      }

      var OwnElement = getWindow(node).ShadowRoot;
      return node instanceof OwnElement || node instanceof ShadowRoot;
    }

    // and applies them to the HTMLElements such as popper and arrow

    function applyStyles(_ref) {
      var state = _ref.state;
      Object.keys(state.elements).forEach(function (name) {
        var style = state.styles[name] || {};
        var attributes = state.attributes[name] || {};
        var element = state.elements[name]; // arrow is optional + virtual elements

        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        } // Flow doesn't support to extend this property, but it's the most
        // effective way to apply styles to an HTMLElement
        // $FlowFixMe[cannot-write]


        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function (name) {
          var value = attributes[name];

          if (value === false) {
            element.removeAttribute(name);
          } else {
            element.setAttribute(name, value === true ? '' : value);
          }
        });
      });
    }

    function effect$2(_ref2) {
      var state = _ref2.state;
      var initialStyles = {
        popper: {
          position: state.options.strategy,
          left: '0',
          top: '0',
          margin: '0'
        },
        arrow: {
          position: 'absolute'
        },
        reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);
      state.styles = initialStyles;

      if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
      }

      return function () {
        Object.keys(state.elements).forEach(function (name) {
          var element = state.elements[name];
          var attributes = state.attributes[name] || {};
          var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

          var style = styleProperties.reduce(function (style, property) {
            style[property] = '';
            return style;
          }, {}); // arrow is optional + virtual elements

          if (!isHTMLElement(element) || !getNodeName(element)) {
            return;
          }

          Object.assign(element.style, style);
          Object.keys(attributes).forEach(function (attribute) {
            element.removeAttribute(attribute);
          });
        });
      };
    } // eslint-disable-next-line import/no-unused-modules


    var applyStyles$1 = {
      name: 'applyStyles',
      enabled: true,
      phase: 'write',
      fn: applyStyles,
      effect: effect$2,
      requires: ['computeStyles']
    };

    function getBasePlacement$1(placement) {
      return placement.split('-')[0];
    }

    var round$2 = Math.round;
    function getBoundingClientRect(element, includeScale) {
      if (includeScale === void 0) {
        includeScale = false;
      }

      var rect = element.getBoundingClientRect();
      var scaleX = 1;
      var scaleY = 1;

      if (isHTMLElement(element) && includeScale) {
        // Fallback to 1 in case both values are `0`
        scaleX = rect.width / element.offsetWidth || 1;
        scaleY = rect.height / element.offsetHeight || 1;
      }

      return {
        width: round$2(rect.width / scaleX),
        height: round$2(rect.height / scaleY),
        top: round$2(rect.top / scaleY),
        right: round$2(rect.right / scaleX),
        bottom: round$2(rect.bottom / scaleY),
        left: round$2(rect.left / scaleX),
        x: round$2(rect.left / scaleX),
        y: round$2(rect.top / scaleY)
      };
    }

    // means it doesn't take into account transforms.

    function getLayoutRect(element) {
      var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
      // Fixes https://github.com/popperjs/popper-core/issues/1223

      var width = element.offsetWidth;
      var height = element.offsetHeight;

      if (Math.abs(clientRect.width - width) <= 1) {
        width = clientRect.width;
      }

      if (Math.abs(clientRect.height - height) <= 1) {
        height = clientRect.height;
      }

      return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width: width,
        height: height
      };
    }

    function contains(parent, child) {
      var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

      if (parent.contains(child)) {
        return true;
      } // then fallback to custom implementation with Shadow DOM support
      else if (rootNode && isShadowRoot(rootNode)) {
          var next = child;

          do {
            if (next && parent.isSameNode(next)) {
              return true;
            } // $FlowFixMe[prop-missing]: need a better way to handle this...


            next = next.parentNode || next.host;
          } while (next);
        } // Give up, the result is false


      return false;
    }

    function getComputedStyle$1(element) {
      return getWindow(element).getComputedStyle(element);
    }

    function isTableElement(element) {
      return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
    }

    function getDocumentElement(element) {
      // $FlowFixMe[incompatible-return]: assume body is always available
      return ((isElement$1(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
      element.document) || window.document).documentElement;
    }

    function getParentNode(element) {
      if (getNodeName(element) === 'html') {
        return element;
      }

      return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
        // $FlowFixMe[incompatible-return]
        // $FlowFixMe[prop-missing]
        element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
        element.parentNode || ( // DOM Element detected
        isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
        // $FlowFixMe[incompatible-call]: HTMLElement is a Node
        getDocumentElement(element) // fallback

      );
    }

    function getTrueOffsetParent(element) {
      if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
      getComputedStyle$1(element).position === 'fixed') {
        return null;
      }

      return element.offsetParent;
    } // `.offsetParent` reports `null` for fixed elements, while absolute elements
    // return the containing block


    function getContainingBlock(element) {
      var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;
      var isIE = navigator.userAgent.indexOf('Trident') !== -1;

      if (isIE && isHTMLElement(element)) {
        // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
        var elementCss = getComputedStyle$1(element);

        if (elementCss.position === 'fixed') {
          return null;
        }
      }

      var currentNode = getParentNode(element);

      while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
        var css = getComputedStyle$1(currentNode); // This is non-exhaustive but covers the most common CSS properties that
        // create a containing block.
        // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

        if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
          return currentNode;
        } else {
          currentNode = currentNode.parentNode;
        }
      }

      return null;
    } // Gets the closest ancestor positioned element. Handles some edge cases,
    // such as table ancestors and cross browser bugs.


    function getOffsetParent(element) {
      var window = getWindow(element);
      var offsetParent = getTrueOffsetParent(element);

      while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {
        offsetParent = getTrueOffsetParent(offsetParent);
      }

      if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static')) {
        return window;
      }

      return offsetParent || getContainingBlock(element) || window;
    }

    function getMainAxisFromPlacement(placement) {
      return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
    }

    var max = Math.max;
    var min$1 = Math.min;
    var round$1 = Math.round;

    function within(min, value, max$1) {
      return max(min, min$1(value, max$1));
    }

    function getFreshSideObject() {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    }

    function mergePaddingObject(paddingObject) {
      return Object.assign({}, getFreshSideObject(), paddingObject);
    }

    function expandToHashMap(value, keys) {
      return keys.reduce(function (hashMap, key) {
        hashMap[key] = value;
        return hashMap;
      }, {});
    }

    var toPaddingObject = function toPaddingObject(padding, state) {
      padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
        placement: state.placement
      })) : padding;
      return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
    };

    function arrow(_ref) {
      var _state$modifiersData$;

      var state = _ref.state,
          name = _ref.name,
          options = _ref.options;
      var arrowElement = state.elements.arrow;
      var popperOffsets = state.modifiersData.popperOffsets;
      var basePlacement = getBasePlacement$1(state.placement);
      var axis = getMainAxisFromPlacement(basePlacement);
      var isVertical = [left, right].indexOf(basePlacement) >= 0;
      var len = isVertical ? 'height' : 'width';

      if (!arrowElement || !popperOffsets) {
        return;
      }

      var paddingObject = toPaddingObject(options.padding, state);
      var arrowRect = getLayoutRect(arrowElement);
      var minProp = axis === 'y' ? top : left;
      var maxProp = axis === 'y' ? bottom : right;
      var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
      var startDiff = popperOffsets[axis] - state.rects.reference[axis];
      var arrowOffsetParent = getOffsetParent(arrowElement);
      var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
      var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
      // outside of the popper bounds

      var min = paddingObject[minProp];
      var max = clientSize - arrowRect[len] - paddingObject[maxProp];
      var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
      var offset = within(min, center, max); // Prevents breaking syntax highlighting...

      var axisProp = axis;
      state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
    }

    function effect$1(_ref2) {
      var state = _ref2.state,
          options = _ref2.options;
      var _options$element = options.element,
          arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

      if (arrowElement == null) {
        return;
      } // CSS selector


      if (typeof arrowElement === 'string') {
        arrowElement = state.elements.popper.querySelector(arrowElement);

        if (!arrowElement) {
          return;
        }
      }

      if (!contains(state.elements.popper, arrowElement)) {

        return;
      }

      state.elements.arrow = arrowElement;
    } // eslint-disable-next-line import/no-unused-modules


    var arrow$1 = {
      name: 'arrow',
      enabled: true,
      phase: 'main',
      fn: arrow,
      effect: effect$1,
      requires: ['popperOffsets'],
      requiresIfExists: ['preventOverflow']
    };

    var unsetSides = {
      top: 'auto',
      right: 'auto',
      bottom: 'auto',
      left: 'auto'
    }; // Round the offsets to the nearest suitable subpixel based on the DPR.
    // Zooming can change the DPR, but it seems to report a value that will
    // cleanly divide the values into the appropriate subpixels.

    function roundOffsetsByDPR(_ref) {
      var x = _ref.x,
          y = _ref.y;
      var win = window;
      var dpr = win.devicePixelRatio || 1;
      return {
        x: round$1(round$1(x * dpr) / dpr) || 0,
        y: round$1(round$1(y * dpr) / dpr) || 0
      };
    }

    function mapToStyles(_ref2) {
      var _Object$assign2;

      var popper = _ref2.popper,
          popperRect = _ref2.popperRect,
          placement = _ref2.placement,
          offsets = _ref2.offsets,
          position = _ref2.position,
          gpuAcceleration = _ref2.gpuAcceleration,
          adaptive = _ref2.adaptive,
          roundOffsets = _ref2.roundOffsets;

      var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === 'function' ? roundOffsets(offsets) : offsets,
          _ref3$x = _ref3.x,
          x = _ref3$x === void 0 ? 0 : _ref3$x,
          _ref3$y = _ref3.y,
          y = _ref3$y === void 0 ? 0 : _ref3$y;

      var hasX = offsets.hasOwnProperty('x');
      var hasY = offsets.hasOwnProperty('y');
      var sideX = left;
      var sideY = top;
      var win = window;

      if (adaptive) {
        var offsetParent = getOffsetParent(popper);
        var heightProp = 'clientHeight';
        var widthProp = 'clientWidth';

        if (offsetParent === getWindow(popper)) {
          offsetParent = getDocumentElement(popper);

          if (getComputedStyle$1(offsetParent).position !== 'static') {
            heightProp = 'scrollHeight';
            widthProp = 'scrollWidth';
          }
        } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


        offsetParent = offsetParent;

        if (placement === top) {
          sideY = bottom; // $FlowFixMe[prop-missing]

          y -= offsetParent[heightProp] - popperRect.height;
          y *= gpuAcceleration ? 1 : -1;
        }

        if (placement === left) {
          sideX = right; // $FlowFixMe[prop-missing]

          x -= offsetParent[widthProp] - popperRect.width;
          x *= gpuAcceleration ? 1 : -1;
        }
      }

      var commonStyles = Object.assign({
        position: position
      }, adaptive && unsetSides);

      if (gpuAcceleration) {
        var _Object$assign;

        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
      }

      return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
    }

    function computeStyles(_ref4) {
      var state = _ref4.state,
          options = _ref4.options;
      var _options$gpuAccelerat = options.gpuAcceleration,
          gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
          _options$adaptive = options.adaptive,
          adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
          _options$roundOffsets = options.roundOffsets,
          roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;

      var commonStyles = {
        placement: getBasePlacement$1(state.placement),
        popper: state.elements.popper,
        popperRect: state.rects.popper,
        gpuAcceleration: gpuAcceleration
      };

      if (state.modifiersData.popperOffsets != null) {
        state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.popperOffsets,
          position: state.options.strategy,
          adaptive: adaptive,
          roundOffsets: roundOffsets
        })));
      }

      if (state.modifiersData.arrow != null) {
        state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.arrow,
          position: 'absolute',
          adaptive: false,
          roundOffsets: roundOffsets
        })));
      }

      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        'data-popper-placement': state.placement
      });
    } // eslint-disable-next-line import/no-unused-modules


    var computeStyles$1 = {
      name: 'computeStyles',
      enabled: true,
      phase: 'beforeWrite',
      fn: computeStyles,
      data: {}
    };

    var passive = {
      passive: true
    };

    function effect(_ref) {
      var state = _ref.state,
          instance = _ref.instance,
          options = _ref.options;
      var _options$scroll = options.scroll,
          scroll = _options$scroll === void 0 ? true : _options$scroll,
          _options$resize = options.resize,
          resize = _options$resize === void 0 ? true : _options$resize;
      var window = getWindow(state.elements.popper);
      var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

      if (scroll) {
        scrollParents.forEach(function (scrollParent) {
          scrollParent.addEventListener('scroll', instance.update, passive);
        });
      }

      if (resize) {
        window.addEventListener('resize', instance.update, passive);
      }

      return function () {
        if (scroll) {
          scrollParents.forEach(function (scrollParent) {
            scrollParent.removeEventListener('scroll', instance.update, passive);
          });
        }

        if (resize) {
          window.removeEventListener('resize', instance.update, passive);
        }
      };
    } // eslint-disable-next-line import/no-unused-modules


    var eventListeners = {
      name: 'eventListeners',
      enabled: true,
      phase: 'write',
      fn: function fn() {},
      effect: effect,
      data: {}
    };

    var hash$1 = {
      left: 'right',
      right: 'left',
      bottom: 'top',
      top: 'bottom'
    };
    function getOppositePlacement(placement) {
      return placement.replace(/left|right|bottom|top/g, function (matched) {
        return hash$1[matched];
      });
    }

    var hash = {
      start: 'end',
      end: 'start'
    };
    function getOppositeVariationPlacement(placement) {
      return placement.replace(/start|end/g, function (matched) {
        return hash[matched];
      });
    }

    function getWindowScroll(node) {
      var win = getWindow(node);
      var scrollLeft = win.pageXOffset;
      var scrollTop = win.pageYOffset;
      return {
        scrollLeft: scrollLeft,
        scrollTop: scrollTop
      };
    }

    function getWindowScrollBarX(element) {
      // If <html> has a CSS width greater than the viewport, then this will be
      // incorrect for RTL.
      // Popper 1 is broken in this case and never had a bug report so let's assume
      // it's not an issue. I don't think anyone ever specifies width on <html>
      // anyway.
      // Browsers where the left scrollbar doesn't cause an issue report `0` for
      // this (e.g. Edge 2019, IE11, Safari)
      return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
    }

    function getViewportRect(element) {
      var win = getWindow(element);
      var html = getDocumentElement(element);
      var visualViewport = win.visualViewport;
      var width = html.clientWidth;
      var height = html.clientHeight;
      var x = 0;
      var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper
      // can be obscured underneath it.
      // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even
      // if it isn't open, so if this isn't available, the popper will be detected
      // to overflow the bottom of the screen too early.

      if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)
        // In Chrome, it returns a value very close to 0 (+/-) but contains rounding
        // errors due to floating point numbers, so we need to check precision.
        // Safari returns a number <= 0, usually < -1 when pinch-zoomed
        // Feature detection fails in mobile emulation mode in Chrome.
        // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <
        // 0.001
        // Fallback here: "Not Safari" userAgent

        if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
          x = visualViewport.offsetLeft;
          y = visualViewport.offsetTop;
        }
      }

      return {
        width: width,
        height: height,
        x: x + getWindowScrollBarX(element),
        y: y
      };
    }

    // of the `<html>` and `<body>` rect bounds if horizontally scrollable

    function getDocumentRect(element) {
      var _element$ownerDocumen;

      var html = getDocumentElement(element);
      var winScroll = getWindowScroll(element);
      var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
      var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
      var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
      var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
      var y = -winScroll.scrollTop;

      if (getComputedStyle$1(body || html).direction === 'rtl') {
        x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
      }

      return {
        width: width,
        height: height,
        x: x,
        y: y
      };
    }

    function isScrollParent(element) {
      // Firefox wants us to check `-x` and `-y` variations as well
      var _getComputedStyle = getComputedStyle$1(element),
          overflow = _getComputedStyle.overflow,
          overflowX = _getComputedStyle.overflowX,
          overflowY = _getComputedStyle.overflowY;

      return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
    }

    function getScrollParent(node) {
      if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
        // $FlowFixMe[incompatible-return]: assume body is always available
        return node.ownerDocument.body;
      }

      if (isHTMLElement(node) && isScrollParent(node)) {
        return node;
      }

      return getScrollParent(getParentNode(node));
    }

    /*
    given a DOM element, return the list of all scroll parents, up the list of ancesors
    until we get to the top window object. This list is what we attach scroll listeners
    to, because if any of these parent elements scroll, we'll need to re-calculate the
    reference element's position.
    */

    function listScrollParents(element, list) {
      var _element$ownerDocumen;

      if (list === void 0) {
        list = [];
      }

      var scrollParent = getScrollParent(element);
      var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
      var win = getWindow(scrollParent);
      var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
      var updatedList = list.concat(target);
      return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target)));
    }

    function rectToClientRect(rect) {
      return Object.assign({}, rect, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
      });
    }

    function getInnerBoundingClientRect(element) {
      var rect = getBoundingClientRect(element);
      rect.top = rect.top + element.clientTop;
      rect.left = rect.left + element.clientLeft;
      rect.bottom = rect.top + element.clientHeight;
      rect.right = rect.left + element.clientWidth;
      rect.width = element.clientWidth;
      rect.height = element.clientHeight;
      rect.x = rect.left;
      rect.y = rect.top;
      return rect;
    }

    function getClientRectFromMixedType(element, clippingParent) {
      return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
    } // A "clipping parent" is an overflowable container with the characteristic of
    // clipping (or hiding) overflowing elements with a position different from
    // `initial`


    function getClippingParents(element) {
      var clippingParents = listScrollParents(getParentNode(element));
      var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle$1(element).position) >= 0;
      var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

      if (!isElement$1(clipperElement)) {
        return [];
      } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


      return clippingParents.filter(function (clippingParent) {
        return isElement$1(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
      });
    } // Gets the maximum area that the element is visible in due to any number of
    // clipping parents


    function getClippingRect(element, boundary, rootBoundary) {
      var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
      var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
      var firstClippingParent = clippingParents[0];
      var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
        var rect = getClientRectFromMixedType(element, clippingParent);
        accRect.top = max(rect.top, accRect.top);
        accRect.right = min$1(rect.right, accRect.right);
        accRect.bottom = min$1(rect.bottom, accRect.bottom);
        accRect.left = max(rect.left, accRect.left);
        return accRect;
      }, getClientRectFromMixedType(element, firstClippingParent));
      clippingRect.width = clippingRect.right - clippingRect.left;
      clippingRect.height = clippingRect.bottom - clippingRect.top;
      clippingRect.x = clippingRect.left;
      clippingRect.y = clippingRect.top;
      return clippingRect;
    }

    function getVariation(placement) {
      return placement.split('-')[1];
    }

    function computeOffsets(_ref) {
      var reference = _ref.reference,
          element = _ref.element,
          placement = _ref.placement;
      var basePlacement = placement ? getBasePlacement$1(placement) : null;
      var variation = placement ? getVariation(placement) : null;
      var commonX = reference.x + reference.width / 2 - element.width / 2;
      var commonY = reference.y + reference.height / 2 - element.height / 2;
      var offsets;

      switch (basePlacement) {
        case top:
          offsets = {
            x: commonX,
            y: reference.y - element.height
          };
          break;

        case bottom:
          offsets = {
            x: commonX,
            y: reference.y + reference.height
          };
          break;

        case right:
          offsets = {
            x: reference.x + reference.width,
            y: commonY
          };
          break;

        case left:
          offsets = {
            x: reference.x - element.width,
            y: commonY
          };
          break;

        default:
          offsets = {
            x: reference.x,
            y: reference.y
          };
      }

      var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

      if (mainAxis != null) {
        var len = mainAxis === 'y' ? 'height' : 'width';

        switch (variation) {
          case start$1:
            offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
            break;

          case end:
            offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
            break;
        }
      }

      return offsets;
    }

    function detectOverflow(state, options) {
      if (options === void 0) {
        options = {};
      }

      var _options = options,
          _options$placement = _options.placement,
          placement = _options$placement === void 0 ? state.placement : _options$placement,
          _options$boundary = _options.boundary,
          boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
          _options$rootBoundary = _options.rootBoundary,
          rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
          _options$elementConte = _options.elementContext,
          elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
          _options$altBoundary = _options.altBoundary,
          altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
          _options$padding = _options.padding,
          padding = _options$padding === void 0 ? 0 : _options$padding;
      var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
      var altContext = elementContext === popper ? reference : popper;
      var referenceElement = state.elements.reference;
      var popperRect = state.rects.popper;
      var element = state.elements[altBoundary ? altContext : elementContext];
      var clippingClientRect = getClippingRect(isElement$1(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
      var referenceClientRect = getBoundingClientRect(referenceElement);
      var popperOffsets = computeOffsets({
        reference: referenceClientRect,
        element: popperRect,
        strategy: 'absolute',
        placement: placement
      });
      var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
      var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
      // 0 or negative = within the clipping rect

      var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
      };
      var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

      if (elementContext === popper && offsetData) {
        var offset = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function (key) {
          var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
          var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
          overflowOffsets[key] += offset[axis] * multiply;
        });
      }

      return overflowOffsets;
    }

    function computeAutoPlacement(state, options) {
      if (options === void 0) {
        options = {};
      }

      var _options = options,
          placement = _options.placement,
          boundary = _options.boundary,
          rootBoundary = _options.rootBoundary,
          padding = _options.padding,
          flipVariations = _options.flipVariations,
          _options$allowedAutoP = _options.allowedAutoPlacements,
          allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
      var variation = getVariation(placement);
      var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
        return getVariation(placement) === variation;
      }) : basePlacements;
      var allowedPlacements = placements$1.filter(function (placement) {
        return allowedAutoPlacements.indexOf(placement) >= 0;
      });

      if (allowedPlacements.length === 0) {
        allowedPlacements = placements$1;
      } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


      var overflows = allowedPlacements.reduce(function (acc, placement) {
        acc[placement] = detectOverflow(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          padding: padding
        })[getBasePlacement$1(placement)];
        return acc;
      }, {});
      return Object.keys(overflows).sort(function (a, b) {
        return overflows[a] - overflows[b];
      });
    }

    function getExpandedFallbackPlacements(placement) {
      if (getBasePlacement$1(placement) === auto) {
        return [];
      }

      var oppositePlacement = getOppositePlacement(placement);
      return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
    }

    function flip(_ref) {
      var state = _ref.state,
          options = _ref.options,
          name = _ref.name;

      if (state.modifiersData[name]._skip) {
        return;
      }

      var _options$mainAxis = options.mainAxis,
          checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
          _options$altAxis = options.altAxis,
          checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
          specifiedFallbackPlacements = options.fallbackPlacements,
          padding = options.padding,
          boundary = options.boundary,
          rootBoundary = options.rootBoundary,
          altBoundary = options.altBoundary,
          _options$flipVariatio = options.flipVariations,
          flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
          allowedAutoPlacements = options.allowedAutoPlacements;
      var preferredPlacement = state.options.placement;
      var basePlacement = getBasePlacement$1(preferredPlacement);
      var isBasePlacement = basePlacement === preferredPlacement;
      var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
      var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
        return acc.concat(getBasePlacement$1(placement) === auto ? computeAutoPlacement(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          padding: padding,
          flipVariations: flipVariations,
          allowedAutoPlacements: allowedAutoPlacements
        }) : placement);
      }, []);
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var checksMap = new Map();
      var makeFallbackChecks = true;
      var firstFittingPlacement = placements[0];

      for (var i = 0; i < placements.length; i++) {
        var placement = placements[i];

        var _basePlacement = getBasePlacement$1(placement);

        var isStartVariation = getVariation(placement) === start$1;
        var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
        var len = isVertical ? 'width' : 'height';
        var overflow = detectOverflow(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          altBoundary: altBoundary,
          padding: padding
        });
        var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

        if (referenceRect[len] > popperRect[len]) {
          mainVariationSide = getOppositePlacement(mainVariationSide);
        }

        var altVariationSide = getOppositePlacement(mainVariationSide);
        var checks = [];

        if (checkMainAxis) {
          checks.push(overflow[_basePlacement] <= 0);
        }

        if (checkAltAxis) {
          checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
        }

        if (checks.every(function (check) {
          return check;
        })) {
          firstFittingPlacement = placement;
          makeFallbackChecks = false;
          break;
        }

        checksMap.set(placement, checks);
      }

      if (makeFallbackChecks) {
        // `2` may be desired in some cases  research later
        var numberOfChecks = flipVariations ? 3 : 1;

        var _loop = function _loop(_i) {
          var fittingPlacement = placements.find(function (placement) {
            var checks = checksMap.get(placement);

            if (checks) {
              return checks.slice(0, _i).every(function (check) {
                return check;
              });
            }
          });

          if (fittingPlacement) {
            firstFittingPlacement = fittingPlacement;
            return "break";
          }
        };

        for (var _i = numberOfChecks; _i > 0; _i--) {
          var _ret = _loop(_i);

          if (_ret === "break") break;
        }
      }

      if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
      }
    } // eslint-disable-next-line import/no-unused-modules


    var flip$1 = {
      name: 'flip',
      enabled: true,
      phase: 'main',
      fn: flip,
      requiresIfExists: ['offset'],
      data: {
        _skip: false
      }
    };

    function getSideOffsets(overflow, rect, preventedOffsets) {
      if (preventedOffsets === void 0) {
        preventedOffsets = {
          x: 0,
          y: 0
        };
      }

      return {
        top: overflow.top - rect.height - preventedOffsets.y,
        right: overflow.right - rect.width + preventedOffsets.x,
        bottom: overflow.bottom - rect.height + preventedOffsets.y,
        left: overflow.left - rect.width - preventedOffsets.x
      };
    }

    function isAnySideFullyClipped(overflow) {
      return [top, right, bottom, left].some(function (side) {
        return overflow[side] >= 0;
      });
    }

    function hide(_ref) {
      var state = _ref.state,
          name = _ref.name;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var preventedOffsets = state.modifiersData.preventOverflow;
      var referenceOverflow = detectOverflow(state, {
        elementContext: 'reference'
      });
      var popperAltOverflow = detectOverflow(state, {
        altBoundary: true
      });
      var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
      var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
      var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
      var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
      state.modifiersData[name] = {
        referenceClippingOffsets: referenceClippingOffsets,
        popperEscapeOffsets: popperEscapeOffsets,
        isReferenceHidden: isReferenceHidden,
        hasPopperEscaped: hasPopperEscaped
      };
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        'data-popper-reference-hidden': isReferenceHidden,
        'data-popper-escaped': hasPopperEscaped
      });
    } // eslint-disable-next-line import/no-unused-modules


    var hide$1 = {
      name: 'hide',
      enabled: true,
      phase: 'main',
      requiresIfExists: ['preventOverflow'],
      fn: hide
    };

    function distanceAndSkiddingToXY(placement, rects, offset) {
      var basePlacement = getBasePlacement$1(placement);
      var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

      var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
        placement: placement
      })) : offset,
          skidding = _ref[0],
          distance = _ref[1];

      skidding = skidding || 0;
      distance = (distance || 0) * invertDistance;
      return [left, right].indexOf(basePlacement) >= 0 ? {
        x: distance,
        y: skidding
      } : {
        x: skidding,
        y: distance
      };
    }

    function offset(_ref2) {
      var state = _ref2.state,
          options = _ref2.options,
          name = _ref2.name;
      var _options$offset = options.offset,
          offset = _options$offset === void 0 ? [0, 0] : _options$offset;
      var data = placements.reduce(function (acc, placement) {
        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
        return acc;
      }, {});
      var _data$state$placement = data[state.placement],
          x = _data$state$placement.x,
          y = _data$state$placement.y;

      if (state.modifiersData.popperOffsets != null) {
        state.modifiersData.popperOffsets.x += x;
        state.modifiersData.popperOffsets.y += y;
      }

      state.modifiersData[name] = data;
    } // eslint-disable-next-line import/no-unused-modules


    var offset$1 = {
      name: 'offset',
      enabled: true,
      phase: 'main',
      requires: ['popperOffsets'],
      fn: offset
    };

    function popperOffsets(_ref) {
      var state = _ref.state,
          name = _ref.name;
      // Offsets are the actual position the popper needs to have to be
      // properly positioned near its reference element
      // This is the most basic placement, and will be adjusted by
      // the modifiers in the next step
      state.modifiersData[name] = computeOffsets({
        reference: state.rects.reference,
        element: state.rects.popper,
        strategy: 'absolute',
        placement: state.placement
      });
    } // eslint-disable-next-line import/no-unused-modules


    var popperOffsets$1 = {
      name: 'popperOffsets',
      enabled: true,
      phase: 'read',
      fn: popperOffsets,
      data: {}
    };

    function getAltAxis(axis) {
      return axis === 'x' ? 'y' : 'x';
    }

    function preventOverflow(_ref) {
      var state = _ref.state,
          options = _ref.options,
          name = _ref.name;
      var _options$mainAxis = options.mainAxis,
          checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
          _options$altAxis = options.altAxis,
          checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
          boundary = options.boundary,
          rootBoundary = options.rootBoundary,
          altBoundary = options.altBoundary,
          padding = options.padding,
          _options$tether = options.tether,
          tether = _options$tether === void 0 ? true : _options$tether,
          _options$tetherOffset = options.tetherOffset,
          tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
      var overflow = detectOverflow(state, {
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding,
        altBoundary: altBoundary
      });
      var basePlacement = getBasePlacement$1(state.placement);
      var variation = getVariation(state.placement);
      var isBasePlacement = !variation;
      var mainAxis = getMainAxisFromPlacement(basePlacement);
      var altAxis = getAltAxis(mainAxis);
      var popperOffsets = state.modifiersData.popperOffsets;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
        placement: state.placement
      })) : tetherOffset;
      var data = {
        x: 0,
        y: 0
      };

      if (!popperOffsets) {
        return;
      }

      if (checkMainAxis || checkAltAxis) {
        var mainSide = mainAxis === 'y' ? top : left;
        var altSide = mainAxis === 'y' ? bottom : right;
        var len = mainAxis === 'y' ? 'height' : 'width';
        var offset = popperOffsets[mainAxis];
        var min = popperOffsets[mainAxis] + overflow[mainSide];
        var max$1 = popperOffsets[mainAxis] - overflow[altSide];
        var additive = tether ? -popperRect[len] / 2 : 0;
        var minLen = variation === start$1 ? referenceRect[len] : popperRect[len];
        var maxLen = variation === start$1 ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
        // outside the reference bounds

        var arrowElement = state.elements.arrow;
        var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
          width: 0,
          height: 0
        };
        var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
        // to include its full size in the calculation. If the reference is small
        // and near the edge of a boundary, the popper can overflow even if the
        // reference is not overflowing as well (e.g. virtual elements with no
        // width or height)

        var arrowLen = within(0, referenceRect[len], arrowRect[len]);
        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
        var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
        var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
        var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
        var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;

        if (checkMainAxis) {
          var preventedOffset = within(tether ? min$1(min, tetherMin) : min, offset, tether ? max(max$1, tetherMax) : max$1);
          popperOffsets[mainAxis] = preventedOffset;
          data[mainAxis] = preventedOffset - offset;
        }

        if (checkAltAxis) {
          var _mainSide = mainAxis === 'x' ? top : left;

          var _altSide = mainAxis === 'x' ? bottom : right;

          var _offset = popperOffsets[altAxis];

          var _min = _offset + overflow[_mainSide];

          var _max = _offset - overflow[_altSide];

          var _preventedOffset = within(tether ? min$1(_min, tetherMin) : _min, _offset, tether ? max(_max, tetherMax) : _max);

          popperOffsets[altAxis] = _preventedOffset;
          data[altAxis] = _preventedOffset - _offset;
        }
      }

      state.modifiersData[name] = data;
    } // eslint-disable-next-line import/no-unused-modules


    var preventOverflow$1 = {
      name: 'preventOverflow',
      enabled: true,
      phase: 'main',
      fn: preventOverflow,
      requiresIfExists: ['offset']
    };

    function getHTMLElementScroll(element) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }

    function getNodeScroll(node) {
      if (node === getWindow(node) || !isHTMLElement(node)) {
        return getWindowScroll(node);
      } else {
        return getHTMLElementScroll(node);
      }
    }

    function isElementScaled(element) {
      var rect = element.getBoundingClientRect();
      var scaleX = rect.width / element.offsetWidth || 1;
      var scaleY = rect.height / element.offsetHeight || 1;
      return scaleX !== 1 || scaleY !== 1;
    } // Returns the composite rect of an element relative to its offsetParent.
    // Composite means it takes into account transforms as well as layout.


    function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
      if (isFixed === void 0) {
        isFixed = false;
      }

      var isOffsetParentAnElement = isHTMLElement(offsetParent);
      var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
      var documentElement = getDocumentElement(offsetParent);
      var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);
      var scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      var offsets = {
        x: 0,
        y: 0
      };

      if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
        isScrollParent(documentElement)) {
          scroll = getNodeScroll(offsetParent);
        }

        if (isHTMLElement(offsetParent)) {
          offsets = getBoundingClientRect(offsetParent, true);
          offsets.x += offsetParent.clientLeft;
          offsets.y += offsetParent.clientTop;
        } else if (documentElement) {
          offsets.x = getWindowScrollBarX(documentElement);
        }
      }

      return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
      };
    }

    function order(modifiers) {
      var map = new Map();
      var visited = new Set();
      var result = [];
      modifiers.forEach(function (modifier) {
        map.set(modifier.name, modifier);
      }); // On visiting object, check for its dependencies and visit them recursively

      function sort(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function (dep) {
          if (!visited.has(dep)) {
            var depModifier = map.get(dep);

            if (depModifier) {
              sort(depModifier);
            }
          }
        });
        result.push(modifier);
      }

      modifiers.forEach(function (modifier) {
        if (!visited.has(modifier.name)) {
          // check for visited object
          sort(modifier);
        }
      });
      return result;
    }

    function orderModifiers(modifiers) {
      // order based on dependencies
      var orderedModifiers = order(modifiers); // order based on phase

      return modifierPhases.reduce(function (acc, phase) {
        return acc.concat(orderedModifiers.filter(function (modifier) {
          return modifier.phase === phase;
        }));
      }, []);
    }

    function debounce$1(fn) {
      var pending;
      return function () {
        if (!pending) {
          pending = new Promise(function (resolve) {
            Promise.resolve().then(function () {
              pending = undefined;
              resolve(fn());
            });
          });
        }

        return pending;
      };
    }

    function mergeByName(modifiers) {
      var merged = modifiers.reduce(function (merged, current) {
        var existing = merged[current.name];
        merged[current.name] = existing ? Object.assign({}, existing, current, {
          options: Object.assign({}, existing.options, current.options),
          data: Object.assign({}, existing.data, current.data)
        }) : current;
        return merged;
      }, {}); // IE11 does not support Object.values

      return Object.keys(merged).map(function (key) {
        return merged[key];
      });
    }

    var DEFAULT_OPTIONS = {
      placement: 'bottom',
      modifiers: [],
      strategy: 'absolute'
    };

    function areValidElements() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return !args.some(function (element) {
        return !(element && typeof element.getBoundingClientRect === 'function');
      });
    }

    function popperGenerator(generatorOptions) {
      if (generatorOptions === void 0) {
        generatorOptions = {};
      }

      var _generatorOptions = generatorOptions,
          _generatorOptions$def = _generatorOptions.defaultModifiers,
          defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
          _generatorOptions$def2 = _generatorOptions.defaultOptions,
          defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
      return function createPopper(reference, popper, options) {
        if (options === void 0) {
          options = defaultOptions;
        }

        var state = {
          placement: 'bottom',
          orderedModifiers: [],
          options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
          modifiersData: {},
          elements: {
            reference: reference,
            popper: popper
          },
          attributes: {},
          styles: {}
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance = {
          state: state,
          setOptions: function setOptions(options) {
            cleanupModifierEffects();
            state.options = Object.assign({}, defaultOptions, state.options, options);
            state.scrollParents = {
              reference: isElement$1(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
              popper: listScrollParents(popper)
            }; // Orders the modifiers based on their dependencies and `phase`
            // properties

            var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

            state.orderedModifiers = orderedModifiers.filter(function (m) {
              return m.enabled;
            }); // Validate the provided modifiers so that the consumer will get warned

            runModifierEffects();
            return instance.update();
          },
          // Sync update  it will always be executed, even if not necessary. This
          // is useful for low frequency updates where sync behavior simplifies the
          // logic.
          // For high frequency updates (e.g. `resize` and `scroll` events), always
          // prefer the async Popper#update method
          forceUpdate: function forceUpdate() {
            if (isDestroyed) {
              return;
            }

            var _state$elements = state.elements,
                reference = _state$elements.reference,
                popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
            // anymore

            if (!areValidElements(reference, popper)) {

              return;
            } // Store the reference and popper rects to be read by modifiers


            state.rects = {
              reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
              popper: getLayoutRect(popper)
            }; // Modifiers have the ability to reset the current update cycle. The
            // most common use case for this is the `flip` modifier changing the
            // placement, which then needs to re-run all the modifiers, because the
            // logic was previously ran for the previous placement and is therefore
            // stale/incorrect

            state.reset = false;
            state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
            // is filled with the initial data specified by the modifier. This means
            // it doesn't persist and is fresh on each update.
            // To ensure persistent data, use `${name}#persistent`

            state.orderedModifiers.forEach(function (modifier) {
              return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
            });

            for (var index = 0; index < state.orderedModifiers.length; index++) {

              if (state.reset === true) {
                state.reset = false;
                index = -1;
                continue;
              }

              var _state$orderedModifie = state.orderedModifiers[index],
                  fn = _state$orderedModifie.fn,
                  _state$orderedModifie2 = _state$orderedModifie.options,
                  _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
                  name = _state$orderedModifie.name;

              if (typeof fn === 'function') {
                state = fn({
                  state: state,
                  options: _options,
                  name: name,
                  instance: instance
                }) || state;
              }
            }
          },
          // Async and optimistically optimized update  it will not be executed if
          // not necessary (debounced to run at most once-per-tick)
          update: debounce$1(function () {
            return new Promise(function (resolve) {
              instance.forceUpdate();
              resolve(state);
            });
          }),
          destroy: function destroy() {
            cleanupModifierEffects();
            isDestroyed = true;
          }
        };

        if (!areValidElements(reference, popper)) {

          return instance;
        }

        instance.setOptions(options).then(function (state) {
          if (!isDestroyed && options.onFirstUpdate) {
            options.onFirstUpdate(state);
          }
        }); // Modifiers have the ability to execute arbitrary code before the first
        // update cycle runs. They will be executed in the same order as the update
        // cycle. This is useful when a modifier adds some persistent data that
        // other modifiers need to use, but the modifier is run after the dependent
        // one.

        function runModifierEffects() {
          state.orderedModifiers.forEach(function (_ref3) {
            var name = _ref3.name,
                _ref3$options = _ref3.options,
                options = _ref3$options === void 0 ? {} : _ref3$options,
                effect = _ref3.effect;

            if (typeof effect === 'function') {
              var cleanupFn = effect({
                state: state,
                name: name,
                instance: instance,
                options: options
              });

              var noopFn = function noopFn() {};

              effectCleanupFns.push(cleanupFn || noopFn);
            }
          });
        }

        function cleanupModifierEffects() {
          effectCleanupFns.forEach(function (fn) {
            return fn();
          });
          effectCleanupFns = [];
        }

        return instance;
      };
    }

    var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
    var createPopper = /*#__PURE__*/popperGenerator({
      defaultModifiers: defaultModifiers
    }); // eslint-disable-next-line import/no-unused-modules

    /**!
    * tippy.js v6.3.1
    * (c) 2017-2021 atomiks
    * MIT License
    */
    var BOX_CLASS = "tippy-box";
    var CONTENT_CLASS = "tippy-content";
    var BACKDROP_CLASS = "tippy-backdrop";
    var ARROW_CLASS = "tippy-arrow";
    var SVG_ARROW_CLASS = "tippy-svg-arrow";
    var TOUCH_OPTIONS = {
      passive: true,
      capture: true
    };
    function getValueAtIndexOrReturn(value, index, defaultValue) {
      if (Array.isArray(value)) {
        var v = value[index];
        return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
      }

      return value;
    }
    function isType(value, type) {
      var str = {}.toString.call(value);
      return str.indexOf('[object') === 0 && str.indexOf(type + "]") > -1;
    }
    function invokeWithArgsOrReturn(value, args) {
      return typeof value === 'function' ? value.apply(void 0, args) : value;
    }
    function debounce(fn, ms) {
      // Avoid wrapping in `setTimeout` if ms is 0 anyway
      if (ms === 0) {
        return fn;
      }

      var timeout;
      return function (arg) {
        clearTimeout(timeout);
        timeout = setTimeout(function () {
          fn(arg);
        }, ms);
      };
    }
    function removeProperties(obj, keys) {
      var clone = Object.assign({}, obj);
      keys.forEach(function (key) {
        delete clone[key];
      });
      return clone;
    }
    function splitBySpaces(value) {
      return value.split(/\s+/).filter(Boolean);
    }
    function normalizeToArray(value) {
      return [].concat(value);
    }
    function pushIfUnique(arr, value) {
      if (arr.indexOf(value) === -1) {
        arr.push(value);
      }
    }
    function unique$1(arr) {
      return arr.filter(function (item, index) {
        return arr.indexOf(item) === index;
      });
    }
    function getBasePlacement(placement) {
      return placement.split('-')[0];
    }
    function arrayFrom(value) {
      return [].slice.call(value);
    }
    function removeUndefinedProps(obj) {
      return Object.keys(obj).reduce(function (acc, key) {
        if (obj[key] !== undefined) {
          acc[key] = obj[key];
        }

        return acc;
      }, {});
    }

    function div() {
      return document.createElement('div');
    }
    function isElement(value) {
      return ['Element', 'Fragment'].some(function (type) {
        return isType(value, type);
      });
    }
    function isNodeList(value) {
      return isType(value, 'NodeList');
    }
    function isMouseEvent(value) {
      return isType(value, 'MouseEvent');
    }
    function isReferenceElement(value) {
      return !!(value && value._tippy && value._tippy.reference === value);
    }
    function getArrayOfElements(value) {
      if (isElement(value)) {
        return [value];
      }

      if (isNodeList(value)) {
        return arrayFrom(value);
      }

      if (Array.isArray(value)) {
        return value;
      }

      return arrayFrom(document.querySelectorAll(value));
    }
    function setTransitionDuration(els, value) {
      els.forEach(function (el) {
        if (el) {
          el.style.transitionDuration = value + "ms";
        }
      });
    }
    function setVisibilityState(els, state) {
      els.forEach(function (el) {
        if (el) {
          el.setAttribute('data-state', state);
        }
      });
    }
    function getOwnerDocument(elementOrElements) {
      var _element$ownerDocumen;

      var _normalizeToArray = normalizeToArray(elementOrElements),
          element = _normalizeToArray[0]; // Elements created via a <template> have an ownerDocument with no reference to the body


      return (element == null ? void 0 : (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body) ? element.ownerDocument : document;
    }
    function isCursorOutsideInteractiveBorder(popperTreeData, event) {
      var clientX = event.clientX,
          clientY = event.clientY;
      return popperTreeData.every(function (_ref) {
        var popperRect = _ref.popperRect,
            popperState = _ref.popperState,
            props = _ref.props;
        var interactiveBorder = props.interactiveBorder;
        var basePlacement = getBasePlacement(popperState.placement);
        var offsetData = popperState.modifiersData.offset;

        if (!offsetData) {
          return true;
        }

        var topDistance = basePlacement === 'bottom' ? offsetData.top.y : 0;
        var bottomDistance = basePlacement === 'top' ? offsetData.bottom.y : 0;
        var leftDistance = basePlacement === 'right' ? offsetData.left.x : 0;
        var rightDistance = basePlacement === 'left' ? offsetData.right.x : 0;
        var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
        var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
        var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
        var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
        return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
      });
    }
    function updateTransitionEndListener(box, action, listener) {
      var method = action + "EventListener"; // some browsers apparently support `transition` (unprefixed) but only fire
      // `webkitTransitionEnd`...

      ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
        box[method](event, listener);
      });
    }

    var currentInput = {
      isTouch: false
    };
    var lastMouseMoveTime = 0;
    /**
     * When a `touchstart` event is fired, it's assumed the user is using touch
     * input. We'll bind a `mousemove` event listener to listen for mouse input in
     * the future. This way, the `isTouch` property is fully dynamic and will handle
     * hybrid devices that use a mix of touch + mouse input.
     */

    function onDocumentTouchStart() {
      if (currentInput.isTouch) {
        return;
      }

      currentInput.isTouch = true;

      if (window.performance) {
        document.addEventListener('mousemove', onDocumentMouseMove);
      }
    }
    /**
     * When two `mousemove` event are fired consecutively within 20ms, it's assumed
     * the user is using mouse input again. `mousemove` can fire on touch devices as
     * well, but very rarely that quickly.
     */

    function onDocumentMouseMove() {
      var now = performance.now();

      if (now - lastMouseMoveTime < 20) {
        currentInput.isTouch = false;
        document.removeEventListener('mousemove', onDocumentMouseMove);
      }

      lastMouseMoveTime = now;
    }
    /**
     * When an element is in focus and has a tippy, leaving the tab/window and
     * returning causes it to show again. For mouse users this is unexpected, but
     * for keyboard use it makes sense.
     * TODO: find a better technique to solve this problem
     */

    function onWindowBlur() {
      var activeElement = document.activeElement;

      if (isReferenceElement(activeElement)) {
        var instance = activeElement._tippy;

        if (activeElement.blur && !instance.state.isVisible) {
          activeElement.blur();
        }
      }
    }
    function bindGlobalEventListeners() {
      document.addEventListener('touchstart', onDocumentTouchStart, TOUCH_OPTIONS);
      window.addEventListener('blur', onWindowBlur);
    }

    var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
    var ua = isBrowser ? navigator.userAgent : '';
    var isIE = /MSIE |Trident\//.test(ua);

    var pluginProps = {
      animateFill: false,
      followCursor: false,
      inlinePositioning: false,
      sticky: false
    };
    var renderProps = {
      allowHTML: false,
      animation: 'fade',
      arrow: true,
      content: '',
      inertia: false,
      maxWidth: 350,
      role: 'tooltip',
      theme: '',
      zIndex: 9999
    };
    var defaultProps = Object.assign({
      appendTo: function appendTo() {
        return document.body;
      },
      aria: {
        content: 'auto',
        expanded: 'auto'
      },
      delay: 0,
      duration: [300, 250],
      getReferenceClientRect: null,
      hideOnClick: true,
      ignoreAttributes: false,
      interactive: false,
      interactiveBorder: 2,
      interactiveDebounce: 0,
      moveTransition: '',
      offset: [0, 10],
      onAfterUpdate: function onAfterUpdate() {},
      onBeforeUpdate: function onBeforeUpdate() {},
      onCreate: function onCreate() {},
      onDestroy: function onDestroy() {},
      onHidden: function onHidden() {},
      onHide: function onHide() {},
      onMount: function onMount() {},
      onShow: function onShow() {},
      onShown: function onShown() {},
      onTrigger: function onTrigger() {},
      onUntrigger: function onUntrigger() {},
      onClickOutside: function onClickOutside() {},
      placement: 'top',
      plugins: [],
      popperOptions: {},
      render: null,
      showOnCreate: false,
      touch: true,
      trigger: 'mouseenter focus',
      triggerTarget: null
    }, pluginProps, {}, renderProps);
    var defaultKeys = Object.keys(defaultProps);
    var setDefaultProps = function setDefaultProps(partialProps) {

      var keys = Object.keys(partialProps);
      keys.forEach(function (key) {
        defaultProps[key] = partialProps[key];
      });
    };
    function getExtendedPassedProps(passedProps) {
      var plugins = passedProps.plugins || [];
      var pluginProps = plugins.reduce(function (acc, plugin) {
        var name = plugin.name,
            defaultValue = plugin.defaultValue;

        if (name) {
          acc[name] = passedProps[name] !== undefined ? passedProps[name] : defaultValue;
        }

        return acc;
      }, {});
      return Object.assign({}, passedProps, {}, pluginProps);
    }
    function getDataAttributeProps(reference, plugins) {
      var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
        plugins: plugins
      }))) : defaultKeys;
      var props = propKeys.reduce(function (acc, key) {
        var valueAsString = (reference.getAttribute("data-tippy-" + key) || '').trim();

        if (!valueAsString) {
          return acc;
        }

        if (key === 'content') {
          acc[key] = valueAsString;
        } else {
          try {
            acc[key] = JSON.parse(valueAsString);
          } catch (e) {
            acc[key] = valueAsString;
          }
        }

        return acc;
      }, {});
      return props;
    }
    function evaluateProps(reference, props) {
      var out = Object.assign({}, props, {
        content: invokeWithArgsOrReturn(props.content, [reference])
      }, props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins));
      out.aria = Object.assign({}, defaultProps.aria, {}, out.aria);
      out.aria = {
        expanded: out.aria.expanded === 'auto' ? props.interactive : out.aria.expanded,
        content: out.aria.content === 'auto' ? props.interactive ? null : 'describedby' : out.aria.content
      };
      return out;
    }

    var innerHTML = function innerHTML() {
      return 'innerHTML';
    };

    function dangerouslySetInnerHTML(element, html) {
      element[innerHTML()] = html;
    }

    function createArrowElement(value) {
      var arrow = div();

      if (value === true) {
        arrow.className = ARROW_CLASS;
      } else {
        arrow.className = SVG_ARROW_CLASS;

        if (isElement(value)) {
          arrow.appendChild(value);
        } else {
          dangerouslySetInnerHTML(arrow, value);
        }
      }

      return arrow;
    }

    function setContent(content, props) {
      if (isElement(props.content)) {
        dangerouslySetInnerHTML(content, '');
        content.appendChild(props.content);
      } else if (typeof props.content !== 'function') {
        if (props.allowHTML) {
          dangerouslySetInnerHTML(content, props.content);
        } else {
          content.textContent = props.content;
        }
      }
    }
    function getChildren(popper) {
      var box = popper.firstElementChild;
      var boxChildren = arrayFrom(box.children);
      return {
        box: box,
        content: boxChildren.find(function (node) {
          return node.classList.contains(CONTENT_CLASS);
        }),
        arrow: boxChildren.find(function (node) {
          return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
        }),
        backdrop: boxChildren.find(function (node) {
          return node.classList.contains(BACKDROP_CLASS);
        })
      };
    }
    function render(instance) {
      var popper = div();
      var box = div();
      box.className = BOX_CLASS;
      box.setAttribute('data-state', 'hidden');
      box.setAttribute('tabindex', '-1');
      var content = div();
      content.className = CONTENT_CLASS;
      content.setAttribute('data-state', 'hidden');
      setContent(content, instance.props);
      popper.appendChild(box);
      box.appendChild(content);
      onUpdate(instance.props, instance.props);

      function onUpdate(prevProps, nextProps) {
        var _getChildren = getChildren(popper),
            box = _getChildren.box,
            content = _getChildren.content,
            arrow = _getChildren.arrow;

        if (nextProps.theme) {
          box.setAttribute('data-theme', nextProps.theme);
        } else {
          box.removeAttribute('data-theme');
        }

        if (typeof nextProps.animation === 'string') {
          box.setAttribute('data-animation', nextProps.animation);
        } else {
          box.removeAttribute('data-animation');
        }

        if (nextProps.inertia) {
          box.setAttribute('data-inertia', '');
        } else {
          box.removeAttribute('data-inertia');
        }

        box.style.maxWidth = typeof nextProps.maxWidth === 'number' ? nextProps.maxWidth + "px" : nextProps.maxWidth;

        if (nextProps.role) {
          box.setAttribute('role', nextProps.role);
        } else {
          box.removeAttribute('role');
        }

        if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
          setContent(content, instance.props);
        }

        if (nextProps.arrow) {
          if (!arrow) {
            box.appendChild(createArrowElement(nextProps.arrow));
          } else if (prevProps.arrow !== nextProps.arrow) {
            box.removeChild(arrow);
            box.appendChild(createArrowElement(nextProps.arrow));
          }
        } else if (arrow) {
          box.removeChild(arrow);
        }
      }

      return {
        popper: popper,
        onUpdate: onUpdate
      };
    } // Runtime check to identify if the render function is the default one; this
    // way we can apply default CSS transitions logic and it can be tree-shaken away

    render.$$tippy = true;

    var idCounter = 1;
    var mouseMoveListeners = []; // Used by `hideAll()`

    var mountedInstances = [];
    function createTippy(reference, passedProps) {
      var props = evaluateProps(reference, Object.assign({}, defaultProps, {}, getExtendedPassedProps(removeUndefinedProps(passedProps)))); // ===========================================================================
      //  Private members
      // ===========================================================================

      var showTimeout;
      var hideTimeout;
      var scheduleHideAnimationFrame;
      var isVisibleFromClick = false;
      var didHideDueToDocumentMouseDown = false;
      var didTouchMove = false;
      var ignoreOnFirstUpdate = false;
      var lastTriggerEvent;
      var currentTransitionEndListener;
      var onFirstUpdate;
      var listeners = [];
      var debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);
      var currentTarget; // ===========================================================================
      //  Public members
      // ===========================================================================

      var id = idCounter++;
      var popperInstance = null;
      var plugins = unique$1(props.plugins);
      var state = {
        // Is the instance currently enabled?
        isEnabled: true,
        // Is the tippy currently showing and not transitioning out?
        isVisible: false,
        // Has the instance been destroyed?
        isDestroyed: false,
        // Is the tippy currently mounted to the DOM?
        isMounted: false,
        // Has the tippy finished transitioning in?
        isShown: false
      };
      var instance = {
        // properties
        id: id,
        reference: reference,
        popper: div(),
        popperInstance: popperInstance,
        props: props,
        state: state,
        plugins: plugins,
        // methods
        clearDelayTimeouts: clearDelayTimeouts,
        setProps: setProps,
        setContent: setContent,
        show: show,
        hide: hide,
        hideWithInteractivity: hideWithInteractivity,
        enable: enable,
        disable: disable,
        unmount: unmount,
        destroy: destroy
      }; // TODO: Investigate why this early return causes a TDZ error in the tests 
      // it doesn't seem to happen in the browser

      /* istanbul ignore if */

      if (!props.render) {

        return instance;
      } // ===========================================================================
      // Initial mutations
      // ===========================================================================


      var _props$render = props.render(instance),
          popper = _props$render.popper,
          onUpdate = _props$render.onUpdate;

      popper.setAttribute('data-tippy-root', '');
      popper.id = "tippy-" + instance.id;
      instance.popper = popper;
      reference._tippy = instance;
      popper._tippy = instance;
      var pluginsHooks = plugins.map(function (plugin) {
        return plugin.fn(instance);
      });
      var hasAriaExpanded = reference.hasAttribute('aria-expanded');
      addListeners();
      handleAriaExpandedAttribute();
      handleStyles();
      invokeHook('onCreate', [instance]);

      if (props.showOnCreate) {
        scheduleShow();
      } // Prevent a tippy with a delay from hiding if the cursor left then returned
      // before it started hiding


      popper.addEventListener('mouseenter', function () {
        if (instance.props.interactive && instance.state.isVisible) {
          instance.clearDelayTimeouts();
        }
      });
      popper.addEventListener('mouseleave', function (event) {
        if (instance.props.interactive && instance.props.trigger.indexOf('mouseenter') >= 0) {
          getDocument().addEventListener('mousemove', debouncedOnMouseMove);
          debouncedOnMouseMove(event);
        }
      });
      return instance; // ===========================================================================
      //  Private methods
      // ===========================================================================

      function getNormalizedTouchSettings() {
        var touch = instance.props.touch;
        return Array.isArray(touch) ? touch : [touch, 0];
      }

      function getIsCustomTouchBehavior() {
        return getNormalizedTouchSettings()[0] === 'hold';
      }

      function getIsDefaultRenderFn() {
        var _instance$props$rende;

        // @ts-ignore
        return !!((_instance$props$rende = instance.props.render) == null ? void 0 : _instance$props$rende.$$tippy);
      }

      function getCurrentTarget() {
        return currentTarget || reference;
      }

      function getDocument() {
        var parent = getCurrentTarget().parentNode;
        return parent ? getOwnerDocument(parent) : document;
      }

      function getDefaultTemplateChildren() {
        return getChildren(popper);
      }

      function getDelay(isShow) {
        // For touch or keyboard input, force `0` delay for UX reasons
        // Also if the instance is mounted but not visible (transitioning out),
        // ignore delay
        if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === 'focus') {
          return 0;
        }

        return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
      }

      function handleStyles() {
        popper.style.pointerEvents = instance.props.interactive && instance.state.isVisible ? '' : 'none';
        popper.style.zIndex = "" + instance.props.zIndex;
      }

      function invokeHook(hook, args, shouldInvokePropsHook) {
        if (shouldInvokePropsHook === void 0) {
          shouldInvokePropsHook = true;
        }

        pluginsHooks.forEach(function (pluginHooks) {
          if (pluginHooks[hook]) {
            pluginHooks[hook].apply(void 0, args);
          }
        });

        if (shouldInvokePropsHook) {
          var _instance$props;

          (_instance$props = instance.props)[hook].apply(_instance$props, args);
        }
      }

      function handleAriaContentAttribute() {
        var aria = instance.props.aria;

        if (!aria.content) {
          return;
        }

        var attr = "aria-" + aria.content;
        var id = popper.id;
        var nodes = normalizeToArray(instance.props.triggerTarget || reference);
        nodes.forEach(function (node) {
          var currentValue = node.getAttribute(attr);

          if (instance.state.isVisible) {
            node.setAttribute(attr, currentValue ? currentValue + " " + id : id);
          } else {
            var nextValue = currentValue && currentValue.replace(id, '').trim();

            if (nextValue) {
              node.setAttribute(attr, nextValue);
            } else {
              node.removeAttribute(attr);
            }
          }
        });
      }

      function handleAriaExpandedAttribute() {
        if (hasAriaExpanded || !instance.props.aria.expanded) {
          return;
        }

        var nodes = normalizeToArray(instance.props.triggerTarget || reference);
        nodes.forEach(function (node) {
          if (instance.props.interactive) {
            node.setAttribute('aria-expanded', instance.state.isVisible && node === getCurrentTarget() ? 'true' : 'false');
          } else {
            node.removeAttribute('aria-expanded');
          }
        });
      }

      function cleanupInteractiveMouseListeners() {
        getDocument().removeEventListener('mousemove', debouncedOnMouseMove);
        mouseMoveListeners = mouseMoveListeners.filter(function (listener) {
          return listener !== debouncedOnMouseMove;
        });
      }

      function onDocumentPress(event) {
        // Moved finger to scroll instead of an intentional tap outside
        if (currentInput.isTouch) {
          if (didTouchMove || event.type === 'mousedown') {
            return;
          }
        } // Clicked on interactive popper


        if (instance.props.interactive && popper.contains(event.target)) {
          return;
        } // Clicked on the event listeners target


        if (getCurrentTarget().contains(event.target)) {
          if (currentInput.isTouch) {
            return;
          }

          if (instance.state.isVisible && instance.props.trigger.indexOf('click') >= 0) {
            return;
          }
        } else {
          invokeHook('onClickOutside', [instance, event]);
        }

        if (instance.props.hideOnClick === true) {
          instance.clearDelayTimeouts();
          instance.hide(); // `mousedown` event is fired right before `focus` if pressing the
          // currentTarget. This lets a tippy with `focus` trigger know that it
          // should not show

          didHideDueToDocumentMouseDown = true;
          setTimeout(function () {
            didHideDueToDocumentMouseDown = false;
          }); // The listener gets added in `scheduleShow()`, but this may be hiding it
          // before it shows, and hide()'s early bail-out behavior can prevent it
          // from being cleaned up

          if (!instance.state.isMounted) {
            removeDocumentPress();
          }
        }
      }

      function onTouchMove() {
        didTouchMove = true;
      }

      function onTouchStart() {
        didTouchMove = false;
      }

      function addDocumentPress() {
        var doc = getDocument();
        doc.addEventListener('mousedown', onDocumentPress, true);
        doc.addEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
        doc.addEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
        doc.addEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
      }

      function removeDocumentPress() {
        var doc = getDocument();
        doc.removeEventListener('mousedown', onDocumentPress, true);
        doc.removeEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
        doc.removeEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
        doc.removeEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
      }

      function onTransitionedOut(duration, callback) {
        onTransitionEnd(duration, function () {
          if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
            callback();
          }
        });
      }

      function onTransitionedIn(duration, callback) {
        onTransitionEnd(duration, callback);
      }

      function onTransitionEnd(duration, callback) {
        var box = getDefaultTemplateChildren().box;

        function listener(event) {
          if (event.target === box) {
            updateTransitionEndListener(box, 'remove', listener);
            callback();
          }
        } // Make callback synchronous if duration is 0
        // `transitionend` won't fire otherwise


        if (duration === 0) {
          return callback();
        }

        updateTransitionEndListener(box, 'remove', currentTransitionEndListener);
        updateTransitionEndListener(box, 'add', listener);
        currentTransitionEndListener = listener;
      }

      function on(eventType, handler, options) {
        if (options === void 0) {
          options = false;
        }

        var nodes = normalizeToArray(instance.props.triggerTarget || reference);
        nodes.forEach(function (node) {
          node.addEventListener(eventType, handler, options);
          listeners.push({
            node: node,
            eventType: eventType,
            handler: handler,
            options: options
          });
        });
      }

      function addListeners() {
        if (getIsCustomTouchBehavior()) {
          on('touchstart', onTrigger, {
            passive: true
          });
          on('touchend', onMouseLeave, {
            passive: true
          });
        }

        splitBySpaces(instance.props.trigger).forEach(function (eventType) {
          if (eventType === 'manual') {
            return;
          }

          on(eventType, onTrigger);

          switch (eventType) {
            case 'mouseenter':
              on('mouseleave', onMouseLeave);
              break;

            case 'focus':
              on(isIE ? 'focusout' : 'blur', onBlurOrFocusOut);
              break;

            case 'focusin':
              on('focusout', onBlurOrFocusOut);
              break;
          }
        });
      }

      function removeListeners() {
        listeners.forEach(function (_ref) {
          var node = _ref.node,
              eventType = _ref.eventType,
              handler = _ref.handler,
              options = _ref.options;
          node.removeEventListener(eventType, handler, options);
        });
        listeners = [];
      }

      function onTrigger(event) {
        var _lastTriggerEvent;

        var shouldScheduleClickHide = false;

        if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
          return;
        }

        var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === 'focus';
        lastTriggerEvent = event;
        currentTarget = event.currentTarget;
        handleAriaExpandedAttribute();

        if (!instance.state.isVisible && isMouseEvent(event)) {
          // If scrolling, `mouseenter` events can be fired if the cursor lands
          // over a new target, but `mousemove` events don't get fired. This
          // causes interactive tooltips to get stuck open until the cursor is
          // moved
          mouseMoveListeners.forEach(function (listener) {
            return listener(event);
          });
        } // Toggle show/hide when clicking click-triggered tooltips


        if (event.type === 'click' && (instance.props.trigger.indexOf('mouseenter') < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
          shouldScheduleClickHide = true;
        } else {
          scheduleShow(event);
        }

        if (event.type === 'click') {
          isVisibleFromClick = !shouldScheduleClickHide;
        }

        if (shouldScheduleClickHide && !wasFocused) {
          scheduleHide(event);
        }
      }

      function onMouseMove(event) {
        var target = event.target;
        var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper.contains(target);

        if (event.type === 'mousemove' && isCursorOverReferenceOrPopper) {
          return;
        }

        var popperTreeData = getNestedPopperTree().concat(popper).map(function (popper) {
          var _instance$popperInsta;

          var instance = popper._tippy;
          var state = (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.state;

          if (state) {
            return {
              popperRect: popper.getBoundingClientRect(),
              popperState: state,
              props: props
            };
          }

          return null;
        }).filter(Boolean);

        if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
          cleanupInteractiveMouseListeners();
          scheduleHide(event);
        }
      }

      function onMouseLeave(event) {
        var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf('click') >= 0 && isVisibleFromClick;

        if (shouldBail) {
          return;
        }

        if (instance.props.interactive) {
          instance.hideWithInteractivity(event);
          return;
        }

        scheduleHide(event);
      }

      function onBlurOrFocusOut(event) {
        if (instance.props.trigger.indexOf('focusin') < 0 && event.target !== getCurrentTarget()) {
          return;
        } // If focus was moved to within the popper


        if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
          return;
        }

        scheduleHide(event);
      }

      function isEventListenerStopped(event) {
        return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf('touch') >= 0 : false;
      }

      function createPopperInstance() {
        destroyPopperInstance();
        var _instance$props2 = instance.props,
            popperOptions = _instance$props2.popperOptions,
            placement = _instance$props2.placement,
            offset = _instance$props2.offset,
            getReferenceClientRect = _instance$props2.getReferenceClientRect,
            moveTransition = _instance$props2.moveTransition;
        var arrow = getIsDefaultRenderFn() ? getChildren(popper).arrow : null;
        var computedReference = getReferenceClientRect ? {
          getBoundingClientRect: getReferenceClientRect,
          contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
        } : reference;
        var tippyModifier = {
          name: '$$tippy',
          enabled: true,
          phase: 'beforeWrite',
          requires: ['computeStyles'],
          fn: function fn(_ref2) {
            var state = _ref2.state;

            if (getIsDefaultRenderFn()) {
              var _getDefaultTemplateCh = getDefaultTemplateChildren(),
                  box = _getDefaultTemplateCh.box;

              ['placement', 'reference-hidden', 'escaped'].forEach(function (attr) {
                if (attr === 'placement') {
                  box.setAttribute('data-placement', state.placement);
                } else {
                  if (state.attributes.popper["data-popper-" + attr]) {
                    box.setAttribute("data-" + attr, '');
                  } else {
                    box.removeAttribute("data-" + attr);
                  }
                }
              });
              state.attributes.popper = {};
            }
          }
        };
        var modifiers = [{
          name: 'offset',
          options: {
            offset: offset
          }
        }, {
          name: 'preventOverflow',
          options: {
            padding: {
              top: 2,
              bottom: 2,
              left: 5,
              right: 5
            }
          }
        }, {
          name: 'flip',
          options: {
            padding: 5
          }
        }, {
          name: 'computeStyles',
          options: {
            adaptive: !moveTransition
          }
        }, tippyModifier];

        if (getIsDefaultRenderFn() && arrow) {
          modifiers.push({
            name: 'arrow',
            options: {
              element: arrow,
              padding: 3
            }
          });
        }

        modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
        instance.popperInstance = createPopper(computedReference, popper, Object.assign({}, popperOptions, {
          placement: placement,
          onFirstUpdate: onFirstUpdate,
          modifiers: modifiers
        }));
      }

      function destroyPopperInstance() {
        if (instance.popperInstance) {
          instance.popperInstance.destroy();
          instance.popperInstance = null;
        }
      }

      function mount() {
        var appendTo = instance.props.appendTo;
        var parentNode; // By default, we'll append the popper to the triggerTargets's parentNode so
        // it's directly after the reference element so the elements inside the
        // tippy can be tabbed to
        // If there are clipping issues, the user can specify a different appendTo
        // and ensure focus management is handled correctly manually

        var node = getCurrentTarget();

        if (instance.props.interactive && appendTo === defaultProps.appendTo || appendTo === 'parent') {
          parentNode = node.parentNode;
        } else {
          parentNode = invokeWithArgsOrReturn(appendTo, [node]);
        } // The popper element needs to exist on the DOM before its position can be
        // updated as Popper needs to read its dimensions


        if (!parentNode.contains(popper)) {
          parentNode.appendChild(popper);
        }

        createPopperInstance();
      }

      function getNestedPopperTree() {
        return arrayFrom(popper.querySelectorAll('[data-tippy-root]'));
      }

      function scheduleShow(event) {
        instance.clearDelayTimeouts();

        if (event) {
          invokeHook('onTrigger', [instance, event]);
        }

        addDocumentPress();
        var delay = getDelay(true);

        var _getNormalizedTouchSe = getNormalizedTouchSettings(),
            touchValue = _getNormalizedTouchSe[0],
            touchDelay = _getNormalizedTouchSe[1];

        if (currentInput.isTouch && touchValue === 'hold' && touchDelay) {
          delay = touchDelay;
        }

        if (delay) {
          showTimeout = setTimeout(function () {
            instance.show();
          }, delay);
        } else {
          instance.show();
        }
      }

      function scheduleHide(event) {
        instance.clearDelayTimeouts();
        invokeHook('onUntrigger', [instance, event]);

        if (!instance.state.isVisible) {
          removeDocumentPress();
          return;
        } // For interactive tippies, scheduleHide is added to a document.body handler
        // from onMouseLeave so must intercept scheduled hides from mousemove/leave
        // events when trigger contains mouseenter and click, and the tip is
        // currently shown as a result of a click.


        if (instance.props.trigger.indexOf('mouseenter') >= 0 && instance.props.trigger.indexOf('click') >= 0 && ['mouseleave', 'mousemove'].indexOf(event.type) >= 0 && isVisibleFromClick) {
          return;
        }

        var delay = getDelay(false);

        if (delay) {
          hideTimeout = setTimeout(function () {
            if (instance.state.isVisible) {
              instance.hide();
            }
          }, delay);
        } else {
          // Fixes a `transitionend` problem when it fires 1 frame too
          // late sometimes, we don't want hide() to be called.
          scheduleHideAnimationFrame = requestAnimationFrame(function () {
            instance.hide();
          });
        }
      } // ===========================================================================
      //  Public methods
      // ===========================================================================


      function enable() {
        instance.state.isEnabled = true;
      }

      function disable() {
        // Disabling the instance should also hide it
        // https://github.com/atomiks/tippy.js-react/issues/106
        instance.hide();
        instance.state.isEnabled = false;
      }

      function clearDelayTimeouts() {
        clearTimeout(showTimeout);
        clearTimeout(hideTimeout);
        cancelAnimationFrame(scheduleHideAnimationFrame);
      }

      function setProps(partialProps) {

        if (instance.state.isDestroyed) {
          return;
        }

        invokeHook('onBeforeUpdate', [instance, partialProps]);
        removeListeners();
        var prevProps = instance.props;
        var nextProps = evaluateProps(reference, Object.assign({}, instance.props, {}, partialProps, {
          ignoreAttributes: true
        }));
        instance.props = nextProps;
        addListeners();

        if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
          cleanupInteractiveMouseListeners();
          debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);
        } // Ensure stale aria-expanded attributes are removed


        if (prevProps.triggerTarget && !nextProps.triggerTarget) {
          normalizeToArray(prevProps.triggerTarget).forEach(function (node) {
            node.removeAttribute('aria-expanded');
          });
        } else if (nextProps.triggerTarget) {
          reference.removeAttribute('aria-expanded');
        }

        handleAriaExpandedAttribute();
        handleStyles();

        if (onUpdate) {
          onUpdate(prevProps, nextProps);
        }

        if (instance.popperInstance) {
          createPopperInstance(); // Fixes an issue with nested tippies if they are all getting re-rendered,
          // and the nested ones get re-rendered first.
          // https://github.com/atomiks/tippyjs-react/issues/177
          // TODO: find a cleaner / more efficient solution(!)

          getNestedPopperTree().forEach(function (nestedPopper) {
            // React (and other UI libs likely) requires a rAF wrapper as it flushes
            // its work in one
            requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
          });
        }

        invokeHook('onAfterUpdate', [instance, partialProps]);
      }

      function setContent(content) {
        instance.setProps({
          content: content
        });
      }

      function show() {


        var isAlreadyVisible = instance.state.isVisible;
        var isDestroyed = instance.state.isDestroyed;
        var isDisabled = !instance.state.isEnabled;
        var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
        var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);

        if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
          return;
        } // Normalize `disabled` behavior across browsers.
        // Firefox allows events on disabled elements, but Chrome doesn't.
        // Using a wrapper element (i.e. <span>) is recommended.


        if (getCurrentTarget().hasAttribute('disabled')) {
          return;
        }

        invokeHook('onShow', [instance], false);

        if (instance.props.onShow(instance) === false) {
          return;
        }

        instance.state.isVisible = true;

        if (getIsDefaultRenderFn()) {
          popper.style.visibility = 'visible';
        }

        handleStyles();
        addDocumentPress();

        if (!instance.state.isMounted) {
          popper.style.transition = 'none';
        } // If flipping to the opposite side after hiding at least once, the
        // animation will use the wrong placement without resetting the duration


        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh2 = getDefaultTemplateChildren(),
              box = _getDefaultTemplateCh2.box,
              content = _getDefaultTemplateCh2.content;

          setTransitionDuration([box, content], 0);
        }

        onFirstUpdate = function onFirstUpdate() {
          var _instance$popperInsta2;

          if (!instance.state.isVisible || ignoreOnFirstUpdate) {
            return;
          }

          ignoreOnFirstUpdate = true; // reflow

          void popper.offsetHeight;
          popper.style.transition = instance.props.moveTransition;

          if (getIsDefaultRenderFn() && instance.props.animation) {
            var _getDefaultTemplateCh3 = getDefaultTemplateChildren(),
                _box = _getDefaultTemplateCh3.box,
                _content = _getDefaultTemplateCh3.content;

            setTransitionDuration([_box, _content], duration);
            setVisibilityState([_box, _content], 'visible');
          }

          handleAriaContentAttribute();
          handleAriaExpandedAttribute();
          pushIfUnique(mountedInstances, instance); // certain modifiers (e.g. `maxSize`) require a second update after the
          // popper has been positioned for the first time

          (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
          instance.state.isMounted = true;
          invokeHook('onMount', [instance]);

          if (instance.props.animation && getIsDefaultRenderFn()) {
            onTransitionedIn(duration, function () {
              instance.state.isShown = true;
              invokeHook('onShown', [instance]);
            });
          }
        };

        mount();
      }

      function hide() {


        var isAlreadyHidden = !instance.state.isVisible;
        var isDestroyed = instance.state.isDestroyed;
        var isDisabled = !instance.state.isEnabled;
        var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);

        if (isAlreadyHidden || isDestroyed || isDisabled) {
          return;
        }

        invokeHook('onHide', [instance], false);

        if (instance.props.onHide(instance) === false) {
          return;
        }

        instance.state.isVisible = false;
        instance.state.isShown = false;
        ignoreOnFirstUpdate = false;
        isVisibleFromClick = false;

        if (getIsDefaultRenderFn()) {
          popper.style.visibility = 'hidden';
        }

        cleanupInteractiveMouseListeners();
        removeDocumentPress();
        handleStyles();

        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh4 = getDefaultTemplateChildren(),
              box = _getDefaultTemplateCh4.box,
              content = _getDefaultTemplateCh4.content;

          if (instance.props.animation) {
            setTransitionDuration([box, content], duration);
            setVisibilityState([box, content], 'hidden');
          }
        }

        handleAriaContentAttribute();
        handleAriaExpandedAttribute();

        if (instance.props.animation) {
          if (getIsDefaultRenderFn()) {
            onTransitionedOut(duration, instance.unmount);
          }
        } else {
          instance.unmount();
        }
      }

      function hideWithInteractivity(event) {

        getDocument().addEventListener('mousemove', debouncedOnMouseMove);
        pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
        debouncedOnMouseMove(event);
      }

      function unmount() {

        if (instance.state.isVisible) {
          instance.hide();
        }

        if (!instance.state.isMounted) {
          return;
        }

        destroyPopperInstance(); // If a popper is not interactive, it will be appended outside the popper
        // tree by default. This seems mainly for interactive tippies, but we should
        // find a workaround if possible

        getNestedPopperTree().forEach(function (nestedPopper) {
          nestedPopper._tippy.unmount();
        });

        if (popper.parentNode) {
          popper.parentNode.removeChild(popper);
        }

        mountedInstances = mountedInstances.filter(function (i) {
          return i !== instance;
        });
        instance.state.isMounted = false;
        invokeHook('onHidden', [instance]);
      }

      function destroy() {

        if (instance.state.isDestroyed) {
          return;
        }

        instance.clearDelayTimeouts();
        instance.unmount();
        removeListeners();
        delete reference._tippy;
        instance.state.isDestroyed = true;
        invokeHook('onDestroy', [instance]);
      }
    }

    function tippy(targets, optionalProps) {
      if (optionalProps === void 0) {
        optionalProps = {};
      }

      var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);

      bindGlobalEventListeners();
      var passedProps = Object.assign({}, optionalProps, {
        plugins: plugins
      });
      var elements = getArrayOfElements(targets);

      var instances = elements.reduce(function (acc, reference) {
        var instance = reference && createTippy(reference, passedProps);

        if (instance) {
          acc.push(instance);
        }

        return acc;
      }, []);
      return isElement(targets) ? instances[0] : instances;
    }

    tippy.defaultProps = defaultProps;
    tippy.setDefaultProps = setDefaultProps;
    tippy.currentInput = currentInput;

    // every time the popper is destroyed (i.e. a new target), removing the styles
    // and causing transitions to break for singletons when the console is open, but
    // most notably for non-transform styles being used, `gpuAcceleration: false`.

    var applyStylesModifier = Object.assign({}, applyStyles$1, {
      effect: function effect(_ref) {
        var state = _ref.state;
        var initialStyles = {
          popper: {
            position: state.options.strategy,
            left: '0',
            top: '0',
            margin: '0'
          },
          arrow: {
            position: 'absolute'
          },
          reference: {}
        };
        Object.assign(state.elements.popper.style, initialStyles.popper);
        state.styles = initialStyles;

        if (state.elements.arrow) {
          Object.assign(state.elements.arrow.style, initialStyles.arrow);
        } // intentionally return no cleanup function
        // return () => { ... }

      }
    });

    var createSingleton = function createSingleton(tippyInstances, optionalProps) {
      var _optionalProps$popper;

      if (optionalProps === void 0) {
        optionalProps = {};
      }

      var individualInstances = tippyInstances;
      var references = [];
      var currentTarget;
      var overrides = optionalProps.overrides;
      var interceptSetPropsCleanups = [];
      var shownOnCreate = false;

      function setReferences() {
        references = individualInstances.map(function (instance) {
          return instance.reference;
        });
      }

      function enableInstances(isEnabled) {
        individualInstances.forEach(function (instance) {
          if (isEnabled) {
            instance.enable();
          } else {
            instance.disable();
          }
        });
      }

      function interceptSetProps(singleton) {
        return individualInstances.map(function (instance) {
          var originalSetProps = instance.setProps;

          instance.setProps = function (props) {
            originalSetProps(props);

            if (instance.reference === currentTarget) {
              singleton.setProps(props);
            }
          };

          return function () {
            instance.setProps = originalSetProps;
          };
        });
      } // have to pass singleton, as it maybe undefined on first call


      function prepareInstance(singleton, target) {
        var index = references.indexOf(target); // bail-out

        if (target === currentTarget) {
          return;
        }

        currentTarget = target;
        var overrideProps = (overrides || []).concat('content').reduce(function (acc, prop) {
          acc[prop] = individualInstances[index].props[prop];
          return acc;
        }, {});
        singleton.setProps(Object.assign({}, overrideProps, {
          getReferenceClientRect: typeof overrideProps.getReferenceClientRect === 'function' ? overrideProps.getReferenceClientRect : function () {
            return target.getBoundingClientRect();
          }
        }));
      }

      enableInstances(false);
      setReferences();
      var plugin = {
        fn: function fn() {
          return {
            onDestroy: function onDestroy() {
              enableInstances(true);
            },
            onHidden: function onHidden() {
              currentTarget = null;
            },
            onClickOutside: function onClickOutside(instance) {
              if (instance.props.showOnCreate && !shownOnCreate) {
                shownOnCreate = true;
                currentTarget = null;
              }
            },
            onShow: function onShow(instance) {
              if (instance.props.showOnCreate && !shownOnCreate) {
                shownOnCreate = true;
                prepareInstance(instance, references[0]);
              }
            },
            onTrigger: function onTrigger(instance, event) {
              prepareInstance(instance, event.currentTarget);
            }
          };
        }
      };
      var singleton = tippy(div(), Object.assign({}, removeProperties(optionalProps, ['overrides']), {
        plugins: [plugin].concat(optionalProps.plugins || []),
        triggerTarget: references,
        popperOptions: Object.assign({}, optionalProps.popperOptions, {
          modifiers: [].concat(((_optionalProps$popper = optionalProps.popperOptions) == null ? void 0 : _optionalProps$popper.modifiers) || [], [applyStylesModifier])
        })
      }));
      var originalShow = singleton.show;

      singleton.show = function (target) {
        originalShow(); // first time, showOnCreate or programmatic call with no params
        // default to showing first instance

        if (!currentTarget && target == null) {
          return prepareInstance(singleton, references[0]);
        } // triggered from event (do nothing as prepareInstance already called by onTrigger)
        // programmatic call with no params when already visible (do nothing again)


        if (currentTarget && target == null) {
          return;
        } // target is index of instance


        if (typeof target === 'number') {
          return references[target] && prepareInstance(singleton, references[target]);
        } // target is a child tippy instance


        if (individualInstances.includes(target)) {
          var ref = target.reference;
          return prepareInstance(singleton, ref);
        } // target is a ReferenceElement


        if (references.includes(target)) {
          return prepareInstance(singleton, target);
        }
      };

      singleton.showNext = function () {
        var first = references[0];

        if (!currentTarget) {
          return singleton.show(0);
        }

        var index = references.indexOf(currentTarget);
        singleton.show(references[index + 1] || first);
      };

      singleton.showPrevious = function () {
        var last = references[references.length - 1];

        if (!currentTarget) {
          return singleton.show(last);
        }

        var index = references.indexOf(currentTarget);
        var target = references[index - 1] || last;
        singleton.show(target);
      };

      var originalSetProps = singleton.setProps;

      singleton.setProps = function (props) {
        overrides = props.overrides || overrides;
        originalSetProps(props);
      };

      singleton.setInstances = function (nextInstances) {
        enableInstances(true);
        interceptSetPropsCleanups.forEach(function (fn) {
          return fn();
        });
        individualInstances = nextInstances;
        enableInstances(false);
        setReferences();
        interceptSetProps(singleton);
        singleton.setProps({
          triggerTarget: references
        });
      };

      interceptSetPropsCleanups = interceptSetProps(singleton);
      return singleton;
    };

    tippy.setDefaultProps({
      render: render
    });

    function useTooltip(selectors, ctx, options = {}) {
        const elementsRefs = selectors.map(selector => queryAll(selector));
        let singleton = null;
        let instances = null;
        const createTooltip = () => {
            const root = closestElement('.vuerd-editor', ctx);
            const elements = [
                ...flat(elementsRefs.map(ref => ref.value).filter(elements => isArray$4(elements))),
            ];
            instances = tippy(elements, {
                appendTo: root !== null && root !== void 0 ? root : 'parent',
                trigger: 'manual',
            });
            singleton = createSingleton(instances, Object.assign({
                appendTo: root !== null && root !== void 0 ? root : 'parent',
                delay: [500, 100],
                moveTransition: 'transform 0.4s cubic-bezier(0.22, 1, 0.36, 1)',
            }, options));
        };
        const destroyTooltip = () => {
            singleton === null || singleton === void 0 ? void 0 : singleton.destroy();
            instances === null || instances === void 0 ? void 0 : instances.forEach(instance => instance.destroy());
            singleton = null;
            instances = null;
        };
        const resetTooltip = () => {
            destroyTooltip();
            createTooltip();
        };
        mounted(createTooltip);
        unmounted(destroyTooltip);
        return {
            resetTooltip,
        };
    }

    function useUnmounted() {
        const unmountedGroup = [];
        unmounted(() => {
            while (unmountedGroup.length) {
                const f = unmountedGroup.pop();
                isFunction$4(f) ? f() : f.unsubscribe();
            }
        });
        return {
            unmountedGroup,
        };
    }

    const ContextmenuStyle = css `
  .vuerd-contextmenu {
    position: fixed;
    z-index: 1;
    opacity: 0.9;
    color: var(--vuerd-color-font);
    fill: var(--vuerd-color-font);
    background-color: var(--vuerd-color-contextmenu);
    list-style: none;
    padding: 0;
    margin: 0;
    display: flex;
    flex-direction: column;
    font-family: var(--vuerd-font-family) !important;
  }
  .vuerd-contextmenu > li {
    height: ${SIZE_CONTEXTMENU_HEIGHT}px;
    padding: 10px 5px 10px 10px;
    box-sizing: border-box;
    cursor: pointer;
    font-size: ${SIZE_FONT}px;
    white-space: nowrap;
    display: flex;
    flex-direction: row;
    align-items: center;
  }
  .vuerd-contextmenu > li:hover {
    color: var(--vuerd-color-font-active);
    fill: var(--vuerd-color-font-active);
    background-color: var(--vuerd-color-contextmenu-active);
  }
  .vuerd-contextmenu > li > span {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    padding-right: 5px;
  }
  .vuerd-contextmenu > li > span.icon,
  .vuerd-contextmenu > li > span.icon > img {
    width: 18px;
    display: flex;
    align-items: center;
  }
  .vuerd-contextmenu > li > span.name {
    width: 70px;
  }
  .vuerd-contextmenu > li > span.keymap {
    width: 60px;
    display: inline-block;
    padding-right: 0;
  }
  .vuerd-contextmenu > li > span.arrow {
    width: 13px;
    padding-right: 0;
  }
`;

    const iconTpl = (menu) => menu.icon
        ? html `
        <span class="icon">
          <vuerd-icon
            .prefix=${menu.icon.prefix}
            .size=${menu.icon.size || 14}
            name=${menu.icon.name}
          >
          </vuerd-icon>
        </span>
      `
        : menu.iconBase64
            ? html `
        <span class="icon">
          <img src=${menu.iconBase64} />
        </span>
      `
            : html `<span class="icon"></span>`;

    const Contextmenu$1 = (props, ctx) => {
        const state = observable$1({ menu: null });
        const rootRef = query('.vuerd-contextmenu');
        const { unmountedGroup } = useUnmounted();
        const { resetTooltip } = useTooltip(['.keymap'], ctx);
        const childrenX = () => {
            const ul = rootRef.value;
            return ul ? props.x + ul.clientWidth : props.x;
        };
        const childrenY = () => state.menu
            ? props.y + props.menus.indexOf(state.menu) * SIZE_CONTEXTMENU_HEIGHT
            : props.y;
        const onMouseover = (menu) => (state.menu = menu);
        const onClose = () => ctx.dispatchEvent(new CustomEvent('close'));
        const onExecute = (menu) => {
            var _a;
            if (!menu.execute || ((_a = menu.children) === null || _a === void 0 ? void 0 : _a.length))
                return;
            menu.execute();
            if (!menu.options || menu.options.close !== false) {
                onClose();
            }
        };
        const createContextmenuEvent = (eventName) => (event) => {
            event.stopPropagation();
            ctx.dispatchEvent(new CustomEvent(eventName, {
                composed: true,
                bubbles: true,
            }));
        };
        const onMousedown = createContextmenuEvent('vuerd-contextmenu-mousedown');
        const onTouchstart = createContextmenuEvent('vuerd-contextmenu-touchstart');
        unmountedGroup.push(watch(props, propName => {
            if (propName !== 'menus')
                return;
            state.menu = null;
            resetTooltip();
        }));
        unmounted(() => (state.menu = null));
        return () => {
            var _a, _b;
            return html `
      <ul
        class="vuerd-contextmenu"
        style=${styleMap({
            left: `${props.x}px`,
            top: `${props.y}px`,
        })}
        @mousedown=${onMousedown}
        @touchstart=${onTouchstart}
      >
        ${props.menus.map(menu => {
            var _a, _b, _c, _d;
            return html `
            <li
              @mouseover=${() => onMouseover(menu)}
              @click=${() => onExecute(menu)}
            >
              ${iconTpl(menu)}
              <span
                class="name"
                style=${styleMap({
                width: `${(_b = (_a = menu.options) === null || _a === void 0 ? void 0 : _a.nameWidth) !== null && _b !== void 0 ? _b : 70}px`,
            })}
                title=${menu.name}
              >
                ${menu.name}
              </span>
              <span
                class="keymap"
                style=${styleMap({
                width: `${(_d = (_c = menu.options) === null || _c === void 0 ? void 0 : _c.keymapWidth) !== null && _d !== void 0 ? _d : 60}px`,
            })}
                data-tippy-content=${menu.keymapTooltip
                ? menu.keymapTooltip
                : ''}
              >
                ${menu.keymap}
              </span>
              ${menu.children && menu.children.length
                ? html `
                    <span class="arrow">
                      <vuerd-icon size="13" name="chevron-right"></vuerd-icon>
                    </span>
                  `
                : null}
            </li>
          `;
        })}
      </ul>
      ${((_b = (_a = state.menu) === null || _a === void 0 ? void 0 : _a.children) === null || _b === void 0 ? void 0 : _b.length)
            ? html `
            <vuerd-contextmenu
              .menus=${state.menu.children}
              .x=${childrenX()}
              .y=${childrenY()}
              @close=${onClose}
            ></vuerd-contextmenu>
          `
            : null}
    `;
        };
    };
    defineComponent('vuerd-contextmenu', {
        observedProps: [
            {
                name: 'x',
                type: Number,
                default: 0,
            },
            {
                name: 'y',
                type: Number,
                default: 0,
            },
            'menus',
        ],
        style: ContextmenuStyle,
        render: Contextmenu$1,
    });

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spreadArray$1(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
        return to;
    }

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function isFunction$3(value) {
        return typeof value === 'function';
    }

    function createErrorClass(createImpl) {
        var _super = function (instance) {
            Error.call(instance);
            instance.stack = new Error().stack;
        };
        var ctorFunc = createImpl(_super);
        ctorFunc.prototype = Object.create(Error.prototype);
        ctorFunc.prototype.constructor = ctorFunc;
        return ctorFunc;
    }

    var UnsubscriptionError = createErrorClass(function (_super) {
        return function UnsubscriptionErrorImpl(errors) {
            _super(this);
            this.message = errors
                ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ')
                : '';
            this.name = 'UnsubscriptionError';
            this.errors = errors;
        };
    });

    function arrRemove(arr, item) {
        if (arr) {
            var index = arr.indexOf(item);
            0 <= index && arr.splice(index, 1);
        }
    }

    var Subscription = (function () {
        function Subscription(initialTeardown) {
            this.initialTeardown = initialTeardown;
            this.closed = false;
            this._parentage = null;
            this._teardowns = null;
        }
        Subscription.prototype.unsubscribe = function () {
            var e_1, _a, e_2, _b;
            var errors;
            if (!this.closed) {
                this.closed = true;
                var _parentage = this._parentage;
                if (_parentage) {
                    this._parentage = null;
                    if (Array.isArray(_parentage)) {
                        try {
                            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                                var parent_1 = _parentage_1_1.value;
                                parent_1.remove(this);
                            }
                        }
                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
                        finally {
                            try {
                                if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
                            }
                            finally { if (e_1) throw e_1.error; }
                        }
                    }
                    else {
                        _parentage.remove(this);
                    }
                }
                var initialTeardown = this.initialTeardown;
                if (isFunction$3(initialTeardown)) {
                    try {
                        initialTeardown();
                    }
                    catch (e) {
                        errors = e instanceof UnsubscriptionError ? e.errors : [e];
                    }
                }
                var _teardowns = this._teardowns;
                if (_teardowns) {
                    this._teardowns = null;
                    try {
                        for (var _teardowns_1 = __values(_teardowns), _teardowns_1_1 = _teardowns_1.next(); !_teardowns_1_1.done; _teardowns_1_1 = _teardowns_1.next()) {
                            var teardown_1 = _teardowns_1_1.value;
                            try {
                                execTeardown(teardown_1);
                            }
                            catch (err) {
                                errors = errors !== null && errors !== void 0 ? errors : [];
                                if (err instanceof UnsubscriptionError) {
                                    errors = __spreadArray$1(__spreadArray$1([], __read(errors)), __read(err.errors));
                                }
                                else {
                                    errors.push(err);
                                }
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_teardowns_1_1 && !_teardowns_1_1.done && (_b = _teardowns_1.return)) _b.call(_teardowns_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
                if (errors) {
                    throw new UnsubscriptionError(errors);
                }
            }
        };
        Subscription.prototype.add = function (teardown) {
            var _a;
            if (teardown && teardown !== this) {
                if (this.closed) {
                    execTeardown(teardown);
                }
                else {
                    if (teardown instanceof Subscription) {
                        if (teardown.closed || teardown._hasParent(this)) {
                            return;
                        }
                        teardown._addParent(this);
                    }
                    (this._teardowns = (_a = this._teardowns) !== null && _a !== void 0 ? _a : []).push(teardown);
                }
            }
        };
        Subscription.prototype._hasParent = function (parent) {
            var _parentage = this._parentage;
            return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));
        };
        Subscription.prototype._addParent = function (parent) {
            var _parentage = this._parentage;
            this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
        };
        Subscription.prototype._removeParent = function (parent) {
            var _parentage = this._parentage;
            if (_parentage === parent) {
                this._parentage = null;
            }
            else if (Array.isArray(_parentage)) {
                arrRemove(_parentage, parent);
            }
        };
        Subscription.prototype.remove = function (teardown) {
            var _teardowns = this._teardowns;
            _teardowns && arrRemove(_teardowns, teardown);
            if (teardown instanceof Subscription) {
                teardown._removeParent(this);
            }
        };
        Subscription.EMPTY = (function () {
            var empty = new Subscription();
            empty.closed = true;
            return empty;
        })();
        return Subscription;
    }());
    var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
    function isSubscription(value) {
        return (value instanceof Subscription ||
            (value && 'closed' in value && isFunction$3(value.remove) && isFunction$3(value.add) && isFunction$3(value.unsubscribe)));
    }
    function execTeardown(teardown) {
        if (isFunction$3(teardown)) {
            teardown();
        }
        else {
            teardown.unsubscribe();
        }
    }

    var config = {
        onUnhandledError: null,
        onStoppedNotification: null,
        Promise: undefined,
        useDeprecatedSynchronousErrorHandling: false,
        useDeprecatedNextContext: false,
    };

    var timeoutProvider = {
        setTimeout: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var delegate = timeoutProvider.delegate;
            return ((delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) || setTimeout).apply(void 0, __spreadArray$1([], __read(args)));
        },
        clearTimeout: function (handle) {
            var delegate = timeoutProvider.delegate;
            return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
        },
        delegate: undefined,
    };

    function reportUnhandledError(err) {
        timeoutProvider.setTimeout(function () {
            {
                throw err;
            }
        });
    }

    function noop$1() { }

    var context = null;
    function errorContext(cb) {
        if (config.useDeprecatedSynchronousErrorHandling) {
            var isRoot = !context;
            if (isRoot) {
                context = { errorThrown: false, error: null };
            }
            cb();
            if (isRoot) {
                var _a = context, errorThrown = _a.errorThrown, error = _a.error;
                context = null;
                if (errorThrown) {
                    throw error;
                }
            }
        }
        else {
            cb();
        }
    }

    var Subscriber = (function (_super) {
        __extends(Subscriber, _super);
        function Subscriber(destination) {
            var _this = _super.call(this) || this;
            _this.isStopped = false;
            if (destination) {
                _this.destination = destination;
                if (isSubscription(destination)) {
                    destination.add(_this);
                }
            }
            else {
                _this.destination = EMPTY_OBSERVER;
            }
            return _this;
        }
        Subscriber.create = function (next, error, complete) {
            return new SafeSubscriber(next, error, complete);
        };
        Subscriber.prototype.next = function (value) {
            if (this.isStopped) ;
            else {
                this._next(value);
            }
        };
        Subscriber.prototype.error = function (err) {
            if (this.isStopped) ;
            else {
                this.isStopped = true;
                this._error(err);
            }
        };
        Subscriber.prototype.complete = function () {
            if (this.isStopped) ;
            else {
                this.isStopped = true;
                this._complete();
            }
        };
        Subscriber.prototype.unsubscribe = function () {
            if (!this.closed) {
                this.isStopped = true;
                _super.prototype.unsubscribe.call(this);
                this.destination = null;
            }
        };
        Subscriber.prototype._next = function (value) {
            this.destination.next(value);
        };
        Subscriber.prototype._error = function (err) {
            try {
                this.destination.error(err);
            }
            finally {
                this.unsubscribe();
            }
        };
        Subscriber.prototype._complete = function () {
            try {
                this.destination.complete();
            }
            finally {
                this.unsubscribe();
            }
        };
        return Subscriber;
    }(Subscription));
    var SafeSubscriber = (function (_super) {
        __extends(SafeSubscriber, _super);
        function SafeSubscriber(observerOrNext, error, complete) {
            var _this = _super.call(this) || this;
            var next;
            if (isFunction$3(observerOrNext)) {
                next = observerOrNext;
            }
            else if (observerOrNext) {
                (next = observerOrNext.next, error = observerOrNext.error, complete = observerOrNext.complete);
                var context_1;
                if (_this && config.useDeprecatedNextContext) {
                    context_1 = Object.create(observerOrNext);
                    context_1.unsubscribe = function () { return _this.unsubscribe(); };
                }
                else {
                    context_1 = observerOrNext;
                }
                next = next === null || next === void 0 ? void 0 : next.bind(context_1);
                error = error === null || error === void 0 ? void 0 : error.bind(context_1);
                complete = complete === null || complete === void 0 ? void 0 : complete.bind(context_1);
            }
            _this.destination = {
                next: next ? wrapForErrorHandling(next) : noop$1,
                error: wrapForErrorHandling(error !== null && error !== void 0 ? error : defaultErrorHandler),
                complete: complete ? wrapForErrorHandling(complete) : noop$1,
            };
            return _this;
        }
        return SafeSubscriber;
    }(Subscriber));
    function wrapForErrorHandling(handler, instance) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            try {
                handler.apply(void 0, __spreadArray$1([], __read(args)));
            }
            catch (err) {
                {
                    reportUnhandledError(err);
                }
            }
        };
    }
    function defaultErrorHandler(err) {
        throw err;
    }
    var EMPTY_OBSERVER = {
        closed: true,
        next: noop$1,
        error: defaultErrorHandler,
        complete: noop$1,
    };

    var observable = (function () { return (typeof Symbol === 'function' && Symbol.observable) || '@@observable'; })();

    function identity$1(x) {
        return x;
    }

    function pipeFromArray(fns) {
        if (fns.length === 0) {
            return identity$1;
        }
        if (fns.length === 1) {
            return fns[0];
        }
        return function piped(input) {
            return fns.reduce(function (prev, fn) { return fn(prev); }, input);
        };
    }

    var Observable = (function () {
        function Observable(subscribe) {
            if (subscribe) {
                this._subscribe = subscribe;
            }
        }
        Observable.prototype.lift = function (operator) {
            var observable = new Observable();
            observable.source = this;
            observable.operator = operator;
            return observable;
        };
        Observable.prototype.subscribe = function (observerOrNext, error, complete) {
            var _this = this;
            var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
            errorContext(function () {
                var _a = _this, operator = _a.operator, source = _a.source;
                subscriber.add(operator
                    ?
                        operator.call(subscriber, source)
                    : source
                        ?
                            _this._subscribe(subscriber)
                        :
                            _this._trySubscribe(subscriber));
            });
            return subscriber;
        };
        Observable.prototype._trySubscribe = function (sink) {
            try {
                return this._subscribe(sink);
            }
            catch (err) {
                sink.error(err);
            }
        };
        Observable.prototype.forEach = function (next, promiseCtor) {
            var _this = this;
            promiseCtor = getPromiseCtor(promiseCtor);
            return new promiseCtor(function (resolve, reject) {
                var subscription;
                subscription = _this.subscribe(function (value) {
                    try {
                        next(value);
                    }
                    catch (err) {
                        reject(err);
                        subscription === null || subscription === void 0 ? void 0 : subscription.unsubscribe();
                    }
                }, reject, resolve);
            });
        };
        Observable.prototype._subscribe = function (subscriber) {
            var _a;
            return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
        };
        Observable.prototype[observable] = function () {
            return this;
        };
        Observable.prototype.pipe = function () {
            var operations = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                operations[_i] = arguments[_i];
            }
            return pipeFromArray(operations)(this);
        };
        Observable.prototype.toPromise = function (promiseCtor) {
            var _this = this;
            promiseCtor = getPromiseCtor(promiseCtor);
            return new promiseCtor(function (resolve, reject) {
                var value;
                _this.subscribe(function (x) { return (value = x); }, function (err) { return reject(err); }, function () { return resolve(value); });
            });
        };
        Observable.create = function (subscribe) {
            return new Observable(subscribe);
        };
        return Observable;
    }());
    function getPromiseCtor(promiseCtor) {
        var _a;
        return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
    }
    function isObserver(value) {
        return value && isFunction$3(value.next) && isFunction$3(value.error) && isFunction$3(value.complete);
    }
    function isSubscriber(value) {
        return (value && value instanceof Subscriber) || (isObserver(value) && isSubscription(value));
    }

    function hasLift(source) {
        return isFunction$3(source === null || source === void 0 ? void 0 : source.lift);
    }
    function operate(init) {
        return function (source) {
            if (hasLift(source)) {
                return source.lift(function (liftedSource) {
                    try {
                        return init(liftedSource, this);
                    }
                    catch (err) {
                        this.error(err);
                    }
                });
            }
            throw new TypeError('Unable to lift unknown Observable type');
        };
    }

    var OperatorSubscriber = (function (_super) {
        __extends(OperatorSubscriber, _super);
        function OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
            var _this = _super.call(this, destination) || this;
            _this.onFinalize = onFinalize;
            _this._next = onNext
                ? function (value) {
                    try {
                        onNext(value);
                    }
                    catch (err) {
                        destination.error(err);
                    }
                }
                : _super.prototype._next;
            _this._error = onError
                ? function (err) {
                    try {
                        onError(err);
                    }
                    catch (err) {
                        destination.error(err);
                    }
                    finally {
                        this.unsubscribe();
                    }
                }
                : _super.prototype._error;
            _this._complete = onComplete
                ? function () {
                    try {
                        onComplete();
                    }
                    catch (err) {
                        destination.error(err);
                    }
                    finally {
                        this.unsubscribe();
                    }
                }
                : _super.prototype._complete;
            return _this;
        }
        OperatorSubscriber.prototype.unsubscribe = function () {
            var _a;
            var closed = this.closed;
            _super.prototype.unsubscribe.call(this);
            !closed && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
        };
        return OperatorSubscriber;
    }(Subscriber));

    var ObjectUnsubscribedError = createErrorClass(function (_super) {
        return function ObjectUnsubscribedErrorImpl() {
            _super(this);
            this.name = 'ObjectUnsubscribedError';
            this.message = 'object unsubscribed';
        };
    });

    var Subject = (function (_super) {
        __extends(Subject, _super);
        function Subject() {
            var _this = _super.call(this) || this;
            _this.closed = false;
            _this.observers = [];
            _this.isStopped = false;
            _this.hasError = false;
            _this.thrownError = null;
            return _this;
        }
        Subject.prototype.lift = function (operator) {
            var subject = new AnonymousSubject(this, this);
            subject.operator = operator;
            return subject;
        };
        Subject.prototype._throwIfClosed = function () {
            if (this.closed) {
                throw new ObjectUnsubscribedError();
            }
        };
        Subject.prototype.next = function (value) {
            var _this = this;
            errorContext(function () {
                var e_1, _a;
                _this._throwIfClosed();
                if (!_this.isStopped) {
                    var copy = _this.observers.slice();
                    try {
                        for (var copy_1 = __values(copy), copy_1_1 = copy_1.next(); !copy_1_1.done; copy_1_1 = copy_1.next()) {
                            var observer = copy_1_1.value;
                            observer.next(value);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (copy_1_1 && !copy_1_1.done && (_a = copy_1.return)) _a.call(copy_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
            });
        };
        Subject.prototype.error = function (err) {
            var _this = this;
            errorContext(function () {
                _this._throwIfClosed();
                if (!_this.isStopped) {
                    _this.hasError = _this.isStopped = true;
                    _this.thrownError = err;
                    var observers = _this.observers;
                    while (observers.length) {
                        observers.shift().error(err);
                    }
                }
            });
        };
        Subject.prototype.complete = function () {
            var _this = this;
            errorContext(function () {
                _this._throwIfClosed();
                if (!_this.isStopped) {
                    _this.isStopped = true;
                    var observers = _this.observers;
                    while (observers.length) {
                        observers.shift().complete();
                    }
                }
            });
        };
        Subject.prototype.unsubscribe = function () {
            this.isStopped = this.closed = true;
            this.observers = null;
        };
        Object.defineProperty(Subject.prototype, "observed", {
            get: function () {
                var _a;
                return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
            },
            enumerable: false,
            configurable: true
        });
        Subject.prototype._trySubscribe = function (subscriber) {
            this._throwIfClosed();
            return _super.prototype._trySubscribe.call(this, subscriber);
        };
        Subject.prototype._subscribe = function (subscriber) {
            this._throwIfClosed();
            this._checkFinalizedStatuses(subscriber);
            return this._innerSubscribe(subscriber);
        };
        Subject.prototype._innerSubscribe = function (subscriber) {
            var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
            return hasError || isStopped
                ? EMPTY_SUBSCRIPTION
                : (observers.push(subscriber), new Subscription(function () { return arrRemove(observers, subscriber); }));
        };
        Subject.prototype._checkFinalizedStatuses = function (subscriber) {
            var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
            if (hasError) {
                subscriber.error(thrownError);
            }
            else if (isStopped) {
                subscriber.complete();
            }
        };
        Subject.prototype.asObservable = function () {
            var observable = new Observable();
            observable.source = this;
            return observable;
        };
        Subject.create = function (destination, source) {
            return new AnonymousSubject(destination, source);
        };
        return Subject;
    }(Observable));
    var AnonymousSubject = (function (_super) {
        __extends(AnonymousSubject, _super);
        function AnonymousSubject(destination, source) {
            var _this = _super.call(this) || this;
            _this.destination = destination;
            _this.source = source;
            return _this;
        }
        AnonymousSubject.prototype.next = function (value) {
            var _a, _b;
            (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
        };
        AnonymousSubject.prototype.error = function (err) {
            var _a, _b;
            (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
        };
        AnonymousSubject.prototype.complete = function () {
            var _a, _b;
            (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
        };
        AnonymousSubject.prototype._subscribe = function (subscriber) {
            var _a, _b;
            return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
        };
        return AnonymousSubject;
    }(Subject));

    var dateTimestampProvider = {
        now: function () {
            return (dateTimestampProvider.delegate || Date).now();
        },
        delegate: undefined,
    };

    var Action = (function (_super) {
        __extends(Action, _super);
        function Action(scheduler, work) {
            return _super.call(this) || this;
        }
        Action.prototype.schedule = function (state, delay) {
            return this;
        };
        return Action;
    }(Subscription));

    var intervalProvider = {
        setInterval: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var delegate = intervalProvider.delegate;
            return ((delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) || setInterval).apply(void 0, __spreadArray$1([], __read(args)));
        },
        clearInterval: function (handle) {
            var delegate = intervalProvider.delegate;
            return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
        },
        delegate: undefined,
    };

    var AsyncAction = (function (_super) {
        __extends(AsyncAction, _super);
        function AsyncAction(scheduler, work) {
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            _this.pending = false;
            return _this;
        }
        AsyncAction.prototype.schedule = function (state, delay) {
            if (delay === void 0) { delay = 0; }
            if (this.closed) {
                return this;
            }
            this.state = state;
            var id = this.id;
            var scheduler = this.scheduler;
            if (id != null) {
                this.id = this.recycleAsyncId(scheduler, id, delay);
            }
            this.pending = true;
            this.delay = delay;
            this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
            return this;
        };
        AsyncAction.prototype.requestAsyncId = function (scheduler, _id, delay) {
            if (delay === void 0) { delay = 0; }
            return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
        };
        AsyncAction.prototype.recycleAsyncId = function (_scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            if (delay != null && this.delay === delay && this.pending === false) {
                return id;
            }
            intervalProvider.clearInterval(id);
            return undefined;
        };
        AsyncAction.prototype.execute = function (state, delay) {
            if (this.closed) {
                return new Error('executing a cancelled action');
            }
            this.pending = false;
            var error = this._execute(state, delay);
            if (error) {
                return error;
            }
            else if (this.pending === false && this.id != null) {
                this.id = this.recycleAsyncId(this.scheduler, this.id, null);
            }
        };
        AsyncAction.prototype._execute = function (state, _delay) {
            var errored = false;
            var errorValue;
            try {
                this.work(state);
            }
            catch (e) {
                errored = true;
                errorValue = (!!e && e) || new Error(e);
            }
            if (errored) {
                this.unsubscribe();
                return errorValue;
            }
        };
        AsyncAction.prototype.unsubscribe = function () {
            if (!this.closed) {
                var _a = this, id = _a.id, scheduler = _a.scheduler;
                var actions = scheduler.actions;
                this.work = this.state = this.scheduler = null;
                this.pending = false;
                arrRemove(actions, this);
                if (id != null) {
                    this.id = this.recycleAsyncId(scheduler, id, null);
                }
                this.delay = null;
                _super.prototype.unsubscribe.call(this);
            }
        };
        return AsyncAction;
    }(Action));

    var Scheduler = (function () {
        function Scheduler(schedulerActionCtor, now) {
            if (now === void 0) { now = Scheduler.now; }
            this.schedulerActionCtor = schedulerActionCtor;
            this.now = now;
        }
        Scheduler.prototype.schedule = function (work, delay, state) {
            if (delay === void 0) { delay = 0; }
            return new this.schedulerActionCtor(this, work).schedule(state, delay);
        };
        Scheduler.now = dateTimestampProvider.now;
        return Scheduler;
    }());

    var AsyncScheduler = (function (_super) {
        __extends(AsyncScheduler, _super);
        function AsyncScheduler(SchedulerAction, now) {
            if (now === void 0) { now = Scheduler.now; }
            var _this = _super.call(this, SchedulerAction, now) || this;
            _this.actions = [];
            _this._active = false;
            _this._scheduled = undefined;
            return _this;
        }
        AsyncScheduler.prototype.flush = function (action) {
            var actions = this.actions;
            if (this._active) {
                actions.push(action);
                return;
            }
            var error;
            this._active = true;
            do {
                if ((error = action.execute(action.state, action.delay))) {
                    break;
                }
            } while ((action = actions.shift()));
            this._active = false;
            if (error) {
                while ((action = actions.shift())) {
                    action.unsubscribe();
                }
                throw error;
            }
        };
        return AsyncScheduler;
    }(Scheduler));

    var asyncScheduler = new AsyncScheduler(AsyncAction);
    var async = asyncScheduler;

    var EMPTY = new Observable(function (subscriber) { return subscriber.complete(); });

    function scheduleArray(input, scheduler) {
        return new Observable(function (subscriber) {
            var i = 0;
            return scheduler.schedule(function () {
                if (i === input.length) {
                    subscriber.complete();
                }
                else {
                    subscriber.next(input[i++]);
                    if (!subscriber.closed) {
                        this.schedule();
                    }
                }
            });
        });
    }

    var isArrayLike$2 = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });

    function isPromise(value) {
        return isFunction$3(value === null || value === void 0 ? void 0 : value.then);
    }

    function getSymbolIterator() {
        if (typeof Symbol !== 'function' || !Symbol.iterator) {
            return '@@iterator';
        }
        return Symbol.iterator;
    }
    var iterator = getSymbolIterator();

    function isInteropObservable(input) {
        return isFunction$3(input[observable]);
    }

    function isIterable(input) {
        return isFunction$3(input === null || input === void 0 ? void 0 : input[iterator]);
    }

    function isAsyncIterable(obj) {
        return Symbol.asyncIterator && isFunction$3(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
    }

    function createInvalidObservableTypeError(input) {
        return new TypeError("You provided " + (input !== null && typeof input === 'object' ? 'an invalid object' : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
    }

    function readableStreamLikeToAsyncGenerator(readableStream) {
        return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
            var reader, _a, value, done;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        reader = readableStream.getReader();
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, , 9, 10]);
                        _b.label = 2;
                    case 2:
                        return [4, __await(reader.read())];
                    case 3:
                        _a = _b.sent(), value = _a.value, done = _a.done;
                        if (!done) return [3, 5];
                        return [4, __await(void 0)];
                    case 4: return [2, _b.sent()];
                    case 5: return [4, __await(value)];
                    case 6: return [4, _b.sent()];
                    case 7:
                        _b.sent();
                        return [3, 2];
                    case 8: return [3, 10];
                    case 9:
                        reader.releaseLock();
                        return [7];
                    case 10: return [2];
                }
            });
        });
    }
    function isReadableStreamLike(obj) {
        return isFunction$3(obj === null || obj === void 0 ? void 0 : obj.getReader);
    }

    function innerFrom(input) {
        if (input instanceof Observable) {
            return input;
        }
        if (input != null) {
            if (isInteropObservable(input)) {
                return fromInteropObservable(input);
            }
            if (isArrayLike$2(input)) {
                return fromArrayLike(input);
            }
            if (isPromise(input)) {
                return fromPromise(input);
            }
            if (isAsyncIterable(input)) {
                return fromAsyncIterable(input);
            }
            if (isIterable(input)) {
                return fromIterable(input);
            }
            if (isReadableStreamLike(input)) {
                return fromReadableStreamLike(input);
            }
        }
        throw createInvalidObservableTypeError(input);
    }
    function fromInteropObservable(obj) {
        return new Observable(function (subscriber) {
            var obs = obj[observable]();
            if (isFunction$3(obs.subscribe)) {
                return obs.subscribe(subscriber);
            }
            throw new TypeError('Provided object does not correctly implement Symbol.observable');
        });
    }
    function fromArrayLike(array) {
        return new Observable(function (subscriber) {
            for (var i = 0; i < array.length && !subscriber.closed; i++) {
                subscriber.next(array[i]);
            }
            subscriber.complete();
        });
    }
    function fromPromise(promise) {
        return new Observable(function (subscriber) {
            promise
                .then(function (value) {
                if (!subscriber.closed) {
                    subscriber.next(value);
                    subscriber.complete();
                }
            }, function (err) { return subscriber.error(err); })
                .then(null, reportUnhandledError);
        });
    }
    function fromIterable(iterable) {
        return new Observable(function (subscriber) {
            var e_1, _a;
            try {
                for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
                    var value = iterable_1_1.value;
                    subscriber.next(value);
                    if (subscriber.closed) {
                        return;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            subscriber.complete();
        });
    }
    function fromAsyncIterable(asyncIterable) {
        return new Observable(function (subscriber) {
            process$1(asyncIterable, subscriber).catch(function (err) { return subscriber.error(err); });
        });
    }
    function fromReadableStreamLike(readableStream) {
        return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
    }
    function process$1(asyncIterable, subscriber) {
        var asyncIterable_1, asyncIterable_1_1;
        var e_2, _a;
        return __awaiter(this, void 0, void 0, function () {
            var value, e_2_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 5, 6, 11]);
                        asyncIterable_1 = __asyncValues(asyncIterable);
                        _b.label = 1;
                    case 1: return [4, asyncIterable_1.next()];
                    case 2:
                        if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
                        value = asyncIterable_1_1.value;
                        subscriber.next(value);
                        if (subscriber.closed) {
                            return [2];
                        }
                        _b.label = 3;
                    case 3: return [3, 1];
                    case 4: return [3, 11];
                    case 5:
                        e_2_1 = _b.sent();
                        e_2 = { error: e_2_1 };
                        return [3, 11];
                    case 6:
                        _b.trys.push([6, , 9, 10]);
                        if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
                        return [4, _a.call(asyncIterable_1)];
                    case 7:
                        _b.sent();
                        _b.label = 8;
                    case 8: return [3, 10];
                    case 9:
                        if (e_2) throw e_2.error;
                        return [7];
                    case 10: return [7];
                    case 11:
                        subscriber.complete();
                        return [2];
                }
            });
        });
    }

    function internalFromArray(input, scheduler) {
        return scheduler ? scheduleArray(input, scheduler) : fromArrayLike(input);
    }

    function isScheduler(value) {
        return value && isFunction$3(value.schedule);
    }

    function last(arr) {
        return arr[arr.length - 1];
    }
    function popScheduler(args) {
        return isScheduler(last(args)) ? args.pop() : undefined;
    }
    function popNumber(args, defaultValue) {
        return typeof last(args) === 'number' ? args.pop() : defaultValue;
    }

    function isValidDate(value) {
        return value instanceof Date && !isNaN(value);
    }

    function map(project, thisArg) {
        return operate(function (source, subscriber) {
            var index = 0;
            source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                subscriber.next(project.call(thisArg, value, index++));
            }));
        });
    }

    var isArray$3 = Array.isArray;
    function callOrApply(fn, args) {
        return isArray$3(args) ? fn.apply(void 0, __spreadArray$1([], __read(args))) : fn(args);
    }
    function mapOneOrManyArgs(fn) {
        return map(function (args) { return callOrApply(fn, args); });
    }

    function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalTeardown) {
        var buffer = [];
        var active = 0;
        var index = 0;
        var isComplete = false;
        var checkComplete = function () {
            if (isComplete && !buffer.length && !active) {
                subscriber.complete();
            }
        };
        var outerNext = function (value) { return (active < concurrent ? doInnerSub(value) : buffer.push(value)); };
        var doInnerSub = function (value) {
            expand && subscriber.next(value);
            active++;
            var innerComplete = false;
            innerFrom(project(value, index++)).subscribe(new OperatorSubscriber(subscriber, function (innerValue) {
                onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
                if (expand) {
                    outerNext(innerValue);
                }
                else {
                    subscriber.next(innerValue);
                }
            }, function () {
                innerComplete = true;
            }, undefined, function () {
                if (innerComplete) {
                    try {
                        active--;
                        var _loop_1 = function () {
                            var bufferedValue = buffer.shift();
                            innerSubScheduler ? subscriber.add(innerSubScheduler.schedule(function () { return doInnerSub(bufferedValue); })) : doInnerSub(bufferedValue);
                        };
                        while (buffer.length && active < concurrent) {
                            _loop_1();
                        }
                        checkComplete();
                    }
                    catch (err) {
                        subscriber.error(err);
                    }
                }
            }));
        };
        source.subscribe(new OperatorSubscriber(subscriber, outerNext, function () {
            isComplete = true;
            checkComplete();
        }));
        return function () {
            additionalTeardown === null || additionalTeardown === void 0 ? void 0 : additionalTeardown();
        };
    }

    function mergeMap(project, resultSelector, concurrent) {
        if (concurrent === void 0) { concurrent = Infinity; }
        if (isFunction$3(resultSelector)) {
            return mergeMap(function (a, i) { return map(function (b, ii) { return resultSelector(a, b, i, ii); })(innerFrom(project(a, i))); }, concurrent);
        }
        else if (typeof resultSelector === 'number') {
            concurrent = resultSelector;
        }
        return operate(function (source, subscriber) { return mergeInternals(source, subscriber, project, concurrent); });
    }

    function mergeAll(concurrent) {
        if (concurrent === void 0) { concurrent = Infinity; }
        return mergeMap(identity$1, concurrent);
    }

    var nodeEventEmitterMethods = ['addListener', 'removeListener'];
    var eventTargetMethods = ['addEventListener', 'removeEventListener'];
    var jqueryMethods = ['on', 'off'];
    function fromEvent(target, eventName, options, resultSelector) {
        if (isFunction$3(options)) {
            resultSelector = options;
            options = undefined;
        }
        if (resultSelector) {
            return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
        }
        var _a = __read(isEventTarget(target)
            ? eventTargetMethods.map(function (methodName) { return function (handler) { return target[methodName](eventName, handler, options); }; })
            :
                isNodeStyleEventEmitter(target)
                    ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName))
                    : isJQueryStyleEventEmitter(target)
                        ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName))
                        : [], 2), add = _a[0], remove = _a[1];
        if (!add) {
            if (isArrayLike$2(target)) {
                return mergeMap(function (subTarget) { return fromEvent(subTarget, eventName, options); })(internalFromArray(target));
            }
        }
        if (!add) {
            throw new TypeError('Invalid event target');
        }
        return new Observable(function (subscriber) {
            var handler = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return subscriber.next(1 < args.length ? args : args[0]);
            };
            add(handler);
            return function () { return remove(handler); };
        });
    }
    function toCommonHandlerRegistry(target, eventName) {
        return function (methodName) { return function (handler) { return target[methodName](eventName, handler); }; };
    }
    function isNodeStyleEventEmitter(target) {
        return isFunction$3(target.addListener) && isFunction$3(target.removeListener);
    }
    function isJQueryStyleEventEmitter(target) {
        return isFunction$3(target.on) && isFunction$3(target.off);
    }
    function isEventTarget(target) {
        return isFunction$3(target.addEventListener) && isFunction$3(target.removeEventListener);
    }

    function timer$1(dueTime, intervalOrScheduler, scheduler) {
        if (dueTime === void 0) { dueTime = 0; }
        if (scheduler === void 0) { scheduler = async; }
        var intervalDuration = -1;
        if (intervalOrScheduler != null) {
            if (isScheduler(intervalOrScheduler)) {
                scheduler = intervalOrScheduler;
            }
            else {
                intervalDuration = intervalOrScheduler;
            }
        }
        return new Observable(function (subscriber) {
            var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
            if (due < 0) {
                due = 0;
            }
            var n = 0;
            return scheduler.schedule(function () {
                if (!subscriber.closed) {
                    subscriber.next(n++);
                    if (0 <= intervalDuration) {
                        this.schedule(undefined, intervalDuration);
                    }
                    else {
                        subscriber.complete();
                    }
                }
            }, due);
        });
    }

    function merge() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var scheduler = popScheduler(args);
        var concurrent = popNumber(args, Infinity);
        var sources = args;
        return !sources.length
            ?
                EMPTY
            : sources.length === 1
                ?
                    innerFrom(sources[0])
                :
                    mergeAll(concurrent)(internalFromArray(sources, scheduler));
    }

    function filter$1(predicate, thisArg) {
        return operate(function (source, subscriber) {
            var index = 0;
            source.subscribe(new OperatorSubscriber(subscriber, function (value) { return predicate.call(thisArg, value, index++) && subscriber.next(value); }));
        });
    }

    function buffer(closingNotifier) {
        return operate(function (source, subscriber) {
            var currentBuffer = [];
            source.subscribe(new OperatorSubscriber(subscriber, function (value) { return currentBuffer.push(value); }, function () {
                subscriber.next(currentBuffer);
                subscriber.complete();
            }));
            closingNotifier.subscribe(new OperatorSubscriber(subscriber, function () {
                var b = currentBuffer;
                currentBuffer = [];
                subscriber.next(b);
            }, noop$1));
            return function () {
                currentBuffer = null;
            };
        });
    }

    function debounceTime(dueTime, scheduler) {
        if (scheduler === void 0) { scheduler = asyncScheduler; }
        return operate(function (source, subscriber) {
            var activeTask = null;
            var lastValue = null;
            var lastTime = null;
            var emit = function () {
                if (activeTask) {
                    activeTask.unsubscribe();
                    activeTask = null;
                    var value = lastValue;
                    lastValue = null;
                    subscriber.next(value);
                }
            };
            function emitWhenIdle() {
                var targetTime = lastTime + dueTime;
                var now = scheduler.now();
                if (now < targetTime) {
                    activeTask = this.schedule(undefined, targetTime - now);
                    subscriber.add(activeTask);
                    return;
                }
                emit();
            }
            source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                lastValue = value;
                lastTime = scheduler.now();
                if (!activeTask) {
                    activeTask = scheduler.schedule(emitWhenIdle, dueTime);
                    subscriber.add(activeTask);
                }
            }, function () {
                emit();
                subscriber.complete();
            }, undefined, function () {
                lastValue = activeTask = null;
            }));
        });
    }

    function groupBy(keySelector, elementOrOptions, duration, connector) {
        return operate(function (source, subscriber) {
            var element;
            if (!elementOrOptions || typeof elementOrOptions === 'function') {
                element = elementOrOptions;
            }
            else {
                (duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector);
            }
            var groups = new Map();
            var notify = function (cb) {
                groups.forEach(cb);
                cb(subscriber);
            };
            var handleError = function (err) { return notify(function (consumer) { return consumer.error(err); }); };
            var groupBySourceSubscriber = new GroupBySubscriber(subscriber, function (value) {
                try {
                    var key_1 = keySelector(value);
                    var group_1 = groups.get(key_1);
                    if (!group_1) {
                        groups.set(key_1, (group_1 = connector ? connector() : new Subject()));
                        var grouped = createGroupedObservable(key_1, group_1);
                        subscriber.next(grouped);
                        if (duration) {
                            var durationSubscriber_1 = new OperatorSubscriber(group_1, function () {
                                group_1.complete();
                                durationSubscriber_1 === null || durationSubscriber_1 === void 0 ? void 0 : durationSubscriber_1.unsubscribe();
                            }, undefined, undefined, function () { return groups.delete(key_1); });
                            groupBySourceSubscriber.add(innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
                        }
                    }
                    group_1.next(element ? element(value) : value);
                }
                catch (err) {
                    handleError(err);
                }
            }, function () { return notify(function (consumer) { return consumer.complete(); }); }, handleError, function () { return groups.clear(); });
            source.subscribe(groupBySourceSubscriber);
            function createGroupedObservable(key, groupSubject) {
                var result = new Observable(function (groupSubscriber) {
                    groupBySourceSubscriber.activeGroups++;
                    var innerSub = groupSubject.subscribe(groupSubscriber);
                    return function () {
                        innerSub.unsubscribe();
                        --groupBySourceSubscriber.activeGroups === 0 &&
                            groupBySourceSubscriber.teardownAttempted &&
                            groupBySourceSubscriber.unsubscribe();
                    };
                });
                result.key = key;
                return result;
            }
        });
    }
    var GroupBySubscriber = (function (_super) {
        __extends(GroupBySubscriber, _super);
        function GroupBySubscriber() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.activeGroups = 0;
            _this.teardownAttempted = false;
            return _this;
        }
        GroupBySubscriber.prototype.unsubscribe = function () {
            this.teardownAttempted = true;
            this.activeGroups === 0 && _super.prototype.unsubscribe.call(this);
        };
        return GroupBySubscriber;
    }(OperatorSubscriber));

    function takeUntil(notifier) {
        return operate(function (source, subscriber) {
            innerFrom(notifier).subscribe(new OperatorSubscriber(subscriber, function () { return subscriber.complete(); }, noop$1));
            !subscriber.closed && source.subscribe(subscriber);
        });
    }

    var defaultThrottleConfig = {
        leading: true,
        trailing: false,
    };
    function throttle(durationSelector, _a) {
        var _b = _a === void 0 ? defaultThrottleConfig : _a, leading = _b.leading, trailing = _b.trailing;
        return operate(function (source, subscriber) {
            var hasValue = false;
            var sendValue = null;
            var throttled = null;
            var isComplete = false;
            var endThrottling = function () {
                throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
                throttled = null;
                if (trailing) {
                    send();
                    isComplete && subscriber.complete();
                }
            };
            var cleanupThrottling = function () {
                throttled = null;
                isComplete && subscriber.complete();
            };
            var startThrottle = function (value) {
                return (throttled = innerFrom(durationSelector(value)).subscribe(new OperatorSubscriber(subscriber, endThrottling, cleanupThrottling)));
            };
            var send = function () {
                if (hasValue) {
                    hasValue = false;
                    var value = sendValue;
                    sendValue = null;
                    subscriber.next(value);
                    !isComplete && startThrottle(value);
                }
            };
            source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                hasValue = true;
                sendValue = value;
                !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
            }, function () {
                isComplete = true;
                !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
            }));
        });
    }

    function throttleTime(duration, scheduler, config) {
        if (scheduler === void 0) { scheduler = asyncScheduler; }
        if (config === void 0) { config = defaultThrottleConfig; }
        var duration$ = timer$1(duration, scheduler);
        return throttle(function () { return duration$; }, config);
    }

    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    ctx.font = `${SIZE_FONT}px 'Noto Sans', sans-serif`;
    const getTextWidth = (value) => ctx.measureText(value).width;

    function onNumberOnly(event) {
        const input = event.target;
        input.value = input.value.replace(/[^0-9]/g, '');
    }
    function onPreventDefault(event) {
        event.preventDefault();
        return event;
    }
    function onStopPropagation(event) {
        event.stopPropagation();
        return event;
    }
    function onStopImmediatePropagation(event) {
        event.stopImmediatePropagation();
        return event;
    }
    pipe(onPreventDefault, onStopPropagation, onStopImmediatePropagation);
    function markToHTML(className, target, keyword) {
        const match = new RegExp(keyword.split('').join('|'), 'i');
        const list = target.split('');
        const buffer = [];
        while (list.length) {
            const cur = list.shift();
            match.test(cur)
                ? buffer.push(`<span class="${className}">${cur}</span>`)
                : buffer.push(cur);
        }
        return buffer.join('');
    }
    function lastCursorFocus(input) {
        const len = input.value.length;
        input.selectionStart = len;
        input.selectionEnd = len;
        input.focus();
    }
    function onInputClear(event) {
        const input = event.target;
        if (!input)
            return;
        input.value = '';
    }

    const TEXT_PADDING = 2;
    function createHelper() {
        let ghostText = null;
        let ghostInput = null;
        const subscriptionHelper = createSubscriptionHelper();
        const keydown$ = new Subject();
        const setGhostText = (ghost) => {
            ghostText = ghost;
        };
        const setGhostInput = (ghost) => {
            ghostInput = ghost;
            subscriptionHelper.push(fromEvent(ghostInput, 'input').subscribe(onInputClear));
        };
        const getTextWidth$1 = (value) => getTextWidth(value) + TEXT_PADDING;
        const getFastTextWidth = (value) => value.length * 10 + TEXT_PADDING;
        const getTextWidthLegacy = (value) => {
            if (!ghostText)
                return getFastTextWidth(value);
            ghostText.innerText = value;
            return ghostText.offsetWidth + TEXT_PADDING;
        };
        const focus = () => {
            if (!ghostInput)
                return;
            ghostInput.focus();
        };
        const blur = () => {
            if (!ghostInput)
                return;
            ghostInput.blur();
        };
        const destroy = () => subscriptionHelper.destroy();
        return {
            keydown$,
            setGhostText,
            setGhostInput,
            getTextWidth: getTextWidth$1,
            getTextWidthLegacy,
            getFastTextWidth,
            focus,
            blur,
            destroy,
        };
    }

    class Logger {
    }
    Logger.debug = (...args) => args.forEach(console.dir);
    Logger.log = console.log;
    Logger.warn = console.warn;
    Logger.error = console.error;

    const notEmptyCommands = filter$1(commands => !!commands.length);

    const commandsFilter = (commandTypes) => (source$) => new Observable(subscriber => source$.subscribe({
        next: commands => subscriber.next(commands.filter(command => commandTypes.includes(command.name))),
        error: value => subscriber.error(value),
        complete: () => subscriber.complete(),
    })).pipe(notEmptyCommands);

    const createCommand$1 = (name, data) => ({
        name,
        data,
        timestamp: Date.now(),
    });
    const changeCommandTypes = [
        // table
        'table.add',
        'table.move',
        'table.remove',
        'table.changeName',
        'table.changeComment',
        'table.sort',
        'table.hide',
        'table.show',
        'table.changeColor',
        // column
        'column.add',
        'column.addCustom',
        'column.remove',
        'column.changeName',
        'column.changeComment',
        'column.changeDataType',
        'column.changeDefault',
        'column.changeAutoIncrement',
        'column.changePrimaryKey',
        'column.changeUnique',
        'column.changeNotNull',
        'column.move',
        // relationship
        'relationship.add',
        'relationship.remove',
        'relationship.hide',
        'relationship.show',
        'relationship.changeRelationshipType',
        'relationship.changeStartRelationshipType',
        'relationship.changeIdentification',
        // index
        'index.add',
        'index.remove',
        'index.changeName',
        'index.changeUnique',
        'index.addColumn',
        'index.removeColumn',
        'index.moveColumn',
        'index.changeColumnOrderType',
        // memo
        'memo.add',
        'memo.move',
        'memo.remove',
        'memo.changeValue',
        'memo.resize',
        'memo.changeColor',
        // canvas
        'canvas.move',
        'canvas.movement',
        'canvas.resize',
        'canvas.zoom',
        'canvas.movementZoom',
        'canvas.changeShow',
        'canvas.changeDatabase',
        'canvas.changeDatabaseName',
        'canvas.changeCanvasType',
        'canvas.changeLanguage',
        'canvas.changeTableCase',
        'canvas.changeColumnCase',
        'canvas.changeRelationshipDataTypeSync',
        'canvas.changeRelationshipOptimization',
        'canvas.moveColumnOrder',
        'canvas.changeHighlightTheme',
        'canvas.changeBracketType',
        'canvas.changePluginSerialization',
        // editor
        'editor.loadJson',
        'editor.clear',
    ];
    const historyCommandTypes = [
        // table
        'table.add',
        'table.move',
        'table.remove',
        'table.changeName',
        'table.changeComment',
        'table.sort',
        'table.hide',
        'table.show',
        // column
        'column.add',
        'column.addCustom',
        'column.remove',
        'column.changeName',
        'column.changeComment',
        'column.changeDataType',
        'column.changeDefault',
        'column.changeAutoIncrement',
        'column.changePrimaryKey',
        'column.changeUnique',
        'column.changeNotNull',
        'column.move',
        // relationship
        'relationship.add',
        'relationship.remove',
        'relationship.hide',
        'relationship.show',
        'relationship.changeRelationshipType',
        'relationship.changeStartRelationshipType',
        'relationship.changeIdentification',
        // memo
        'memo.add',
        'memo.move',
        'memo.remove',
        'memo.changeValue',
        'memo.resize',
        // canvas
        'canvas.move',
        'canvas.movement',
        'canvas.resize',
        'canvas.zoom',
        'canvas.movementZoom',
        'canvas.changeShow',
        'canvas.changeDatabase',
        'canvas.changeDatabaseName',
        // editor
        'editor.loadJson',
        'editor.clear',
    ];
    const streamCommandTypes = [
        'table.move',
        'memo.move',
        'memo.resize',
        'canvas.movement',
        'canvas.movementZoom',
    ];
    const readonlyCommandTypes = [
        // table
        'table.select',
        'table.selectEnd',
        'table.selectAll',
        'table.dragSelect',
        // column
        'column.active',
        'column.activeEnd',
        // memo
        'memo.select',
        'memo.selectEnd',
        'memo.selectAll',
        'memo.dragSelect',
        // canvas
        'canvas.move',
        'canvas.movement',
        'canvas.zoom',
        'canvas.movementZoom',
        'canvas.changeShow',
        'canvas.changeDatabase',
        'canvas.changeCanvasType',
        'canvas.changeLanguage',
        'canvas.changeTableCase',
        'canvas.changeColumnCase',
        'canvas.moveColumnOrder',
        'canvas.changeHighlightTheme',
        'canvas.changeBracketType',
        // editor
        'editor.focusTable',
        'editor.focusColumn',
        'editor.focusTableEnd',
        'editor.focusMoveTable',
        'editor.editTableEnd',
        'editor.selectAllColumn',
        'editor.initLoadJson',
        'editor.initClear',
        'editor.changeViewport',
        'editor.findActive',
        'editor.findActiveEnd',
        'editor.readonly',
        // editor filter
        'editor.filter.active',
        'editor.filter.activeEnd',
        'editor.filter.add',
        'editor.filter.remove',
        'editor.filter.changeColumnType',
        'editor.filter.changeFilterCode',
        'editor.filter.changeValue',
        'editor.filter.move',
        'editor.filter.changeOperatorType',
        'editor.filter.focus',
        'editor.filter.focusFilter',
        'editor.filter.focusEnd',
        'editor.filter.focusMove',
        'editor.filter.edit',
        'editor.filter.editEnd',
        'editor.filter.selectAll',
        'editor.filter.draggable',
        'editor.filter.draggableEnd',
    ];

    /** Used to match a single whitespace character. */

    var reWhitespace = /\s/;

    /**
     * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
     * character of `string`.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {number} Returns the index of the last non-whitespace character.
     */
    function trimmedEndIndex$1(string) {
      var index = string.length;

      while (index-- && reWhitespace.test(string.charAt(index))) {}
      return index;
    }

    var _trimmedEndIndex = trimmedEndIndex$1;

    var trimmedEndIndex = _trimmedEndIndex;

    /** Used to match leading whitespace. */
    var reTrimStart = /^\s+/;

    /**
     * The base implementation of `_.trim`.
     *
     * @private
     * @param {string} string The string to trim.
     * @returns {string} Returns the trimmed string.
     */
    function baseTrim$1(string) {
      return string
        ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
        : string;
    }

    var _baseTrim = baseTrim$1;

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */

    function isObject$3(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    var isObject_1 = isObject$3;

    var baseTrim = _baseTrim,
        isObject$2 = isObject_1,
        isSymbol = isSymbol_1;

    /** Used as references for various `Number` constants. */
    var NAN = 0 / 0;

    /** Used to detect bad signed hexadecimal string values. */
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

    /** Used to detect binary string values. */
    var reIsBinary = /^0b[01]+$/i;

    /** Used to detect octal string values. */
    var reIsOctal = /^0o[0-7]+$/i;

    /** Built-in method references without a dependency on `root`. */
    var freeParseInt = parseInt;

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber$2(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject$2(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject$2(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    var toNumber_1 = toNumber$2;

    var toNumber$1 = toNumber_1;

    /** Used as references for various `Number` constants. */
    var INFINITY = 1 / 0,
        MAX_INTEGER = 1.7976931348623157e+308;

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite$1(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber$1(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    var toFinite_1 = toFinite$1;

    var toFinite = toFinite_1;

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger$1(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }

    var toInteger_1 = toInteger$1;

    var root$8 = _root,
        toInteger = toInteger_1,
        toNumber = toNumber_1,
        toString = toString_1;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeIsFinite = root$8.isFinite,
        nativeMin = Math.min;

    /**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound$1(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        number = toNumber(number);
        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
        if (precision && nativeIsFinite(number)) {
          // Shift with exponential notation to avoid floating-point issues.
          // See [MDN](https://mdn.io/round#Examples) for more details.
          var pair = (toString(number) + 'e').split('e'),
              value = func(pair[0] + 'e' + (+pair[1] + precision));

          pair = (toString(value) + 'e').split('e');
          return +(pair[0] + 'e' + (+pair[1] - precision));
        }
        return func(number);
      };
    }

    var _createRound = createRound$1;

    var createRound = _createRound;

    /**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    var round_1 = round;

    const canvasSizeBalanceRange = createBalanceRange(SIZE_CANVAS_MIN, SIZE_CANVAS_MAX);
    const zoomBalanceRange$1 = createBalanceRange(SIZE_CANVAS_ZOOM_MIN, SIZE_CANVAS_ZOOM_MAX);
    const canvasSizeRange = (size) => canvasSizeBalanceRange((isString$2(size)
        ? Number(size.replace(/[^0-9]/g, ''))
        : size));
    const zoomLevelRange = (zoomLevel) => zoomBalanceRange$1((isString$2(zoomLevel)
        ? Number(zoomLevel.replace(/[^0-9]/g, ''))
        : zoomLevel));
    const zoomDisplayFormat = (zoomLevel) => `${(zoomLevel * 100).toFixed()}%`;

    function executeMoveCanvas$1({ canvasState, editorState: { viewport } }, data) {
        const scrollTopBalanceRange = createBalanceRange(viewport.height - canvasState.height, 0);
        const scrollLeftBalanceRange = createBalanceRange(viewport.width - canvasState.width, 0);
        canvasState.scrollTop = scrollTopBalanceRange(data.scrollTop);
        canvasState.scrollLeft = scrollLeftBalanceRange(data.scrollLeft);
    }
    function executeMovementCanvas$1({ canvasState, editorState: { viewport } }, data) {
        const scrollTopBalanceRange = createBalanceRange(viewport.height - canvasState.height, 0);
        const scrollLeftBalanceRange = createBalanceRange(viewport.width - canvasState.width, 0);
        canvasState.scrollTop = scrollTopBalanceRange(canvasState.scrollTop + data.movementY);
        canvasState.scrollLeft = scrollLeftBalanceRange(canvasState.scrollLeft + data.movementX);
    }
    function executeResizeCanvas$1({ canvasState }, data) {
        canvasState.width = data.width;
        canvasState.height = data.height;
    }
    function executeZoomCanvas$1({ canvasState }, data) {
        canvasState.zoomLevel = round_1(zoomBalanceRange$1(data.zoomLevel), 2);
    }
    function executeMovementZoomCanvas$1({ canvasState }, data) {
        canvasState.zoomLevel = round_1(zoomBalanceRange$1(canvasState.zoomLevel + data.movementZoomLevel), 2);
    }
    function executeChangeCanvasShow$1({ canvasState: { show } }, data) {
        show[data.showKey] = data.value;
    }
    function executeChangeDatabase$1({ canvasState }, data) {
        canvasState.database = data.database;
    }
    function executeChangeDatabaseName$1({ canvasState }, data) {
        canvasState.databaseName = data.value;
    }
    function executeChangeCanvasType({ canvasState }, data) {
        canvasState.canvasType = data.canvasType;
    }
    function executeChangeLanguage({ canvasState }, data) {
        canvasState.language = data.language;
    }
    function executeChangeTableCase({ canvasState }, data) {
        canvasState.tableCase = data.nameCase;
    }
    function executeChangeColumnCase({ canvasState }, data) {
        canvasState.columnCase = data.nameCase;
    }
    function executeChangeRelationshipDataTypeSync({ canvasState: { setting } }, data) {
        setting.relationshipDataTypeSync = data.value;
    }
    function executeChangeRelationshipOptimization({ canvasState: { setting } }, data) {
        setting.relationshipOptimization = data.value;
    }
    function executeMoveColumnOrder({ canvasState: { setting: { columnOrder }, }, }, data) {
        if (data.columnType === data.targetColumnType)
            return;
        const targetIndex = columnOrder.indexOf(data.targetColumnType);
        const currentIndex = columnOrder.indexOf(data.columnType);
        if (targetIndex === -1 || currentIndex === -1)
            return;
        columnOrder.splice(currentIndex, 1);
        columnOrder.splice(targetIndex, 0, data.columnType);
    }
    function executeChangeHighlightTheme({ canvasState }, data) {
        canvasState.highlightTheme = data.highlightTheme;
    }
    function executeChangeBracketType({ canvasState }, data) {
        canvasState.bracketType = data.bracketType;
    }
    function executeChangePluginSerialization({ canvasState }, data) {
        canvasState.pluginSerializationMap[data.key] = data.value;
    }
    const executeCanvasCommandMap$1 = {
        'canvas.move': executeMoveCanvas$1,
        'canvas.movement': executeMovementCanvas$1,
        'canvas.resize': executeResizeCanvas$1,
        'canvas.zoom': executeZoomCanvas$1,
        'canvas.movementZoom': executeMovementZoomCanvas$1,
        'canvas.changeShow': executeChangeCanvasShow$1,
        'canvas.changeDatabase': executeChangeDatabase$1,
        'canvas.changeDatabaseName': executeChangeDatabaseName$1,
        'canvas.changeCanvasType': executeChangeCanvasType,
        'canvas.changeLanguage': executeChangeLanguage,
        'canvas.changeTableCase': executeChangeTableCase,
        'canvas.changeColumnCase': executeChangeColumnCase,
        'canvas.changeRelationshipDataTypeSync': executeChangeRelationshipDataTypeSync,
        'canvas.changeRelationshipOptimization': executeChangeRelationshipOptimization,
        'canvas.moveColumnOrder': executeMoveColumnOrder,
        'canvas.changeHighlightTheme': executeChangeHighlightTheme,
        'canvas.changeBracketType': executeChangeBracketType,
        'canvas.changePluginSerialization': executeChangePluginSerialization,
    };

    const moveCanvas = (scrollTop, scrollLeft) => createCommand$1('canvas.move', { scrollTop, scrollLeft });
    const movementCanvas = (movementX, movementY) => createCommand$1('canvas.movement', { movementX, movementY });
    const resizeCanvas = (width, height) => createCommand$1('canvas.resize', { width, height });
    const zoomCanvas = (zoomLevel) => createCommand$1('canvas.zoom', {
        zoomLevel: zoomBalanceRange$1(zoomLevel),
    });
    const movementZoomCanvas = (movementZoomLevel) => createCommand$1('canvas.movementZoom', {
        movementZoomLevel,
    });
    const changeCanvasShow = ({ canvasState: { show } }, showKey) => createCommand$1('canvas.changeShow', { showKey, value: !show[showKey] });
    const changeDatabase = (database) => createCommand$1('canvas.changeDatabase', { database });
    const changeDatabaseName = (value) => createCommand$1('canvas.changeDatabaseName', { value });
    const changeCanvasType = (canvasType) => createCommand$1('canvas.changeCanvasType', { canvasType });
    const changeLanguage = (language) => createCommand$1('canvas.changeLanguage', { language });
    const changeTableCase = (nameCase) => createCommand$1('canvas.changeTableCase', { nameCase });
    const changeColumnCase = (nameCase) => createCommand$1('canvas.changeColumnCase', { nameCase });
    const changeRelationshipDataTypeSync = (value) => createCommand$1('canvas.changeRelationshipDataTypeSync', { value });
    const changeRelationshipOptimization = (value) => createCommand$1('canvas.changeRelationshipOptimization', { value });
    const moveColumnOrder = (columnType, targetColumnType) => createCommand$1('canvas.moveColumnOrder', { columnType, targetColumnType });
    const changeHighlightTheme = (highlightTheme) => createCommand$1('canvas.changeHighlightTheme', { highlightTheme });
    const changeBracketType = (bracketType) => createCommand$1('canvas.changeBracketType', { bracketType });
    const changePluginSerialization = (key, value) => createCommand$1('canvas.changePluginSerialization', { key, value });

    var canvasCommand = /*#__PURE__*/Object.freeze({
        __proto__: null,
        moveCanvas: moveCanvas,
        movementCanvas: movementCanvas,
        resizeCanvas: resizeCanvas,
        zoomCanvas: zoomCanvas,
        movementZoomCanvas: movementZoomCanvas,
        changeCanvasShow: changeCanvasShow,
        changeDatabase: changeDatabase,
        changeDatabaseName: changeDatabaseName,
        changeCanvasType: changeCanvasType,
        changeLanguage: changeLanguage,
        changeTableCase: changeTableCase,
        changeColumnCase: changeColumnCase,
        changeRelationshipDataTypeSync: changeRelationshipDataTypeSync,
        changeRelationshipOptimization: changeRelationshipOptimization,
        moveColumnOrder: moveColumnOrder,
        changeHighlightTheme: changeHighlightTheme,
        changeBracketType: changeBracketType,
        changePluginSerialization: changePluginSerialization
    });

    function getColumn(tables, tableId, columnId) {
        const table = getData(tables, tableId);
        return table ? getData(table.columns, columnId) : null;
    }
    function getDataTypeSyncColumns(stack, tables, relationships, targetColumns = []) {
        const target = stack.pop();
        if (target) {
            if (getIndex(targetColumns, target.id) === -1) {
                targetColumns.push(target);
                relationships.forEach(relationship => {
                    const { start, end } = relationship;
                    const index = start.columnIds.indexOf(target.id);
                    if (index !== -1) {
                        const columnId = end.columnIds[index];
                        const column = getColumn(tables, end.tableId, columnId);
                        column && stack.push(column);
                    }
                    else {
                        const index = end.columnIds.indexOf(target.id);
                        if (index !== -1) {
                            const columnId = start.columnIds[index];
                            const column = getColumn(tables, start.tableId, columnId);
                            column && stack.push(column);
                        }
                    }
                });
            }
            getDataTypeSyncColumns(stack, tables, relationships, targetColumns);
        }
        return targetColumns;
    }
    function getChangeOption(tables, tableId, columnId, columnOptionKey) {
        const column = getColumn(tables, tableId, columnId);
        return column ? !column.option[columnOptionKey] : false;
    }
    function getColumns(table, columnIds) {
        const columns = [];
        columnIds.forEach(columnId => {
            const column = getData(table.columns, columnId);
            if (!column)
                return;
            columns.push(column);
        });
        return columns;
    }
    const commentWidthBalanceRange = createBalanceRange(SIZE_MIN_WIDTH, SIZE_MAX_WIDTH_COMMENT);
    const widthBalanceRange = createBalanceRange(SIZE_MIN_WIDTH, 10000);

    const migrationRelationshipTypes = ['ZeroOneN', 'One', 'N'];
    const migrationRelationshipTypeMap = {
        ZeroOneN: 'ZeroN',
        One: 'OneOnly',
        N: 'OneN',
    };
    const migrationRelationshipType = (relationshipType) => migrationRelationshipTypes.includes(relationshipType)
        ? migrationRelationshipTypeMap[relationshipType]
        : relationshipType;

    const isLoadRelationship = (loadRelationship) => isString$2(loadRelationship.id) &&
        isBoolean(loadRelationship.identification) &&
        isString$2(loadRelationship.relationshipType) &&
        isObject$4(loadRelationship.start) &&
        isObject$4(loadRelationship.end) &&
        isString$2(loadRelationship.start.tableId) &&
        isNumber(loadRelationship.start.x) &&
        isNumber(loadRelationship.start.y) &&
        isString$2(loadRelationship.start.direction) &&
        isArray$4(loadRelationship.start.columnIds) &&
        isString$2(loadRelationship.end.tableId) &&
        isNumber(loadRelationship.end.x) &&
        isNumber(loadRelationship.end.y) &&
        isString$2(loadRelationship.end.direction) &&
        isArray$4(loadRelationship.end.columnIds);
    class RelationshipModel {
        constructor({ addRelationship, loadRelationship }) {
            this.identification = false;
            this.relationshipType = 'ZeroN';
            this.startRelationshipType = 'Dash';
            this.start = {
                tableId: '',
                columnIds: [],
                x: 0,
                y: 0,
                direction: 'bottom',
            };
            this.end = {
                tableId: '',
                columnIds: [],
                x: 0,
                y: 0,
                direction: 'bottom',
            };
            this.constraintName = '';
            this.visible = true;
            if (addRelationship) {
                const { id, relationshipType, start, end, constraintName } = addRelationship;
                this.id = id;
                this.relationshipType = migrationRelationshipType(relationshipType);
                this.start.tableId = start.tableId;
                this.start.columnIds = [...start.columnIds];
                this.end.tableId = end.tableId;
                this.end.columnIds = [...end.columnIds];
                this.constraintName = constraintName;
            }
            else if (loadRelationship && isLoadRelationship(loadRelationship)) {
                const { id, identification, relationshipType, startRelationshipType, start, end, constraintName, visible, } = cloneDeep(loadRelationship);
                this.id = id;
                this.identification = identification;
                this.relationshipType = migrationRelationshipType(relationshipType);
                this.start = start;
                this.end = end;
                this.constraintName = constraintName || '';
                if (startRelationshipType) {
                    this.startRelationshipType = startRelationshipType;
                }
                if (isBoolean(visible))
                    this.visible = visible;
            }
            else {
                throw new Error('not found relationship');
            }
        }
    }

    function executeAddRelationship$1({ relationshipState: { relationships }, tableState: { tables } }, data) {
        const { start, end } = data;
        const startTable = getData(tables, start.tableId);
        const endTable = getData(tables, end.tableId);
        if (!start.columnIds.length || !startTable || !endTable)
            return;
        relationships.push(new RelationshipModel({ addRelationship: data }));
    }
    function executeRemoveRelationship$1(state, data) {
        const { relationshipState: { relationships }, } = state;
        for (let i = 0; i < relationships.length; i++) {
            const relationship = relationships[i];
            if (data.relationshipIds.includes(relationship.id)) {
                relationships.splice(i, 1);
                i--;
                // TODO: Refactoring
                removeValidRelationshipColumnId(state, relationship.end.tableId, relationship.end.columnIds);
            }
        }
    }
    function executeChangeRelationshipType$1({ relationshipState: { relationships } }, data) {
        const relationship = getData(relationships, data.relationshipId);
        if (!relationship)
            return;
        relationship.relationshipType = data.relationshipType;
    }
    function executeChangeStartRelationshipType$1({ relationshipState: { relationships } }, data) {
        const relationship = getData(relationships, data.relationshipId);
        if (!relationship)
            return;
        relationship.startRelationshipType = data.startRelationshipType;
    }
    function executeChangeIdentification$1({ relationshipState: { relationships } }, data) {
        const relationship = getData(relationships, data.relationshipId);
        if (!relationship)
            return;
        relationship.identification = data.identification;
    }
    function executeLoadRelationship({ relationshipState: { relationships }, tableState: { tables } }, data) {
        const table = getData(tables, data.end.tableId);
        if (!table || !getData(tables, data.start.tableId))
            return;
        relationships.push(new RelationshipModel({ loadRelationship: data }));
        data.end.columnIds.forEach(columnId => {
            const column = getData(table.columns, columnId);
            if (!column)
                return;
            if (column.option.primaryKey) {
                column.ui.pfk = true;
                column.ui.pk = false;
                column.ui.fk = false;
            }
            else {
                column.ui.pfk = false;
                column.ui.pk = false;
                column.ui.fk = true;
            }
        });
    }
    function executeHideRelationship$1({ relationshipState: { relationships } }, data) {
        const relationship = getData(relationships, data.relationshipId);
        if (relationship)
            relationship.visible = false;
    }
    function executeShowRelationship$1({ relationshipState: { relationships } }, data) {
        const relationship = getData(relationships, data.relationshipId);
        if (relationship)
            relationship.visible = true;
    }
    const executeRelationshipCommandMap$1 = {
        'relationship.add': executeAddRelationship$1,
        'relationship.remove': executeRemoveRelationship$1,
        'relationship.changeRelationshipType': executeChangeRelationshipType$1,
        'relationship.changeStartRelationshipType': executeChangeStartRelationshipType$1,
        'relationship.changeIdentification': executeChangeIdentification$1,
        'relationship.load': executeLoadRelationship,
        'relationship.hide': executeHideRelationship$1,
        'relationship.show': executeShowRelationship$1,
    };

    /**
     * TODO: Refactoring
     */
    function validIdentification(state) {
        const { relationships } = state.relationshipState;
        const { tables } = state.tableState;
        relationships.forEach(relationship => {
            const { end } = relationship;
            const table = getData(tables, end.tableId);
            if (!table)
                return;
            const columns = getColumns(table, end.columnIds);
            const identification = columns.every(column => column.option.primaryKey);
            if (identification !== relationship.identification) {
                executeChangeIdentification$1(state, {
                    relationshipId: relationship.id,
                    identification,
                });
            }
        });
    }
    function validStartRelationship(state) {
        const { relationships } = state.relationshipState;
        const { tables } = state.tableState;
        relationships.forEach(relationship => {
            const { end } = relationship;
            const table = getData(tables, end.tableId);
            if (!table)
                return;
            const columns = getColumns(table, end.columnIds);
            const startRelationshipType = columns.every(column => column.option.notNull)
                ? 'Dash'
                : 'Ring';
            if (startRelationshipType !== relationship.startRelationshipType) {
                executeChangeStartRelationshipType$1(state, {
                    relationshipId: relationship.id,
                    startRelationshipType,
                });
            }
        });
    }
    function removeValidTableRelationship(state, tableIds) {
        const { relationships } = state.relationshipState;
        const removeRelationshipIds = [];
        relationships.forEach(relationship => {
            const { start, end } = relationship;
            if (!tableIds.some(tableId => tableId === start.tableId || tableId === end.tableId))
                return;
            removeRelationshipIds.push(relationship.id);
        });
        if (removeRelationshipIds.length !== 0) {
            executeRemoveRelationship$1(state, {
                relationshipIds: removeRelationshipIds,
            });
        }
    }
    function removeValidColumnRelationship(state, table, columnIds) {
        const { relationships } = state.relationshipState;
        const removeRelationshipIds = [];
        const validColumnUIKeyList = [];
        relationships.forEach(relationship => {
            const { start, end } = relationship;
            const validColumnUIKey = {
                startTableId: start.tableId,
                endTableId: end.tableId,
                columnIds: [],
            };
            if (table.id === start.tableId) {
                for (let i = 0; i < start.columnIds.length; i++) {
                    const id = start.columnIds[i];
                    if (!columnIds.includes(id))
                        return;
                    validColumnUIKey.columnIds.push(end.columnIds[i]);
                    start.columnIds.splice(i, 1);
                    end.columnIds.splice(i, 1);
                    i--;
                }
            }
            else if (table.id === end.tableId) {
                for (let i = 0; i < end.columnIds.length; i++) {
                    const id = end.columnIds[i];
                    if (!columnIds.includes(id))
                        return;
                    validColumnUIKey.columnIds.push(id);
                    start.columnIds.splice(i, 1);
                    end.columnIds.splice(i, 1);
                    i--;
                }
            }
            if (start.columnIds.length === 0) {
                removeRelationshipIds.push(relationship.id);
            }
            validColumnUIKeyList.push(validColumnUIKey);
        });
        if (removeRelationshipIds.length !== 0) {
            executeRemoveRelationship$1(state, {
                relationshipIds: removeRelationshipIds,
            });
        }
        validColumnUIKeyList.forEach(validColumnUIKey => {
            if (validColumnUIKey.columnIds.length === 0)
                return;
            removeValidRelationshipColumnId(state, validColumnUIKey.startTableId, validColumnUIKey.columnIds);
            removeValidRelationshipColumnId(state, validColumnUIKey.endTableId, validColumnUIKey.columnIds);
        });
    }
    function removeValidRelationshipColumnId(state, tableId, columnIds) {
        const { tables } = state.tableState;
        const table = getData(tables, tableId);
        if (!table)
            return;
        columnIds.forEach(columnId => {
            const column = getData(table.columns, columnId);
            if (!column)
                return;
            if (column.ui.fk) {
                column.ui.fk = false;
            }
            else if (column.ui.pfk) {
                column.ui.pfk = false;
                column.ui.pk = true;
            }
        });
    }
    function removeValidColumnIndex(state, table, columnIds) {
        const { indexes } = state.tableState;
        const tableIndexes = indexes.filter(index => index.tableId === table.id);
        tableIndexes.forEach(index => {
            for (let i = 0; i < index.columns.length; i++) {
                const id = index.columns[i].id;
                if (columnIds.includes(id)) {
                    index.columns.splice(i, 1);
                    i--;
                }
            }
        });
    }
    function removeValidTableIndex(state, tableIds) {
        const { indexes } = state.tableState;
        for (let i = 0; i < indexes.length; i++) {
            const id = indexes[i].tableId;
            if (tableIds.includes(id)) {
                indexes.splice(i, 1);
                i--;
            }
        }
    }

    class ColumnModel {
        constructor({ addColumn, addCustomColumn }) {
            this.name = '';
            this.comment = '';
            this.dataType = '';
            this.default = '';
            this.option = {
                autoIncrement: false,
                primaryKey: false,
                unique: false,
                notNull: false,
            };
            this.ui = {
                active: false,
                pk: false,
                fk: false,
                pfk: false,
                widthName: SIZE_MIN_WIDTH,
                widthComment: SIZE_MIN_WIDTH,
                widthDataType: SIZE_MIN_WIDTH,
                widthDefault: SIZE_MIN_WIDTH,
            };
            if (addColumn) {
                const { id } = addColumn;
                this.id = id;
            }
            else if (addCustomColumn) {
                const { id, option, ui, value } = cloneDeep(addCustomColumn);
                this.id = id;
                option && Object.assign(this.option, option);
                ui && Object.assign(this.ui, ui);
                if (value) {
                    this.name = value.name;
                    this.comment = value.comment;
                    this.dataType = value.dataType;
                    this.default = value.default;
                    this.ui.widthName = value.widthName;
                    this.ui.widthComment = value.widthComment;
                    this.ui.widthDataType = value.widthDataType;
                    this.ui.widthDefault = value.widthDefault;
                }
            }
            else {
                throw new Error('not found column');
            }
        }
    }

    function executeAddColumn$1({ tableState: { tables } }, data) {
        data.forEach((addColumn) => {
            const table = getData(tables, addColumn.tableId);
            table && table.columns.push(new ColumnModel({ addColumn }));
        });
    }
    function executeAddCustomColumn$1({ tableState: { tables } }, data) {
        data.forEach((addCustomColumn) => {
            const table = getData(tables, addCustomColumn.tableId);
            if (!table)
                return;
            table.columns.push(new ColumnModel({ addCustomColumn }));
        });
    }
    function executeRemoveColumn$1(state, data) {
        const { tableState: { tables }, } = state;
        const table = getData(tables, data.tableId);
        if (!table)
            return;
        for (let i = 0; i < table.columns.length; i++) {
            const column = table.columns[i];
            if (data.columnIds.includes(column.id)) {
                table.columns.splice(i, 1);
                i--;
            }
        }
        // TODO: Refactoring
        removeValidColumnIndex(state, table, data.columnIds);
        removeValidColumnRelationship(state, table, data.columnIds);
        validIdentification(state);
        validStartRelationship(state);
    }
    function executeRemoveOnlyColumn(state, data) {
        const { tableState: { tables }, } = state;
        const table = getData(tables, data.tableId);
        if (!table)
            return;
        for (let i = 0; i < table.columns.length; i++) {
            const column = table.columns[i];
            if (data.columnIds.includes(column.id)) {
                table.columns.splice(i, 1);
                i--;
            }
        }
    }
    function executeChangeColumnName$1({ tableState: { tables } }, data) {
        const column = getColumn(tables, data.tableId, data.columnId);
        if (!column)
            return;
        column.name = data.value;
        column.ui.widthName = data.width;
    }
    function executeChangeColumnComment$1({ tableState: { tables } }, data) {
        const column = getColumn(tables, data.tableId, data.columnId);
        if (!column)
            return;
        column.comment = data.value;
        column.ui.widthComment = commentWidthBalanceRange(data.width);
    }
    function executeChangeColumnDataType$1({ canvasState: { setting }, tableState: { tables }, relationshipState: { relationships }, }, data) {
        const targetColumn = getColumn(tables, data.tableId, data.columnId);
        if (!targetColumn)
            return;
        let columns = [targetColumn];
        if (setting.relationshipDataTypeSync) {
            columns = getDataTypeSyncColumns([targetColumn], tables, relationships);
        }
        columns.forEach(column => {
            column.dataType = data.value;
            column.ui.widthDataType = data.width;
        });
    }
    function executeChangeColumnDefault$1({ tableState: { tables } }, data) {
        const column = getColumn(tables, data.tableId, data.columnId);
        if (!column)
            return;
        column.default = data.value;
        column.ui.widthDefault = data.width;
    }
    function executeChangeColumnAutoIncrement$1({ tableState: { tables } }, data) {
        const column = getColumn(tables, data.tableId, data.columnId);
        if (!column)
            return;
        column.option.autoIncrement = data.value;
    }
    function executeChangeColumnPrimaryKey$1(state, data) {
        const { tableState: { tables }, } = state;
        const column = getColumn(tables, data.tableId, data.columnId);
        if (!column)
            return;
        if (data.value) {
            if (column.ui.fk) {
                column.ui.fk = false;
                column.ui.pfk = true;
            }
            else {
                column.ui.pk = true;
            }
        }
        else {
            if (column.ui.pfk) {
                column.ui.pfk = false;
                column.ui.fk = true;
            }
            else {
                column.ui.pk = false;
            }
        }
        column.option.primaryKey = data.value;
        // TODO: Refactoring
        validIdentification(state);
    }
    function executeChangeColumnUnique$1({ tableState: { tables } }, data) {
        const column = getColumn(tables, data.tableId, data.columnId);
        if (!column)
            return;
        column.option.unique = data.value;
    }
    function executeChangeColumnNotNull$1(state, data) {
        const { tableState: { tables }, } = state;
        const column = getColumn(tables, data.tableId, data.columnId);
        if (!column)
            return;
        column.option.notNull = data.value;
        // TODO: Refactoring
        validStartRelationship(state);
    }
    function executeMoveColumn$1(state, data) {
        const { tableState: { tables }, } = state;
        const currentTable = getData(tables, data.tableId);
        const currentColumns = [];
        data.columnIds.forEach(columnId => {
            const column = getColumn(tables, data.tableId, columnId);
            column && currentColumns.push(column);
        });
        const targetTable = getData(tables, data.targetTableId);
        const targetColumn = getColumn(tables, data.targetTableId, data.targetColumnId);
        if (!currentTable || !targetTable || !currentColumns.length || !targetColumn)
            return;
        if (data.tableId === data.targetTableId &&
            !data.columnIds.includes(data.targetColumnId)) {
            const targetIndex = getIndex(currentTable.columns, targetColumn.id);
            if (targetIndex === -1)
                return;
            currentColumns.forEach(currentColumn => {
                const currentIndex = getIndex(currentTable.columns, currentColumn.id);
                if (currentIndex === -1)
                    return;
                currentTable.columns.splice(currentIndex, 1);
            });
            currentTable.columns.splice(targetIndex, 0, ...currentColumns);
        }
        else if (data.tableId !== data.targetTableId &&
            !data.columnIds.includes(data.targetColumnId)) {
            const targetIndex = getIndex(targetTable.columns, targetColumn.id);
            if (targetIndex === -1)
                return;
            currentColumns.forEach(currentColumn => {
                const currentIndex = getIndex(currentTable.columns, currentColumn.id);
                if (currentIndex === -1)
                    return;
                currentTable.columns.splice(currentIndex, 1);
            });
            targetTable.columns.splice(targetIndex, 0, ...currentColumns);
            // TODO: Refactoring
            removeValidColumnIndex(state, currentTable, data.columnIds);
            removeValidColumnRelationship(state, currentTable, data.columnIds);
            validIdentification(state);
            validStartRelationship(state);
        }
    }
    function executeActiveColumn({ tableState: { tables } }, data) {
        data.forEach(activeColumn => {
            const table = getData(tables, activeColumn.tableId);
            if (!table)
                return;
            activeColumn.columnIds.forEach(columnId => {
                const column = getData(table.columns, columnId);
                column && (column.ui.active = true);
            });
        });
    }
    function executeActiveEndColumn({ tableState: { tables } }, data) {
        data.forEach(activeColumn => {
            const table = getData(tables, activeColumn.tableId);
            if (!table)
                return;
            activeColumn.columnIds.forEach(columnId => {
                const column = getData(table.columns, columnId);
                column && (column.ui.active = false);
            });
        });
    }
    function executeLoadColumn({ tableState: { tables } }, data) {
        const table = getData(tables, data.tableId);
        if (!table)
            return;
        data.columns.forEach((column, index) => {
            column.ui.active = false;
            table.columns.splice(data.indexList[index], 0, column);
        });
    }
    const executeColumnCommandMap$1 = {
        'column.add': executeAddColumn$1,
        'column.addCustom': executeAddCustomColumn$1,
        'column.remove': executeRemoveColumn$1,
        'column.removeOnly': executeRemoveOnlyColumn,
        'column.changeName': executeChangeColumnName$1,
        'column.changeComment': executeChangeColumnComment$1,
        'column.changeDataType': executeChangeColumnDataType$1,
        'column.changeDefault': executeChangeColumnDefault$1,
        'column.changeAutoIncrement': executeChangeColumnAutoIncrement$1,
        'column.changePrimaryKey': executeChangeColumnPrimaryKey$1,
        'column.changeUnique': executeChangeColumnUnique$1,
        'column.changeNotNull': executeChangeColumnNotNull$1,
        'column.move': executeMoveColumn$1,
        'column.active': executeActiveColumn,
        'column.activeEnd': executeActiveEndColumn,
        'column.load': executeLoadColumn,
    };

    const createFilterState = () => ({
        active: false,
        operatorType: 'OR',
        filters: [],
        focus: null,
        draggable: null,
    });
    const operatorTypes = ['AND', 'OR'];
    const textFilterCodeList = [
        'eq',
        'ne',
        'contain',
        'start',
        'end',
    ];
    const columnTypes = [
        'tableName',
        'tableComment',
        'option',
        'name',
        'dataType',
        'default',
        'comment',
    ];
    const focusFilterTypes = [
        'columnType',
        'filterCode',
        'value',
    ];

    const createEditorState = () => ({
        panels: [],
        excludePanel: [],
        hasUndo: false,
        hasRedo: false,
        focusTable: null,
        drawRelationship: null,
        draggableColumn: null,
        viewport: {
            width: DEFAULT_WIDTH,
            height: DEFAULT_HEIGHT,
        },
        copyColumns: [],
        findActive: false,
        readonly: false,
        filterState: createFilterState(),
        erdUiEventNone: false,
    });
    const moveKeys = [
        'ArrowDown',
        'ArrowLeft',
        'ArrowRight',
        'ArrowUp',
        'Tab',
    ];
    const tableTypes = ['tableName', 'tableComment'];

    const appendSelectColumns = (columnIds, columnId) => uniq$1([...columnIds, columnId]);
    function selectRangeColumns(columns, fromColumnId, toColumnId) {
        if (!fromColumnId || fromColumnId === toColumnId)
            return [toColumnId];
        const fromIndex = getIndex(columns, fromColumnId);
        const toIndex = getIndex(columns, toColumnId);
        if (fromIndex === -1)
            return [toColumnId];
        return range(fromIndex, toIndex).map(index => columns[index].id);
    }
    const appendSelectRangeColumns = (columns, columnIds, fromColumnId, toColumnId) => uniq$1([
        ...columnIds,
        ...selectRangeColumns(columns, fromColumnId, toColumnId),
    ]);

    function getColumnTypes({ canvasState: { show, setting: { columnOrder }, }, }) {
        const showKeys = [
            'columnName',
            ...Object.keys(show).filter(key => show[key]),
        ];
        const match = new RegExp(showKeys.join('|'), 'i');
        return [...columnOrder.filter(key => match.test(key))];
    }
    const isColumns = (focusTable) => !!focusTable.table.columns.length;
    function isLastColumn(state) {
        const { editorState: { focusTable }, } = state;
        if (!focusTable)
            return true;
        const columnTypes = getColumnTypes(state);
        const index = columnTypes.indexOf(focusTable.focusType);
        return index === columnTypes.length - 1;
    }
    function isFirstColumn(state) {
        const { editorState: { focusTable }, } = state;
        if (!focusTable)
            return true;
        const columnTypes = getColumnTypes(state);
        const index = columnTypes.indexOf(focusTable.focusType);
        return index === 0;
    }
    function isLastRowColumn({ table, columnId }) {
        if (!columnId)
            return true;
        const index = getIndex(table.columns, columnId);
        return index === table.columns.length - 1;
    }
    function isFirstRowColumn({ table, columnId }) {
        if (!columnId)
            return true;
        const index = getIndex(table.columns, columnId);
        return index === 0;
    }
    function getLastColumnType(state) {
        const columnTypes = getColumnTypes(state);
        return columnTypes[columnTypes.length - 1];
    }
    function getFirstColumnType(state) {
        const columnTypes = getColumnTypes(state);
        return columnTypes[0];
    }
    function getNextRightColumnType(state) {
        const { editorState: { focusTable }, } = state;
        if (!focusTable)
            return 'columnName';
        const columnTypes = getColumnTypes(state);
        const index = columnTypes.indexOf(focusTable.focusType);
        return isLastColumn(state) ? columnTypes[0] : columnTypes[index + 1];
    }
    function getNextLeftColumnType(state) {
        const { editorState: { focusTable }, } = state;
        if (!focusTable)
            return 'columnName';
        const columnTypes = getColumnTypes(state);
        const index = columnTypes.indexOf(focusTable.focusType);
        return isFirstColumn(state)
            ? columnTypes[columnTypes.length - 1]
            : columnTypes[index - 1];
    }
    function getRemoveFirstColumnId(focusTable, columnIds) {
        if (!focusTable.columnId)
            return null;
        const columnIndex = getIndex(focusTable.table.columns, focusTable.columnId);
        if (columnIndex <= 0)
            return null;
        let columnId = null;
        for (let i = columnIndex; i >= 0; i--) {
            const column = focusTable.table.columns[i];
            if (!columnIds.includes(column.id)) {
                columnId = column.id;
                break;
            }
        }
        return columnId;
    }
    function getTableTypes({ canvasState: { show } }) {
        return show.tableComment ? ['tableName', 'tableComment'] : ['tableName'];
    }
    function isLastTable(state) {
        const { editorState: { focusTable }, } = state;
        if (!focusTable)
            return true;
        const tableTypes = getTableTypes(state);
        const index = tableTypes.indexOf(focusTable.focusType);
        return index === tableTypes.length - 1;
    }
    function isFirstTable(state) {
        const { editorState: { focusTable }, } = state;
        if (!focusTable)
            return true;
        const tableTypes = getTableTypes(state);
        const index = tableTypes.indexOf(focusTable.focusType);
        return index === 0;
    }
    const isTableFocusType = (focusType) => tableTypes.includes(focusType);
    function getNextRightTableType(state) {
        const { editorState: { focusTable }, } = state;
        if (!focusTable)
            return 'tableName';
        const tableTypes = getTableTypes(state);
        const index = tableTypes.indexOf(focusTable.focusType);
        return isLastTable(state) ? tableTypes[0] : tableTypes[index + 1];
    }
    function getNextLeftTableType(state) {
        const { editorState: { focusTable }, } = state;
        if (!focusTable)
            return 'tableName';
        const tableTypes = getTableTypes(state);
        const index = tableTypes.indexOf(focusTable.focusType);
        return isFirstTable(state)
            ? tableTypes[tableTypes.length - 1]
            : tableTypes[index - 1];
    }
    function arrowUp$1(state, data) {
        const { editorState: { focusTable }, } = state;
        if (!focusTable)
            return;
        if (isTableFocusType(focusTable.focusType)) {
            if (isColumns(focusTable)) {
                const columnId = focusTable.table.columns[focusTable.table.columns.length - 1].id;
                focusTable.focusType = getLastColumnType(state);
                focusTable.columnId = columnId;
                focusTable.prevSelectColumnId = columnId;
                focusTable.selectColumnIds = [columnId];
            }
        }
        else {
            if (isFirstRowColumn(focusTable)) {
                focusTable.focusType = 'tableName';
                focusTable.columnId = null;
                focusTable.prevSelectColumnId = null;
                focusTable.selectColumnIds = [];
            }
            else if (focusTable.columnId) {
                const index = getIndex(focusTable.table.columns, focusTable.columnId);
                const column = focusTable.table.columns[index - 1];
                focusTable.columnId = column.id;
                focusTable.prevSelectColumnId = column.id;
                if (data.shiftKey && data.moveKey !== 'Tab') {
                    focusTable.selectColumnIds = appendSelectColumns(focusTable.selectColumnIds, column.id);
                }
                else {
                    focusTable.selectColumnIds = [column.id];
                }
            }
        }
    }
    function arrowDown$1(state, data) {
        const { editorState: { focusTable }, } = state;
        if (!focusTable)
            return;
        if (isTableFocusType(focusTable.focusType)) {
            if (isColumns(focusTable)) {
                const columnId = focusTable.table.columns[0].id;
                focusTable.focusType = getFirstColumnType(state);
                focusTable.columnId = columnId;
                focusTable.prevSelectColumnId = columnId;
                focusTable.selectColumnIds = [columnId];
            }
        }
        else {
            if (isLastRowColumn(focusTable)) {
                focusTable.focusType = 'tableName';
                focusTable.columnId = null;
                focusTable.prevSelectColumnId = null;
                focusTable.selectColumnIds = [];
            }
            else if (focusTable.columnId) {
                const index = getIndex(focusTable.table.columns, focusTable.columnId);
                const column = focusTable.table.columns[index + 1];
                focusTable.columnId = column.id;
                focusTable.prevSelectColumnId = column.id;
                if (data.shiftKey && data.moveKey !== 'Tab') {
                    focusTable.selectColumnIds = appendSelectColumns(focusTable.selectColumnIds, column.id);
                }
                else {
                    focusTable.selectColumnIds = [column.id];
                }
            }
        }
    }
    function arrowRight$1(state, data) {
        const { editorState: { focusTable }, } = state;
        if (!focusTable)
            return;
        if (isTableFocusType(focusTable.focusType)) {
            if (isLastTable(state)) {
                if (isColumns(focusTable)) {
                    const columnId = focusTable.table.columns[0].id;
                    focusTable.focusType = getFirstColumnType(state);
                    focusTable.columnId = columnId;
                    focusTable.prevSelectColumnId = columnId;
                    focusTable.selectColumnIds = [columnId];
                }
                else {
                    focusTable.focusType = getNextRightTableType(state);
                }
            }
            else {
                focusTable.focusType = getNextRightTableType(state);
            }
        }
        else {
            if (isLastColumn(state)) {
                if (isLastRowColumn(focusTable)) {
                    focusTable.focusType = 'tableName';
                    focusTable.columnId = null;
                    focusTable.prevSelectColumnId = null;
                    focusTable.selectColumnIds = [];
                }
                else if (focusTable.columnId) {
                    const index = getIndex(focusTable.table.columns, focusTable.columnId);
                    const column = focusTable.table.columns[index + 1];
                    focusTable.focusType = getFirstColumnType(state);
                    focusTable.columnId = column.id;
                    focusTable.prevSelectColumnId = column.id;
                    if (data.shiftKey && data.moveKey !== 'Tab') {
                        focusTable.selectColumnIds = appendSelectColumns(focusTable.selectColumnIds, column.id);
                    }
                    else {
                        focusTable.selectColumnIds = [column.id];
                    }
                }
            }
            else {
                focusTable.focusType = getNextRightColumnType(state);
                if (!data.shiftKey && focusTable.columnId) {
                    focusTable.prevSelectColumnId = focusTable.columnId;
                    focusTable.selectColumnIds = [focusTable.columnId];
                }
            }
        }
    }
    function arrowLeft$1(state, data) {
        const { editorState: { focusTable }, canvasState: { show }, } = state;
        if (!focusTable)
            return;
        if (isTableFocusType(focusTable.focusType)) {
            if (isFirstTable(state)) {
                if (isColumns(focusTable)) {
                    const columnId = focusTable.table.columns[focusTable.table.columns.length - 1].id;
                    focusTable.focusType = getLastColumnType(state);
                    focusTable.columnId = columnId;
                    focusTable.prevSelectColumnId = columnId;
                    focusTable.selectColumnIds = [columnId];
                }
                else {
                    focusTable.focusType = getNextLeftTableType(state);
                }
            }
            else {
                focusTable.focusType = getNextLeftTableType(state);
            }
        }
        else {
            if (isFirstColumn(state)) {
                if (isFirstRowColumn(focusTable)) {
                    focusTable.focusType = show.tableComment ? 'tableComment' : 'tableName';
                    focusTable.columnId = null;
                    focusTable.prevSelectColumnId = null;
                    focusTable.selectColumnIds = [];
                }
                else if (focusTable.columnId) {
                    const index = getIndex(focusTable.table.columns, focusTable.columnId);
                    const column = focusTable.table.columns[index - 1];
                    focusTable.focusType = getLastColumnType(state);
                    focusTable.columnId = column.id;
                    focusTable.prevSelectColumnId = column.id;
                    if (data.shiftKey && data.moveKey !== 'Tab') {
                        focusTable.selectColumnIds = appendSelectColumns(focusTable.selectColumnIds, column.id);
                    }
                    else {
                        focusTable.selectColumnIds = [column.id];
                    }
                }
            }
            else {
                focusTable.focusType = getNextLeftColumnType(state);
                if (!data.shiftKey && focusTable.columnId) {
                    focusTable.prevSelectColumnId = focusTable.columnId;
                    focusTable.selectColumnIds = [focusTable.columnId];
                }
            }
        }
    }

    const zIndexMap = (data) => data.ui.zIndex;
    const nextZIndex = (tables, memos) => Math.max(1, ...tables.map(zIndexMap), ...memos.map(zIndexMap)) + 1;
    const isDuplicatePosition = (ui, point) => ui.top === point.y && ui.left === point.x;
    function nextPoint({ canvasState: { scrollLeft, scrollTop }, tableState: { tables }, memoState: { memos }, }) {
        const point = {
            x: SIZE_START_X - scrollLeft,
            y: SIZE_START_Y - scrollTop,
        };
        let isPosition = false;
        do {
            isPosition = false;
            for (const table of tables) {
                if (isDuplicatePosition(table.ui, point)) {
                    point.x += SIZE_START_ADD;
                    point.y += SIZE_START_ADD;
                    isPosition = true;
                    break;
                }
            }
            for (const memo of memos) {
                if (isDuplicatePosition(memo.ui, point)) {
                    point.x += SIZE_START_ADD;
                    point.y += SIZE_START_ADD;
                    isPosition = true;
                    break;
                }
            }
        } while (isPosition);
        return point;
    }

    function addRelationship(relationshipType, startTable, endTableId, constraintName) {
        const columnIds = startTable.columns
            .filter(column => column.option.primaryKey)
            .map(column => column.id);
        return createCommand$1('relationship.add', {
            id: v4(),
            relationshipType,
            start: {
                tableId: startTable.id,
                columnIds,
            },
            end: {
                tableId: endTableId,
                columnIds: columnIds.map(() => v4()),
            },
            constraintName,
        });
    }
    const removeRelationship = (relationshipIds) => createCommand$1('relationship.remove', { relationshipIds });
    const changeRelationshipType = (relationshipId, relationshipType) => createCommand$1('relationship.changeRelationshipType', {
        relationshipId,
        relationshipType,
    });
    const changeStartRelationshipType = (relationshipId, startRelationshipType) => createCommand$1('relationship.changeStartRelationshipType', {
        relationshipId,
        startRelationshipType,
    });
    const changeIdentification = (relationshipId, identification) => createCommand$1('relationship.changeIdentification', {
        relationshipId,
        identification,
    });
    const loadRelationship = (relationship) => createCommand$1('relationship.load', relationship);
    const hideRelationship = (relationshipId) => createCommand$1('relationship.hide', { relationshipId });
    const showRelationship = (relationshipId) => createCommand$1('relationship.show', { relationshipId });

    var relationshipCommand = /*#__PURE__*/Object.freeze({
        __proto__: null,
        addRelationship: addRelationship,
        removeRelationship: removeRelationship,
        changeRelationshipType: changeRelationshipType,
        changeStartRelationshipType: changeStartRelationshipType,
        changeIdentification: changeIdentification,
        loadRelationship: loadRelationship,
        hideRelationship: hideRelationship,
        showRelationship: showRelationship
    });

    function* addTable$(store, active = true) {
        yield selectEndTable();
        yield selectEndMemo();
        const addTableCmd = addTable(store, active);
        yield addTableCmd;
        yield focusTable(addTableCmd.data.id);
    }
    function* selectTable$(store, ctrlKey, tableId) {
        const { editorState: { drawRelationship }, } = store;
        yield selectTable(store, ctrlKey, tableId);
        if (!ctrlKey) {
            yield selectEndMemo();
        }
        yield focusTable(tableId);
        if (!drawRelationship)
            return;
        if (drawRelationship.start) {
            const endTable = getData(store.tableState.tables, tableId);
            const fkName = `fk_${drawRelationship.start.table.name}_to_${endTable === null || endTable === void 0 ? void 0 : endTable.name}`.toLowerCase();
            const addRelationshipCmd = addRelationship(drawRelationship.relationshipType, drawRelationship.start.table, tableId, fkName);
            const startTable = drawRelationship.start.table;
            const { start, end } = addRelationshipCmd.data;
            const createEndColumns = [];
            start.columnIds.forEach((startColumnId, index) => {
                const startColumn = getData(startTable.columns, startColumnId);
                if (!startColumn)
                    return;
                createEndColumns.push({
                    tableId: end.tableId,
                    id: end.columnIds[index],
                    option: {
                        autoIncrement: false,
                        primaryKey: false,
                        unique: false,
                        notNull: true,
                    },
                    ui: {
                        active: false,
                        pk: false,
                        fk: true,
                        pfk: false,
                    },
                    value: {
                        name: startColumn.name,
                        comment: startColumn.comment,
                        dataType: startColumn.dataType,
                        default: startColumn.default,
                        widthName: startColumn.ui.widthName,
                        widthComment: startColumn.ui.widthComment,
                        widthDataType: startColumn.ui.widthDataType,
                        widthDefault: startColumn.ui.widthDefault,
                    },
                });
            });
            yield createCommand$1('column.addCustom', createEndColumns);
            yield addRelationshipCmd;
            yield drawEndRelationship();
        }
        else {
            yield drawStartAddRelationship$(store, tableId);
        }
    }
    function* selectEndTable$() {
        yield selectEndTable();
        yield focusTableEnd();
    }
    function* addTableDefault$(tableId, helper) {
        const idCol = new ColumnModel({
            addColumn: { tableId: tableId, id: v4() },
        });
        idCol.name = 'id';
        idCol.dataType = 'INT';
        idCol.option.autoIncrement = true;
        idCol.option.primaryKey = true;
        idCol.ui.pk = true;
        const createdAt = new ColumnModel({
            addColumn: { tableId, id: v4() },
        });
        createdAt.name = 'created_at';
        createdAt.dataType = 'timestamp';
        createdAt.ui.widthName = helper.getTextWidth('created_at');
        const updatedAt = new ColumnModel({
            addColumn: { tableId, id: v4() },
        });
        updatedAt.name = 'updated_at';
        updatedAt.dataType = 'timestamp';
        createdAt.ui.widthName = helper.getTextWidth('updated_at');
        createdAt.ui.widthDataType = helper.getTextWidth('timestamp');
        yield loadColumn(tableId, [updatedAt, createdAt, idCol], []);
    }

    function addTable(store, active = true) {
        const { tableState, memoState } = store;
        const point = nextPoint(store);
        return createCommand$1('table.add', {
            id: v4(),
            ui: {
                active,
                left: point.x,
                top: point.y,
                zIndex: nextZIndex(tableState.tables, memoState.memos),
            },
        });
    }
    const moveTable = ({ tableState: { tables }, memoState: { memos }, canvasState: { zoomLevel }, }, ctrlKey, movementX, movementY, tableId) => createCommand$1('table.move', {
        movementX: movementX / zoomLevel,
        movementY: movementY / zoomLevel,
        tableIds: ctrlKey
            ? tables.filter(table => table.ui.active).map(table => table.id)
            : [tableId],
        memoIds: ctrlKey
            ? memos.filter(memo => memo.ui.active).map(memo => memo.id)
            : [],
    });
    const removeTable = ({ tableState: { tables } }, tableId) => createCommand$1('table.remove', {
        tableIds: tableId
            ? [tableId]
            : tables.filter(table => table.ui.active).map(table => table.id),
    });
    const selectTable = ({ tableState: { tables }, memoState: { memos } }, ctrlKey, tableId) => createCommand$1('table.select', {
        ctrlKey,
        tableId,
        zIndex: nextZIndex(tables, memos),
    });
    const selectEndTable = () => createCommand$1('table.selectEnd', null);
    const selectAllTable = () => createCommand$1('table.selectAll', null);
    function changeTableName(helper, tableId, value) {
        const width = helper.getTextWidth(value);
        return createCommand$1('table.changeName', {
            tableId,
            value,
            width: width < SIZE_MIN_WIDTH ? SIZE_MIN_WIDTH : width,
        });
    }
    function changeTableComment(helper, tableId, value) {
        const width = helper.getTextWidth(value);
        return createCommand$1('table.changeComment', {
            tableId,
            value,
            width: width < SIZE_MIN_WIDTH ? SIZE_MIN_WIDTH : width,
        });
    }
    const dragSelectTable = (min, max) => createCommand$1('table.dragSelect', {
        min,
        max,
    });
    const sortTable = () => createCommand$1('table.sort', null);
    const loadTable = (table) => createCommand$1('table.load', table);
    const hideTable = (tableId) => createCommand$1('table.hide', { tableId });
    const showTable = (tableId) => createCommand$1('table.show', { tableId });
    const changeColorTable = ({ tableState: { tables }, memoState: { memos } }, ctrlKey, color, tableId) => createCommand$1('table.changeColor', {
        tableIds: ctrlKey
            ? tables.filter(table => table.ui.active).map(table => table.id)
            : [tableId],
        memoIds: ctrlKey
            ? memos.filter(memo => memo.ui.active).map(memo => memo.id)
            : [],
        color,
    });

    var tableCommand = /*#__PURE__*/Object.freeze({
        __proto__: null,
        addTable: addTable,
        moveTable: moveTable,
        removeTable: removeTable,
        selectTable: selectTable,
        selectEndTable: selectEndTable,
        selectAllTable: selectAllTable,
        changeTableName: changeTableName,
        changeTableComment: changeTableComment,
        dragSelectTable: dragSelectTable,
        sortTable: sortTable,
        loadTable: loadTable,
        hideTable: hideTable,
        showTable: showTable,
        changeColorTable: changeColorTable,
        addTable$: addTable$,
        selectTable$: selectTable$,
        selectEndTable$: selectEndTable$,
        addTableDefault$: addTableDefault$
    });

    function* addMemo$(store, active = true) {
        yield selectEndTable$();
        yield selectEndMemo();
        yield addMemo(store, active);
    }
    function* selectMemo$(store, ctrlKey, memoId) {
        yield selectMemo(store, ctrlKey, memoId);
        if (!ctrlKey) {
            yield selectEndTable$();
        }
    }

    function addMemo(store, active = true) {
        const { tableState, memoState } = store;
        const point = nextPoint(store);
        return createCommand$1('memo.add', {
            id: v4(),
            ui: {
                active,
                left: point.x,
                top: point.y,
                zIndex: nextZIndex(tableState.tables, memoState.memos),
                width: SIZE_MEMO_WIDTH,
                height: SIZE_MEMO_HEIGHT,
            },
        });
    }
    const moveMemo = ({ tableState: { tables }, memoState: { memos }, canvasState: { zoomLevel }, }, ctrlKey, movementX, movementY, memoId) => createCommand$1('memo.move', {
        movementX: movementX / zoomLevel,
        movementY: movementY / zoomLevel,
        tableIds: ctrlKey
            ? tables.filter(table => table.ui.active).map(table => table.id)
            : [],
        memoIds: ctrlKey
            ? memos.filter(memo => memo.ui.active).map(memo => memo.id)
            : [memoId],
    });
    const removeMemo = ({ memoState: { memos } }, memoId) => createCommand$1('memo.remove', {
        memoIds: memoId
            ? [memoId]
            : memos.filter(memo => memo.ui.active).map(memo => memo.id),
    });
    const selectMemo = ({ tableState: { tables }, memoState: { memos } }, ctrlKey, memoId) => createCommand$1('memo.select', {
        ctrlKey,
        memoId,
        zIndex: nextZIndex(tables, memos),
    });
    const selectEndMemo = () => createCommand$1('memo.selectEnd', null);
    const selectAllMemo = () => createCommand$1('memo.selectAll', null);
    const changeMemoValue = (memoId, value) => createCommand$1('memo.changeValue', { memoId, value });
    const resizeMemo = (memoId, top, left, width, height) => createCommand$1('memo.resize', {
        memoId,
        top,
        left,
        width,
        height,
    });
    const dragSelectMemo = (min, max) => createCommand$1('memo.dragSelect', { min, max });
    const loadMemo = (memo) => createCommand$1('memo.load', memo);
    const changeColorMemo = ({ tableState: { tables }, memoState: { memos } }, ctrlKey, color, memoId) => createCommand$1('memo.changeColor', {
        tableIds: ctrlKey
            ? tables.filter(table => table.ui.active).map(table => table.id)
            : [],
        memoIds: ctrlKey
            ? memos.filter(memo => memo.ui.active).map(memo => memo.id)
            : [memoId],
        color,
    });

    var memoCommand = /*#__PURE__*/Object.freeze({
        __proto__: null,
        addMemo: addMemo,
        moveMemo: moveMemo,
        removeMemo: removeMemo,
        selectMemo: selectMemo,
        selectEndMemo: selectEndMemo,
        selectAllMemo: selectAllMemo,
        changeMemoValue: changeMemoValue,
        resizeMemo: resizeMemo,
        dragSelectMemo: dragSelectMemo,
        loadMemo: loadMemo,
        changeColorMemo: changeColorMemo,
        addMemo$: addMemo$,
        selectMemo$: selectMemo$
    });

    function* focusMoveTable$(store, moveKey, shiftKey) {
        const { editorState: { focusTable }, } = store;
        if (!focusTable)
            return;
        if (moveKey === 'Tab' &&
            !shiftKey &&
            ((isTableFocusType(focusTable.focusType) &&
                isLastTable(store) &&
                !isColumns(focusTable)) ||
                (!isTableFocusType(focusTable.focusType) &&
                    isLastColumn(store) &&
                    isLastRowColumn(focusTable)))) {
            yield addColumn$(store, focusTable.table.id);
        }
        else {
            yield focusMoveTable(moveKey, shiftKey);
        }
    }
    function* drawStartRelationship$({ editorState }, relationshipType) {
        var _a;
        if (((_a = editorState.drawRelationship) === null || _a === void 0 ? void 0 : _a.relationshipType) === relationshipType) {
            yield drawEndRelationship();
        }
        else {
            yield drawStartRelationship(relationshipType);
        }
    }
    function* drawStartAddRelationship$({ tableState: { tables } }, tableId) {
        const table = getData(tables, tableId);
        if (!table)
            return;
        if (!table.columns.some(column => column.option.primaryKey)) {
            const addCustomColumnCmd = addCustomColumn({
                autoIncrement: false,
                primaryKey: true,
                unique: false,
                notNull: true,
            }, {
                active: false,
                pk: true,
                fk: false,
                pfk: false,
            }, null, [tableId]);
            yield addCustomColumnCmd;
            const column = addCustomColumnCmd.data[0];
            yield focusColumn(tableId, column.id, 'columnName');
        }
        yield drawStartAddRelationship(tableId);
    }
    function* loadJson$(value) {
        yield clear();
        yield loadJson(value);
    }
    function* initLoadJson$(value) {
        yield initClear();
        yield initLoadJson(value);
    }
    function* pasteColumn$({ editorState, tableState: { tables } }) {
        const copyColumns = [...editorState.copyColumns];
        const tableIds = tables
            .filter(table => table.ui.active)
            .map(table => table.id);
        while (copyColumns.length && tableIds.length) {
            const column = copyColumns.shift();
            const { option, ui } = column;
            yield addCustomColumn({
                autoIncrement: option.autoIncrement,
                primaryKey: option.primaryKey,
                unique: option.unique,
                notNull: option.notNull,
            }, {
                active: false,
                pk: option.primaryKey,
                fk: false,
                pfk: false,
            }, {
                name: column.name,
                dataType: column.dataType,
                default: column.default,
                comment: column.comment,
                widthName: ui.widthName,
                widthDataType: ui.widthDataType,
                widthDefault: ui.widthDefault,
                widthComment: ui.widthComment,
            }, tableIds);
        }
    }
    function* findActive$() {
        yield findActive();
        yield selectEndTable$();
        yield selectEndMemo();
    }
    function* readonlyEditor$(readonly) {
        if (readonly) {
            yield editTableEnd();
            yield drawEndRelationship();
            yield draggableColumnEnd();
            yield readonlyEditor(readonly);
        }
        else {
            yield readonlyEditor(readonly);
        }
    }

    const appendSelectFilters = (filterIds, filterId) => uniq$1([...filterIds, filterId]);
    function selectRangeFilters(filters, fromFilterId, toFilterId) {
        if (!fromFilterId || fromFilterId === toFilterId)
            return [toFilterId];
        const fromIndex = getIndex(filters, fromFilterId);
        const toIndex = getIndex(filters, toFilterId);
        if (fromIndex === -1)
            return [toFilterId];
        return range(fromIndex, toIndex).map(index => filters[index].id);
    }
    const appendSelectRangeFilters = (filters, filterIds, fromFilterId, toFilterId) => uniq$1([
        ...filterIds,
        ...selectRangeFilters(filters, fromFilterId, toFilterId),
    ]);

    const isFilterFocusType = (focusType) => focusFilterTypes.includes(focusType);
    const isFilters = (state) => !!state.filters.length;
    function isFirstRowFilter({ filters, focus }) {
        if (!focus || !focus.filterId)
            return;
        const index = getIndex(filters, focus.filterId);
        return index === 0;
    }
    function isLastRowFilter({ filters, focus }) {
        if (!focus || !focus.filterId)
            return;
        const index = getIndex(filters, focus.filterId);
        return index === filters.length - 1;
    }
    function isLastFilterColumn({ focus }) {
        if (!focus || !focus.filterId)
            return;
        const index = focusFilterTypes.indexOf(focus.focusType);
        return index === focusFilterTypes.length - 1;
    }
    function isFirstFilterColumn({ focus }) {
        if (!focus || !focus.filterId)
            return;
        const index = focusFilterTypes.indexOf(focus.focusType);
        return index === 0;
    }
    function getNextRightFilterColumnType(state) {
        const { focus } = state;
        if (!focus || !focus.filterId)
            return 'columnType';
        const index = focusFilterTypes.indexOf(focus.focusType);
        return isLastFilterColumn(state)
            ? focusFilterTypes[0]
            : focusFilterTypes[index + 1];
    }
    function getNextLeftFilterColumnType(state) {
        const { focus } = state;
        if (!focus || !focus.filterId)
            return 'columnType';
        const index = focusFilterTypes.indexOf(focus.focusType);
        return isFirstFilterColumn(state)
            ? focusFilterTypes[focusFilterTypes.length - 1]
            : focusFilterTypes[index - 1];
    }
    function getRemoveFirstFilterId({ focus, filters }, filterIds) {
        if (!(focus === null || focus === void 0 ? void 0 : focus.filterId))
            return null;
        const filterIndex = getIndex(filters, focus.filterId);
        if (filterIndex <= 0)
            return null;
        let filterId = null;
        for (let i = filterIndex; i >= 0; i--) {
            const filter = filters[i];
            if (!filterIds.includes(filter.id)) {
                filterId = filter.id;
                break;
            }
        }
        return filterId;
    }
    function arrowUp(state, data) {
        const { focus, filters } = state;
        if (!focus)
            return;
        if (isFilterFocusType(focus.focusType)) {
            if (isFirstRowFilter(state)) {
                focus.focusType = 'operatorType';
                focus.filterId = null;
                focus.prevSelectFilterId = null;
                focus.selectFilterIds = [];
            }
            else if (focus.filterId) {
                const index = getIndex(filters, focus.filterId);
                const filter = filters[index - 1];
                focus.filterId = filter.id;
                focus.prevSelectFilterId = filter.id;
                if (data.shiftKey && data.moveKey !== 'Tab') {
                    focus.selectFilterIds = appendSelectFilters(focus.selectFilterIds, filter.id);
                }
                else {
                    focus.selectFilterIds = [filter.id];
                }
            }
        }
        else {
            if (isFilters(state)) {
                const filterId = filters[filters.length - 1].id;
                focus.focusType = 'value';
                focus.filterId = filterId;
                focus.prevSelectFilterId = filterId;
                focus.selectFilterIds = [filterId];
            }
        }
    }
    function arrowDown(state, data) {
        const { focus, filters } = state;
        if (!focus)
            return;
        if (isFilterFocusType(focus.focusType)) {
            if (isLastRowFilter(state)) {
                focus.focusType = 'operatorType';
                focus.filterId = null;
                focus.prevSelectFilterId = null;
                focus.selectFilterIds = [];
            }
            else if (focus.filterId) {
                const index = getIndex(filters, focus.filterId);
                const filter = filters[index + 1];
                focus.filterId = filter.id;
                focus.prevSelectFilterId = filter.id;
                if (data.shiftKey && data.moveKey !== 'Tab') {
                    focus.selectFilterIds = appendSelectFilters(focus.selectFilterIds, filter.id);
                }
                else {
                    focus.selectFilterIds = [filter.id];
                }
            }
        }
        else {
            if (isFilters(state)) {
                const filterId = filters[0].id;
                focus.focusType = 'columnType';
                focus.filterId = filterId;
                focus.prevSelectFilterId = filterId;
                focus.selectFilterIds = [filterId];
            }
        }
    }
    function arrowRight(state, data) {
        const { focus, filters } = state;
        if (!focus)
            return;
        if (isFilterFocusType(focus.focusType)) {
            if (isLastFilterColumn(state)) {
                if (isLastRowFilter(state)) {
                    focus.focusType = 'operatorType';
                    focus.filterId = null;
                    focus.prevSelectFilterId = null;
                    focus.selectFilterIds = [];
                }
                else if (focus.filterId) {
                    const index = getIndex(filters, focus.filterId);
                    const filter = filters[index + 1];
                    focus.focusType = 'columnType';
                    focus.filterId = filter.id;
                    focus.prevSelectFilterId = filter.id;
                    if (data.shiftKey && data.moveKey !== 'Tab') {
                        focus.selectFilterIds = appendSelectFilters(focus.selectFilterIds, filter.id);
                    }
                    else {
                        focus.selectFilterIds = [filter.id];
                    }
                }
            }
            else {
                focus.focusType = getNextRightFilterColumnType(state);
                if (!data.shiftKey && focus.filterId) {
                    focus.prevSelectFilterId = focus.filterId;
                    focus.selectFilterIds = [focus.filterId];
                }
            }
        }
        else {
            if (isFilters(state)) {
                const filterId = filters[0].id;
                focus.focusType = 'columnType';
                focus.filterId = filterId;
                focus.prevSelectFilterId = filterId;
                focus.selectFilterIds = [filterId];
            }
        }
    }
    function arrowLeft(state, data) {
        const { focus, filters } = state;
        if (!focus)
            return;
        if (isFilterFocusType(focus.focusType)) {
            if (isFirstFilterColumn(state)) {
                if (isFirstRowFilter(state)) {
                    focus.focusType = 'operatorType';
                    focus.filterId = null;
                    focus.prevSelectFilterId = null;
                    focus.selectFilterIds = [];
                }
                else if (focus.filterId) {
                    const index = getIndex(filters, focus.filterId);
                    const filter = filters[index - 1];
                    focus.focusType = 'value';
                    focus.filterId = filter.id;
                    focus.prevSelectFilterId = filter.id;
                    if (data.shiftKey && data.moveKey !== 'Tab') {
                        focus.selectFilterIds = appendSelectFilters(focus.selectFilterIds, filter.id);
                    }
                    else {
                        focus.selectFilterIds = [filter.id];
                    }
                }
            }
            else {
                focus.focusType = getNextLeftFilterColumnType(state);
                if (!data.shiftKey && focus.filterId) {
                    focus.prevSelectFilterId = focus.filterId;
                    focus.selectFilterIds = [focus.filterId];
                }
            }
        }
        else {
            if (isFilters(state)) {
                const filterId = filters[filters.length - 1].id;
                focus.focusType = 'value';
                focus.filterId = filterId;
                focus.prevSelectFilterId = filterId;
                focus.selectFilterIds = [filterId];
            }
        }
    }

    function* filterActive$() {
        yield filterActive();
        yield filterFocus();
    }
    function* filterActiveEnd$() {
        yield filterActiveEnd();
        yield focusFilterEnd();
    }
    function* addFilter$() {
        const addFilterCmd = addFilter();
        yield addFilterCmd;
        yield focusFilter(addFilterCmd.data.id, 'columnType');
    }
    function* removeFilter$({ editorState: { filterState } }, filterIds) {
        if (filterState.focus && filterState.focus.filterId) {
            const filterId = getRemoveFirstFilterId(filterState, filterIds);
            if (filterId) {
                yield focusFilter(filterId, filterState.focus.focusType);
            }
            else {
                yield filterFocus();
            }
        }
        yield removeFilter(filterIds);
    }
    function* focusMoveFilter$({ editorState: { filterState } }, moveKey, shiftKey) {
        const { focus } = filterState;
        if (!focus)
            return;
        if ((moveKey === 'Tab' &&
            !shiftKey &&
            isFilterFocusType(focus.focusType) &&
            isLastFilterColumn(filterState) &&
            isLastRowFilter(filterState)) ||
            (!isFilterFocusType(focus.focusType) && !isFilters(filterState))) {
            yield addFilter$();
        }
        else {
            yield focusMoveFilter(moveKey, shiftKey);
        }
    }

    const filterActive = () => createCommand$1('editor.filter.active', null);
    const filterActiveEnd = () => createCommand$1('editor.filter.activeEnd', null);
    const addFilter = () => createCommand$1('editor.filter.add', {
        id: v4(),
    });
    const removeFilter = (filterIds) => createCommand$1('editor.filter.remove', {
        filterIds,
    });
    const changeFilterColumnType = (filterId, columnType) => createCommand$1('editor.filter.changeColumnType', {
        filterId,
        columnType,
    });
    const changeFilterCode = (filterId, filterCode) => createCommand$1('editor.filter.changeFilterCode', {
        filterId,
        filterCode,
    });
    const changeFilterValue = (filterId, value) => createCommand$1('editor.filter.changeValue', {
        filterId,
        value,
    });
    const moveFilter = (filterIds, targetFilterId) => createCommand$1('editor.filter.move', {
        filterIds,
        targetFilterId,
    });
    const changeFilterOperatorType = (operatorType) => createCommand$1('editor.filter.changeOperatorType', {
        operatorType,
    });
    const filterFocus = (focusType) => createCommand$1('editor.filter.focus', {
        focusType,
    });
    const focusFilter = (filterId, focusType, ctrlKey = false, shiftKey = false) => createCommand$1('editor.filter.focusFilter', {
        filterId,
        focusType,
        ctrlKey,
        shiftKey,
    });
    const focusFilterEnd = () => createCommand$1('editor.filter.focusEnd', null);
    const focusMoveFilter = (moveKey, shiftKey) => createCommand$1('editor.filter.focusMove', {
        moveKey,
        shiftKey,
    });
    const editFilter = () => createCommand$1('editor.filter.edit', null);
    const editFilterEnd = () => createCommand$1('editor.filter.editEnd', null);
    const selectAllFilter = () => createCommand$1('editor.filter.selectAll', null);
    const draggableFilter = ({ editorState: { filterState: { focus }, }, }, filterId, ctrlKey) => createCommand$1('editor.filter.draggable', {
        filterIds: ctrlKey && focus ? [...focus.selectFilterIds] : [filterId],
    });
    const draggableFilterEnd = () => createCommand$1('editor.filter.draggableEnd', null);

    const hasUndoRedo = (hasUndo, hasRedo) => createCommand$1('editor.hasUndoRedo', { hasUndo, hasRedo });
    const focusTable = (tableId, focusType) => createCommand$1('editor.focusTable', { tableId, focusType });
    const focusColumn = (tableId, columnId, focusType, ctrlKey = false, shiftKey = false) => createCommand$1('editor.focusColumn', {
        tableId,
        columnId,
        focusType,
        ctrlKey,
        shiftKey,
    });
    const focusTableEnd = () => createCommand$1('editor.focusTableEnd', null);
    const focusMoveTable = (moveKey, shiftKey) => createCommand$1('editor.focusMoveTable', { moveKey, shiftKey });
    const editTable = () => createCommand$1('editor.editTable', null);
    const editTableEnd = () => createCommand$1('editor.editTableEnd', null);
    const selectAllColumn = () => createCommand$1('editor.selectAllColumn', null);
    const drawStartRelationship = (relationshipType) => createCommand$1('editor.drawStartRelationship', { relationshipType });
    const drawStartAddRelationship = (tableId) => createCommand$1('editor.drawStartAddRelationship', { tableId });
    const drawEndRelationship = () => createCommand$1('editor.drawEndRelationship', null);
    const drawRelationship = (x, y) => createCommand$1('editor.drawRelationship', { x, y });
    const draggableColumn = ({ editorState: { focusTable } }, tableId, columnId, ctrlKey) => createCommand$1('editor.draggableColumn', {
        tableId,
        columnIds: ctrlKey && focusTable ? [...focusTable.selectColumnIds] : [columnId],
    });
    const draggableColumnEnd = () => createCommand$1('editor.draggableColumnEnd', null);
    const loadJson = (value) => createCommand$1('editor.loadJson', { value });
    const initLoadJson = (value) => createCommand$1('editor.initLoadJson', { value });
    const clear = () => createCommand$1('editor.clear', null);
    const initClear = () => createCommand$1('editor.initClear', null);
    const changeViewport = (width, height) => createCommand$1('editor.changeViewport', { width, height });
    const copyColumn = (tableId, columnIds) => createCommand$1('editor.copyColumn', {
        tableId,
        columnIds,
    });
    const findActive = () => createCommand$1('editor.findActive', null);
    const findActiveEnd = () => createCommand$1('editor.findActiveEnd', null);
    const readonlyEditor = (readonly) => createCommand$1('editor.readonly', { readonly });

    var editorCommand = /*#__PURE__*/Object.freeze({
        __proto__: null,
        hasUndoRedo: hasUndoRedo,
        focusTable: focusTable,
        focusColumn: focusColumn,
        focusTableEnd: focusTableEnd,
        focusMoveTable: focusMoveTable,
        editTable: editTable,
        editTableEnd: editTableEnd,
        selectAllColumn: selectAllColumn,
        drawStartRelationship: drawStartRelationship,
        drawStartAddRelationship: drawStartAddRelationship,
        drawEndRelationship: drawEndRelationship,
        drawRelationship: drawRelationship,
        draggableColumn: draggableColumn,
        draggableColumnEnd: draggableColumnEnd,
        loadJson: loadJson,
        initLoadJson: initLoadJson,
        clear: clear,
        initClear: initClear,
        changeViewport: changeViewport,
        copyColumn: copyColumn,
        findActive: findActive,
        findActiveEnd: findActiveEnd,
        readonlyEditor: readonlyEditor,
        focusMoveTable$: focusMoveTable$,
        drawStartRelationship$: drawStartRelationship$,
        drawStartAddRelationship$: drawStartAddRelationship$,
        loadJson$: loadJson$,
        initLoadJson$: initLoadJson$,
        pasteColumn$: pasteColumn$,
        findActive$: findActive$,
        readonlyEditor$: readonlyEditor$,
        filterActive$: filterActive$,
        filterActiveEnd$: filterActiveEnd$,
        addFilter$: addFilter$,
        removeFilter$: removeFilter$,
        focusMoveFilter$: focusMoveFilter$,
        filterActive: filterActive,
        filterActiveEnd: filterActiveEnd,
        addFilter: addFilter,
        removeFilter: removeFilter,
        changeFilterColumnType: changeFilterColumnType,
        changeFilterCode: changeFilterCode,
        changeFilterValue: changeFilterValue,
        moveFilter: moveFilter,
        changeFilterOperatorType: changeFilterOperatorType,
        filterFocus: filterFocus,
        focusFilter: focusFilter,
        focusFilterEnd: focusFilterEnd,
        focusMoveFilter: focusMoveFilter,
        editFilter: editFilter,
        editFilterEnd: editFilterEnd,
        selectAllFilter: selectAllFilter,
        draggableFilter: draggableFilter,
        draggableFilterEnd: draggableFilterEnd
    });

    function* addColumn$(store, tableId) {
        const addColumnCmd = addColumn$1(store, tableId);
        yield addColumnCmd;
        const column = addColumnCmd.data[addColumnCmd.data.length - 1];
        yield focusColumn(column.tableId, column.id, 'columnName');
    }
    function* removeColumn$({ editorState }, tableId, columnIds) {
        if (editorState.focusTable && editorState.focusTable.columnId) {
            const columnId = getRemoveFirstColumnId(editorState.focusTable, columnIds);
            if (columnId) {
                yield focusColumn(editorState.focusTable.table.id, columnId, editorState.focusTable.focusType);
            }
            else {
                yield focusTable(editorState.focusTable.table.id, 'tableName');
            }
        }
        yield removeColumn(tableId, columnIds);
    }
    function* changeColumnPrimaryKey$(store, tableId, columnId) {
        const { tableState: { tables }, } = store;
        const changeColumnPrimaryKeyCmd = changeColumnPrimaryKey(store, tableId, columnId);
        yield changeColumnPrimaryKeyCmd;
        const column = getColumn(tables, tableId, columnId);
        if (!changeColumnPrimaryKeyCmd.data.value || !column || column.option.notNull)
            return;
        yield changeColumnNotNull(store, tableId, columnId);
    }
    function* moveColumn$(store, tableId, columnIds, targetTableId, targetColumnId) {
        yield moveColumn(tableId, columnIds, targetTableId, targetColumnId);
        if (tableId === targetTableId || columnIds.includes(targetColumnId))
            return;
        yield createCommand$1('editor.draggableColumn', {
            tableId: targetTableId,
            columnIds,
        });
        yield selectTable(store, false, targetTableId);
        yield focusColumn(targetTableId, columnIds[0], 'columnName');
    }

    const addColumn$1 = (store, tableId) => createCommand$1('column.add', tableId
        ? [
            {
                id: v4(),
                tableId,
            },
        ]
        : store.tableState.tables
            .filter(table => table.ui.active)
            .map(table => {
            return {
                id: v4(),
                tableId: table.id,
            };
        }));
    const addCustomColumn = (option, ui, value, tableIds) => createCommand$1('column.addCustom', tableIds.map(tableId => ({
        tableId,
        id: v4(),
        option,
        ui,
        value,
    })));
    const removeColumn = (tableId, columnIds) => createCommand$1('column.remove', {
        tableId,
        columnIds,
    });
    const removeOnlyColumn = (tableId, columnIds) => createCommand$1('column.removeOnly', {
        tableId,
        columnIds,
    });
    function changeColumnName(helper, tableId, columnId, value) {
        const width = helper.getTextWidth(value);
        return createCommand$1('column.changeName', {
            tableId,
            columnId,
            value,
            width: width < SIZE_MIN_WIDTH ? SIZE_MIN_WIDTH : width,
        });
    }
    function changeColumnComment(helper, tableId, columnId, value) {
        const width = helper.getTextWidth(value);
        return createCommand$1('column.changeComment', {
            tableId,
            columnId,
            value,
            width: width < SIZE_MIN_WIDTH ? SIZE_MIN_WIDTH : width,
        });
    }
    function changeColumnDataType(helper, tableId, columnId, value) {
        const width = helper.getTextWidth(value);
        return createCommand$1('column.changeDataType', {
            tableId,
            columnId,
            value,
            width: width < SIZE_MIN_WIDTH ? SIZE_MIN_WIDTH : width,
        });
    }
    function changeColumnDefault(helper, tableId, columnId, value) {
        const width = helper.getTextWidth(value);
        return createCommand$1('column.changeDefault', {
            tableId,
            columnId,
            value,
            width: width < SIZE_MIN_WIDTH ? SIZE_MIN_WIDTH : width,
        });
    }
    const changeColumnAutoIncrement = ({ tableState: { tables } }, tableId, columnId) => createCommand$1('column.changeAutoIncrement', {
        tableId,
        columnId,
        value: getChangeOption(tables, tableId, columnId, 'autoIncrement'),
    });
    const changeColumnPrimaryKey = ({ tableState: { tables } }, tableId, columnId) => createCommand$1('column.changePrimaryKey', {
        tableId,
        columnId,
        value: getChangeOption(tables, tableId, columnId, 'primaryKey'),
    });
    const changeColumnUnique = ({ tableState: { tables } }, tableId, columnId) => createCommand$1('column.changeUnique', {
        tableId,
        columnId,
        value: getChangeOption(tables, tableId, columnId, 'unique'),
    });
    const changeColumnNotNull = ({ tableState: { tables } }, tableId, columnId) => createCommand$1('column.changeNotNull', {
        tableId,
        columnId,
        value: getChangeOption(tables, tableId, columnId, 'notNull'),
    });
    const moveColumn = (tableId, columnIds, targetTableId, targetColumnId) => createCommand$1('column.move', {
        tableId,
        columnIds,
        targetTableId,
        targetColumnId,
    });
    const activeColumn = ({ start, end }) => createCommand$1('column.active', [
        {
            tableId: start.tableId,
            columnIds: start.columnIds,
        },
        {
            tableId: end.tableId,
            columnIds: end.columnIds,
        },
    ]);
    const activeEndColumn = ({ start, end }) => createCommand$1('column.activeEnd', [
        {
            tableId: start.tableId,
            columnIds: start.columnIds,
        },
        {
            tableId: end.tableId,
            columnIds: end.columnIds,
        },
    ]);
    const loadColumn = (tableId, columns, indexList) => createCommand$1('column.load', {
        tableId,
        columns,
        indexList,
    });

    var columnCommand = /*#__PURE__*/Object.freeze({
        __proto__: null,
        addColumn: addColumn$1,
        addCustomColumn: addCustomColumn,
        removeColumn: removeColumn,
        removeOnlyColumn: removeOnlyColumn,
        changeColumnName: changeColumnName,
        changeColumnComment: changeColumnComment,
        changeColumnDataType: changeColumnDataType,
        changeColumnDefault: changeColumnDefault,
        changeColumnAutoIncrement: changeColumnAutoIncrement,
        changeColumnPrimaryKey: changeColumnPrimaryKey,
        changeColumnUnique: changeColumnUnique,
        changeColumnNotNull: changeColumnNotNull,
        moveColumn: moveColumn,
        activeColumn: activeColumn,
        activeEndColumn: activeEndColumn,
        loadColumn: loadColumn,
        addColumn$: addColumn$,
        removeColumn$: removeColumn$,
        changeColumnPrimaryKey$: changeColumnPrimaryKey$,
        moveColumn$: moveColumn$
    });

    const contextPanelConfig = observable$1({
        panels: [],
        exclude: [],
    });
    const addPanel = (...newPanels) => contextPanelConfig.panels.push(...newPanels);
    const setExcludePanel = (exclude) => (contextPanelConfig.exclude = exclude);

    const databaseList = [
        'MariaDB',
        'MSSQL',
        'MySQL',
        'Oracle',
        'PostgreSQL',
        'SQLite',
    ];
    const languageList = [
        'GraphQL',
        'C#',
        'Java',
        'Kotlin',
        'TypeScript',
        'JPA',
        'Scala',
    ];
    const nameCaseList = [
        'none',
        'camelCase',
        'pascalCase',
        'snakeCase',
    ];
    const highlightThemes = [
        'MonokaiSublime',
        'VS2015',
        'AtomOneDark',
        'AtomOneLight',
        'GithubGist',
    ];
    const bracketTypes = [
        'none',
        'doubleQuote',
        'singleQuote',
        'backtick',
    ];
    const bracketTypeMap = {
        none: '',
        singleQuote: `'`,
        doubleQuote: `"`,
        backtick: '`',
    };
    const createCanvasState = () => ({
        version: "2.2.10",
        width: 2000,
        height: 2000,
        scrollTop: 0,
        scrollLeft: 0,
        zoomLevel: 1,
        show: {
            tableComment: true,
            columnComment: true,
            columnDataType: true,
            columnDefault: true,
            columnAutoIncrement: false,
            columnPrimaryKey: true,
            columnUnique: false,
            columnNotNull: true,
            relationship: true,
        },
        database: 'MySQL',
        databaseName: '',
        canvasType: 'ERD',
        language: 'GraphQL',
        tableCase: 'pascalCase',
        columnCase: 'camelCase',
        highlightTheme: 'VS2015',
        bracketType: 'none',
        setting: {
            relationshipDataTypeSync: true,
            relationshipOptimization: false,
            columnOrder: [
                'columnName',
                'columnDataType',
                'columnNotNull',
                'columnUnique',
                'columnAutoIncrement',
                'columnDefault',
                'columnComment',
            ],
        },
        pluginSerializationMap: {},
    });

    class FilterModel {
        constructor({ addFilter }) {
            this.columnType = 'tableName';
            this.filterCode = 'contain';
            this.value = '';
            if (addFilter) {
                this.id = addFilter.id;
            }
            else {
                throw new Error('not found filter');
            }
        }
    }

    function executeFilterActive({ editorState: { filterState } }) {
        filterState.active = true;
    }
    function executeFilterActiveEnd({ editorState: { filterState }, }) {
        filterState.active = false;
    }
    function executeAddFilter({ editorState: { filterState: { filters }, }, }, data) {
        filters.push(new FilterModel({ addFilter: data }));
    }
    function executeRemoveFilter({ editorState: { filterState: { filters }, }, }, data) {
        for (let i = 0; i < filters.length; i++) {
            const filter = filters[i];
            if (data.filterIds.includes(filter.id)) {
                filters.splice(i, 1);
                i--;
            }
        }
    }
    function executeChangeFilterColumnType({ editorState: { filterState: { filters }, }, }, data) {
        const filter = getData(filters, data.filterId);
        if (!filter)
            return;
        filter.columnType = data.columnType;
    }
    function executeChangeFilterCode({ editorState: { filterState: { filters }, }, }, data) {
        const filter = getData(filters, data.filterId);
        if (!filter)
            return;
        filter.filterCode = data.filterCode;
    }
    function executeChangeFilterValue({ editorState: { filterState: { filters }, }, }, data) {
        const filter = getData(filters, data.filterId);
        if (!filter)
            return;
        filter.value = data.value;
    }
    function executeMoveFilter({ editorState: { filterState: { filters }, }, }, data) {
        const currentFilters = [];
        data.filterIds.forEach(filterId => {
            const filter = getData(filters, filterId);
            filter && currentFilters.push(filter);
        });
        const targetFilter = getData(filters, data.targetFilterId);
        if (!currentFilters.length ||
            !targetFilter ||
            data.filterIds.includes(data.targetFilterId))
            return;
        const targetIndex = getIndex(filters, targetFilter.id);
        if (targetIndex === -1)
            return;
        currentFilters.forEach(currentFilter => {
            const currentIndex = getIndex(filters, currentFilter.id);
            if (currentIndex === -1)
                return;
            filters.splice(currentIndex, 1);
        });
        filters.splice(targetIndex, 0, ...currentFilters);
    }
    function executeChangeFilterOperatorType({ editorState: { filterState } }, data) {
        filterState.operatorType = data.operatorType;
    }
    function executeFilterFocus({ editorState: { filterState } }, data) {
        if (filterState.focus) {
            filterState.focus.focusType = 'operatorType';
            filterState.focus.filterId = null;
            filterState.focus.prevSelectFilterId = null;
            filterState.focus.selectFilterIds = [];
        }
        else {
            filterState.focus = {
                focusType: 'operatorType',
                filterId: null,
                prevSelectFilterId: null,
                selectFilterIds: [],
                edit: false,
            };
        }
    }
    function executeFocusFilter({ editorState: { filterState } }, data) {
        if (filterState.focus) {
            const focus = filterState.focus;
            focus.filterId = data.filterId;
            focus.focusType = data.focusType;
            if (data.ctrlKey && data.shiftKey) {
                focus.selectFilterIds = appendSelectRangeFilters(filterState.filters, focus.selectFilterIds, focus.prevSelectFilterId, focus.filterId);
            }
            else if (data.shiftKey) {
                focus.selectFilterIds = selectRangeFilters(filterState.filters, focus.prevSelectFilterId, focus.filterId);
            }
            else if (data.ctrlKey) {
                focus.selectFilterIds = appendSelectFilters(focus.selectFilterIds, data.filterId);
            }
            else {
                focus.selectFilterIds = [data.filterId];
            }
            focus.prevSelectFilterId = data.filterId;
        }
        else {
            filterState.focus = {
                focusType: data.focusType,
                filterId: data.filterId,
                prevSelectFilterId: data.filterId,
                selectFilterIds: [data.filterId],
                edit: false,
            };
        }
    }
    function executeFocusFilterEnd({ editorState: { filterState } }) {
        filterState.focus = null;
    }
    function executeFocusMoveFilter({ editorState: { filterState } }, data) {
        if (!filterState.focus)
            return;
        filterState.focus.edit = false;
        switch (data.moveKey) {
            case 'ArrowUp':
                arrowUp(filterState, data);
                break;
            case 'ArrowDown':
                arrowDown(filterState, data);
                break;
            case 'ArrowLeft':
                arrowLeft(filterState, data);
                break;
            case 'ArrowRight':
                arrowRight(filterState, data);
                break;
            case 'Tab':
                data.shiftKey
                    ? arrowLeft(filterState, data)
                    : arrowRight(filterState, data);
                break;
        }
    }
    function executeEditFilter({ editorState: { filterState: { focus }, }, }) {
        if (!focus)
            return;
        focus.edit = true;
    }
    function executeEditFilterEnd({ editorState: { filterState: { focus }, }, }) {
        if (!focus)
            return;
        focus.edit = false;
    }
    function executeSelectAllFilter({ editorState: { filterState: { focus, filters }, }, }) {
        if (!focus)
            return;
        focus.selectFilterIds = filters.map(filter => filter.id);
    }
    function executeDraggableFilter({ editorState: { filterState } }, data) {
        filterState.draggable = data;
    }
    function executeDraggableFilterEnd({ editorState: { filterState }, }) {
        filterState.draggable = null;
    }
    const executeFilterCommandMap = {
        'editor.filter.active': executeFilterActive,
        'editor.filter.activeEnd': executeFilterActiveEnd,
        'editor.filter.add': executeAddFilter,
        'editor.filter.remove': executeRemoveFilter,
        'editor.filter.changeColumnType': executeChangeFilterColumnType,
        'editor.filter.changeFilterCode': executeChangeFilterCode,
        'editor.filter.changeValue': executeChangeFilterValue,
        'editor.filter.move': executeMoveFilter,
        'editor.filter.changeOperatorType': executeChangeFilterOperatorType,
        'editor.filter.focus': executeFilterFocus,
        'editor.filter.focusFilter': executeFocusFilter,
        'editor.filter.focusEnd': executeFocusFilterEnd,
        'editor.filter.focusMove': executeFocusMoveFilter,
        'editor.filter.edit': executeEditFilter,
        'editor.filter.editEnd': executeEditFilterEnd,
        'editor.filter.selectAll': executeSelectAllFilter,
        'editor.filter.draggable': executeDraggableFilter,
        'editor.filter.draggableEnd': executeDraggableFilterEnd,
    };

    const isLoadIndex = (loadIndex) => isString$2(loadIndex.id) &&
        isString$2(loadIndex.name) &&
        isString$2(loadIndex.tableId) &&
        isBoolean(loadIndex.unique) &&
        isArray$4(loadIndex.columns);
    class IndexModel {
        constructor({ addIndex, loadIndex }) {
            this.name = '';
            this.columns = [];
            this.unique = false;
            if (addIndex) {
                const { id, tableId } = addIndex;
                this.id = id;
                this.tableId = tableId;
            }
            else if (loadIndex && isLoadIndex(loadIndex)) {
                const { id, name, tableId, columns, unique } = cloneDeep(loadIndex);
                this.id = id;
                this.name = name;
                this.tableId = tableId;
                this.columns = columns;
                this.unique = unique;
            }
            else {
                throw new Error('not found index');
            }
        }
    }

    function executeAddIndex({ tableState: { indexes } }, data) {
        indexes.push(new IndexModel({ addIndex: data }));
    }
    function executeRemoveIndex({ tableState: { indexes } }, data) {
        for (let i = 0; i < indexes.length; i++) {
            const id = indexes[i].id;
            if (data.indexIds.includes(id)) {
                indexes.splice(i, 1);
                i--;
            }
        }
    }
    function executeChangeIndexName({ tableState: { indexes } }, data) {
        const index = getData(indexes, data.indexId);
        if (!index)
            return;
        index.name = data.value;
    }
    function executeChangeIndexUnique({ tableState: { indexes } }, data) {
        const index = getData(indexes, data.indexId);
        if (!index)
            return;
        index.unique = data.value;
    }
    function executeAddIndexColumn({ tableState: { indexes } }, data) {
        const index = getData(indexes, data.indexId);
        if (!index || index.columns.some(column => column.id === data.columnId))
            return;
        index.columns.push({
            id: data.columnId,
            orderType: 'ASC',
        });
    }
    function executeRemoveIndexColumn({ tableState: { indexes } }, data) {
        const index = getData(indexes, data.indexId);
        if (!index)
            return;
        const targetIndex = getIndex(index.columns, data.columnId);
        if (targetIndex === -1)
            return;
        index.columns.splice(targetIndex, 1);
    }
    function executeMoveIndexColumn({ tableState: { indexes } }, data) {
        const index = getData(indexes, data.indexId);
        if (!index || data.columnId === data.targetColumnId)
            return;
        const currentColumn = getData(index.columns, data.columnId);
        if (!currentColumn)
            return;
        const currentIndex = getIndex(index.columns, data.columnId);
        if (currentIndex === -1)
            return;
        const targetIndex = getIndex(index.columns, data.targetColumnId);
        if (targetIndex === -1)
            return;
        index.columns.splice(currentIndex, 1);
        index.columns.splice(targetIndex, 0, currentColumn);
    }
    function executeChangeIndexColumnOrderType({ tableState: { indexes } }, data) {
        const index = getData(indexes, data.indexId);
        if (!index)
            return;
        const column = getData(index.columns, data.columnId);
        if (!column)
            return;
        column.orderType = data.value;
    }
    function executeLoadIndex({ tableState: { indexes } }, data) {
        indexes.push(new IndexModel({ loadIndex: data }));
    }
    const executeIndexCommandMap = {
        'index.add': executeAddIndex,
        'index.remove': executeRemoveIndex,
        'index.changeName': executeChangeIndexName,
        'index.changeUnique': executeChangeIndexUnique,
        'index.addColumn': executeAddIndexColumn,
        'index.removeColumn': executeRemoveIndexColumn,
        'index.moveColumn': executeMoveIndexColumn,
        'index.changeColumnOrderType': executeChangeIndexColumnOrderType,
        'index.load': executeLoadIndex,
    };

    const isLoadMemo = (loadMemo) => isString$2(loadMemo.id) &&
        isString$2(loadMemo.value) &&
        isObject$4(loadMemo.ui) &&
        isBoolean(loadMemo.ui.active) &&
        isNumber(loadMemo.ui.top) &&
        isNumber(loadMemo.ui.left) &&
        isNumber(loadMemo.ui.width) &&
        isNumber(loadMemo.ui.height) &&
        isNumber(loadMemo.ui.zIndex);
    class MemoModel {
        constructor({ addMemo, loadMemo }) {
            this.value = '';
            this.ui = {
                active: false,
                left: SIZE_START_X,
                top: SIZE_START_Y,
                zIndex: 2,
                width: SIZE_MEMO_WIDTH,
                height: SIZE_MEMO_HEIGHT,
            };
            if (addMemo) {
                const { id, ui } = addMemo;
                this.id = id;
                this.ui = Object.assign(this.ui, ui);
            }
            else if (loadMemo && isLoadMemo(loadMemo)) {
                const { id, value, ui } = cloneDeep(loadMemo);
                this.id = id;
                this.value = value;
                this.ui = Object.assign(this.ui, ui);
            }
            else {
                throw new Error('not found memo');
            }
        }
    }

    const MEMO_PADDING$2 = SIZE_MEMO_PADDING * 2;
    function executeAddMemo$1({ memoState: { memos } }, data) {
        memos.push(new MemoModel({ addMemo: data }));
    }
    function executeMoveMemo$1({ tableState: { tables }, memoState: { memos } }, data) {
        data.tableIds.forEach(tableId => {
            const table = getData(tables, tableId);
            if (!table)
                return;
            table.ui.left += data.movementX;
            table.ui.top += data.movementY;
        });
        data.memoIds.forEach(memoId => {
            const memo = getData(memos, memoId);
            if (!memo)
                return;
            memo.ui.left += data.movementX;
            memo.ui.top += data.movementY;
        });
    }
    function executeRemoveMemo$1({ memoState: { memos } }, { memoIds }) {
        for (let i = 0; i < memos.length; i++) {
            const id = memos[i].id;
            if (memoIds.includes(id)) {
                memos.splice(i, 1);
                i--;
            }
        }
    }
    function executeSelectMemo({ memoState: { memos } }, data) {
        const targetMemo = getData(memos, data.memoId);
        if (!targetMemo)
            return;
        targetMemo.ui.zIndex = data.zIndex;
        data.ctrlKey
            ? (targetMemo.ui.active = true)
            : memos.forEach(memo => (memo.ui.active = memo.id === data.memoId));
    }
    function executeSelectEndMemo({ memoState: { memos } }) {
        memos.forEach(memo => (memo.ui.active = false));
    }
    function executeSelectAllMemo({ memoState: { memos } }) {
        memos.forEach(memo => (memo.ui.active = true));
    }
    function executeChangeMemoValue$1({ memoState: { memos } }, data) {
        const memo = getData(memos, data.memoId);
        if (!memo)
            return;
        memo.value = data.value;
    }
    function executeResizeMemo$1({ memoState: { memos } }, data) {
        const memo = getData(memos, data.memoId);
        if (!memo)
            return;
        memo.ui.top = data.top;
        memo.ui.left = data.left;
        memo.ui.width = data.width;
        memo.ui.height = data.height;
    }
    function executeDragSelectMemo({ memoState: { memos } }, data) {
        const { min, max } = data;
        memos.forEach(memo => {
            const centerX = memo.ui.left + memo.ui.width / 2 + MEMO_PADDING$2;
            const centerY = memo.ui.top + memo.ui.height / 2 + MEMO_PADDING$2;
            memo.ui.active =
                min.x <= centerX &&
                    max.x >= centerX &&
                    min.y <= centerY &&
                    max.y >= centerY;
        });
    }
    function executeLoadMemo({ memoState: { memos } }, data) {
        memos.push(new MemoModel({ loadMemo: data }));
    }
    function executeChangeColorMemo({ tableState: { tables }, memoState: { memos } }, data) {
        data.tableIds.forEach(tableId => {
            const table = getData(tables, tableId);
            if (!table)
                return;
            table.ui.color = data.color;
        });
        data.memoIds.forEach(memoId => {
            const memo = getData(memos, memoId);
            if (!memo)
                return;
            memo.ui.color = data.color;
        });
    }
    const executeMemoCommandMap$1 = {
        'memo.add': executeAddMemo$1,
        'memo.move': executeMoveMemo$1,
        'memo.remove': executeRemoveMemo$1,
        'memo.select': executeSelectMemo,
        'memo.selectEnd': executeSelectEndMemo,
        'memo.selectAll': executeSelectAllMemo,
        'memo.changeValue': executeChangeMemoValue$1,
        'memo.resize': executeResizeMemo$1,
        'memo.dragSelect': executeDragSelectMemo,
        'memo.load': executeLoadMemo,
        'memo.changeColor': executeChangeColorMemo,
    };

    function getMaxWidthColumn(columns, show) {
        const columnWidth = {
            width: 0,
            name: 0,
            comment: 0,
            dataType: 0,
            default: 0,
            notNull: 0,
            autoIncrement: 0,
            unique: 0,
        };
        columns.forEach(column => {
            columnWidth.name < column.ui.widthName &&
                (columnWidth.name = column.ui.widthName);
            show.columnComment &&
                columnWidth.comment < column.ui.widthComment &&
                (columnWidth.comment = column.ui.widthComment);
            show.columnDataType &&
                columnWidth.dataType < column.ui.widthDataType &&
                (columnWidth.dataType = column.ui.widthDataType);
            show.columnDefault &&
                columnWidth.default < column.ui.widthDefault &&
                (columnWidth.default = column.ui.widthDefault);
        });
        show.columnNotNull && (columnWidth.notNull = SIZE_COLUMN_OPTION_NN);
        show.columnUnique && (columnWidth.unique = SIZE_COLUMN_OPTION_UQ);
        show.columnAutoIncrement &&
            (columnWidth.autoIncrement = SIZE_COLUMN_OPTION_AI);
        Object.keys(columnWidth)
            .filter(key => key !== 'width')
            .forEach(key => {
            const k = key;
            if (!columnWidth[k])
                return;
            columnWidth.width += columnWidth[k] + SIZE_COLUMN_MARGIN_RIGHT;
        });
        return columnWidth;
    }
    const defaultWidthColumnMap = [
        {
            key: 'columnComment',
            width: SIZE_MIN_WIDTH,
        },
        {
            key: 'columnDataType',
            width: SIZE_MIN_WIDTH,
        },
        {
            key: 'columnDefault',
            width: SIZE_MIN_WIDTH,
        },
        {
            key: 'columnNotNull',
            width: SIZE_COLUMN_OPTION_NN,
        },
        {
            key: 'columnAutoIncrement',
            width: SIZE_COLUMN_OPTION_AI,
        },
        {
            key: 'columnUnique',
            width: SIZE_COLUMN_OPTION_UQ,
        },
    ];
    function getDefaultWidthColumn(show) {
        let width = SIZE_MIN_WIDTH + SIZE_COLUMN_MARGIN_RIGHT;
        defaultWidthColumnMap.forEach(data => show[data.key] && (width += data.width + SIZE_COLUMN_MARGIN_RIGHT));
        return width;
    }

    const isLoadTable = (loadTable) => isString$2(loadTable.id) &&
        isString$2(loadTable.name) &&
        isString$2(loadTable.comment) &&
        isArray$4(loadTable.columns) &&
        isObject$4(loadTable.ui) &&
        isBoolean(loadTable.ui.active) &&
        isNumber(loadTable.ui.left) &&
        isNumber(loadTable.ui.top) &&
        isNumber(loadTable.ui.zIndex) &&
        isNumber(loadTable.ui.widthName) &&
        isNumber(loadTable.ui.widthComment);
    class TableModel {
        constructor({ addTable, loadTable }, show) {
            this.name = '';
            this.comment = '';
            this.columns = [];
            this.ui = {
                active: false,
                left: SIZE_START_X,
                top: SIZE_START_Y,
                zIndex: 2,
                widthName: SIZE_MIN_WIDTH,
                widthComment: SIZE_MIN_WIDTH,
            };
            this.visible = true;
            this._show = show;
            if (addTable) {
                const { id, ui } = addTable;
                this.id = id;
                this.ui = Object.assign(this.ui, ui);
                this.visible = true;
            }
            else if (loadTable && isLoadTable(loadTable)) {
                const { id, name, comment, columns, ui, visible } = cloneDeep(loadTable);
                this.id = id;
                this.name = name;
                this.comment = comment;
                this.columns = columns;
                this.ui = Object.assign(this.ui, ui);
                if (isBoolean(visible))
                    this.visible = visible;
            }
            else {
                throw new Error('not found table');
            }
        }
        width() {
            // table header width
            let width = this.ui.widthName + SIZE_COLUMN_MARGIN_RIGHT;
            if (this._show.tableComment) {
                width += this.ui.widthComment + SIZE_COLUMN_MARGIN_RIGHT;
            }
            // default width column
            const defaultWidthColumn = getDefaultWidthColumn(this._show) +
                SIZE_COLUMN_CLOSE +
                SIZE_COLUMN_KEY +
                SIZE_COLUMN_MARGIN_RIGHT;
            if (width < defaultWidthColumn) {
                width = defaultWidthColumn;
            }
            // max width column
            const maxWidthColumn = this.maxWidthColumn().width +
                SIZE_COLUMN_CLOSE +
                SIZE_COLUMN_KEY +
                SIZE_COLUMN_MARGIN_RIGHT;
            if (width < maxWidthColumn) {
                width = maxWidthColumn;
            }
            return width;
        }
        height() {
            return SIZE_TABLE_HEADER_HEIGHT + this.columns.length * SIZE_COLUMN_HEIGHT;
        }
        maxWidthColumn() {
            return getMaxWidthColumn(this.columns, this._show);
        }
    }

    const TABLE_PADDING$4 = (SIZE_TABLE_PADDING + SIZE_TABLE_BORDER) * 2;
    const TABLE_SORT_PADDING = TABLE_PADDING$4 * 4;
    function executeAddTable$1({ tableState: { tables }, canvasState: { show } }, data) {
        tables.push(new TableModel({ addTable: data }, show));
    }
    function executeMoveTable$1({ tableState: { tables }, memoState: { memos } }, data) {
        data.tableIds.forEach(tableId => {
            const table = getData(tables, tableId);
            if (!table)
                return;
            table.ui.left =
                Math.round((table.ui.left + data.movementX + Number.EPSILON) * 10000) /
                    10000;
            table.ui.top =
                Math.round((table.ui.top + data.movementY + Number.EPSILON) * 10000) /
                    10000;
        });
        data.memoIds.forEach(memoId => {
            const memo = getData(memos, memoId);
            if (!memo)
                return;
            memo.ui.left += data.movementX;
            memo.ui.top += data.movementY;
        });
    }
    function executeRemoveTable$1(state, data) {
        const { tableState: { tables }, } = state;
        for (let i = 0; i < tables.length; i++) {
            const id = tables[i].id;
            if (data.tableIds.includes(id)) {
                tables.splice(i, 1);
                i--;
            }
        }
        // TODO: Refactoring
        removeValidTableIndex(state, data.tableIds);
        removeValidTableRelationship(state, data.tableIds);
    }
    function executeSelectTable({ tableState: { tables } }, data) {
        const targetTable = getData(tables, data.tableId);
        if (!targetTable)
            return;
        targetTable.ui.zIndex = data.zIndex;
        data.ctrlKey
            ? (targetTable.ui.active = true)
            : tables.forEach(table => (table.ui.active = table.id === data.tableId));
    }
    function executeSelectEndTable({ tableState: { tables } }) {
        tables.forEach(table => (table.ui.active = false));
    }
    function executeSelectAllTable({ tableState: { tables } }) {
        tables.forEach(table => (table.ui.active = true));
    }
    function executeChangeTableName$1({ tableState: { tables } }, data) {
        const table = getData(tables, data.tableId);
        if (!table)
            return;
        table.name = data.value;
        table.ui.widthName = data.width;
    }
    function executeChangeTableComment$1({ tableState: { tables } }, data) {
        const table = getData(tables, data.tableId);
        if (!table)
            return;
        table.comment = data.value;
        table.ui.widthComment = commentWidthBalanceRange(data.width);
    }
    function executeDragSelectTable({ tableState: { tables } }, data) {
        const { min, max } = data;
        tables.forEach(table => {
            const centerX = table.ui.left + table.width() / 2 + TABLE_PADDING$4;
            const centerY = table.ui.top + table.height() / 2 + TABLE_PADDING$4;
            table.ui.active =
                min.x <= centerX &&
                    max.x >= centerX &&
                    min.y <= centerY &&
                    max.y >= centerY;
        });
    }
    function executeSortTable$1({ tableState: { tables }, canvasState, }) {
        const canvasWidth = canvasState.width;
        tables.sort((a, b) => a.columns.length - b.columns.length);
        let widthSum = 50;
        let currentHeight = 50;
        let maxHeight = 50;
        tables.forEach(table => {
            const width = table.width() + TABLE_SORT_PADDING;
            const height = table.height() + TABLE_SORT_PADDING;
            if (widthSum + width > canvasWidth) {
                currentHeight += maxHeight;
                maxHeight = 0;
                widthSum = 50;
            }
            if (maxHeight < height) {
                maxHeight = height;
            }
            table.ui.top = currentHeight;
            table.ui.left = widthSum;
            widthSum += width;
        });
    }
    function executeLoadTable({ tableState: { tables }, canvasState: { show } }, data) {
        tables.push(new TableModel({ loadTable: data }, show));
    }
    function executeHideTable$1({ tableState: { tables }, relationshipState: { relationships } }, data) {
        const table = getData(tables, data.tableId);
        if (table) {
            table.visible = false;
            relationships.forEach(relationship => {
                if (relationship.end.tableId === data.tableId ||
                    relationship.start.tableId === data.tableId) {
                    relationship.visible = false;
                }
            });
        }
    }
    function executeShowTable$1({ tableState: { tables }, relationshipState: { relationships } }, data) {
        const table = getData(tables, data.tableId);
        if (table) {
            table.visible = true;
            relationships.forEach(relationship => {
                if (relationship.end.tableId === data.tableId) {
                    const startTable = getData(tables, relationship.start.tableId);
                    if (startTable === null || startTable === void 0 ? void 0 : startTable.visible)
                        relationship.visible = true;
                }
                if (relationship.start.tableId === data.tableId) {
                    const endTable = getData(tables, relationship.end.tableId);
                    if (endTable === null || endTable === void 0 ? void 0 : endTable.visible)
                        relationship.visible = true;
                }
            });
        }
    }
    function executeChangeColorTable({ tableState: { tables }, memoState: { memos } }, data) {
        data.tableIds.forEach(tableId => {
            const table = getData(tables, tableId);
            if (!table)
                return;
            table.ui.color = data.color;
        });
        data.memoIds.forEach(memoId => {
            const memo = getData(memos, memoId);
            if (!memo)
                return;
            memo.ui.color = data.color;
        });
    }
    const executeTableCommandMap$1 = {
        'table.add': executeAddTable$1,
        'table.move': executeMoveTable$1,
        'table.remove': executeRemoveTable$1,
        'table.select': executeSelectTable,
        'table.selectEnd': executeSelectEndTable,
        'table.selectAll': executeSelectAllTable,
        'table.changeName': executeChangeTableName$1,
        'table.changeComment': executeChangeTableComment$1,
        'table.dragSelect': executeDragSelectTable,
        'table.sort': executeSortTable$1,
        'table.load': executeLoadTable,
        'table.hide': executeHideTable$1,
        'table.show': executeShowTable$1,
        'table.changeColor': executeChangeColorTable,
    };

    function executeHasUndoRedo({ editorState }, data) {
        editorState.hasUndo = data.hasUndo;
        editorState.hasRedo = data.hasRedo;
    }
    function executeFocusTable({ editorState, tableState: { tables } }, data) {
        var _a, _b;
        if (((_a = editorState.focusTable) === null || _a === void 0 ? void 0 : _a.table.id) === data.tableId && data.focusType) {
            editorState.focusTable.focusType = data.focusType;
            editorState.focusTable.columnId = null;
            editorState.focusTable.prevSelectColumnId = null;
            editorState.focusTable.selectColumnIds = [];
        }
        else if (data.focusType) {
            const table = getData(tables, data.tableId);
            if (!table)
                return;
            editorState.focusTable = {
                table,
                focusType: data.focusType,
                columnId: null,
                prevSelectColumnId: null,
                selectColumnIds: [],
                edit: false,
            };
        }
        else if (((_b = editorState.focusTable) === null || _b === void 0 ? void 0 : _b.table.id) !== data.tableId) {
            const table = getData(tables, data.tableId);
            if (!table)
                return;
            editorState.focusTable = {
                table,
                focusType: 'tableName',
                columnId: null,
                prevSelectColumnId: null,
                selectColumnIds: [],
                edit: false,
            };
        }
    }
    function executeFocusColumn({ editorState, tableState: { tables } }, data) {
        var _a;
        if (((_a = editorState.focusTable) === null || _a === void 0 ? void 0 : _a.table.id) === data.tableId) {
            const focusTable = editorState.focusTable;
            focusTable.columnId = data.columnId;
            focusTable.focusType = data.focusType;
            if (data.ctrlKey && data.shiftKey) {
                focusTable.selectColumnIds = appendSelectRangeColumns(focusTable.table.columns, focusTable.selectColumnIds, focusTable.prevSelectColumnId, focusTable.columnId);
            }
            else if (data.shiftKey) {
                focusTable.selectColumnIds = selectRangeColumns(focusTable.table.columns, focusTable.prevSelectColumnId, focusTable.columnId);
            }
            else if (data.ctrlKey) {
                focusTable.selectColumnIds = appendSelectColumns(focusTable.selectColumnIds, data.columnId);
            }
            else {
                focusTable.selectColumnIds = [data.columnId];
            }
            focusTable.prevSelectColumnId = data.columnId;
        }
        else {
            const table = getData(tables, data.tableId);
            if (!table)
                return;
            editorState.focusTable = {
                table,
                focusType: data.focusType,
                columnId: data.columnId,
                prevSelectColumnId: data.columnId,
                selectColumnIds: [data.columnId],
                edit: false,
            };
        }
    }
    function executeFocusTableEnd({ editorState }) {
        editorState.focusTable = null;
    }
    function executeFocusMoveTable(state, data) {
        const { editorState } = state;
        if (!editorState.focusTable)
            return;
        editorState.focusTable.edit = false;
        switch (data.moveKey) {
            case 'ArrowUp':
                arrowUp$1(state, data);
                break;
            case 'ArrowDown':
                arrowDown$1(state, data);
                break;
            case 'ArrowLeft':
                arrowLeft$1(state, data);
                break;
            case 'ArrowRight':
                arrowRight$1(state, data);
                break;
            case 'Tab':
                data.shiftKey ? arrowLeft$1(state, data) : arrowRight$1(state, data);
                break;
        }
    }
    function executeEditTable({ editorState: { focusTable } }) {
        if (!focusTable)
            return;
        focusTable.edit = true;
    }
    function executeEditTableEnd({ editorState: { focusTable } }) {
        if (!focusTable)
            return;
        focusTable.edit = false;
    }
    function executeSelectAllColumn({ editorState: { focusTable } }) {
        if (!focusTable)
            return;
        focusTable.selectColumnIds = focusTable.table.columns.map(column => column.id);
    }
    function executeDrawStartRelationship({ editorState }, data) {
        editorState.drawRelationship = {
            relationshipType: data.relationshipType,
            start: null,
            end: {
                x: 0,
                y: 0,
            },
        };
    }
    function executeDrawStartAddRelationship({ tableState: { tables }, editorState: { drawRelationship } }, data) {
        if (!drawRelationship)
            return;
        const table = getData(tables, data.tableId);
        if (!table)
            return;
        drawRelationship.start = {
            table,
            x: table.ui.left,
            y: table.ui.top,
        };
    }
    function executeDrawEndRelationship({ editorState }) {
        editorState.drawRelationship = null;
    }
    function executeDrawRelationship({ editorState: { drawRelationship }, canvasState: { scrollLeft, scrollTop }, }, data) {
        if (!(drawRelationship === null || drawRelationship === void 0 ? void 0 : drawRelationship.start))
            return;
        drawRelationship.end.x = data.x - scrollLeft;
        drawRelationship.end.y = data.y - scrollTop;
    }
    function executeDraggableColumn({ editorState }, data) {
        editorState.draggableColumn = data;
    }
    function executeDraggableColumnEnd({ editorState }) {
        editorState.draggableColumn = null;
    }
    // TODO: Refactoring
    function executeLoadJson$1(state, data) {
        const { canvasState, editorState } = state;
        const panelNames = [...contextPanelConfig.panels, ...editorState.panels]
            .map(panel => panel.key)
            .filter(key => !isRegExp(contextPanelConfig.exclude, key) &&
            !isRegExp(editorState.excludePanel, key));
        const json = JSON.parse(data.value);
        const canvasStateAny = canvasState;
        const canvasJson = json.canvas;
        if (isObject$4(canvasJson)) {
            Object.keys(canvasStateAny).forEach(key => {
                if (!isEmpty(canvasJson[key])) {
                    switch (key) {
                        case 'show':
                            Object.keys(canvasState.show).forEach(showKey => {
                                if (typeof canvasJson.show[showKey] === 'boolean') {
                                    canvasStateAny.show[showKey] = canvasJson.show[showKey];
                                }
                            });
                            break;
                        case 'database':
                            if (databaseList.includes(canvasJson.database)) {
                                canvasState.database = canvasJson.database;
                            }
                            break;
                        case 'canvasType':
                            if (panelNames.includes(canvasJson.canvasType)) {
                                canvasState.canvasType = canvasJson.canvasType;
                            }
                            break;
                        case 'language':
                            if (languageList.includes(canvasJson.language)) {
                                canvasState.language = canvasJson.language;
                            }
                            break;
                        case 'tableCase':
                            if (nameCaseList.includes(canvasJson.tableCase)) {
                                canvasState.tableCase = canvasJson.tableCase;
                            }
                            break;
                        case 'columnCase':
                            if (nameCaseList.includes(canvasJson.columnCase)) {
                                canvasState.columnCase = canvasJson.columnCase;
                            }
                            break;
                        case 'highlightTheme':
                            if (highlightThemes.includes(canvasJson.highlightTheme)) {
                                canvasState.highlightTheme = canvasJson.highlightTheme;
                            }
                            break;
                        case 'bracketType':
                            if (bracketTypes.includes(canvasJson.bracketType)) {
                                canvasState.bracketType = canvasJson.bracketType;
                            }
                            break;
                        case 'width':
                        case 'height':
                        case 'scrollTop':
                        case 'scrollLeft':
                        case 'zoomLevel':
                            if (typeof canvasJson[key] === 'number') {
                                canvasState[key] = canvasJson[key];
                            }
                            break;
                        case 'databaseName':
                            if (typeof canvasJson[key] === 'string') {
                                canvasState[key] = canvasJson[key];
                            }
                            break;
                        case 'setting':
                            if (typeof canvasJson.setting.relationshipDataTypeSync === 'boolean') {
                                canvasState.setting.relationshipDataTypeSync =
                                    canvasJson.setting.relationshipDataTypeSync;
                            }
                            if (typeof canvasJson.setting.relationshipOptimization === 'boolean') {
                                canvasState.setting.relationshipOptimization =
                                    canvasJson.setting.relationshipOptimization;
                            }
                            if (Array.isArray(canvasJson.setting.columnOrder) &&
                                canvasJson.setting.columnOrder.length === 7 &&
                                canvasJson.setting.columnOrder.indexOf('columnName') !== -1 &&
                                canvasJson.setting.columnOrder.indexOf('columnDataType') !== -1 &&
                                canvasJson.setting.columnOrder.indexOf('columnNotNull') !== -1 &&
                                canvasJson.setting.columnOrder.indexOf('columnDefault') !== -1 &&
                                canvasJson.setting.columnOrder.indexOf('columnComment') !== -1 &&
                                canvasJson.setting.columnOrder.indexOf('columnUnique') !== -1 &&
                                canvasJson.setting.columnOrder.indexOf('columnAutoIncrement') !==
                                    -1) {
                                canvasState.setting.columnOrder.splice(0, canvasState.setting.columnOrder.length);
                                canvasState.setting.columnOrder.push(...canvasJson.setting.columnOrder);
                            }
                            break;
                        case 'pluginSerializationMap':
                            if (isObject$4(canvasJson.pluginSerializationMap)) {
                                canvasState.pluginSerializationMap =
                                    canvasJson.pluginSerializationMap;
                            }
                            break;
                    }
                }
            });
        }
        const tableJson = json.table;
        if (isObject$4(tableJson)) {
            Array.isArray(tableJson.tables) &&
                tableJson.tables.forEach((loadTable) => executeLoadTable(state, loadTable));
            Array.isArray(tableJson.indexes) &&
                tableJson.indexes.forEach((loadIndex) => executeLoadIndex(state, loadIndex));
        }
        const memoJson = json.memo;
        if (isObject$4(memoJson) && Array.isArray(memoJson.memos)) {
            memoJson.memos.forEach((loadMemo) => executeLoadMemo(state, loadMemo));
        }
        const relationshipJson = json.relationship;
        if (isObject$4(relationshipJson) &&
            Array.isArray(relationshipJson.relationships)) {
            relationshipJson.relationships.forEach((loadRelationship) => {
                executeLoadRelationship(state, loadRelationship);
            });
            // migration version 2.0.3
            validStartRelationship(state);
        }
    }
    function executeClear$1({ tableState: { tables, indexes }, memoState: { memos }, relationshipState: { relationships }, }) {
        tables.splice(0, tables.length);
        indexes.splice(0, indexes.length);
        memos.splice(0, memos.length);
        relationships.splice(0, relationships.length);
    }
    function executeChangeViewport({ editorState: { viewport } }, data) {
        viewport.width = data.width;
        viewport.height = data.height;
    }
    function executeCopyColumn({ tableState: { tables }, editorState: { copyColumns } }, data) {
        const table = getData(tables, data.tableId);
        if (!table)
            return;
        copyColumns.splice(0, copyColumns.length);
        data.columnIds.forEach(columnId => {
            const column = getData(table.columns, columnId);
            if (!column)
                return;
            copyColumns.push(cloneDeep(column));
        });
    }
    function executeFindActive({ editorState }) {
        editorState.findActive = true;
    }
    function executeFindActiveEnd({ editorState }) {
        editorState.findActive = false;
    }
    function executeReadonlyEditor({ editorState }, data) {
        editorState.readonly = data.readonly;
    }
    const executeEditorCommandMap$1 = Object.assign({ 'editor.hasUndoRedo': executeHasUndoRedo, 'editor.focusTable': executeFocusTable, 'editor.focusColumn': executeFocusColumn, 'editor.focusTableEnd': executeFocusTableEnd, 'editor.focusMoveTable': executeFocusMoveTable, 'editor.editTable': executeEditTable, 'editor.editTableEnd': executeEditTableEnd, 'editor.selectAllColumn': executeSelectAllColumn, 'editor.drawStartRelationship': executeDrawStartRelationship, 'editor.drawStartAddRelationship': executeDrawStartAddRelationship, 'editor.drawEndRelationship': executeDrawEndRelationship, 'editor.drawRelationship': executeDrawRelationship, 'editor.draggableColumn': executeDraggableColumn, 'editor.draggableColumnEnd': executeDraggableColumnEnd, 'editor.loadJson': executeLoadJson$1, 'editor.initLoadJson': executeLoadJson$1, 'editor.clear': executeClear$1, 'editor.initClear': executeClear$1, 'editor.changeViewport': executeChangeViewport, 'editor.copyColumn': executeCopyColumn, 'editor.findActive': executeFindActive, 'editor.findActiveEnd': executeFindActiveEnd, 'editor.readonly': executeReadonlyEditor }, executeFilterCommandMap);

    const addIndex = (tableId) => createCommand$1('index.add', {
        id: v4(),
        tableId,
    });
    const removeIndex = (indexIds) => createCommand$1('index.remove', {
        indexIds,
    });
    const changeIndexName = (indexId, value) => createCommand$1('index.changeName', {
        indexId,
        value,
    });
    const changeIndexUnique = (indexId, value) => createCommand$1('index.changeUnique', {
        indexId,
        value,
    });
    const addIndexColumn = (indexId, columnId) => createCommand$1('index.addColumn', {
        indexId,
        columnId,
    });
    const removeIndexColumn = (indexId, columnId) => createCommand$1('index.removeColumn', {
        indexId,
        columnId,
    });
    const moveIndexColumn = (indexId, columnId, targetColumnId) => createCommand$1('index.moveColumn', {
        indexId,
        columnId,
        targetColumnId,
    });
    const changeIndexColumnOrderType = (indexId, columnId, value) => createCommand$1('index.changeColumnOrderType', {
        indexId,
        columnId,
        value,
    });
    const loadIndex = (index) => createCommand$1('index.load', index);

    var indexCommand = /*#__PURE__*/Object.freeze({
        __proto__: null,
        addIndex: addIndex,
        removeIndex: removeIndex,
        changeIndexName: changeIndexName,
        changeIndexUnique: changeIndexUnique,
        addIndexColumn: addIndexColumn,
        removeIndexColumn: removeIndexColumn,
        moveIndexColumn: moveIndexColumn,
        changeIndexColumnOrderType: changeIndexColumnOrderType,
        loadIndex: loadIndex
    });

    const executeCommandMap$1 = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, executeCanvasCommandMap$1), executeMemoCommandMap$1), executeTableCommandMap$1), executeColumnCommandMap$1), executeEditorCommandMap$1), executeRelationshipCommandMap$1), executeIndexCommandMap);
    const createCommand = () => ({
        canvas: canvasCommand,
        memo: memoCommand,
        table: tableCommand,
        column: columnCommand,
        editor: editorCommand,
        relationship: relationshipCommand,
        index: indexCommand,
    });
    function createStream() {
        const dispatch$ = new Subject();
        const history$ = new Subject();
        const change$ = merge(history$, dispatch$.pipe(commandsFilter(changeCommandTypes))).pipe(notEmptyCommands, debounceTime(200));
        const hook$ = merge(history$, dispatch$).pipe(notEmptyCommands);
        return {
            dispatch$,
            history$,
            change$,
            hook$,
        };
    }
    function executeCommand$(state, commands) {
        commands.forEach(command => {
            const execute = executeCommandMap$1[command.name];
            execute && execute(state, command.data);
        });
    }
    const executeCommand$1 = curry$1((state, commands) => {
        try {
            executeCommand$(state, commands);
        }
        catch (err) {
            Logger.error(err);
        }
    });

    function createHistory(effect) {
        let commands = [];
        let index = -1;
        let limit = 0;
        let run = false;
        const hasUndo = () => index !== -1;
        const hasRedo = () => index < commands.length - 1;
        const setLimit = (newLimit) => (limit = newLimit);
        const execute = (command, key) => {
            run = true;
            command[key]();
            run = false;
        };
        const push = (command) => {
            if (run)
                return;
            commands.splice(index + 1, commands.length - index);
            commands.push(command);
            if (limit !== 0 && commands.length > limit) {
                commands = commands.slice(commands.length - limit, commands.length);
            }
            index = commands.length - 1;
            effect();
        };
        const undo = () => {
            if (!hasUndo())
                return;
            const command = commands[index];
            execute(command, 'undo');
            index--;
            effect();
        };
        const redo = () => {
            if (!hasRedo())
                return;
            const command = commands[index + 1];
            execute(command, 'redo');
            index++;
            effect();
        };
        const clear = () => {
            const prevSize = commands.length;
            commands = [];
            index = -1;
            prevSize > 0 && effect();
        };
        return {
            hasUndo,
            hasRedo,
            push,
            undo,
            redo,
            clear,
            setLimit,
        };
    }

    const groupByStreamCommands = (source$) => new Observable(subscriber => source$.subscribe({
        next: commands => {
            const batchCommands = [];
            const streamCommands = [];
            commands.forEach(command => streamCommandTypes.includes(command.name)
                ? streamCommands.push(command)
                : batchCommands.push(command));
            subscriber.next(batchCommands);
            subscriber.next(streamCommands);
        },
        error: value => subscriber.error(value),
        complete: () => subscriber.complete(),
    })).pipe(notEmptyCommands, groupBy(commands => commands.some(command => streamCommandTypes.includes(command.name))), mergeMap(group$ => group$.key
        ? group$.pipe(buffer(group$.pipe(debounceTime(200))), map(buff => buff.reduce((acc, cur) => acc.concat(cur), [])))
        : group$));

    const readonlyCommands = ({ editorState }) => (source$) => new Observable(subscriber => source$.subscribe({
        next: commands => editorState.readonly
            ? subscriber.next(commands.filter(command => readonlyCommandTypes.includes(command.name)))
            : subscriber.next(commands),
        error: value => subscriber.error(value),
        complete: () => subscriber.complete(),
    })).pipe(notEmptyCommands);

    function executeMoveCanvas({ canvasState: { scrollTop, scrollLeft } }, batchUndoCommand) {
        batchUndoCommand.push(moveCanvas(scrollTop, scrollLeft));
    }
    function executeResizeCanvas({ canvasState: { width, height } }, batchUndoCommand) {
        batchUndoCommand.push(resizeCanvas(width, height));
    }
    function executeZoomCanvas({ canvasState: { zoomLevel } }, batchUndoCommand) {
        batchUndoCommand.push(zoomCanvas(zoomLevel));
    }
    function executeChangeCanvasShow(store, batchUndoCommand, data) {
        batchUndoCommand.push(createCommand$1('canvas.changeShow', {
            showKey: data.showKey,
            value: !data.value,
        }));
    }
    function executeChangeDatabase({ canvasState: { database } }, batchUndoCommand) {
        batchUndoCommand.push(changeDatabase(database));
    }
    function executeChangeDatabaseName({ canvasState: { databaseName } }, batchUndoCommand) {
        batchUndoCommand.push(changeDatabaseName(databaseName));
    }
    const executeCanvasCommandMap = {
        'canvas.move': executeMoveCanvas,
        'canvas.resize': executeResizeCanvas,
        'canvas.zoom': executeZoomCanvas,
        'canvas.changeShow': executeChangeCanvasShow,
        'canvas.changeDatabase': executeChangeDatabase,
        'canvas.changeDatabaseName': executeChangeDatabaseName,
    };

    function executeAddColumn(store, batchUndoCommand, data) {
        batchUndoCommand.push(...data.map(addColumn => removeColumn(addColumn.tableId, [addColumn.id])));
    }
    function executeAddCustomColumn(store, batchUndoCommand, data) {
        batchUndoCommand.push(...data.map(addColumn => removeColumn(addColumn.tableId, [addColumn.id])));
    }
    function executeRemoveColumn({ tableState: { tables, indexes }, relationshipState: { relationships }, }, batchUndoCommand, data) {
        const targetRelationships = [];
        const targetIndexes = [];
        const table = getData(tables, data.tableId);
        if (!table)
            return;
        relationships.forEach(relationship => {
            const { start, end } = relationship;
            if ((data.tableId === start.tableId &&
                data.columnIds.some(columnId => start.columnIds.includes(columnId))) ||
                (data.tableId === end.tableId &&
                    data.columnIds.some(columnId => end.columnIds.includes(columnId)))) {
                targetRelationships.push(cloneDeep(relationship));
            }
        });
        const tableIndexes = indexes.filter(index => index.tableId === table.id);
        tableIndexes.forEach(index => targetIndexes.push(cloneDeep(index)));
        const columns = [];
        const indexList = [];
        data.columnIds.forEach(columnId => {
            const column = getData(table.columns, columnId);
            const index = getIndex(table.columns, columnId);
            if (column && index !== -1) {
                columns.push(cloneDeep(column));
                indexList.push(index);
            }
        });
        batchUndoCommand.push(loadColumn(data.tableId, columns, indexList));
        if (targetRelationships.length) {
            batchUndoCommand.push(removeRelationship(targetRelationships.map(relationship => relationship.id)), ...targetRelationships.map(relationship => loadRelationship(relationship)));
        }
        if (targetIndexes.length) {
            batchUndoCommand.push(removeIndex(targetIndexes.map(index => index.id)), ...targetIndexes.map(index => loadIndex(index)));
        }
    }
    function executeChangeColumnName({ tableState: { tables } }, batchUndoCommand, data) {
        const column = getColumn(tables, data.tableId, data.columnId);
        if (!column)
            return;
        batchUndoCommand.push(createCommand$1('column.changeName', {
            tableId: data.tableId,
            columnId: data.columnId,
            value: column.name,
            width: column.ui.widthName,
        }));
    }
    function executeChangeColumnComment({ tableState: { tables } }, batchUndoCommand, data) {
        const column = getColumn(tables, data.tableId, data.columnId);
        if (!column)
            return;
        batchUndoCommand.push(createCommand$1('column.changeComment', {
            tableId: data.tableId,
            columnId: data.columnId,
            value: column.comment,
            width: column.ui.widthComment,
        }));
    }
    function executeChangeColumnDataType({ tableState: { tables } }, batchUndoCommand, data) {
        const column = getColumn(tables, data.tableId, data.columnId);
        if (!column)
            return;
        batchUndoCommand.push(createCommand$1('column.changeDataType', {
            tableId: data.tableId,
            columnId: data.columnId,
            value: column.dataType,
            width: column.ui.widthDataType,
        }));
    }
    function executeChangeColumnDefault({ tableState: { tables } }, batchUndoCommand, data) {
        const column = getColumn(tables, data.tableId, data.columnId);
        if (!column)
            return;
        batchUndoCommand.push(createCommand$1('column.changeDefault', {
            tableId: data.tableId,
            columnId: data.columnId,
            value: column.default,
            width: column.ui.widthDefault,
        }));
    }
    function executeChangeColumnAutoIncrement(store, batchUndoCommand, data) {
        batchUndoCommand.push(createCommand$1('column.changeAutoIncrement', {
            tableId: data.tableId,
            columnId: data.columnId,
            value: !data.value,
        }));
    }
    function executeChangeColumnPrimaryKey(store, batchUndoCommand, data) {
        batchUndoCommand.push(createCommand$1('column.changePrimaryKey', {
            tableId: data.tableId,
            columnId: data.columnId,
            value: !data.value,
        }));
    }
    function executeChangeColumnUnique(store, batchUndoCommand, data) {
        batchUndoCommand.push(createCommand$1('column.changeUnique', {
            tableId: data.tableId,
            columnId: data.columnId,
            value: !data.value,
        }));
    }
    function executeChangeColumnNotNull(store, batchUndoCommand, data) {
        batchUndoCommand.push(createCommand$1('column.changeNotNull', {
            tableId: data.tableId,
            columnId: data.columnId,
            value: !data.value,
        }));
    }
    function executeMoveColumn({ tableState: { tables, indexes }, relationshipState: { relationships }, }, batchUndoCommand, data) {
        const currentTable = getData(tables, data.tableId);
        const currentColumns = [];
        data.columnIds.forEach(columnId => {
            const column = getColumn(tables, data.tableId, columnId);
            if (!column)
                return;
            currentColumns.push(column);
        });
        const targetTable = getData(tables, data.targetTableId);
        const targetColumn = getColumn(tables, data.targetTableId, data.targetColumnId);
        if (currentTable && targetTable && currentColumns.length && targetColumn) {
            if (data.tableId === data.targetTableId &&
                !data.columnIds.includes(data.targetColumnId)) {
                const columns = [];
                const indexList = [];
                data.columnIds.forEach(columnId => {
                    const column = getData(currentTable.columns, columnId);
                    const index = getIndex(currentTable.columns, columnId);
                    if (column && index !== -1) {
                        columns.push(cloneDeep(column));
                        indexList.push(index);
                    }
                });
                batchUndoCommand.push(removeOnlyColumn(data.tableId, data.columnIds), loadColumn(data.tableId, columns, indexList));
            }
            else if (data.tableId !== data.targetTableId &&
                !data.columnIds.includes(data.targetColumnId)) {
                const targetRelationships = [];
                const targetIndexes = [];
                const columns = [];
                const indexList = [];
                data.columnIds.forEach(columnId => {
                    const column = getData(currentTable.columns, columnId);
                    const index = getIndex(currentTable.columns, columnId);
                    if (column && index !== -1) {
                        columns.push(cloneDeep(column));
                        indexList.push(index);
                    }
                });
                batchUndoCommand.push(removeOnlyColumn(data.targetTableId, data.columnIds), loadColumn(data.tableId, columns, indexList));
                relationships.forEach(relationship => {
                    const { start, end } = relationship;
                    if ((data.tableId === start.tableId &&
                        data.columnIds.some(columnId => start.columnIds.includes(columnId))) ||
                        (data.tableId === end.tableId &&
                            data.columnIds.some(columnId => end.columnIds.includes(columnId)))) {
                        targetRelationships.push(cloneDeep(relationship));
                    }
                });
                const tableIndexes = indexes.filter(index => index.tableId === data.tableId);
                tableIndexes.forEach(index => targetIndexes.push(cloneDeep(index)));
                if (targetRelationships.length) {
                    batchUndoCommand.push(removeRelationship(targetRelationships.map(relationship => relationship.id)), ...targetRelationships.map(relationship => loadRelationship(relationship)));
                }
                if (targetIndexes.length) {
                    batchUndoCommand.push(removeIndex(targetIndexes.map(index => index.id)), ...targetIndexes.map(index => loadIndex(index)));
                }
            }
        }
    }
    const executeColumnCommandMap = {
        'column.add': executeAddColumn,
        'column.addCustom': executeAddCustomColumn,
        'column.remove': executeRemoveColumn,
        'column.changeName': executeChangeColumnName,
        'column.changeComment': executeChangeColumnComment,
        'column.changeDataType': executeChangeColumnDataType,
        'column.changeDefault': executeChangeColumnDefault,
        'column.changeAutoIncrement': executeChangeColumnAutoIncrement,
        'column.changePrimaryKey': executeChangeColumnPrimaryKey,
        'column.changeUnique': executeChangeColumnUnique,
        'column.changeNotNull': executeChangeColumnNotNull,
        'column.move': executeMoveColumn,
    };

    /*!
     * @vuerd/sql-ddl-parser
     * @version 0.2.2 | Fri Nov 05 2021
     * @author dineug <dineug2@gmail.com>
     * @license MIT
     */
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    }

    /**
     * https://mariadb.com/kb/en/data-types/
     */
    var MariaDBTypes$1 = [
        'BIGINT',
        'BINARY',
        'BIT',
        'BLOB',
        'BOOL',
        'BOOLEAN',
        'CHAR',
        'DATE',
        'DATETIME',
        'DEC',
        'DECIMAL',
        'DOUBLE PRECISION',
        'DOUBLE',
        'ENUM',
        'FIXED',
        'FLOAT',
        'GEOMETRY',
        'GEOMETRYCOLLECTION',
        'INT',
        'INTEGER',
        'JSON',
        'LINESTRING',
        'LONGBLOB',
        'LONGTEXT',
        'MEDIUMBLOB',
        'MEDIUMINT',
        'MEDIUMTEXT',
        'MULTILINESTRING',
        'MULTIPOINT',
        'MULTIPOLYGON',
        'NUMERIC',
        'POINT',
        'POLYGON',
        'REAL',
        'SET',
        'SMALLINT',
        'TEXT',
        'TIME',
        'TIMESTAMP',
        'TINYBLOB',
        'TINYINT',
        'TINYTEXT',
        'VARBINARY',
        'VARCHAR',
        'YEAR',
    ];

    /**
     * https://docs.microsoft.com/ko-kr/sql/t-sql/data-types/data-types-transact-sql?view=sql-server-ver15
     */
    var MSSQLTypes$1 = [
        'BIGINT',
        'BINARY',
        'BIT',
        'CHAR',
        'DATE',
        'DATETIME',
        'DATETIME2',
        'DATETIMEOFFSET',
        'DECIMAL',
        'FLOAT',
        'GEOGRAPHY',
        'GEOMETRY',
        'IMAGE',
        'INT',
        'MONEY',
        'NCHAR',
        'NTEXT',
        'NUMERIC',
        'NVARCHAR',
        'REAL',
        'SMALLDATETIME',
        'SMALLINT',
        'SMALLMONEY',
        'SQL_VARIANT',
        'TEXT',
        'TIME',
        'TINYINT',
        'UNIQUEIDENTIFIER',
        'VARBINARY',
        'VARCHAR',
        'XML',
    ];

    /**
     * https://dev.mysql.com/doc/refman/8.0/en/data-types.html
     */
    var MySQLTypes$1 = [
        'BIGINT',
        'BINARY',
        'BIT',
        'BLOB',
        'BOOL',
        'BOOLEAN',
        'CHAR',
        'DATE',
        'DATETIME',
        'DEC',
        'DECIMAL',
        'DOUBLE PRECISION',
        'DOUBLE',
        'ENUM',
        'FLOAT',
        'GEOMETRY',
        'GEOMETRYCOLLECTION',
        'INT',
        'INTEGER',
        'JSON',
        'LINESTRING',
        'LONGBLOB',
        'LONGTEXT',
        'MEDIUMBLOB',
        'MEDIUMINT',
        'MEDIUMTEXT',
        'MULTILINESTRING',
        'MULTIPOINT',
        'MULTIPOLYGON',
        'NUMERIC',
        'POINT',
        'POLYGON',
        'SET',
        'SMALLINT',
        'TEXT',
        'TIME',
        'TIMESTAMP',
        'TINYBLOB',
        'TINYINT',
        'TINYTEXT',
        'VARBINARY',
        'VARCHAR',
        'YEAR',
    ];

    /**
     * https://docs.oracle.com/cd/B28359_01/server.111/b28318/datatype.htm#CNCPT012
     */
    var OracleTypes$1 = [
        'BFILE',
        'BINARY_DOUBLE',
        'BINARY_FLOAT',
        'BLOB',
        'CHAR',
        'CLOB',
        'DATE',
        'DATETIME',
        'LONG RAW',
        'LONG',
        'NCHAR',
        'NCLOB',
        'NUMBER',
        'NVARCHAR2',
        'RAW',
        'TIMESTAMP WITH LOCAL TIME ZONE',
        'TIMESTAMP WITH TIME ZONE',
        'TIMESTAMP',
        'UriType',
        'VARCHAR',
        'VARCHAR2',
        'XMLType',
    ];

    /**
     * https://www.postgresql.org/docs/current/datatype.html
     */
    var PostgreSQLTypes$1 = [
        'BIGINT',
        'BIGSERIAL',
        'BIT VARYING',
        'BIT',
        'BOOL',
        'BOOLEAN',
        'BOX',
        'BYTEA',
        'CHAR',
        'CHARACTER VARYING',
        'CHARACTER',
        'CIDR',
        'CIRCLE',
        'DATE',
        'DECIMAL',
        'DOUBLE PRECISION',
        'FLOAT4',
        'FLOAT8',
        'INET',
        'INT',
        'INT2',
        'INT4',
        'INT8',
        'INTEGER',
        'INTERVAL',
        'JSON',
        'JSONB',
        'LINE',
        'LSEG',
        'MACADDR',
        'MACADDR8',
        'MONEY',
        'NUMERIC',
        'PATH',
        'PG_LSN',
        'POINT',
        'POLYGON',
        'REAL',
        'SERIAL',
        'SERIAL2',
        'SERIAL4',
        'SERIAL8',
        'SMALLINT',
        'SMALLSERIAL',
        'TEXT',
        'TIME WITH',
        'TIME',
        'TIMESTAMP WITH',
        'TIMESTAMP',
        'TIMESTAMPTZ',
        'TIMETZ',
        'TSQUERY',
        'TSVECTOR',
        'TXID_SNAPSHOT',
        'UUID',
        'VARBIT',
        'VARCHAR',
        'XML',
    ];

    /**
     * https://www.sqlite.org/datatype3.html
     */
    var SQLiteTypes$1 = [
        'BLOB',
        'INTEGER',
        'NUMERIC',
        'REAL',
        'TEXT',
    ];

    var MariaDBKeywords = [];

    var MSSQLKeywords = [];

    var MySQLKeywords = [
        'ADD',
        'ALTER',
        'AND',
        'AS',
        'ASC',
        'AUTO_INCREMENT',
        'BY',
        'CASCADE',
        'COLUMN',
        'COMMENT',
        'CONSTRAINT',
        'CREATE',
        'DATABASE',
        'DEFAULT',
        'DELETE',
        'DESC',
        'DROP',
        'EXISTS',
        'FOREIGN',
        'IF',
        'INDEX',
        'KEY',
        'LIKE',
        'NOT',
        'NULL',
        'ON',
        'OR',
        'PRIMARY',
        'REFERENCES',
        'RENAME',
        'SCHEMA',
        'SELECT',
        'SET',
        'TABLE',
        'UNION',
        'UNIQUE',
        'USE',
    ];

    var OracleKeywords = [];

    var PostgreSQLKeywords = [];

    var SQLiteKeywords = ['AUTOINCREMENT'];

    var tokenMatch = {
        whiteSpace: /(?:\s+|#.*|-- +.*|\/\*(?:[\s\S])*?\*\/)+/,
        leftParen: '(',
        rightParen: ')',
        comma: ',',
        period: '.',
        equal: '=',
        semicolon: ';',
        doubleQuote: "\"",
        singleQuote: "'",
        backtick: '`',
        keywords: getKeywords(),
        // number, english, korean, chinese, japanese
        string: /[a-z0-9_\u3131-\u314E\u314F-\u3163\uAC00-\uD7A3\u3040-\u309F\u30A0-\u30FF\u3400-\u4DB5\u4E00-\u9FCC]/i,
        unknown: /.+/,
        dataTypes: getDataTypes(),
    };
    function getDataTypes() {
        var keywords = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], MariaDBTypes$1), MSSQLTypes$1), MySQLTypes$1), OracleTypes$1), PostgreSQLTypes$1), SQLiteTypes$1);
        return Array.from(new Set(keywords.map(function (keyword) { return keyword.toUpperCase(); })));
    }
    function getKeywords() {
        var keywords = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], MariaDBKeywords), MSSQLKeywords), MySQLKeywords), OracleKeywords), PostgreSQLKeywords), SQLiteKeywords), getDataTypes());
        return Array.from(new Set(keywords.map(function (keyword) { return keyword.toUpperCase(); })));
    }
    function keywordEqual(token, value) {
        return (token.type === 'keyword' &&
            token.value.toUpperCase() === value.toUpperCase());
    }
    function isExtraString(token) {
        if (!token)
            return false;
        return (token.type === 'doubleQuoteString' ||
            token.type === 'singleQuoteString' ||
            token.type === 'backtickString');
    }
    function isStringKeyword(token) {
        if (!token)
            return false;
        var value = token.value.toUpperCase();
        return token.type === 'string' && tokenMatch.keywords.includes(value);
    }
    function isKeyword(token) {
        if (!token)
            return false;
        return token.type === 'keyword';
    }
    function isString$1(token) {
        if (!token)
            return false;
        return token.type === 'string';
    }
    function isPeriod(token) {
        if (!token)
            return false;
        return token.type === 'period';
    }
    function isLeftParen(token) {
        if (!token)
            return false;
        return token.type === 'leftParen';
    }
    function isRightParen(token) {
        if (!token)
            return false;
        return token.type === 'rightParen';
    }
    function isSemicolon(token) {
        if (!token)
            return false;
        return token.type === 'semicolon';
    }
    function isComma(token) {
        if (!token)
            return false;
        return token.type === 'comma';
    }
    function isCurrent(list, current) {
        return list.length > current;
    }
    function isNewStatement(token) {
        if (!token)
            return false;
        return (keywordEqual(token, 'CREATE') ||
            keywordEqual(token, 'ALTER') ||
            keywordEqual(token, 'DROP') ||
            keywordEqual(token, 'USE') ||
            keywordEqual(token, 'RENAME') ||
            keywordEqual(token, 'DELETE') ||
            keywordEqual(token, 'SELECT'));
    }
    function isCreateTable(tokens) {
        return (tokens.length > 2 &&
            keywordEqual(tokens[0], 'CREATE') &&
            keywordEqual(tokens[1], 'TABLE'));
    }
    function isCreateIndex(tokens) {
        return (tokens.length > 2 &&
            keywordEqual(tokens[0], 'CREATE') &&
            keywordEqual(tokens[1], 'INDEX'));
    }
    function isCreateUniqueIndex(tokens) {
        return (tokens.length > 3 &&
            keywordEqual(tokens[0], 'CREATE') &&
            keywordEqual(tokens[1], 'UNIQUE') &&
            keywordEqual(tokens[2], 'INDEX'));
    }
    function isAlterTableAddPrimaryKey(tokens) {
        return ((tokens.length > 6 &&
            keywordEqual(tokens[0], 'ALTER') &&
            keywordEqual(tokens[1], 'TABLE') &&
            keywordEqual(tokens[3], 'ADD') &&
            keywordEqual(tokens[4], 'PRIMARY') &&
            keywordEqual(tokens[5], 'KEY')) ||
            (tokens.length > 8 &&
                keywordEqual(tokens[0], 'ALTER') &&
                keywordEqual(tokens[1], 'TABLE') &&
                keywordEqual(tokens[3], 'ADD') &&
                keywordEqual(tokens[4], 'CONSTRAINT') &&
                keywordEqual(tokens[6], 'PRIMARY') &&
                keywordEqual(tokens[7], 'KEY')));
    }
    function isAlterTableAddForeignKey(tokens) {
        return ((tokens.length > 6 &&
            keywordEqual(tokens[0], 'ALTER') &&
            keywordEqual(tokens[1], 'TABLE') &&
            keywordEqual(tokens[3], 'ADD') &&
            keywordEqual(tokens[4], 'FOREIGN') &&
            keywordEqual(tokens[5], 'KEY')) ||
            (tokens.length > 8 &&
                keywordEqual(tokens[0], 'ALTER') &&
                keywordEqual(tokens[1], 'TABLE') &&
                keywordEqual(tokens[3], 'ADD') &&
                keywordEqual(tokens[4], 'CONSTRAINT') &&
                keywordEqual(tokens[6], 'FOREIGN') &&
                keywordEqual(tokens[7], 'KEY')));
    }
    function isAlterTableAddUnique(tokens) {
        return ((tokens.length > 5 &&
            keywordEqual(tokens[0], 'ALTER') &&
            keywordEqual(tokens[1], 'TABLE') &&
            keywordEqual(tokens[3], 'ADD') &&
            keywordEqual(tokens[4], 'UNIQUE')) ||
            (tokens.length > 7 &&
                keywordEqual(tokens[0], 'ALTER') &&
                keywordEqual(tokens[1], 'TABLE') &&
                keywordEqual(tokens[3], 'ADD') &&
                keywordEqual(tokens[4], 'CONSTRAINT') &&
                keywordEqual(tokens[6], 'UNIQUE')));
    }
    function isDataType(token) {
        if (!token)
            return false;
        var value = token.value.toUpperCase();
        return token.type === 'keyword' && tokenMatch.dataTypes.includes(value);
    }
    function isNot(token) {
        if (!token)
            return false;
        return keywordEqual(token, 'NOT');
    }
    function isNull(token) {
        if (!token)
            return false;
        return keywordEqual(token, 'NULL');
    }
    function isDefault(token) {
        if (!token)
            return false;
        return keywordEqual(token, 'DEFAULT');
    }
    function isComment(token) {
        if (!token)
            return false;
        return keywordEqual(token, 'COMMENT');
    }
    function isAutoIncrement(token) {
        if (!token)
            return false;
        return (keywordEqual(token, 'AUTO_INCREMENT') ||
            keywordEqual(token, 'AUTOINCREMENT'));
    }
    function isPrimary(token) {
        if (!token)
            return false;
        return keywordEqual(token, 'PRIMARY');
    }
    function isKey(token) {
        if (!token)
            return false;
        return keywordEqual(token, 'KEY');
    }
    function isUnique(token) {
        if (!token)
            return false;
        return keywordEqual(token, 'UNIQUE');
    }
    function isConstraint(token) {
        if (!token)
            return false;
        return keywordEqual(token, 'CONSTRAINT');
    }
    function isIndex$2(token) {
        if (!token)
            return false;
        return keywordEqual(token, 'INDEX');
    }
    function isForeign(token) {
        if (!token)
            return false;
        return keywordEqual(token, 'FOREIGN');
    }
    function isReferences(token) {
        if (!token)
            return false;
        return keywordEqual(token, 'REFERENCES');
    }
    function isDESC(token) {
        if (!token)
            return false;
        return keywordEqual(token, 'DESC');
    }
    function isOn(token) {
        if (!token)
            return false;
        return keywordEqual(token, 'ON');
    }
    function isTable(token) {
        if (!token)
            return false;
        return keywordEqual(token, 'TABLE');
    }

    function createTable$2(tokens) {
        var current = { value: 0 };
        var ast = {
            type: 'create.table',
            name: '',
            comment: '',
            columns: [],
            indexes: [],
            foreignKeys: [],
        };
        while (isCurrent(tokens, current.value)) {
            var token = tokens[current.value];
            if (isLeftParen(token)) {
                current.value++;
                var _a = createTableColumns(tokens, current), columns = _a.columns, indexes = _a.indexes, foreignKeys = _a.foreignKeys;
                ast.columns = columns;
                ast.indexes = indexes;
                ast.foreignKeys = foreignKeys;
                continue;
            }
            if (isString$1(token) && !ast.name) {
                ast.name = token.value;
                token = tokens[++current.value];
                if (isPeriod(token)) {
                    token = tokens[++current.value];
                    if (isString$1(token)) {
                        ast.name = token.value;
                        current.value++;
                    }
                }
                continue;
            }
            if (isComment(token)) {
                token = tokens[++current.value];
                if (isString$1(token)) {
                    ast.comment = token.value;
                    current.value++;
                }
                continue;
            }
            current.value++;
        }
        return ast;
    }
    function createTableColumns(tokens, current) {
        var columns = [];
        var indexes = [];
        var foreignKeys = [];
        var primaryKeyColumnNames = [];
        var uniqueColumnNames = [];
        var column = {
            name: '',
            dataType: '',
            default: '',
            comment: '',
            primaryKey: false,
            autoIncrement: false,
            unique: false,
            nullable: true,
        };
        while (isCurrent(tokens, current.value)) {
            var token = tokens[current.value];
            if (isString$1(token) && !column.name) {
                column.name = token.value;
                current.value++;
                continue;
            }
            if (isLeftParen(token)) {
                token = tokens[++current.value];
                while (isCurrent(tokens, current.value) && !isRightParen(token)) {
                    token = tokens[++current.value];
                }
                current.value++;
                continue;
            }
            if (isConstraint(token)) {
                token = tokens[++current.value];
                if (isString$1(token)) {
                    current.value++;
                }
                continue;
            }
            if (isPrimary(token)) {
                token = tokens[++current.value];
                if (isKey(token)) {
                    token = tokens[++current.value];
                    if (isLeftParen(token)) {
                        token = tokens[++current.value];
                        while (isCurrent(tokens, current.value) && !isRightParen(token)) {
                            if (isString$1(token)) {
                                primaryKeyColumnNames.push(token.value.toUpperCase());
                            }
                            token = tokens[++current.value];
                        }
                        current.value++;
                    }
                    else {
                        column.primaryKey = true;
                    }
                }
                continue;
            }
            if (isForeign(token)) {
                var foreignKey = parserForeignKey(tokens, current);
                if (foreignKey) {
                    foreignKeys.push(foreignKey);
                }
                continue;
            }
            if (isIndex$2(token) || isKey(token)) {
                token = tokens[++current.value];
                if (isString$1(token)) {
                    var name_1 = token.value;
                    var indexColumns = [];
                    token = tokens[++current.value];
                    if (isLeftParen(token)) {
                        token = tokens[++current.value];
                        var indexColumn = {
                            name: '',
                            sort: 'ASC',
                        };
                        while (isCurrent(tokens, current.value) && !isRightParen(token)) {
                            if (isString$1(token)) {
                                indexColumn.name = token.value;
                            }
                            if (isDESC(token)) {
                                indexColumn.sort = 'DESC';
                            }
                            if (isComma(token)) {
                                indexColumns.push(indexColumn);
                                indexColumn = {
                                    name: '',
                                    sort: 'ASC',
                                };
                            }
                            token = tokens[++current.value];
                        }
                        if (!indexColumns.includes(indexColumn) && indexColumn.name !== '') {
                            indexColumns.push(indexColumn);
                        }
                        if (indexColumns.length) {
                            indexes.push({
                                name: name_1,
                                unique: false,
                                columns: indexColumns,
                            });
                        }
                        current.value++;
                    }
                }
                continue;
            }
            if (isUnique(token)) {
                token = tokens[++current.value];
                if (isKey(token)) {
                    token = tokens[++current.value];
                }
                if (isString$1(token)) {
                    token = tokens[++current.value];
                }
                if (isLeftParen(token)) {
                    token = tokens[++current.value];
                    while (isCurrent(tokens, current.value) && !isRightParen(token)) {
                        if (isString$1(token)) {
                            uniqueColumnNames.push(token.value.toUpperCase());
                        }
                        token = tokens[++current.value];
                    }
                    current.value++;
                }
                else {
                    column.unique = true;
                }
                continue;
            }
            if (isNot(token)) {
                token = tokens[++current.value];
                if (isNull(token)) {
                    column.nullable = false;
                    current.value++;
                }
                continue;
            }
            if (isDefault(token)) {
                token = tokens[++current.value];
                if (isString$1(token) || isKeyword(token)) {
                    column.default = token.value;
                    current.value++;
                }
                continue;
            }
            if (isComment(token)) {
                token = tokens[++current.value];
                if (isString$1(token)) {
                    column.comment = token.value;
                    current.value++;
                }
                continue;
            }
            if (isAutoIncrement(token)) {
                column.autoIncrement = true;
                current.value++;
                continue;
            }
            if (isDataType(token)) {
                var value = token.value;
                token = tokens[++current.value];
                if (isLeftParen(token)) {
                    value += '(';
                    token = tokens[++current.value];
                    while (isCurrent(tokens, current.value) && !isRightParen(token)) {
                        value += token.value;
                        token = tokens[++current.value];
                    }
                    value += ')';
                    current.value++;
                }
                column.dataType = value;
                continue;
            }
            if (isComma(token)) {
                if (column.name || column.dataType) {
                    columns.push(column);
                }
                column = {
                    name: '',
                    dataType: '',
                    default: '',
                    comment: '',
                    primaryKey: false,
                    autoIncrement: false,
                    unique: false,
                    nullable: true,
                };
                current.value++;
                continue;
            }
            if (isRightParen(token)) {
                current.value++;
                break;
            }
            current.value++;
        }
        if (!columns.includes(column) && (column.name || column.dataType)) {
            columns.push(column);
        }
        columns.forEach(function (column) {
            if (primaryKeyColumnNames.includes(column.name.toUpperCase())) {
                column.primaryKey = true;
            }
            if (uniqueColumnNames.includes(column.name.toUpperCase())) {
                column.unique = true;
            }
        });
        return {
            columns: columns,
            indexes: indexes,
            foreignKeys: foreignKeys,
        };
    }
    function parserForeignKey(tokens, current) {
        var foreignKey = {
            columnNames: [],
            refTableName: '',
            refColumnNames: [],
        };
        var token = tokens[++current.value];
        if (isKey(token)) {
            token = tokens[++current.value];
            if (isLeftParen(token)) {
                token = tokens[++current.value];
                while (isCurrent(tokens, current.value) && !isRightParen(token)) {
                    if (isString$1(token)) {
                        foreignKey.columnNames.push(token.value);
                    }
                    token = tokens[++current.value];
                }
                token = tokens[++current.value];
            }
            if (isReferences(token)) {
                token = tokens[++current.value];
                if (isString$1(token)) {
                    foreignKey.refTableName = token.value;
                    token = tokens[++current.value];
                    if (isPeriod(token)) {
                        token = tokens[++current.value];
                        if (isString$1(token)) {
                            foreignKey.refTableName = token.value;
                            token = tokens[++current.value];
                        }
                    }
                    if (isLeftParen(token)) {
                        token = tokens[++current.value];
                        while (isCurrent(tokens, current.value) && !isRightParen(token)) {
                            if (isString$1(token)) {
                                foreignKey.refColumnNames.push(token.value);
                            }
                            token = tokens[++current.value];
                        }
                        token = tokens[++current.value];
                    }
                }
            }
            if (foreignKey.columnNames.length &&
                foreignKey.columnNames.length === foreignKey.refColumnNames.length) {
                return foreignKey;
            }
        }
        return null;
    }

    function alterTableAddForeignKey(tokens) {
        var current = { value: 0 };
        var ast = {
            type: 'alter.table.add.foreignKey',
            name: '',
            columnNames: [],
            refTableName: '',
            refColumnNames: [],
        };
        while (isCurrent(tokens, current.value)) {
            var token = tokens[current.value];
            if (isTable(token)) {
                token = tokens[++current.value];
                if (isString$1(token)) {
                    ast.name = token.value;
                    token = tokens[++current.value];
                    if (isPeriod(token)) {
                        token = tokens[++current.value];
                        if (isString$1(token)) {
                            ast.name = token.value;
                            current.value++;
                        }
                    }
                }
                continue;
            }
            if (isConstraint(token)) {
                token = tokens[++current.value];
                if (isString$1(token)) {
                    current.value++;
                }
                continue;
            }
            if (isForeign(token)) {
                var foreignKey = parserForeignKey(tokens, current);
                if (foreignKey) {
                    ast.columnNames = foreignKey.columnNames;
                    ast.refTableName = foreignKey.refTableName;
                    ast.refColumnNames = foreignKey.refColumnNames;
                }
                continue;
            }
            current.value++;
        }
        return ast;
    }

    function alterTableAddPrimaryKey(tokens) {
        var current = 0;
        var ast = {
            type: 'alter.table.add.primaryKey',
            name: '',
            columnNames: [],
        };
        while (isCurrent(tokens, current)) {
            var token = tokens[current];
            if (isTable(token)) {
                token = tokens[++current];
                if (isString$1(token)) {
                    ast.name = token.value;
                    token = tokens[++current];
                    if (isPeriod(token)) {
                        token = tokens[++current];
                        if (isString$1(token)) {
                            ast.name = token.value;
                            current++;
                        }
                    }
                }
                continue;
            }
            if (isConstraint(token)) {
                token = tokens[++current];
                if (isString$1(token)) {
                    current++;
                }
                continue;
            }
            if (isPrimary(token)) {
                token = tokens[++current];
                if (isKey(token)) {
                    token = tokens[++current];
                    if (isLeftParen(token)) {
                        token = tokens[++current];
                        while (isCurrent(tokens, current) && !isRightParen(token)) {
                            if (isString$1(token)) {
                                ast.columnNames.push(token.value);
                            }
                            token = tokens[++current];
                        }
                        token = tokens[++current];
                    }
                }
                continue;
            }
            current++;
        }
        return ast;
    }

    function alterTableAddUnique(tokens) {
        var current = 0;
        var ast = {
            type: 'alter.table.add.unique',
            name: '',
            columnNames: [],
        };
        while (isCurrent(tokens, current)) {
            var token = tokens[current];
            if (isTable(token)) {
                token = tokens[++current];
                if (isString$1(token)) {
                    ast.name = token.value;
                    token = tokens[++current];
                    if (isPeriod(token)) {
                        token = tokens[++current];
                        if (isString$1(token)) {
                            ast.name = token.value;
                            current++;
                        }
                    }
                }
                continue;
            }
            if (isConstraint(token)) {
                token = tokens[++current];
                if (isString$1(token)) {
                    current++;
                }
                continue;
            }
            if (isUnique(token)) {
                token = tokens[++current];
                if (isLeftParen(token)) {
                    token = tokens[++current];
                    while (isCurrent(tokens, current) && !isRightParen(token)) {
                        if (isString$1(token)) {
                            ast.columnNames.push(token.value);
                        }
                        token = tokens[++current];
                    }
                    current++;
                }
                continue;
            }
            current++;
        }
        return ast;
    }

    function createIndex$2(tokens, unique) {
        if (unique === void 0) { unique = false; }
        var current = 0;
        var ast = {
            type: 'create.index',
            name: '',
            unique: unique,
            tableName: '',
            columns: [],
        };
        while (isCurrent(tokens, current)) {
            var token = tokens[current];
            if (isIndex$2(token)) {
                token = tokens[++current];
                if (isString$1(token)) {
                    ast.name = token.value;
                }
                continue;
            }
            if (isOn(token)) {
                token = tokens[++current];
                if (isString$1(token)) {
                    ast.tableName = token.value;
                    token = tokens[++current];
                    if (isLeftParen(token)) {
                        token = tokens[++current];
                        var indexColumn = {
                            name: '',
                            sort: 'ASC',
                        };
                        while (isCurrent(tokens, current) && !isRightParen(token)) {
                            if (isString$1(token)) {
                                indexColumn.name = token.value;
                            }
                            if (isDESC(token)) {
                                indexColumn.sort = 'DESC';
                            }
                            if (isComma(token)) {
                                ast.columns.push(indexColumn);
                                indexColumn = {
                                    name: '',
                                    sort: 'ASC',
                                };
                            }
                            token = tokens[++current];
                        }
                        if (!ast.columns.includes(indexColumn) && indexColumn.name !== '') {
                            ast.columns.push(indexColumn);
                        }
                        current++;
                    }
                }
                continue;
            }
            current++;
        }
        return ast;
    }

    function createUniqueIndex(tokens) {
        return createIndex$2(tokens, true);
    }

    /**
     * https://github.com/jamiebuilds/the-super-tiny-compiler
     */
    function tokenizer(input) {
        var current = 0;
        var tokens = [];
        while (current < input.length) {
            var char = input[current];
            if (tokenMatch.whiteSpace.test(char)) {
                current++;
                continue;
            }
            if (char === tokenMatch.leftParen) {
                tokens.push({
                    type: 'leftParen',
                    value: '(',
                });
                current++;
                continue;
            }
            if (char === tokenMatch.rightParen) {
                tokens.push({
                    type: 'rightParen',
                    value: ')',
                });
                current++;
                continue;
            }
            if (char === tokenMatch.comma) {
                tokens.push({
                    type: 'comma',
                    value: ',',
                });
                current++;
                continue;
            }
            if (char === tokenMatch.period) {
                tokens.push({
                    type: 'period',
                    value: '.',
                });
                current++;
                continue;
            }
            if (char === tokenMatch.equal) {
                tokens.push({
                    type: 'equal',
                    value: '=',
                });
                current++;
                continue;
            }
            if (char === tokenMatch.semicolon) {
                tokens.push({
                    type: 'semicolon',
                    value: ';',
                });
                current++;
                continue;
            }
            if (char === tokenMatch.doubleQuote) {
                var value = '';
                char = input[++current];
                while (char !== tokenMatch.doubleQuote) {
                    value += char;
                    char = input[++current];
                }
                char = input[++current];
                tokens.push({ type: 'doubleQuoteString', value: value });
                continue;
            }
            if (char === tokenMatch.singleQuote) {
                var value = '';
                char = input[++current];
                while (char !== tokenMatch.singleQuote) {
                    value += char;
                    char = input[++current];
                }
                char = input[++current];
                tokens.push({ type: 'singleQuoteString', value: value });
                continue;
            }
            if (char === tokenMatch.backtick) {
                var value = '';
                char = input[++current];
                while (char !== tokenMatch.backtick) {
                    value += char;
                    char = input[++current];
                }
                char = input[++current];
                tokens.push({ type: 'backtickString', value: value });
                continue;
            }
            if (tokenMatch.string.test(char)) {
                var value = '';
                while (tokenMatch.string.test(char)) {
                    value += char;
                    char = input[++current];
                }
                tokens.push({ type: 'string', value: value });
                continue;
            }
            if (tokenMatch.unknown.test(char)) {
                var value = '';
                while (tokenMatch.unknown.test(char)) {
                    value += char;
                    char = input[++current];
                }
                tokens.push({ type: 'unknown', value: value });
                continue;
            }
            current++;
        }
        tokens.forEach(function (token) {
            if (isExtraString(token)) {
                token.type = 'string';
            }
            else if (isStringKeyword(token)) {
                token.type = 'keyword';
            }
        });
        return tokens;
    }
    function parser(tokens) {
        var current = 0;
        var tokenStatements = [];
        var statements = [];
        while (current < tokens.length) {
            var token = tokens[current];
            if (isNewStatement(token)) {
                var statement = [];
                statement.push(token);
                token = tokens[++current];
                while (current < tokens.length &&
                    !isNewStatement(token) &&
                    !isSemicolon(token)) {
                    statement.push(token);
                    token = tokens[++current];
                }
                tokenStatements.push(statement);
            }
            if (token && isNewStatement(token)) {
                continue;
            }
            current++;
        }
        tokenStatements.forEach(function (tokenStatement) {
            if (isCreateTable(tokenStatement)) {
                statements.push(createTable$2(tokenStatement));
            }
            else if (isCreateIndex(tokenStatement)) {
                statements.push(createIndex$2(tokenStatement));
            }
            else if (isCreateUniqueIndex(tokenStatement)) {
                statements.push(createUniqueIndex(tokenStatement));
            }
            else if (isAlterTableAddPrimaryKey(tokenStatement)) {
                statements.push(alterTableAddPrimaryKey(tokenStatement));
            }
            else if (isAlterTableAddForeignKey(tokenStatement)) {
                statements.push(alterTableAddForeignKey(tokenStatement));
            }
            else if (isAlterTableAddUnique(tokenStatement)) {
                statements.push(alterTableAddUnique(tokenStatement));
            }
        });
        return statements;
    }
    function DDLParser(input) {
        var tokens = tokenizer(input);
        return parser(tokens);
    }

    var domToImage$1 = {exports: {}};

    (function (module) {
    (function (global) {

        var util = newUtil();
        var inliner = newInliner();
        var fontFaces = newFontFaces();
        var images = newImages();

        // Default impl options
        var defaultOptions = {
            // Default is to fail on error, no placeholder
            imagePlaceholder: undefined,
            // Default cache bust is false, it will use the cache
            cacheBust: false
        };

        var domtoimage = {
            toSvg: toSvg,
            toPng: toPng,
            toJpeg: toJpeg,
            toBlob: toBlob,
            toPixelData: toPixelData,
            impl: {
                fontFaces: fontFaces,
                images: images,
                util: util,
                inliner: inliner,
                options: {}
            }
        };

        module.exports = domtoimage;


        /**
         * @param {Node} node - The DOM Node object to render
         * @param {Object} options - Rendering options
         * @param {Function} options.filter - Should return true if passed node should be included in the output
         *          (excluding node means excluding it's children as well). Not called on the root node.
         * @param {String} options.bgcolor - color for the background, any valid CSS color value.
         * @param {Number} options.width - width to be applied to node before rendering.
         * @param {Number} options.height - height to be applied to node before rendering.
         * @param {Object} options.style - an object whose properties to be copied to node's style before rendering.
         * @param {Number} options.quality - a Number between 0 and 1 indicating image quality (applicable to JPEG only),
                    defaults to 1.0.
         * @param {String} options.imagePlaceholder - dataURL to use as a placeholder for failed images, default behaviour is to fail fast on images we can't fetch
         * @param {Boolean} options.cacheBust - set to true to cache bust by appending the time to the request url
         * @return {Promise} - A promise that is fulfilled with a SVG image data URL
         * */
        function toSvg(node, options) {
            options = options || {};
            copyOptions(options);
            return Promise.resolve(node)
                .then(function (node) {
                    return cloneNode(node, options.filter, true);
                })
                .then(embedFonts)
                .then(inlineImages)
                .then(applyOptions)
                .then(function (clone) {
                    return makeSvgDataUri(clone,
                        options.width || util.width(node),
                        options.height || util.height(node)
                    );
                });

            function applyOptions(clone) {
                if (options.bgcolor) clone.style.backgroundColor = options.bgcolor;

                if (options.width) clone.style.width = options.width + 'px';
                if (options.height) clone.style.height = options.height + 'px';

                if (options.style)
                    Object.keys(options.style).forEach(function (property) {
                        clone.style[property] = options.style[property];
                    });

                return clone;
            }
        }

        /**
         * @param {Node} node - The DOM Node object to render
         * @param {Object} options - Rendering options, @see {@link toSvg}
         * @return {Promise} - A promise that is fulfilled with a Uint8Array containing RGBA pixel data.
         * */
        function toPixelData(node, options) {
            return draw(node, options || {})
                .then(function (canvas) {
                    return canvas.getContext('2d').getImageData(
                        0,
                        0,
                        util.width(node),
                        util.height(node)
                    ).data;
                });
        }

        /**
         * @param {Node} node - The DOM Node object to render
         * @param {Object} options - Rendering options, @see {@link toSvg}
         * @return {Promise} - A promise that is fulfilled with a PNG image data URL
         * */
        function toPng(node, options) {
            return draw(node, options || {})
                .then(function (canvas) {
                    return canvas.toDataURL();
                });
        }

        /**
         * @param {Node} node - The DOM Node object to render
         * @param {Object} options - Rendering options, @see {@link toSvg}
         * @return {Promise} - A promise that is fulfilled with a JPEG image data URL
         * */
        function toJpeg(node, options) {
            options = options || {};
            return draw(node, options)
                .then(function (canvas) {
                    return canvas.toDataURL('image/jpeg', options.quality || 1.0);
                });
        }

        /**
         * @param {Node} node - The DOM Node object to render
         * @param {Object} options - Rendering options, @see {@link toSvg}
         * @return {Promise} - A promise that is fulfilled with a PNG image blob
         * */
        function toBlob(node, options) {
            return draw(node, options || {})
                .then(util.canvasToBlob);
        }

        function copyOptions(options) {
            // Copy options to impl options for use in impl
            if(typeof(options.imagePlaceholder) === 'undefined') {
                domtoimage.impl.options.imagePlaceholder = defaultOptions.imagePlaceholder;
            } else {
                domtoimage.impl.options.imagePlaceholder = options.imagePlaceholder;
            }

            if(typeof(options.cacheBust) === 'undefined') {
                domtoimage.impl.options.cacheBust = defaultOptions.cacheBust;
            } else {
                domtoimage.impl.options.cacheBust = options.cacheBust;
            }
        }

        function draw(domNode, options) {
            return toSvg(domNode, options)
                .then(util.makeImage)
                .then(util.delay(100))
                .then(function (image) {
                    var canvas = newCanvas(domNode);
                    canvas.getContext('2d').drawImage(image, 0, 0);
                    return canvas;
                });

            function newCanvas(domNode) {
                var canvas = document.createElement('canvas');
                canvas.width = options.width || util.width(domNode);
                canvas.height = options.height || util.height(domNode);

                if (options.bgcolor) {
                    var ctx = canvas.getContext('2d');
                    ctx.fillStyle = options.bgcolor;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }

                return canvas;
            }
        }

        function cloneNode(node, filter, root) {
            if (!root && filter && !filter(node)) return Promise.resolve();

            return Promise.resolve(node)
                .then(makeNodeCopy)
                .then(function (clone) {
                    return cloneChildren(node, clone, filter);
                })
                .then(function (clone) {
                    return processClone(node, clone);
                });

            function makeNodeCopy(node) {
                if (node instanceof HTMLCanvasElement) return util.makeImage(node.toDataURL());
                return node.cloneNode(false);
            }

            function cloneChildren(original, clone, filter) {
                var children = original.childNodes;
                if (children.length === 0) return Promise.resolve(clone);

                return cloneChildrenInOrder(clone, util.asArray(children), filter)
                    .then(function () {
                        return clone;
                    });

                function cloneChildrenInOrder(parent, children, filter) {
                    var done = Promise.resolve();
                    children.forEach(function (child) {
                        done = done
                            .then(function () {
                                return cloneNode(child, filter);
                            })
                            .then(function (childClone) {
                                if (childClone) parent.appendChild(childClone);
                            });
                    });
                    return done;
                }
            }

            function processClone(original, clone) {
                if (!(clone instanceof Element)) return clone;

                return Promise.resolve()
                    .then(cloneStyle)
                    .then(clonePseudoElements)
                    .then(copyUserInput)
                    .then(fixSvg)
                    .then(function () {
                        return clone;
                    });

                function cloneStyle() {
                    copyStyle(window.getComputedStyle(original), clone.style);

                    function copyStyle(source, target) {
                        if (source.cssText) target.cssText = source.cssText;
                        else copyProperties(source, target);

                        function copyProperties(source, target) {
                            util.asArray(source).forEach(function (name) {
                                target.setProperty(
                                    name,
                                    source.getPropertyValue(name),
                                    source.getPropertyPriority(name)
                                );
                            });
                        }
                    }
                }

                function clonePseudoElements() {
                    [':before', ':after'].forEach(function (element) {
                        clonePseudoElement(element);
                    });

                    function clonePseudoElement(element) {
                        var style = window.getComputedStyle(original, element);
                        var content = style.getPropertyValue('content');

                        if (content === '' || content === 'none') return;

                        var className = util.uid();
                        clone.className = clone.className + ' ' + className;
                        var styleElement = document.createElement('style');
                        styleElement.appendChild(formatPseudoElementStyle(className, element, style));
                        clone.appendChild(styleElement);

                        function formatPseudoElementStyle(className, element, style) {
                            var selector = '.' + className + ':' + element;
                            var cssText = style.cssText ? formatCssText(style) : formatCssProperties(style);
                            return document.createTextNode(selector + '{' + cssText + '}');

                            function formatCssText(style) {
                                var content = style.getPropertyValue('content');
                                return style.cssText + ' content: ' + content + ';';
                            }

                            function formatCssProperties(style) {

                                return util.asArray(style)
                                    .map(formatProperty)
                                    .join('; ') + ';';

                                function formatProperty(name) {
                                    return name + ': ' +
                                        style.getPropertyValue(name) +
                                        (style.getPropertyPriority(name) ? ' !important' : '');
                                }
                            }
                        }
                    }
                }

                function copyUserInput() {
                    if (original instanceof HTMLTextAreaElement) clone.innerHTML = original.value;
                    if (original instanceof HTMLInputElement) clone.setAttribute("value", original.value);
                }

                function fixSvg() {
                    if (!(clone instanceof SVGElement)) return;
                    clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');

                    if (!(clone instanceof SVGRectElement)) return;
                    ['width', 'height'].forEach(function (attribute) {
                        var value = clone.getAttribute(attribute);
                        if (!value) return;

                        clone.style.setProperty(attribute, value);
                    });
                }
            }
        }

        function embedFonts(node) {
            return fontFaces.resolveAll()
                .then(function (cssText) {
                    var styleNode = document.createElement('style');
                    node.appendChild(styleNode);
                    styleNode.appendChild(document.createTextNode(cssText));
                    return node;
                });
        }

        function inlineImages(node) {
            return images.inlineAll(node)
                .then(function () {
                    return node;
                });
        }

        function makeSvgDataUri(node, width, height) {
            return Promise.resolve(node)
                .then(function (node) {
                    node.setAttribute('xmlns', 'http://www.w3.org/1999/xhtml');
                    return new XMLSerializer().serializeToString(node);
                })
                .then(util.escapeXhtml)
                .then(function (xhtml) {
                    return '<foreignObject x="0" y="0" width="100%" height="100%">' + xhtml + '</foreignObject>';
                })
                .then(function (foreignObject) {
                    return '<svg xmlns="http://www.w3.org/2000/svg" width="' + width + '" height="' + height + '">' +
                        foreignObject + '</svg>';
                })
                .then(function (svg) {
                    return 'data:image/svg+xml;charset=utf-8,' + svg;
                });
        }

        function newUtil() {
            return {
                escape: escape,
                parseExtension: parseExtension,
                mimeType: mimeType,
                dataAsUrl: dataAsUrl,
                isDataUrl: isDataUrl,
                canvasToBlob: canvasToBlob,
                resolveUrl: resolveUrl,
                getAndEncode: getAndEncode,
                uid: uid(),
                delay: delay,
                asArray: asArray,
                escapeXhtml: escapeXhtml,
                makeImage: makeImage,
                width: width,
                height: height
            };

            function mimes() {
                /*
                 * Only WOFF and EOT mime types for fonts are 'real'
                 * see http://www.iana.org/assignments/media-types/media-types.xhtml
                 */
                var WOFF = 'application/font-woff';
                var JPEG = 'image/jpeg';

                return {
                    'woff': WOFF,
                    'woff2': WOFF,
                    'ttf': 'application/font-truetype',
                    'eot': 'application/vnd.ms-fontobject',
                    'png': 'image/png',
                    'jpg': JPEG,
                    'jpeg': JPEG,
                    'gif': 'image/gif',
                    'tiff': 'image/tiff',
                    'svg': 'image/svg+xml'
                };
            }

            function parseExtension(url) {
                var match = /\.([^\.\/]*?)$/g.exec(url);
                if (match) return match[1];
                else return '';
            }

            function mimeType(url) {
                var extension = parseExtension(url).toLowerCase();
                return mimes()[extension] || '';
            }

            function isDataUrl(url) {
                return url.search(/^(data:)/) !== -1;
            }

            function toBlob(canvas) {
                return new Promise(function (resolve) {
                    var binaryString = window.atob(canvas.toDataURL().split(',')[1]);
                    var length = binaryString.length;
                    var binaryArray = new Uint8Array(length);

                    for (var i = 0; i < length; i++)
                        binaryArray[i] = binaryString.charCodeAt(i);

                    resolve(new Blob([binaryArray], {
                        type: 'image/png'
                    }));
                });
            }

            function canvasToBlob(canvas) {
                if (canvas.toBlob)
                    return new Promise(function (resolve) {
                        canvas.toBlob(resolve);
                    });

                return toBlob(canvas);
            }

            function resolveUrl(url, baseUrl) {
                var doc = document.implementation.createHTMLDocument();
                var base = doc.createElement('base');
                doc.head.appendChild(base);
                var a = doc.createElement('a');
                doc.body.appendChild(a);
                base.href = baseUrl;
                a.href = url;
                return a.href;
            }

            function uid() {
                var index = 0;

                return function () {
                    return 'u' + fourRandomChars() + index++;

                    function fourRandomChars() {
                        /* see http://stackoverflow.com/a/6248722/2519373 */
                        return ('0000' + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4);
                    }
                };
            }

            function makeImage(uri) {
                return new Promise(function (resolve, reject) {
                    var image = new Image();
                    image.onload = function () {
                        resolve(image);
                    };
                    image.onerror = reject;
                    image.src = uri;
                });
            }

            function getAndEncode(url) {
                var TIMEOUT = 30000;
                if(domtoimage.impl.options.cacheBust) {
                    // Cache bypass so we dont have CORS issues with cached images
                    // Source: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache
                    url += ((/\?/).test(url) ? "&" : "?") + (new Date()).getTime();
                }

                return new Promise(function (resolve) {
                    var request = new XMLHttpRequest();

                    request.onreadystatechange = done;
                    request.ontimeout = timeout;
                    request.responseType = 'blob';
                    request.timeout = TIMEOUT;
                    request.open('GET', url, true);
                    request.send();

                    var placeholder;
                    if(domtoimage.impl.options.imagePlaceholder) {
                        var split = domtoimage.impl.options.imagePlaceholder.split(/,/);
                        if(split && split[1]) {
                            placeholder = split[1];
                        }
                    }

                    function done() {
                        if (request.readyState !== 4) return;

                        if (request.status !== 200) {
                            if(placeholder) {
                                resolve(placeholder);
                            } else {
                                fail('cannot fetch resource: ' + url + ', status: ' + request.status);
                            }

                            return;
                        }

                        var encoder = new FileReader();
                        encoder.onloadend = function () {
                            var content = encoder.result.split(/,/)[1];
                            resolve(content);
                        };
                        encoder.readAsDataURL(request.response);
                    }

                    function timeout() {
                        if(placeholder) {
                            resolve(placeholder);
                        } else {
                            fail('timeout of ' + TIMEOUT + 'ms occured while fetching resource: ' + url);
                        }
                    }

                    function fail(message) {
                        console.error(message);
                        resolve('');
                    }
                });
            }

            function dataAsUrl(content, type) {
                return 'data:' + type + ';base64,' + content;
            }

            function escape(string) {
                return string.replace(/([.*+?^${}()|\[\]\/\\])/g, '\\$1');
            }

            function delay(ms) {
                return function (arg) {
                    return new Promise(function (resolve) {
                        setTimeout(function () {
                            resolve(arg);
                        }, ms);
                    });
                };
            }

            function asArray(arrayLike) {
                var array = [];
                var length = arrayLike.length;
                for (var i = 0; i < length; i++) array.push(arrayLike[i]);
                return array;
            }

            function escapeXhtml(string) {
                return string.replace(/#/g, '%23').replace(/\n/g, '%0A');
            }

            function width(node) {
                var leftBorder = px(node, 'border-left-width');
                var rightBorder = px(node, 'border-right-width');
                return node.scrollWidth + leftBorder + rightBorder;
            }

            function height(node) {
                var topBorder = px(node, 'border-top-width');
                var bottomBorder = px(node, 'border-bottom-width');
                return node.scrollHeight + topBorder + bottomBorder;
            }

            function px(node, styleProperty) {
                var value = window.getComputedStyle(node).getPropertyValue(styleProperty);
                return parseFloat(value.replace('px', ''));
            }
        }

        function newInliner() {
            var URL_REGEX = /url\(['"]?([^'"]+?)['"]?\)/g;

            return {
                inlineAll: inlineAll,
                shouldProcess: shouldProcess,
                impl: {
                    readUrls: readUrls,
                    inline: inline
                }
            };

            function shouldProcess(string) {
                return string.search(URL_REGEX) !== -1;
            }

            function readUrls(string) {
                var result = [];
                var match;
                while ((match = URL_REGEX.exec(string)) !== null) {
                    result.push(match[1]);
                }
                return result.filter(function (url) {
                    return !util.isDataUrl(url);
                });
            }

            function inline(string, url, baseUrl, get) {
                return Promise.resolve(url)
                    .then(function (url) {
                        return baseUrl ? util.resolveUrl(url, baseUrl) : url;
                    })
                    .then(get || util.getAndEncode)
                    .then(function (data) {
                        return util.dataAsUrl(data, util.mimeType(url));
                    })
                    .then(function (dataUrl) {
                        return string.replace(urlAsRegex(url), '$1' + dataUrl + '$3');
                    });

                function urlAsRegex(url) {
                    return new RegExp('(url\\([\'"]?)(' + util.escape(url) + ')([\'"]?\\))', 'g');
                }
            }

            function inlineAll(string, baseUrl, get) {
                if (nothingToInline()) return Promise.resolve(string);

                return Promise.resolve(string)
                    .then(readUrls)
                    .then(function (urls) {
                        var done = Promise.resolve(string);
                        urls.forEach(function (url) {
                            done = done.then(function (string) {
                                return inline(string, url, baseUrl, get);
                            });
                        });
                        return done;
                    });

                function nothingToInline() {
                    return !shouldProcess(string);
                }
            }
        }

        function newFontFaces() {
            return {
                resolveAll: resolveAll,
                impl: {
                    readAll: readAll
                }
            };

            function resolveAll() {
                return readAll()
                    .then(function (webFonts) {
                        return Promise.all(
                            webFonts.map(function (webFont) {
                                return webFont.resolve();
                            })
                        );
                    })
                    .then(function (cssStrings) {
                        return cssStrings.join('\n');
                    });
            }

            function readAll() {
                return Promise.resolve(util.asArray(document.styleSheets))
                    .then(getCssRules)
                    .then(selectWebFontRules)
                    .then(function (rules) {
                        return rules.map(newWebFont);
                    });

                function selectWebFontRules(cssRules) {
                    return cssRules
                        .filter(function (rule) {
                            return rule.type === CSSRule.FONT_FACE_RULE;
                        })
                        .filter(function (rule) {
                            return inliner.shouldProcess(rule.style.getPropertyValue('src'));
                        });
                }

                function getCssRules(styleSheets) {
                    var cssRules = [];
                    styleSheets.forEach(function (sheet) {
                        try {
                            util.asArray(sheet.cssRules || []).forEach(cssRules.push.bind(cssRules));
                        } catch (e) {
                            console.log('Error while reading CSS rules from ' + sheet.href, e.toString());
                        }
                    });
                    return cssRules;
                }

                function newWebFont(webFontRule) {
                    return {
                        resolve: function resolve() {
                            var baseUrl = (webFontRule.parentStyleSheet || {}).href;
                            return inliner.inlineAll(webFontRule.cssText, baseUrl);
                        },
                        src: function () {
                            return webFontRule.style.getPropertyValue('src');
                        }
                    };
                }
            }
        }

        function newImages() {
            return {
                inlineAll: inlineAll,
                impl: {
                    newImage: newImage
                }
            };

            function newImage(element) {
                return {
                    inline: inline
                };

                function inline(get) {
                    if (util.isDataUrl(element.src)) return Promise.resolve();

                    return Promise.resolve(element.src)
                        .then(get || util.getAndEncode)
                        .then(function (data) {
                            return util.dataAsUrl(data, util.mimeType(element.src));
                        })
                        .then(function (dataUrl) {
                            return new Promise(function (resolve, reject) {
                                element.onload = resolve;
                                element.onerror = reject;
                                element.src = dataUrl;
                            });
                        });
                }
            }

            function inlineAll(node) {
                if (!(node instanceof Element)) return Promise.resolve(node);

                return inlineBackground(node)
                    .then(function () {
                        if (node instanceof HTMLImageElement)
                            return newImage(node).inline();
                        else
                            return Promise.all(
                                util.asArray(node.childNodes).map(function (child) {
                                    return inlineAll(child);
                                })
                            );
                    });

                function inlineBackground(node) {
                    var background = node.style.getPropertyValue('background');

                    if (!background) return Promise.resolve(node);

                    return inliner.inlineAll(background)
                        .then(function (inlined) {
                            node.style.setProperty(
                                'background',
                                inlined,
                                node.style.getPropertyPriority('background')
                            );
                        })
                        .then(function () {
                            return node;
                        });
                }
            }
        }
    })();
    }(domToImage$1));

    var domToImage = domToImage$1.exports;

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */

    function listCacheClear$1() {
      this.__data__ = [];
      this.size = 0;
    }

    var _listCacheClear = listCacheClear$1;

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */

    function eq$2(value, other) {
      return value === other || (value !== value && other !== other);
    }

    var eq_1 = eq$2;

    var eq$1 = eq_1;

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf$4(array, key) {
      var length = array.length;
      while (length--) {
        if (eq$1(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    var _assocIndexOf = assocIndexOf$4;

    var assocIndexOf$3 = _assocIndexOf;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype;

    /** Built-in value references. */
    var splice = arrayProto.splice;

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete$1(key) {
      var data = this.__data__,
          index = assocIndexOf$3(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    var _listCacheDelete = listCacheDelete$1;

    var assocIndexOf$2 = _assocIndexOf;

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet$1(key) {
      var data = this.__data__,
          index = assocIndexOf$2(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    var _listCacheGet = listCacheGet$1;

    var assocIndexOf$1 = _assocIndexOf;

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas$1(key) {
      return assocIndexOf$1(this.__data__, key) > -1;
    }

    var _listCacheHas = listCacheHas$1;

    var assocIndexOf = _assocIndexOf;

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet$1(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    var _listCacheSet = listCacheSet$1;

    var listCacheClear = _listCacheClear,
        listCacheDelete = _listCacheDelete,
        listCacheGet = _listCacheGet,
        listCacheHas = _listCacheHas,
        listCacheSet = _listCacheSet;

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache$4(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `ListCache`.
    ListCache$4.prototype.clear = listCacheClear;
    ListCache$4.prototype['delete'] = listCacheDelete;
    ListCache$4.prototype.get = listCacheGet;
    ListCache$4.prototype.has = listCacheHas;
    ListCache$4.prototype.set = listCacheSet;

    var _ListCache = ListCache$4;

    var ListCache$3 = _ListCache;

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear$1() {
      this.__data__ = new ListCache$3;
      this.size = 0;
    }

    var _stackClear = stackClear$1;

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */

    function stackDelete$1(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    var _stackDelete = stackDelete$1;

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */

    function stackGet$1(key) {
      return this.__data__.get(key);
    }

    var _stackGet = stackGet$1;

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */

    function stackHas$1(key) {
      return this.__data__.has(key);
    }

    var _stackHas = stackHas$1;

    var baseGetTag$3 = _baseGetTag,
        isObject$1 = isObject_1;

    /** `Object#toString` result references. */
    var asyncTag = '[object AsyncFunction]',
        funcTag$1 = '[object Function]',
        genTag = '[object GeneratorFunction]',
        proxyTag = '[object Proxy]';

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction$2(value) {
      if (!isObject$1(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag$3(value);
      return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    var isFunction_1 = isFunction$2;

    var root$7 = _root;

    /** Used to detect overreaching core-js shims. */
    var coreJsData$1 = root$7['__core-js_shared__'];

    var _coreJsData = coreJsData$1;

    var coreJsData = _coreJsData;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked$1(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    var _isMasked = isMasked$1;

    /** Used for built-in method references. */

    var funcProto$1 = Function.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString$1 = funcProto$1.toString;

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource$2(func) {
      if (func != null) {
        try {
          return funcToString$1.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    var _toSource = toSource$2;

    var isFunction$1 = isFunction_1,
        isMasked = _isMasked,
        isObject = isObject_1,
        toSource$1 = _toSource;

    /**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

    /** Used to detect host constructors (Safari). */
    var reIsHostCtor = /^\[object .+?Constructor\]$/;

    /** Used for built-in method references. */
    var funcProto = Function.prototype,
        objectProto$9 = Object.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty$7 = objectProto$9.hasOwnProperty;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty$7).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative$1(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource$1(value));
    }

    var _baseIsNative = baseIsNative$1;

    /**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */

    function getValue$1(object, key) {
      return object == null ? undefined : object[key];
    }

    var _getValue = getValue$1;

    var baseIsNative = _baseIsNative,
        getValue = _getValue;

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative$6(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }

    var _getNative = getNative$6;

    var getNative$5 = _getNative,
        root$6 = _root;

    /* Built-in method references that are verified to be native. */
    var Map$4 = getNative$5(root$6, 'Map');

    var _Map = Map$4;

    var getNative$4 = _getNative;

    /* Built-in method references that are verified to be native. */
    var nativeCreate$4 = getNative$4(Object, 'create');

    var _nativeCreate = nativeCreate$4;

    var nativeCreate$3 = _nativeCreate;

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear$1() {
      this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
      this.size = 0;
    }

    var _hashClear = hashClear$1;

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */

    function hashDelete$1(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    var _hashDelete = hashDelete$1;

    var nativeCreate$2 = _nativeCreate;

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

    /** Used for built-in method references. */
    var objectProto$8 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$6 = objectProto$8.hasOwnProperty;

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet$1(key) {
      var data = this.__data__;
      if (nativeCreate$2) {
        var result = data[key];
        return result === HASH_UNDEFINED$2 ? undefined : result;
      }
      return hasOwnProperty$6.call(data, key) ? data[key] : undefined;
    }

    var _hashGet = hashGet$1;

    var nativeCreate$1 = _nativeCreate;

    /** Used for built-in method references. */
    var objectProto$7 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$5 = objectProto$7.hasOwnProperty;

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas$1(key) {
      var data = this.__data__;
      return nativeCreate$1 ? (data[key] !== undefined) : hasOwnProperty$5.call(data, key);
    }

    var _hashHas = hashHas$1;

    var nativeCreate = _nativeCreate;

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet$1(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
      return this;
    }

    var _hashSet = hashSet$1;

    var hashClear = _hashClear,
        hashDelete = _hashDelete,
        hashGet = _hashGet,
        hashHas = _hashHas,
        hashSet = _hashSet;

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash$1(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `Hash`.
    Hash$1.prototype.clear = hashClear;
    Hash$1.prototype['delete'] = hashDelete;
    Hash$1.prototype.get = hashGet;
    Hash$1.prototype.has = hashHas;
    Hash$1.prototype.set = hashSet;

    var _Hash = Hash$1;

    var Hash = _Hash,
        ListCache$2 = _ListCache,
        Map$3 = _Map;

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear$1() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash,
        'map': new (Map$3 || ListCache$2),
        'string': new Hash
      };
    }

    var _mapCacheClear = mapCacheClear$1;

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */

    function isKeyable$1(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    var _isKeyable = isKeyable$1;

    var isKeyable = _isKeyable;

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData$4(map, key) {
      var data = map.__data__;
      return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    var _getMapData = getMapData$4;

    var getMapData$3 = _getMapData;

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete$1(key) {
      var result = getMapData$3(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    var _mapCacheDelete = mapCacheDelete$1;

    var getMapData$2 = _getMapData;

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet$1(key) {
      return getMapData$2(this, key).get(key);
    }

    var _mapCacheGet = mapCacheGet$1;

    var getMapData$1 = _getMapData;

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas$1(key) {
      return getMapData$1(this, key).has(key);
    }

    var _mapCacheHas = mapCacheHas$1;

    var getMapData = _getMapData;

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet$1(key, value) {
      var data = getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    var _mapCacheSet = mapCacheSet$1;

    var mapCacheClear = _mapCacheClear,
        mapCacheDelete = _mapCacheDelete,
        mapCacheGet = _mapCacheGet,
        mapCacheHas = _mapCacheHas,
        mapCacheSet = _mapCacheSet;

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache$2(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `MapCache`.
    MapCache$2.prototype.clear = mapCacheClear;
    MapCache$2.prototype['delete'] = mapCacheDelete;
    MapCache$2.prototype.get = mapCacheGet;
    MapCache$2.prototype.has = mapCacheHas;
    MapCache$2.prototype.set = mapCacheSet;

    var _MapCache = MapCache$2;

    var ListCache$1 = _ListCache,
        Map$2 = _Map,
        MapCache$1 = _MapCache;

    /** Used as the size to enable large array optimizations. */
    var LARGE_ARRAY_SIZE = 200;

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet$1(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache$1) {
        var pairs = data.__data__;
        if (!Map$2 || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache$1(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    var _stackSet = stackSet$1;

    var ListCache = _ListCache,
        stackClear = _stackClear,
        stackDelete = _stackDelete,
        stackGet = _stackGet,
        stackHas = _stackHas,
        stackSet = _stackSet;

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack$1(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }

    // Add methods to `Stack`.
    Stack$1.prototype.clear = stackClear;
    Stack$1.prototype['delete'] = stackDelete;
    Stack$1.prototype.get = stackGet;
    Stack$1.prototype.has = stackHas;
    Stack$1.prototype.set = stackSet;

    var _Stack = Stack$1;

    /** Used to stand-in for `undefined` hash values. */

    var HASH_UNDEFINED = '__lodash_hash_undefined__';

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd$1(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }

    var _setCacheAdd = setCacheAdd$1;

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */

    function setCacheHas$1(value) {
      return this.__data__.has(value);
    }

    var _setCacheHas = setCacheHas$1;

    var MapCache = _MapCache,
        setCacheAdd = _setCacheAdd,
        setCacheHas = _setCacheHas;

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache$1(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    // Add methods to `SetCache`.
    SetCache$1.prototype.add = SetCache$1.prototype.push = setCacheAdd;
    SetCache$1.prototype.has = setCacheHas;

    var _SetCache = SetCache$1;

    /**
     * A specialized version of `_.some` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */

    function arraySome$1(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }

    var _arraySome = arraySome$1;

    /**
     * Checks if a `cache` value for `key` exists.
     *
     * @private
     * @param {Object} cache The cache to query.
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */

    function cacheHas$1(cache, key) {
      return cache.has(key);
    }

    var _cacheHas = cacheHas$1;

    var SetCache = _SetCache,
        arraySome = _arraySome,
        cacheHas = _cacheHas;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$3 = 1,
        COMPARE_UNORDERED_FLAG$1 = 2;

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays$2(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Check that cyclic values are equal.
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG$1) ? new SetCache : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!arraySome(other, function(othValue, othIndex) {
                if (!cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    var _equalArrays = equalArrays$2;

    var root$5 = _root;

    /** Built-in value references. */
    var Uint8Array$2 = root$5.Uint8Array;

    var _Uint8Array = Uint8Array$2;

    /**
     * Converts `map` to its key-value pairs.
     *
     * @private
     * @param {Object} map The map to convert.
     * @returns {Array} Returns the key-value pairs.
     */

    function mapToArray$1(map) {
      var index = -1,
          result = Array(map.size);

      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }

    var _mapToArray = mapToArray$1;

    /**
     * Converts `set` to an array of its values.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the values.
     */

    function setToArray$1(set) {
      var index = -1,
          result = Array(set.size);

      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }

    var _setToArray = setToArray$1;

    var Symbol$1 = _Symbol,
        Uint8Array$1 = _Uint8Array,
        eq = eq_1,
        equalArrays$1 = _equalArrays,
        mapToArray = _mapToArray,
        setToArray = _setToArray;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$2 = 1,
        COMPARE_UNORDERED_FLAG = 2;

    /** `Object#toString` result references. */
    var boolTag$1 = '[object Boolean]',
        dateTag$1 = '[object Date]',
        errorTag$1 = '[object Error]',
        mapTag$2 = '[object Map]',
        numberTag$1 = '[object Number]',
        regexpTag$1 = '[object RegExp]',
        setTag$2 = '[object Set]',
        stringTag$1 = '[object String]',
        symbolTag = '[object Symbol]';

    var arrayBufferTag$1 = '[object ArrayBuffer]',
        dataViewTag$2 = '[object DataView]';

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag$1(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag$2:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag$1:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
            return false;
          }
          return true;

        case boolTag$1:
        case dateTag$1:
        case numberTag$1:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag$1:
          return object.name == other.name && object.message == other.message;

        case regexpTag$1:
        case stringTag$1:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag$2:
          var convert = mapToArray;

        case setTag$2:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = equalArrays$1(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    var _equalByTag = equalByTag$1;

    /**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */

    function arrayPush$1(array, values) {
      var index = -1,
          length = values.length,
          offset = array.length;

      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }

    var _arrayPush = arrayPush$1;

    var arrayPush = _arrayPush,
        isArray$2 = isArray_1;

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys$1(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray$2(object) ? result : arrayPush(result, symbolsFunc(object));
    }

    var _baseGetAllKeys = baseGetAllKeys$1;

    /**
     * A specialized version of `_.filter` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */

    function arrayFilter$1(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    var _arrayFilter = arrayFilter$1;

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */

    function stubArray$1() {
      return [];
    }

    var stubArray_1 = stubArray$1;

    var arrayFilter = _arrayFilter,
        stubArray = stubArray_1;

    /** Used for built-in method references. */
    var objectProto$6 = Object.prototype;

    /** Built-in value references. */
    var propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeGetSymbols = Object.getOwnPropertySymbols;

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols$1 = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable$1.call(object, symbol);
      });
    };

    var _getSymbols = getSymbols$1;

    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */

    function baseTimes$1(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }

    var _baseTimes = baseTimes$1;

    var baseGetTag$2 = _baseGetTag,
        isObjectLike$3 = isObjectLike_1;

    /** `Object#toString` result references. */
    var argsTag$2 = '[object Arguments]';

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments$1(value) {
      return isObjectLike$3(value) && baseGetTag$2(value) == argsTag$2;
    }

    var _baseIsArguments = baseIsArguments$1;

    var baseIsArguments = _baseIsArguments,
        isObjectLike$2 = isObjectLike_1;

    /** Used for built-in method references. */
    var objectProto$5 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

    /** Built-in value references. */
    var propertyIsEnumerable = objectProto$5.propertyIsEnumerable;

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments$1 = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike$2(value) && hasOwnProperty$4.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    var isArguments_1 = isArguments$1;

    var isBuffer$2 = {exports: {}};

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */

    function stubFalse() {
      return false;
    }

    var stubFalse_1 = stubFalse;

    (function (module, exports) {
    var root = _root,
        stubFalse = stubFalse_1;

    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Built-in value references. */
    var Buffer = moduleExports ? root.Buffer : undefined;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    module.exports = isBuffer;
    }(isBuffer$2, isBuffer$2.exports));

    /** Used as references for various `Number` constants. */

    var MAX_SAFE_INTEGER$1 = 9007199254740991;

    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex$1(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$1 : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    var _isIndex = isIndex$1;

    /** Used as references for various `Number` constants. */

    var MAX_SAFE_INTEGER = 9007199254740991;

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength$2(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    var isLength_1 = isLength$2;

    var baseGetTag$1 = _baseGetTag,
        isLength$1 = isLength_1,
        isObjectLike$1 = isObjectLike_1;

    /** `Object#toString` result references. */
    var argsTag$1 = '[object Arguments]',
        arrayTag$1 = '[object Array]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag = '[object Function]',
        mapTag$1 = '[object Map]',
        numberTag = '[object Number]',
        objectTag$2 = '[object Object]',
        regexpTag = '[object RegExp]',
        setTag$1 = '[object Set]',
        stringTag = '[object String]',
        weakMapTag$1 = '[object WeakMap]';

    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag$1 = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';

    /** Used to identify `toStringTag` values of typed arrays. */
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
    typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
    typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
    typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
    typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] =
    typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
    typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag] =
    typedArrayTags[errorTag] = typedArrayTags[funcTag] =
    typedArrayTags[mapTag$1] = typedArrayTags[numberTag] =
    typedArrayTags[objectTag$2] = typedArrayTags[regexpTag] =
    typedArrayTags[setTag$1] = typedArrayTags[stringTag] =
    typedArrayTags[weakMapTag$1] = false;

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray$1(value) {
      return isObjectLike$1(value) &&
        isLength$1(value.length) && !!typedArrayTags[baseGetTag$1(value)];
    }

    var _baseIsTypedArray = baseIsTypedArray$1;

    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */

    function baseUnary$1(func) {
      return function(value) {
        return func(value);
      };
    }

    var _baseUnary = baseUnary$1;

    var _nodeUtil = {exports: {}};

    (function (module, exports) {
    var freeGlobal = _freeGlobal;

    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Detect free variable `process` from Node.js. */
    var freeProcess = moduleExports && freeGlobal.process;

    /** Used to access faster Node.js helpers. */
    var nodeUtil = (function() {
      try {
        // Use `util.types` for Node.js 10+.
        var types = freeModule && freeModule.require && freeModule.require('util').types;

        if (types) {
          return types;
        }

        // Legacy `process.binding('util')` for Node.js < 10.
        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }());

    module.exports = nodeUtil;
    }(_nodeUtil, _nodeUtil.exports));

    var baseIsTypedArray = _baseIsTypedArray,
        baseUnary = _baseUnary,
        nodeUtil = _nodeUtil.exports;

    /* Node.js helper references. */
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray$2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    var isTypedArray_1 = isTypedArray$2;

    var baseTimes = _baseTimes,
        isArguments = isArguments_1,
        isArray$1 = isArray_1,
        isBuffer$1 = isBuffer$2.exports,
        isIndex = _isIndex,
        isTypedArray$1 = isTypedArray_1;

    /** Used for built-in method references. */
    var objectProto$4 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys$1(value, inherited) {
      var isArr = isArray$1(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer$1(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray$1(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty$3.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    var _arrayLikeKeys = arrayLikeKeys$1;

    /** Used for built-in method references. */

    var objectProto$3 = Object.prototype;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype$1(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$3;

      return value === proto;
    }

    var _isPrototype = isPrototype$1;

    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */

    function overArg$1(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }

    var _overArg = overArg$1;

    var overArg = _overArg;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeKeys$1 = overArg(Object.keys, Object);

    var _nativeKeys = nativeKeys$1;

    var isPrototype = _isPrototype,
        nativeKeys = _nativeKeys;

    /** Used for built-in method references. */
    var objectProto$2 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys$1(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty$2.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    var _baseKeys = baseKeys$1;

    var isFunction = isFunction_1,
        isLength = isLength_1;

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike$1(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    var isArrayLike_1 = isArrayLike$1;

    var arrayLikeKeys = _arrayLikeKeys,
        baseKeys = _baseKeys,
        isArrayLike = isArrayLike_1;

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys$1(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    var keys_1 = keys$1;

    var baseGetAllKeys = _baseGetAllKeys,
        getSymbols = _getSymbols,
        keys = keys_1;

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys$1(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }

    var _getAllKeys = getAllKeys$1;

    var getAllKeys = _getAllKeys;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$1 = 1;

    /** Used for built-in method references. */
    var objectProto$1 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects$1(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
          return false;
        }
      }
      // Check that cyclic values are equal.
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    var _equalObjects = equalObjects$1;

    var getNative$3 = _getNative,
        root$4 = _root;

    /* Built-in method references that are verified to be native. */
    var DataView$1 = getNative$3(root$4, 'DataView');

    var _DataView = DataView$1;

    var getNative$2 = _getNative,
        root$3 = _root;

    /* Built-in method references that are verified to be native. */
    var Promise$2 = getNative$2(root$3, 'Promise');

    var _Promise = Promise$2;

    var getNative$1 = _getNative,
        root$2 = _root;

    /* Built-in method references that are verified to be native. */
    var Set$2 = getNative$1(root$2, 'Set');

    var _Set = Set$2;

    var getNative = _getNative,
        root$1 = _root;

    /* Built-in method references that are verified to be native. */
    var WeakMap$2 = getNative(root$1, 'WeakMap');

    var _WeakMap = WeakMap$2;

    var DataView = _DataView,
        Map$1 = _Map,
        Promise$1 = _Promise,
        Set$1 = _Set,
        WeakMap$1 = _WeakMap,
        baseGetTag = _baseGetTag,
        toSource = _toSource;

    /** `Object#toString` result references. */
    var mapTag = '[object Map]',
        objectTag$1 = '[object Object]',
        promiseTag = '[object Promise]',
        setTag = '[object Set]',
        weakMapTag = '[object WeakMap]';

    var dataViewTag = '[object DataView]';

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map$1),
        promiseCtorString = toSource(Promise$1),
        setCtorString = toSource(Set$1),
        weakMapCtorString = toSource(WeakMap$1);

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag$1 = baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((DataView && getTag$1(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
        (Map$1 && getTag$1(new Map$1) != mapTag) ||
        (Promise$1 && getTag$1(Promise$1.resolve()) != promiseTag) ||
        (Set$1 && getTag$1(new Set$1) != setTag) ||
        (WeakMap$1 && getTag$1(new WeakMap$1) != weakMapTag)) {
      getTag$1 = function(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag$1 ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag;
            case mapCtorString: return mapTag;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag;
            case weakMapCtorString: return weakMapTag;
          }
        }
        return result;
      };
    }

    var _getTag = getTag$1;

    var Stack = _Stack,
        equalArrays = _equalArrays,
        equalByTag = _equalByTag,
        equalObjects = _equalObjects,
        getTag = _getTag,
        isArray = isArray_1,
        isBuffer = isBuffer$2.exports,
        isTypedArray = isTypedArray_1;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG = 1;

    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        objectTag = '[object Object]';

    /** Used for built-in method references. */
    var objectProto = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep$1(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag : getTag(object),
          othTag = othIsArr ? arrayTag : getTag(other);

      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;

      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return (objIsArr || isTypedArray(object))
          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new Stack);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack);
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    var _baseIsEqualDeep = baseIsEqualDeep$1;

    var baseIsEqualDeep = _baseIsEqualDeep,
        isObjectLike = isObjectLike_1;

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual$1(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$1, stack);
    }

    var _baseIsEqual = baseIsEqual$1;

    var baseIsEqual = _baseIsEqual;

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }

    var isEqual_1 = isEqual;

    function createEventBus() {
        const bus = document.createElement('div');
        const on = (eventName) => new Observable(subscriber => {
            const handler = (event) => subscriber.next(event.detail);
            bus.addEventListener(eventName, handler);
            return () => bus.removeEventListener(eventName, handler);
        });
        const emit = (eventName, detail) => {
            bus.dispatchEvent(new CustomEvent(eventName, {
                detail,
            }));
        };
        return {
            on,
            emit,
        };
    }
    var BalanceRange;
    (function (BalanceRange) {
        BalanceRange["move"] = "BalanceRange.move";
    })(BalanceRange || (BalanceRange = {}));
    var Drawer$1;
    (function (Drawer) {
        Drawer["openTableProperties"] = "Drawer.openTableProperties";
        Drawer["close"] = "Drawer.close";
    })(Drawer$1 || (Drawer$1 = {}));
    var Contextmenu;
    (function (Contextmenu) {
        Contextmenu["close"] = "Contextmenu.close";
    })(Contextmenu || (Contextmenu = {}));
    var ColorPicker$1;
    (function (ColorPicker) {
        ColorPicker["close"] = "ColorPicker.close";
        ColorPicker["open"] = "ColorPicker.open";
    })(ColorPicker$1 || (ColorPicker$1 = {}));
    var ToastBar$1;
    (function (ToastBar) {
        ToastBar["add"] = "ToastBar.add";
    })(ToastBar$1 || (ToastBar$1 = {}));
    var Editor;
    (function (Editor) {
        Editor["change"] = "Editor.change";
    })(Editor || (Editor = {}));
    var Liquibase;
    (function (Liquibase) {
        Liquibase["progress"] = "Liquibase.liquibase-progress";
        Liquibase["progressEnd"] = "Liquibase.liquibase-progress-end";
    })(Liquibase || (Liquibase = {}));
    const Bus = {
        BalanceRange,
        Drawer: Drawer$1,
        Contextmenu,
        Liquibase,
        ColorPicker: ColorPicker$1,
        ToastBar: ToastBar$1,
        Editor,
    };

    /**
     * https://mariadb.com/kb/en/data-types/
     */
    const MariaDBTypes = [
        { name: 'BIGINT', primitiveType: 'long' },
        { name: 'BINARY', primitiveType: 'string' },
        { name: 'BIT', primitiveType: 'int' },
        { name: 'BLOB', primitiveType: 'lob' },
        { name: 'BOOL', primitiveType: 'boolean' },
        { name: 'BOOLEAN', primitiveType: 'boolean' },
        { name: 'CHAR', primitiveType: 'string' },
        { name: 'DATE', primitiveType: 'date' },
        { name: 'DATETIME', primitiveType: 'dateTime' },
        { name: 'DEC', primitiveType: 'decimal' },
        { name: 'DECIMAL', primitiveType: 'decimal' },
        { name: 'DOUBLE PRECISION', primitiveType: 'double' },
        { name: 'DOUBLE', primitiveType: 'double' },
        { name: 'ENUM', primitiveType: 'string' },
        { name: 'FIXED', primitiveType: 'decimal' },
        { name: 'FLOAT', primitiveType: 'float' },
        { name: 'GEOMETRY', primitiveType: 'string' },
        { name: 'GEOMETRYCOLLECTION', primitiveType: 'string' },
        { name: 'INT', primitiveType: 'int' },
        { name: 'INTEGER', primitiveType: 'int' },
        { name: 'JSON', primitiveType: 'lob' },
        { name: 'LINESTRING', primitiveType: 'string' },
        { name: 'LONGBLOB', primitiveType: 'lob' },
        { name: 'LONGTEXT', primitiveType: 'lob' },
        { name: 'MEDIUMBLOB', primitiveType: 'lob' },
        { name: 'MEDIUMINT', primitiveType: 'int' },
        { name: 'MEDIUMTEXT', primitiveType: 'lob' },
        { name: 'MULTILINESTRING', primitiveType: 'string' },
        { name: 'MULTIPOINT', primitiveType: 'string' },
        { name: 'MULTIPOLYGON', primitiveType: 'string' },
        { name: 'NUMERIC', primitiveType: 'decimal' },
        { name: 'POINT', primitiveType: 'string' },
        { name: 'POLYGON', primitiveType: 'string' },
        { name: 'REAL', primitiveType: 'double' },
        { name: 'SET', primitiveType: 'string' },
        { name: 'SMALLINT', primitiveType: 'int' },
        { name: 'TEXT', primitiveType: 'lob' },
        { name: 'TIME', primitiveType: 'time' },
        { name: 'TIMESTAMP', primitiveType: 'dateTime' },
        { name: 'TINYBLOB', primitiveType: 'lob' },
        { name: 'TINYINT', primitiveType: 'int' },
        { name: 'TINYTEXT', primitiveType: 'lob' },
        { name: 'VARBINARY', primitiveType: 'string' },
        { name: 'VARCHAR', primitiveType: 'string' },
        { name: 'YEAR', primitiveType: 'int' },
    ];

    /**
     * https://docs.microsoft.com/ko-kr/sql/t-sql/data-types/data-types-transact-sql?view=sql-server-ver15
     */
    const MSSQLTypes = [
        { name: 'bigint', primitiveType: 'long' },
        { name: 'binary', primitiveType: 'lob' },
        { name: 'bit', primitiveType: 'int' },
        { name: 'char', primitiveType: 'string' },
        { name: 'date', primitiveType: 'date' },
        { name: 'datetime', primitiveType: 'dateTime' },
        { name: 'datetime2', primitiveType: 'dateTime' },
        { name: 'datetimeoffset', primitiveType: 'dateTime' },
        { name: 'decimal', primitiveType: 'decimal' },
        { name: 'float', primitiveType: 'double' },
        { name: 'geography', primitiveType: 'string' },
        { name: 'geometry', primitiveType: 'string' },
        { name: 'image', primitiveType: 'lob' },
        { name: 'int', primitiveType: 'int' },
        { name: 'money', primitiveType: 'double' },
        { name: 'nchar', primitiveType: 'string' },
        { name: 'ntext', primitiveType: 'lob' },
        { name: 'numeric', primitiveType: 'float' },
        { name: 'nvarchar', primitiveType: 'string' },
        { name: 'real', primitiveType: 'float' },
        { name: 'smalldatetime', primitiveType: 'dateTime' },
        { name: 'smallint', primitiveType: 'int' },
        { name: 'smallmoney', primitiveType: 'float' },
        { name: 'sql_variant', primitiveType: 'string' },
        { name: 'text', primitiveType: 'lob' },
        { name: 'time', primitiveType: 'time' },
        { name: 'tinyint', primitiveType: 'int' },
        { name: 'uniqueidentifier', primitiveType: 'string' },
        { name: 'varbinary', primitiveType: 'string' },
        { name: 'varchar', primitiveType: 'string' },
        { name: 'xml', primitiveType: 'lob' },
    ];

    /**
     * https://dev.mysql.com/doc/refman/8.0/en/data-types.html
     */
    const MySQLTypes = [
        { name: 'BIGINT', primitiveType: 'long' },
        { name: 'BINARY', primitiveType: 'string' },
        { name: 'BIT', primitiveType: 'int' },
        { name: 'BLOB', primitiveType: 'lob' },
        { name: 'BOOL', primitiveType: 'boolean' },
        { name: 'BOOLEAN', primitiveType: 'boolean' },
        { name: 'CHAR', primitiveType: 'string' },
        { name: 'DATE', primitiveType: 'date' },
        { name: 'DATETIME', primitiveType: 'dateTime' },
        { name: 'DEC', primitiveType: 'decimal' },
        { name: 'DECIMAL', primitiveType: 'decimal' },
        { name: 'DOUBLE PRECISION', primitiveType: 'double' },
        { name: 'DOUBLE', primitiveType: 'double' },
        { name: 'ENUM', primitiveType: 'string' },
        { name: 'FLOAT', primitiveType: 'float' },
        { name: 'GEOMETRY', primitiveType: 'string' },
        { name: 'GEOMETRYCOLLECTION', primitiveType: 'string' },
        { name: 'INT', primitiveType: 'int' },
        { name: 'INTEGER', primitiveType: 'int' },
        { name: 'JSON', primitiveType: 'lob' },
        { name: 'LINESTRING', primitiveType: 'string' },
        { name: 'LONGBLOB', primitiveType: 'lob' },
        { name: 'LONGTEXT', primitiveType: 'lob' },
        { name: 'MEDIUMBLOB', primitiveType: 'lob' },
        { name: 'MEDIUMINT', primitiveType: 'int' },
        { name: 'MEDIUMTEXT', primitiveType: 'lob' },
        { name: 'MULTILINESTRING', primitiveType: 'string' },
        { name: 'MULTIPOINT', primitiveType: 'string' },
        { name: 'MULTIPOLYGON', primitiveType: 'string' },
        { name: 'NUMERIC', primitiveType: 'decimal' },
        { name: 'POINT', primitiveType: 'string' },
        { name: 'POLYGON', primitiveType: 'string' },
        { name: 'SET', primitiveType: 'string' },
        { name: 'SMALLINT', primitiveType: 'int' },
        { name: 'TEXT', primitiveType: 'lob' },
        { name: 'TIME', primitiveType: 'time' },
        { name: 'TIMESTAMP', primitiveType: 'dateTime' },
        { name: 'TINYBLOB', primitiveType: 'lob' },
        { name: 'TINYINT', primitiveType: 'int' },
        { name: 'TINYTEXT', primitiveType: 'lob' },
        { name: 'VARBINARY', primitiveType: 'string' },
        { name: 'VARCHAR', primitiveType: 'string' },
        { name: 'YEAR', primitiveType: 'int' },
    ];

    /**
     * https://docs.oracle.com/cd/B28359_01/server.111/b28318/datatype.htm#CNCPT012
     */
    const OracleTypes = [
        { name: 'BFILE', primitiveType: 'lob' },
        { name: 'BINARY_DOUBLE', primitiveType: 'double' },
        { name: 'BINARY_FLOAT', primitiveType: 'float' },
        { name: 'BLOB', primitiveType: 'lob' },
        { name: 'CHAR', primitiveType: 'string' },
        { name: 'CLOB', primitiveType: 'lob' },
        { name: 'DATE', primitiveType: 'date' },
        { name: 'DATETIME', primitiveType: 'dateTime' },
        { name: 'LONG RAW', primitiveType: 'lob' },
        { name: 'LONG', primitiveType: 'lob' },
        { name: 'NCHAR', primitiveType: 'string' },
        { name: 'NCLOB', primitiveType: 'lob' },
        { name: 'NUMBER', primitiveType: 'long' },
        { name: 'NVARCHAR2', primitiveType: 'string' },
        { name: 'RAW', primitiveType: 'lob' },
        { name: 'TIMESTAMP WITH LOCAL TIME ZONE', primitiveType: 'dateTime' },
        { name: 'TIMESTAMP WITH TIME ZONE', primitiveType: 'dateTime' },
        { name: 'TIMESTAMP', primitiveType: 'dateTime' },
        { name: 'UriType', primitiveType: 'string' },
        { name: 'VARCHAR', primitiveType: 'string' },
        { name: 'VARCHAR2', primitiveType: 'string' },
        { name: 'XMLType', primitiveType: 'string' },
    ];

    /**
     * https://www.postgresql.org/docs/current/datatype.html
     */
    const PostgreSQLTypes = [
        { name: 'bigint', primitiveType: 'long' },
        { name: 'bigserial', primitiveType: 'long' },
        { name: 'bit varying', primitiveType: 'int' },
        { name: 'bit', primitiveType: 'int' },
        { name: 'bool', primitiveType: 'boolean' },
        { name: 'boolean', primitiveType: 'boolean' },
        { name: 'box', primitiveType: 'string' },
        { name: 'bytea', primitiveType: 'string' },
        { name: 'char', primitiveType: 'string' },
        { name: 'character varying', primitiveType: 'string' },
        { name: 'character', primitiveType: 'string' },
        { name: 'cidr', primitiveType: 'string' },
        { name: 'circle', primitiveType: 'string' },
        { name: 'date', primitiveType: 'date' },
        { name: 'decimal', primitiveType: 'decimal' },
        { name: 'double precision', primitiveType: 'double' },
        { name: 'float4', primitiveType: 'float' },
        { name: 'float8', primitiveType: 'double' },
        { name: 'inet', primitiveType: 'string' },
        { name: 'int', primitiveType: 'int' },
        { name: 'int2', primitiveType: 'int' },
        { name: 'int4', primitiveType: 'int' },
        { name: 'int8', primitiveType: 'long' },
        { name: 'integer', primitiveType: 'int' },
        { name: 'interval', primitiveType: 'time' },
        { name: 'json', primitiveType: 'lob' },
        { name: 'jsonb', primitiveType: 'lob' },
        { name: 'line', primitiveType: 'string' },
        { name: 'lseg', primitiveType: 'string' },
        { name: 'macaddr', primitiveType: 'string' },
        { name: 'macaddr8', primitiveType: 'string' },
        { name: 'money', primitiveType: 'double' },
        { name: 'numeric', primitiveType: 'decimal' },
        { name: 'path', primitiveType: 'string' },
        { name: 'pg_lsn', primitiveType: 'int' },
        { name: 'point', primitiveType: 'string' },
        { name: 'polygon', primitiveType: 'string' },
        { name: 'real', primitiveType: 'float' },
        { name: 'serial', primitiveType: 'int' },
        { name: 'serial2', primitiveType: 'int' },
        { name: 'serial4', primitiveType: 'int' },
        { name: 'serial8', primitiveType: 'long' },
        { name: 'smallint', primitiveType: 'int' },
        { name: 'smallserial', primitiveType: 'int' },
        { name: 'text', primitiveType: 'string' },
        { name: 'time with time zone', primitiveType: 'time' },
        { name: 'time', primitiveType: 'time' },
        { name: 'timestamp with time zone', primitiveType: 'dateTime' },
        { name: 'timestamp', primitiveType: 'dateTime' },
        { name: 'timestamptz', primitiveType: 'dateTime' },
        { name: 'timetz', primitiveType: 'time' },
        { name: 'tsquery', primitiveType: 'string' },
        { name: 'tsvector', primitiveType: 'string' },
        { name: 'txid_snapshot', primitiveType: 'string' },
        { name: 'uuid', primitiveType: 'string' },
        { name: 'varbit', primitiveType: 'int' },
        { name: 'varchar', primitiveType: 'string' },
        { name: 'xml', primitiveType: 'lob' },
    ];

    /**
     * https://www.sqlite.org/datatype3.html
     */
    const SQLiteTypes = [
        { name: 'BLOB', primitiveType: 'lob' },
        { name: 'INTEGER', primitiveType: 'int' },
        { name: 'NUMERIC', primitiveType: 'decimal' },
        { name: 'REAL', primitiveType: 'double' },
        { name: 'TEXT', primitiveType: 'string' },
    ];

    const databaseHints = [
        {
            database: 'MariaDB',
            dataTypeHints: MariaDBTypes,
        },
        {
            database: 'MSSQL',
            dataTypeHints: MSSQLTypes,
        },
        {
            database: 'MySQL',
            dataTypeHints: MySQLTypes,
        },
        {
            database: 'Oracle',
            dataTypeHints: OracleTypes,
        },
        {
            database: 'PostgreSQL',
            dataTypeHints: PostgreSQLTypes,
        },
        {
            database: 'SQLite',
            dataTypeHints: SQLiteTypes,
        },
    ];

    function getPrimitiveType(dataType, database) {
        const dataTypeHints = getDataTypeHints(database);
        for (const dataTypeHint of dataTypeHints) {
            if (dataType
                .toLocaleLowerCase()
                .indexOf(dataTypeHint.name.toLocaleLowerCase()) === 0) {
                return dataTypeHint.primitiveType;
            }
        }
        return 'string';
    }
    function getDataTypeHints(database) {
        for (const data of databaseHints) {
            if (data.database === database) {
                return data.dataTypeHints;
            }
        }
        return [];
    }
    function getNameCase(name, nameCase) {
        let changeName = name;
        switch (nameCase) {
            case 'camelCase':
                changeName = camelCase_1(name);
                break;
            case 'pascalCase':
                changeName = pascalCase(name);
                break;
            case 'snakeCase':
                changeName = snakeCase_1(name);
                break;
        }
        return changeName;
    }

    const translations = [
        {
            liquibase: 'boolean',
            postgresql: 'BOOLEAN',
            unsupportedDatabase: 'BOOLEAN',
            mssql: 'BIT',
            oracle: 'NUMBER(1)',
        },
        {
            liquibase: 'tinyint',
            postgresql: 'SMALLINT',
            unsupportedDatabase: 'TINYINT',
            mssql: 'TINYINT',
            oracle: 'NUMBER(3)',
        },
        {
            liquibase: 'int',
            postgresql: 'INT',
            unsupportedDatabase: 'INT',
            mssql: 'INT',
            oracle: 'INTEGER',
        },
        {
            liquibase: 'mediumint',
            postgresql: 'MEDIUMINT',
            unsupportedDatabase: 'MEDIUMINT',
            mssql: 'INT',
            oracle: 'MEDIUMINT',
        },
        {
            liquibase: 'bigint',
            postgresql: 'BIGINT',
            unsupportedDatabase: 'BIGINT',
            mssql: 'BIGINT',
            oracle: 'NUMBER(38, 0)',
        },
        {
            liquibase: 'float',
            postgresql: 'FLOAT',
            unsupportedDatabase: 'FLOAT',
            mssql: 'FLOAT(53)',
            oracle: 'FLOAT',
        },
        {
            liquibase: 'double',
            postgresql: 'DOUBLE PRECISION',
            unsupportedDatabase: 'DOUBLE',
            mssql: 'FLOAT(53)',
            oracle: 'FLOAT(24)',
        },
        {
            liquibase: 'decimal',
            postgresql: 'DECIMAL',
            unsupportedDatabase: 'DECIMAL',
            mssql: 'DECIMAL(18, 0)',
            oracle: 'DECIMAL',
        },
        {
            liquibase: 'number',
            postgresql: 'numeric',
            unsupportedDatabase: 'NUMBER',
            mssql: 'numeric(18, 0)',
            oracle: 'NUMBER',
        },
        {
            liquibase: 'blob',
            postgresql: 'BYTEA',
            unsupportedDatabase: 'BLOB',
            mssql: 'varbinary(MAX)',
            oracle: 'BLOB',
        },
        {
            liquibase: 'function',
            postgresql: 'FUNCTION',
            unsupportedDatabase: 'FUNCTION',
            mssql: 'FUNCTION',
            oracle: 'FUNCTION',
        },
        {
            liquibase: 'UNKNOWN',
            postgresql: 'UNKNOWN',
            unsupportedDatabase: 'UNKNOWN',
            mssql: 'UNKNOWN',
            oracle: 'UNKNOWN',
        },
        {
            liquibase: 'datetime',
            postgresql: 'TIMESTAMP',
            unsupportedDatabase: 'datetime',
            mssql: 'datetime',
            oracle: 'TIMESTAMP',
        },
        {
            liquibase: 'time',
            postgresql: 'TIME',
            unsupportedDatabase: 'time',
            mssql: 'time(7)',
            oracle: 'DATE',
        },
        {
            liquibase: 'timestamp',
            postgresql: 'TIMESTAMP',
            unsupportedDatabase: 'timestamp',
            mssql: 'datetime',
            oracle: 'TIMESTAMP',
        },
        {
            liquibase: 'date',
            postgresql: 'date',
            unsupportedDatabase: 'date',
            mssql: 'date',
            oracle: 'date',
        },
        {
            liquibase: 'char',
            postgresql: 'CHAR',
            unsupportedDatabase: 'CHAR',
            mssql: 'CHAR(1)',
            oracle: 'CHAR',
        },
        {
            liquibase: 'varchar',
            postgresql: 'VARCHAR',
            unsupportedDatabase: 'VARCHAR',
            mssql: 'VARCHAR(1)',
            oracle: 'VARCHAR2',
        },
        {
            liquibase: 'nchar',
            postgresql: 'NCHAR',
            unsupportedDatabase: 'NCHAR',
            mssql: 'NCHAR(1)',
            oracle: 'NCHAR',
        },
        {
            liquibase: 'nvarchar',
            postgresql: 'VARCHAR',
            unsupportedDatabase: 'NVARCHAR',
            mssql: 'NVARCHAR(1)',
            oracle: 'NVARCHAR2',
        },
        {
            liquibase: 'clob',
            postgresql: 'TEXT',
            unsupportedDatabase: 'CLOB',
            mssql: 'VARCHAR(MAX)',
            oracle: 'CLOB',
        },
        {
            liquibase: 'currency',
            postgresql: 'DECIMAL',
            unsupportedDatabase: 'DECIMAL',
            mssql: 'MONEY',
            oracle: 'NUMBER(15, 2)',
        },
        {
            liquibase: 'uuid',
            postgresql: 'UUID',
            unsupportedDatabase: 'char(36)',
            mssql: 'UNIQUEIDENTIFIER',
            oracle: 'RAW(16)',
        },
    ];

    const supportedDialects = ['oracle', 'postgresql', 'mssql'];
    function formatNames$1(list) {
        const buf = [];
        list.forEach((v, i) => {
            buf.push(v.name);
            if (list.length !== i + 1) {
                buf.push(', ');
            }
        });
        return buf.join('');
    }
    /**
     * Translation between dialects for liquibase
     * @param dialectFrom Source dialect
     * @param dialectTo Destination dialect
     * @param value Value to be translated
     * @returns Translated string
     */
    const translate = (dialectFrom, dialectTo, value) => {
        var translation;
        value = value.trim();
        translation = findTranslation(value, dialectFrom);
        if (!translation) {
            return value;
        }
        return translation[dialectTo];
    };
    const findTranslation = (value, dialect) => {
        return translations.find(trans => trans[dialect].toLowerCase() === value.toLowerCase());
    };
    /**
     * Converts array of XML nodes to string
     * @param xmlNodes Array of XMLNodes that will be converted to string
     * @returns XML in string form
     */
    const createXMLString = (xmlNodes) => {
        let xmlSerializer = new XMLSerializer();
        var parser = new DOMParser();
        var root = parser.parseFromString('</>', 'text/xml');
        var stringBuffer = [];
        xmlNodes.forEach(node => {
            stringBuffer.push(xmlSerializer.serializeToString(createNode(node, root)));
        });
        return stringBuffer.join('\n');
    };
    /**
     * Recursive function, that traverses all nodes
     * @param xmlNode One node that will be converted to string
     * @param root Root html element used to create elements
     * @returns Node converted to XML in string form
     */
    const createNode = (xmlNode, root) => {
        let element = root.createElement(xmlNode.name);
        xmlNode.attributes.forEach(attr => {
            element.setAttribute(attr.name, attr.value);
        });
        xmlNode.children.forEach(child => {
            if (child.name)
                element.insertAdjacentElement('beforeend', createNode(child, root));
        });
        return element;
    };
    class XMLNode {
        constructor(name, attributes = [], children = []) {
            this.name = name;
            this.attributes = attributes;
            this.children = children;
        }
        addAttribute(...attributes) {
            attributes.forEach(attr => {
                this.attributes.push({ name: attr.name, value: attr.value.trim() });
            });
        }
        addChildren(...children) {
            this.children.push(...children);
        }
    }
    const generateSeqName = (tableName, columnName) => {
        return `${tableName}_${columnName}_seq`.toLowerCase();
    };
    const getIdChangeSet = (author) => {
        return author.id.replace(/\\/g, '/').split('/').pop() || '';
    };
    const changeSetAttributes = ({ author, dialect, suffix, }) => {
        const attr = [
            {
                name: 'id',
                value: `${getIdChangeSet(author)}${suffix ? `-${suffix}` : ''}`,
            },
            { name: 'author', value: author.name },
        ];
        if (dialect)
            attr.push({ name: 'dbms', value: dialect });
        return attr;
    };
    const mapppingTranslationsDatabase = {
        postgresql: 'PostgreSQL',
        mssql: 'MSSQL',
        oracle: 'Oracle',
        liquibase: 'MySQL',
        unsupportedDatabase: 'MySQL',
    };

    const TABLE_PADDING$3 = (SIZE_TABLE_PADDING + SIZE_TABLE_BORDER) * 2;
    const PATH_HEIGHT = 30;
    const PATH_END_HEIGHT = PATH_HEIGHT + 20;
    const PATH_LINE_HEIGHT = 35;
    const LINE_SIZE = 10;
    const LINE_HEIGHT = 16;
    const CIRCLE_HEIGHT = 26;
    const directions = ['top', 'bottom', 'left', 'right'];
    function getCoordinate(table) {
        const width = table.width() + TABLE_PADDING$3;
        const height = table.height() + TABLE_PADDING$3;
        const ui = table.ui;
        return {
            width,
            height,
            top: {
                x: ui.left + width / 2,
                y: ui.top,
            },
            bottom: {
                x: ui.left + width / 2,
                y: ui.top + height,
            },
            left: {
                x: ui.left,
                y: ui.top + height / 2,
            },
            right: {
                x: ui.left + width,
                y: ui.top + height / 2,
            },
            lt: {
                x: ui.left,
                y: ui.top,
            },
            rt: {
                x: ui.left + width,
                y: ui.top,
            },
            lb: {
                x: ui.left,
                y: ui.top + height,
            },
            rb: {
                x: ui.left + width,
                y: ui.top + height,
            },
        };
    }
    const getDistance = (a, b) => Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2);
    const directionFilter = (key) => directions.includes(key);
    function getDrawDirection(draw) {
        let direction = 'bottom';
        if (!draw.start)
            return direction;
        const start = getCoordinate(draw.start.table);
        let min = getDistance(start.bottom, draw.end);
        draw.start.x = start.bottom.x;
        draw.start.y = start.bottom.y;
        Object.keys(start)
            .filter(directionFilter)
            .forEach(key => {
            const k = key;
            const temp = getDistance(start[k], draw.end);
            if (min <= temp)
                return;
            min = temp;
            direction = k;
            if (!draw.start)
                return;
            draw.start.x = start[k].x;
            draw.start.y = start[k].y;
        });
        return direction;
    }
    function getDrawPath(direction, draw) {
        const line = {
            start: {
                x1: 0,
                y1: 0,
                x2: 0,
                y2: 0,
            },
        };
        const path = {
            M: { x: 0, y: 0 },
            L: { x: 0, y: 0 },
            Q: { x: 0, y: 0 },
            d() {
                return `M ${this.M.x} ${this.M.y} L ${this.L.x} ${this.L.y}`;
            },
        };
        if (draw.start) {
            line.start.x1 = draw.start.x;
            line.start.y1 = draw.start.y;
            line.start.x2 = draw.start.x;
            line.start.y2 = draw.start.y;
            let change = 1;
            if (direction === 'left' || direction === 'right') {
                if (direction === 'left') {
                    change *= -1;
                }
                line.start.x2 = draw.start.x + change * PATH_END_HEIGHT;
                line.start.x1 += change * PATH_LINE_HEIGHT;
                path.M.x = line.start.x2;
                path.M.y = draw.start.y;
            }
            else if (direction === 'top' || direction === 'bottom') {
                if (direction === 'top') {
                    change *= -1;
                }
                line.start.y2 = draw.start.y + change * PATH_END_HEIGHT;
                line.start.y1 += change * PATH_LINE_HEIGHT;
                path.M.x = draw.start.x;
                path.M.y = line.start.y2;
            }
        }
        path.L.x = draw.end.x;
        path.L.y = draw.end.y;
        return {
            path,
            line,
        };
    }
    function getDrawLine(direction, draw) {
        const line = {
            start: {
                base: {
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: 0,
                },
                base2: {
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: 0,
                },
                center: {
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: 0,
                },
                center2: {
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: 0,
                },
            },
        };
        if (!draw.start)
            return line;
        line.start.base.x1 =
            line.start.base2.x1 =
                line.start.center.x1 =
                    line.start.center2.x1 =
                        draw.start.x;
        line.start.base.x2 =
            line.start.base2.x2 =
                line.start.center.x2 =
                    line.start.center2.x2 =
                        draw.start.x;
        line.start.base.y1 =
            line.start.base2.y1 =
                line.start.center.y1 =
                    line.start.center2.y1 =
                        draw.start.y;
        line.start.base.y2 =
            line.start.base2.y2 =
                line.start.center.y2 =
                    line.start.center2.y2 =
                        draw.start.y;
        let change = 1;
        if (direction === 'left' || direction === 'right') {
            if (direction === 'left') {
                change *= -1;
            }
            line.start.base.x1 = line.start.base.x2 += change * LINE_HEIGHT;
            line.start.base2.x1 = line.start.base2.x2 +=
                change * (LINE_SIZE + LINE_HEIGHT);
            line.start.center.x1 = line.start.base.x1;
            line.start.base.y1 -= LINE_SIZE;
            line.start.base.y2 += LINE_SIZE;
            line.start.base2.y1 -= LINE_SIZE;
            line.start.base2.y2 += LINE_SIZE;
            line.start.center2.x1 += change * (LINE_HEIGHT + LINE_HEIGHT + 3);
        }
        else if (direction === 'top' || direction === 'bottom') {
            if (direction === 'top') {
                change *= -1;
            }
            line.start.base.y1 = line.start.base.y2 += change * LINE_HEIGHT;
            line.start.base2.y1 = line.start.base2.y2 +=
                change * (LINE_SIZE + LINE_HEIGHT);
            line.start.center.y1 = line.start.base.y1;
            line.start.base.x1 -= LINE_SIZE;
            line.start.base.x2 += LINE_SIZE;
            line.start.base2.x1 -= LINE_SIZE;
            line.start.base2.x2 += LINE_SIZE;
            line.start.center2.y1 += change * (LINE_HEIGHT + LINE_HEIGHT + 3);
        }
        return line;
    }
    function getDraw(draw) {
        const drawPath = {
            path: {
                path: {
                    M: { x: 0, y: 0 },
                    L: { x: 0, y: 0 },
                    Q: { x: 0, y: 0 },
                    d() {
                        return `M ${this.M.x} ${this.M.y} L ${this.L.x} ${this.L.y}`;
                    },
                },
                line: {
                    start: {
                        x1: 0,
                        y1: 0,
                        x2: 0,
                        y2: 0,
                    },
                },
            },
            line: {
                start: {
                    base: {
                        x1: 0,
                        y1: 0,
                        x2: 0,
                        y2: 0,
                    },
                    base2: {
                        x1: 0,
                        y1: 0,
                        x2: 0,
                        y2: 0,
                    },
                    center: {
                        x1: 0,
                        y1: 0,
                        x2: 0,
                        y2: 0,
                    },
                    center2: {
                        x1: 0,
                        y1: 0,
                        x2: 0,
                        y2: 0,
                    },
                },
            },
        };
        if (!draw.start)
            return drawPath;
        const direction = getDrawDirection(draw);
        drawPath.path = getDrawPath(direction, draw);
        drawPath.line = getDrawLine(direction, draw);
        return drawPath;
    }
    const getRelationshipGraph = (graphs, table) => graphs.find(graph => graph.table.id === table.id);
    function getDirection(start, end, relationship) {
        const direction = {
            start: 'bottom',
            end: 'bottom',
        };
        let min = getDistance(start.bottom, end.bottom);
        relationship.start.x = start.bottom.x;
        relationship.start.y = start.bottom.y;
        relationship.end.x = end.bottom.x;
        relationship.end.y = end.bottom.y;
        Object.keys(start)
            .filter(directionFilter)
            .forEach(key => {
            Object.keys(end)
                .filter(directionFilter)
                .forEach(key2 => {
                const k = key;
                const k2 = key2;
                const temp = getDistance(start[k], end[k2]);
                if (min <= temp)
                    return;
                min = temp;
                direction.start = k;
                direction.end = k2;
                relationship.start.x = start[k].x;
                relationship.start.y = start[k].y;
                relationship.end.x = end[k2].x;
                relationship.end.y = end[k2].y;
            });
        });
        return direction;
    }
    function relationshipOverlayPoint(direction, graph) {
        const len = graph[direction].length;
        const margin = {
            x: graph.coordinate.width / len,
            y: graph.coordinate.height / len,
        };
        const padding = {
            x: margin.x / 2,
            y: margin.y / 2,
        };
        const xArray = [];
        const yArray = [];
        if (direction === 'left' || direction === 'right') {
            let sum = graph.coordinate.lt.y - padding.y;
            for (let i = 0; i < len; i++) {
                sum += margin.y;
                yArray.push(sum);
            }
        }
        else if (direction === 'top' || direction === 'bottom') {
            let sum = graph.coordinate.lt.x - padding.x;
            for (let i = 0; i < len; i++) {
                sum += margin.x;
                xArray.push(sum);
            }
        }
        return {
            xArray,
            yArray,
        };
    }
    const sortDistance = (a, b) => a.distance - b.distance;
    function relationshipOverlayOrder(direction, table, relationships) {
        const startPoints = [];
        const endPoints = [];
        relationships.forEach(relationship => {
            if (relationship.start.tableId === relationship.end.tableId) {
                // self relationship
                if (direction === 'top') {
                    startPoints.push(relationship.start);
                    endPoints.push(relationship.end);
                }
                else if (direction === 'right') {
                    startPoints.push(relationship.end);
                    endPoints.push(relationship.start);
                }
            }
            else if (relationship.start.tableId === table.id) {
                startPoints.push(relationship.start);
                endPoints.push(relationship.end);
            }
            else {
                startPoints.push(relationship.end);
                endPoints.push(relationship.start);
            }
        });
        const start = {
            x: startPoints[0].x,
            y: startPoints[0].y,
        };
        const distances = [];
        endPoints.forEach((endPoint, index) => {
            distances.push({
                start: startPoints[index],
                end: endPoints[index],
                distance: getDistance(start, endPoint),
            });
        });
        distances.sort(sortDistance);
        return distances;
    }
    function relationshipOverlaySort(direction, graph) {
        const point = relationshipOverlayPoint(direction, graph);
        let distances = relationshipOverlayOrder(direction, graph.table, graph[direction]);
        // if (distances.length > 1) {
        //   if (!relationshipOverlayFirstCheck(direction, distances[0], point)) {
        //     distances = distances.reverse();
        //   }
        // }
        if (direction === 'left' || direction === 'right') {
            point.yArray.forEach((y, index) => {
                distances[index].start.y = y;
            });
        }
        else if (direction === 'top' || direction === 'bottom') {
            point.xArray.forEach((x, index) => {
                distances[index].start.x = x;
            });
        }
    }
    function relationshipSort(tables, relationships) {
        const graphs = [];
        relationships.forEach(relationship => {
            if (!relationship.visible)
                return;
            const tableStart = getData(tables, relationship.start.tableId);
            const tableEnd = getData(tables, relationship.end.tableId);
            if (tableStart && tableEnd) {
                if (relationship.start.tableId === relationship.end.tableId) {
                    relationship.start.direction = 'top';
                    relationship.end.direction = 'right';
                    const graph = getRelationshipGraph(graphs, tableStart);
                    if (graph) {
                        relationship.start.x = graph.coordinate.rt.x - 20;
                        relationship.start.y = graph.coordinate.rt.y;
                        relationship.end.x = graph.coordinate.rt.x;
                        relationship.end.y = graph.coordinate.rt.y + 20;
                        graph.top.push(relationship);
                        graph.right.push(relationship);
                    }
                    else {
                        const coordinate = getCoordinate(tableStart);
                        relationship.start.x = coordinate.rt.x - 20;
                        relationship.start.y = coordinate.rt.y;
                        relationship.end.x = coordinate.rt.x;
                        relationship.end.y = coordinate.rt.y + 20;
                        graphs.push({
                            table: tableStart,
                            coordinate,
                            top: [relationship],
                            bottom: [],
                            left: [],
                            right: [relationship],
                        });
                    }
                }
                else {
                    const coordinateStart = getCoordinate(tableStart);
                    const coordinateEnd = getCoordinate(tableEnd);
                    const direction = getDirection(coordinateStart, coordinateEnd, relationship);
                    const graphStart = getRelationshipGraph(graphs, tableStart);
                    const graphEnd = getRelationshipGraph(graphs, tableEnd);
                    relationship.start.direction = direction.start;
                    relationship.end.direction = direction.end;
                    if (graphStart) {
                        graphStart[direction.start].push(relationship);
                    }
                    else {
                        const graph = {
                            table: tableStart,
                            coordinate: coordinateStart,
                            top: [],
                            bottom: [],
                            left: [],
                            right: [],
                        };
                        graph[direction.start].push(relationship);
                        graphs.push(graph);
                    }
                    if (graphEnd) {
                        graphEnd[direction.end].push(relationship);
                    }
                    else {
                        const graph = {
                            table: tableEnd,
                            coordinate: coordinateEnd,
                            top: [],
                            bottom: [],
                            left: [],
                            right: [],
                        };
                        graph[direction.end].push(relationship);
                        graphs.push(graph);
                    }
                }
            }
        });
        graphs.forEach(graph => {
            directions.forEach(value => {
                const direction = value;
                const len = graph[direction].length;
                if (len < 2)
                    return;
                relationshipOverlaySort(direction, graph);
            });
        });
    }
    function getPath(start, end) {
        const line = {
            start: {
                x1: start.x,
                y1: start.y,
                x2: start.x,
                y2: start.y,
            },
            end: {
                x1: end.x,
                y1: end.y,
                x2: end.x,
                y2: end.y,
            },
        };
        const path = {
            M: { x: 0, y: 0 },
            L: { x: 0, y: 0 },
            Q: { x: 0, y: 0 },
            d() {
                return `M ${this.M.x} ${this.M.y} L ${this.L.x} ${this.L.y}`;
            },
        };
        let change = 1;
        if (start.direction === 'left' || start.direction === 'right') {
            if (start.direction === 'left') {
                change *= -1;
            }
            line.start.x2 = start.x + change * PATH_END_HEIGHT;
            line.start.x1 += change * PATH_LINE_HEIGHT;
            path.M.x = line.start.x2;
            path.M.y = start.y;
        }
        else if (start.direction === 'top' || start.direction === 'bottom') {
            if (start.direction === 'top') {
                change *= -1;
            }
            line.start.y2 = start.y + change * PATH_END_HEIGHT;
            line.start.y1 += change * PATH_LINE_HEIGHT;
            path.M.x = start.x;
            path.M.y = line.start.y2;
        }
        change = 1;
        if (end.direction === 'left' || end.direction === 'right') {
            if (end.direction === 'left') {
                change *= -1;
            }
            line.end.x2 = end.x + change * PATH_END_HEIGHT;
            line.end.x1 += change * PATH_LINE_HEIGHT;
            path.L.x = line.end.x2;
            path.L.y = end.y;
        }
        else if (end.direction === 'top' || end.direction === 'bottom') {
            if (end.direction === 'top') {
                change *= -1;
            }
            line.end.y2 = end.y + change * PATH_END_HEIGHT;
            line.end.y1 += change * PATH_LINE_HEIGHT;
            path.L.x = end.x;
            path.L.y = line.end.y2;
        }
        return {
            line,
            path,
        };
    }
    function getLine(start, end) {
        const line = {
            start: {
                base: {
                    x1: start.x,
                    y1: start.y,
                    x2: start.x,
                    y2: start.y,
                },
                base2: {
                    x1: start.x,
                    y1: start.y,
                    x2: start.x,
                    y2: start.y,
                },
                center: {
                    x1: start.x,
                    y1: start.y,
                    x2: start.x,
                    y2: start.y,
                },
                center2: {
                    x1: start.x,
                    y1: start.y,
                    x2: start.x,
                    y2: start.y,
                },
            },
            end: {
                base: {
                    x1: end.x,
                    y1: end.y,
                    x2: end.x,
                    y2: end.y,
                },
                base2: {
                    x1: end.x,
                    y1: end.y,
                    x2: end.x,
                    y2: end.y,
                },
                left: {
                    x1: end.x,
                    y1: end.y,
                    x2: end.x,
                    y2: end.y,
                },
                center: {
                    x1: end.x,
                    y1: end.y,
                    x2: end.x,
                    y2: end.y,
                },
                center2: {
                    x1: end.x,
                    y1: end.y,
                    x2: end.x,
                    y2: end.y,
                },
                right: {
                    x1: end.x,
                    y1: end.y,
                    x2: end.x,
                    y2: end.y,
                },
            },
        };
        const circle = {
            cx: end.x,
            cy: end.y,
        };
        const startCircle = {
            cx: start.x,
            cy: start.y,
        };
        let change = 1;
        if (start.direction === 'left' || start.direction === 'right') {
            if (start.direction === 'left') {
                change *= -1;
            }
            line.start.base.x1 = line.start.base.x2 += change * LINE_HEIGHT;
            line.start.base2.x1 = line.start.base2.x2 +=
                change * (LINE_SIZE + LINE_HEIGHT);
            line.start.center.x1 = line.start.base.x1;
            line.start.base.y1 -= LINE_SIZE;
            line.start.base.y2 += LINE_SIZE;
            line.start.base2.y1 -= LINE_SIZE;
            line.start.base2.y2 += LINE_SIZE;
            line.start.center2.x1 += change * (LINE_HEIGHT + LINE_HEIGHT + 3);
            startCircle.cx += change * CIRCLE_HEIGHT;
        }
        else if (start.direction === 'top' || start.direction === 'bottom') {
            if (start.direction === 'top') {
                change *= -1;
            }
            line.start.base.y1 = line.start.base.y2 += change * LINE_HEIGHT;
            line.start.base2.y1 = line.start.base2.y2 +=
                change * (LINE_SIZE + LINE_HEIGHT);
            line.start.center.y1 = line.start.base.y1;
            line.start.base.x1 -= LINE_SIZE;
            line.start.base.x2 += LINE_SIZE;
            line.start.base2.x1 -= LINE_SIZE;
            line.start.base2.x2 += LINE_SIZE;
            line.start.center2.y1 += change * (LINE_HEIGHT + LINE_HEIGHT + 3);
            startCircle.cy += change * CIRCLE_HEIGHT;
        }
        change = 1;
        if (end.direction === 'left' || end.direction === 'right') {
            if (end.direction === 'left') {
                change *= -1;
            }
            line.end.base.x1 = line.end.base.x2 += change * LINE_HEIGHT;
            line.end.base2.x1 = line.end.base2.x2 += change * (LINE_SIZE + LINE_HEIGHT);
            line.end.center.x1 =
                line.end.left.x1 =
                    line.end.right.x1 =
                        line.end.base.x1;
            line.end.base.y1 -= LINE_SIZE;
            line.end.base.y2 += LINE_SIZE;
            line.end.base2.y1 -= LINE_SIZE;
            line.end.base2.y2 += LINE_SIZE;
            line.end.left.y2 += LINE_SIZE;
            line.end.right.y2 -= LINE_SIZE;
            line.end.center2.x1 += change * (LINE_HEIGHT + LINE_HEIGHT + 3);
            circle.cx += change * CIRCLE_HEIGHT;
        }
        else if (end.direction === 'top' || end.direction === 'bottom') {
            if (end.direction === 'top') {
                change *= -1;
            }
            line.end.base.y1 = line.end.base.y2 += change * LINE_HEIGHT;
            line.end.base2.y1 = line.end.base2.y2 += change * (LINE_SIZE + LINE_HEIGHT);
            line.end.center.y1 =
                line.end.left.y1 =
                    line.end.right.y1 =
                        line.end.base.y1;
            line.end.base.x1 -= LINE_SIZE;
            line.end.base.x2 += LINE_SIZE;
            line.end.base2.x1 -= LINE_SIZE;
            line.end.base2.x2 += LINE_SIZE;
            line.end.left.x2 += LINE_SIZE;
            line.end.right.x2 -= LINE_SIZE;
            line.end.center2.y1 += change * (LINE_HEIGHT + LINE_HEIGHT + 3);
            circle.cy += change * CIRCLE_HEIGHT;
        }
        return {
            line,
            circle,
            startCircle,
        };
    }
    function getRelationshipPath(relationship) {
        return {
            path: getPath(relationship.start, relationship.end),
            line: getLine(relationship.start, relationship.end),
        };
    }

    function orderByNameASC(tables) {
        return [...tables].sort((a, b) => {
            const nameA = a.name.toLowerCase();
            const nameB = b.name.toLowerCase();
            if (nameA < nameB) {
                return -1;
            }
            else if (nameA > nameB) {
                return 1;
            }
            return 0;
        });
    }
    function orderByRelationship(tables, relationships) {
        const firstTables = [];
        const reshapeTables = [];
        const sortTables = [];
        tables.forEach(table => {
            const endRelationships = relationships
                .filter(relationship => relationship.end.tableId === table.id)
                .map(relationship => relationship.start.tableId);
            if (endRelationships.length === 0) {
                firstTables.push(table);
            }
            else {
                reshapeTables.push(table);
                sortTables.push(table);
            }
        });
        reshapeTables.forEach(table => {
            const firstIndex = firstTableIndex(sortTables, relationships
                .filter(relationship => relationship.start.tableId === table.id)
                .map(relationship => relationship.end.tableId));
            const currentIndex = getIndex(sortTables, table.id);
            if (currentIndex !== -1) {
                sortTables.splice(currentIndex, 1);
            }
            sortTables.splice(firstIndex, 0, table);
        });
        return [...firstTables, ...sortTables];
    }
    function firstTableIndex(tables, tableIds) {
        let index = tables.length - 1;
        for (let i = 0; i < tables.length; i++) {
            const id = tables[i].id;
            if (tableIds.includes(id)) {
                index = i;
                break;
            }
        }
        return index;
    }
    function recalculatingTableWidth(tables, helper) {
        tables.forEach(table => {
            table.ui.widthName = widthBalanceRange(helper.getTextWidth(table.name));
            table.ui.widthComment = commentWidthBalanceRange(helper.getTextWidth(table.comment));
            table.columns.forEach(column => {
                column.ui.widthName = widthBalanceRange(helper.getTextWidth(column.name));
                column.ui.widthDataType = widthBalanceRange(helper.getTextWidth(column.dataType));
                column.ui.widthDefault = widthBalanceRange(helper.getTextWidth(column.default));
                column.ui.widthComment = commentWidthBalanceRange(helper.getTextWidth(column.comment));
            });
        });
    }

    const xmlns = 'http://www.liquibase.org/xml/ns/dbchangelog';
    const xmlnsxsi = 'http://www.w3.org/2001/XMLSchema-instance';
    const xsiSchemaLocation = 'http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.0.xsd';
    /**
     * Creates Liquibase XML file with export (*only supports source dialect `PostgreSQL` and creates changeSet in `oracle`, `mssql` and `postgresql`)
     */
    function createLiquibase(context, id, name) {
        const currentDatabase = context.store.canvasState.database;
        var changeSets;
        switch (currentDatabase) {
            case 'PostgreSQL':
                const author = {
                    id: id.replace(/\.xml$/g, ''),
                    name: name,
                };
                changeSets = createXMLPostgreOracleMSS(context, author);
                break;
            default:
                alert(`Export from ${currentDatabase} dialect not supported, please use PostgreSQL`);
                return '';
        }
        return [
            `<?xml version="1.0" encoding="UTF-8"?>`,
            `<databaseChangeLog xmlns="${xmlns}" xmlns:xsi="${xmlnsxsi}" xsi:schemaLocation="${xsiSchemaLocation}">`,
            createXMLString(changeSets),
            `</databaseChangeLog>`,
        ].join('\n');
    }
    const createXMLPostgreOracleMSS = (context, author) => {
        const { snapshots, store } = context;
        const { tableState, relationshipState } = store;
        // check if no previous snapshots (if size==1 --> first snapshot is the current state)
        if (snapshots.length <= 1) {
            return [
                createSequences(tableState, author),
                ...supportedDialects.map(dbName => createChangeSet({
                    dialect: dbName,
                    tableState,
                    relationshipState,
                    author,
                })),
            ];
        }
        /**
         * Latest change
         */
        function mostRecentDiff() {
            var _a, _b;
            var oldSnap = snapshots[snapshots.length - 1];
            var newSnap = snapshots[snapshots.length - 1];
            for (let i = snapshots.length - 1; i > 0; i--) {
                if (((_a = snapshots[i].metadata) === null || _a === void 0 ? void 0 : _a.type) === 'user' ||
                    ((_b = snapshots[i].metadata) === null || _b === void 0 ? void 0 : _b.type) === 'before-export') {
                    newSnap = snapshots[i];
                    oldSnap = snapshots[i - 1];
                    break;
                }
            }
            return calculateDiff(oldSnap, newSnap);
        }
        /**
         * Original file that was imported
         */
        function originalFileImport() {
            var _a, _b, _c;
            const snapsWithStatements = [];
            for (let i = snapshots.length - 1; i >= 0; i--) {
                if (((_a = snapshots[i].metadata) === null || _a === void 0 ? void 0 : _a.type) === 'before-import' &&
                    ((_b = snapshots[i].metadata) === null || _b === void 0 ? void 0 : _b.filename.replace(/\.xml$/g, '').toLowerCase()) ===
                        author.id.toLowerCase()) {
                    for (let j = i; j >= 0; j--) {
                        if (((_c = snapshots[j].metadata) === null || _c === void 0 ? void 0 : _c.filename.replace(/\.xml$/g, '').toLowerCase()) !== author.id.toLowerCase()) {
                            break;
                        }
                        snapsWithStatements.push(snapshots[j]);
                    }
                    break;
                }
            }
            const historicalDiffs = [];
            for (let i = 0; i < snapsWithStatements.length; i++) {
                historicalDiffs.push(statementsToDiff(snapsWithStatements[i], context));
            }
            return historicalDiffs;
        }
        /**
         * Files that were changed and snapshot changes are only stored in memory
         */
        function updatedFileImport() {
            var _a, _b, _c, _d;
            const diffs = [];
            for (let i = snapshots.length - 1; i >= 0; i--) {
                if (((_a = snapshots[i].metadata) === null || _a === void 0 ? void 0 : _a.type) === 'before-export' &&
                    ((_c = (_b = snapshots[i + 1]) === null || _b === void 0 ? void 0 : _b.metadata) === null || _c === void 0 ? void 0 : _c.type) === 'after-export' &&
                    ((_d = snapshots[i].metadata) === null || _d === void 0 ? void 0 : _d.filename.replace(/\.xml$/g, '').toLowerCase()) ===
                        author.id.toLowerCase()) {
                    diffs.push(calculateDiff(snapshots[i - 1], snapshots[i]));
                }
            }
            return diffs;
        }
        return createTableDiff({
            author,
            diffs: mergeDiffs(mostRecentDiff(), ...updatedFileImport(), ...originalFileImport()),
        });
    };
    function generateChangeSetSequence(author) {
        return new XMLNode('changeSet', changeSetAttributes({ author, suffix: 'common-sequences' }), [generatePreConditions()]);
    }
    function generatePreConditions() {
        return new XMLNode('preConditions', [{ name: 'onFail', value: 'MARK_RAN' }], [
            new XMLNode('or', [], supportedDialects.map(dbName => new XMLNode('dbms', [{ name: 'type', value: dbName }]))),
        ]);
    }
    function createSequence(tableName, columnName) {
        return new XMLNode('createSequence', [
            { name: 'sequenceName', value: generateSeqName(tableName, columnName) },
            { name: 'startValue', value: '1' },
        ]);
    }
    function dropSequence(tableName, columnName) {
        return new XMLNode('dropSequence', [
            { name: 'sequenceName', value: generateSeqName(tableName, columnName) },
        ]);
    }
    function createSequences(tableState, author) {
        var changeSet = generateChangeSetSequence(author);
        tableState.tables.forEach(table => {
            table.columns.forEach(column => {
                if (column.option.autoIncrement) {
                    changeSet.addChildren(createSequence(table.name, column.name));
                }
            });
        });
        return changeSet;
    }
    const createTableDiff = ({ author, diffs, }) => {
        var changeSets = [];
        var changeSetSequences = generateChangeSetSequence(author);
        var changeSetModifyPG = new XMLNode('changeSet', changeSetAttributes({ author, dialect: 'postgresql', suffix: 'postgresql' }));
        var changeSetModifyOracle = new XMLNode('changeSet', changeSetAttributes({ author, dialect: 'oracle', suffix: 'oracle' }));
        var changeSetModifyMssql = new XMLNode('changeSet', changeSetAttributes({ author, dialect: 'mssql', suffix: 'mssql' }));
        var changeSetCommon = new XMLNode('changeSet', changeSetAttributes({ author, suffix: 'common' }));
        let columnsToAdd = new Map();
        diffs.forEach(diff => {
            // add table
            if (diff.type === 'table' && diff.changes === 'add') {
                const newTable = diff.newTable;
                changeSetSequences.addChildren(...newTable.columns
                    .filter(col => col.option.autoIncrement)
                    .map(col => createSequence(newTable.name, col.name)));
                changeSetModifyPG.addChildren(createTable$1({ table: newTable, dialect: 'postgresql' }));
                changeSetModifyOracle.addChildren(createTable$1({ table: newTable, dialect: 'oracle' }));
                changeSetModifyMssql.addChildren(createTable$1({ table: newTable, dialect: 'mssql' }));
            }
            // drop table
            else if (diff.type === 'table' && diff.changes === 'remove') {
                changeSetCommon.addChildren(dropTable(diff.oldTable));
            }
            // rename table
            else if (diff.type === 'table' && diff.changes === 'modify') {
                if (diff.oldTable.name !== diff.newTable.name) {
                    changeSetCommon.addChildren(renameTable(diff.oldTable, diff.newTable));
                }
            }
            // add column
            else if (diff.type === 'column' && diff.changes === 'add') {
                const table = diff.table;
                columnsToAdd.set(table, [
                    ...(columnsToAdd.get(table) || []),
                    diff.newColumn,
                ]);
            }
            // drop column
            else if (diff.type === 'column' && diff.changes === 'remove') {
                changeSetCommon.addChildren(dropColumn(diff.table, diff.oldColumn));
            }
            // add index
            else if (diff.type === 'index' && diff.changes === 'add') {
                changeSetCommon.addChildren(createIndex$1({ table: diff.table, index: diff.newIndex }));
            }
            // drop index
            else if (diff.type === 'index' && diff.changes === 'remove') {
                changeSetCommon.addChildren(dropIndex(diff.table, diff.oldIndex));
            }
            // add FK
            else if (diff.type === 'relationship' && diff.changes === 'add') {
                changeSetCommon.addChildren(addForeignKeyConstraint({
                    startTable: diff.startTable,
                    endTable: diff.endTable,
                    relationship: diff.newRelationship,
                }));
            }
            // drop FK
            else if (diff.type === 'relationship' && diff.changes === 'remove') {
                changeSetCommon.addChildren(dropForeignKeyConstraint(diff.table, diff.oldRelationship));
            }
            // modify column
            else if (diff.type === 'column' && diff.changes === 'modify') {
                const { oldColumn, newColumn, table } = diff;
                // name was changed
                if (oldColumn.name !== newColumn.name) {
                    changeSetCommon.addChildren(renameColumn(table, newColumn, oldColumn));
                }
                // auto increment changed
                if (oldColumn.option.autoIncrement !== newColumn.option.autoIncrement) {
                    if (newColumn.option.autoIncrement === true) {
                        changeSetSequences.addChildren(createSequence(table.name, newColumn.name));
                    }
                    else {
                        changeSetSequences.addChildren(dropSequence(table.name, newColumn.name));
                    }
                }
                // primary key changed
                if (oldColumn.option.primaryKey !== newColumn.option.primaryKey) {
                    if (newColumn.option.primaryKey === true) {
                        changeSetCommon.addChildren(addPrimaryKey(table, [newColumn]));
                    }
                    else {
                        changeSetCommon.addChildren(dropPrimaryKey(table));
                    }
                }
                // unique changed
                if (oldColumn.option.unique !== newColumn.option.unique) {
                    if (newColumn.option.unique === true) {
                        changeSetCommon.addChildren(addUniqueConstraint(table, [newColumn]));
                    }
                    else {
                        changeSetCommon.addChildren(dropUniqueConstraint(table));
                    }
                }
                // datatype was changed
                if (oldColumn.dataType !== newColumn.dataType) {
                    changeSetModifyPG.addChildren(modifyDataType(table, newColumn, 'postgresql'));
                    changeSetModifyOracle.addChildren(modifyDataType(table, newColumn, 'oracle'));
                    changeSetModifyMssql.addChildren(modifyDataType(table, newColumn, 'mssql'));
                }
            }
        });
        columnsToAdd.forEach((colums, table) => {
            changeSetModifyPG.addChildren(addColumn(table, colums, 'postgresql'));
            changeSetModifyOracle.addChildren(addColumn(table, colums, 'oracle'));
            changeSetModifyMssql.addChildren(addColumn(table, colums, 'mssql'));
        });
        // sequences - (minus) first child is always preconditions
        if (changeSetSequences.children.length > 1) {
            changeSets.push(changeSetSequences);
        }
        // if modification
        if (changeSetModifyPG.children.length) {
            changeSets.push(changeSetModifyPG);
            changeSets.push(changeSetModifyOracle);
            changeSets.push(changeSetModifyMssql);
        }
        // if common
        if (changeSetCommon.children.length) {
            changeSets.push(changeSetCommon);
        }
        return changeSets;
    };
    const createChangeSet = ({ dialect, tableState, relationshipState, author, }) => {
        var changeSet = new XMLNode('changeSet');
        const tables = orderByNameASC(tableState.tables);
        const relationships = relationshipState.relationships;
        const indexes = tableState.indexes;
        changeSet.addAttribute(...changeSetAttributes({ author, dialect, suffix: dialect }));
        tables.forEach(table => {
            changeSet.addChildren(createTable$1({
                table,
                dialect,
            }));
        });
        relationships.forEach(relationship => {
            const startTable = getData(tables, relationship.start.tableId);
            const endTable = getData(tables, relationship.end.tableId);
            if (startTable && endTable)
                changeSet.addChildren(addForeignKeyConstraint({
                    startTable,
                    endTable,
                    relationship,
                }));
        });
        indexes.forEach(index => {
            const table = getData(tables, index.tableId);
            if (table)
                changeSet.addChildren(createIndex$1({
                    table,
                    index,
                }));
        });
        return changeSet;
    };
    const createTable$1 = ({ table, dialect, }) => {
        var createTable = new XMLNode('createTable');
        createTable.addAttribute({ name: 'tableName', value: table.name });
        if (table.comment)
            createTable.addAttribute({ name: 'remarks', value: table.comment });
        table.columns.forEach((column, i) => {
            createTable.addChildren(formatColumn$d({
                table,
                column,
                dialect,
            }));
        });
        return createTable;
    };
    /**
     * Formatting of one column
     */
    const formatColumn$d = ({ table, column, dialect, }) => {
        var columnXML = new XMLNode('column', [
            { name: 'name', value: column.name },
            {
                name: 'type',
                value: translate('postgresql', dialect, column.dataType),
            },
        ]);
        if (column.dataType)
            columnXML.addAttribute({
                name: 'type',
                value: translate('postgresql', dialect, column.dataType),
            });
        if (column.option.autoIncrement) {
            const primitive = getPrimitiveType(column.dataType, mapppingTranslationsDatabase[dialect]);
            if (dialect === 'postgresql' &&
                (primitive === 'int' || primitive === 'long')) {
                columnXML.addAttribute({
                    name: 'defaultValueComputed',
                    value: `nextval('${generateSeqName(table.name, column.name)}'::regclass)`,
                });
            }
            else {
                columnXML.addAttribute({
                    name: 'autoIncrement',
                    value: column.option.autoIncrement.toString(),
                });
            }
        }
        if (column.default)
            columnXML.addAttribute({ name: 'defaultValue', value: column.default });
        if (column.comment)
            columnXML.addAttribute({ name: 'remarks', value: column.comment });
        // if constraints
        if (column.option.notNull ||
            column.option.primaryKey ||
            column.option.unique) {
            columnXML.addChildren(formatConstraints({
                primaryKey: column.option.primaryKey,
                nullable: !column.option.notNull,
                unique: column.option.unique,
            }));
        }
        return columnXML;
    };
    /**
     * Formatting constraints inside one column
     */
    const formatConstraints = (constraints) => {
        var constraintsXML = new XMLNode('constraints');
        if (constraints.primaryKey)
            constraintsXML.addAttribute({
                name: 'primaryKey',
                value: constraints.primaryKey.toString(),
            });
        if (constraints.nullable === false)
            constraintsXML.addAttribute({
                name: 'nullable',
                value: constraints.nullable.toString(),
            });
        if (constraints.unique)
            constraintsXML.addAttribute({
                name: 'unique',
                value: constraints.unique.toString(),
            });
        return constraintsXML;
    };
    const addForeignKeyConstraint = ({ startTable, endTable, relationship, }) => {
        if (startTable && endTable) {
            const columns = {
                start: [],
                end: [],
            };
            relationship.end.columnIds.forEach(columnId => {
                const column = getData(endTable.columns, columnId);
                if (column) {
                    columns.end.push(column);
                }
            });
            relationship.start.columnIds.forEach(columnId => {
                const column = getData(startTable.columns, columnId);
                if (column) {
                    columns.start.push(column);
                }
            });
            return new XMLNode('addForeignKeyConstraint', [
                { name: 'baseColumnNames', value: formatNames$1(columns.end) },
                { name: 'baseTableName', value: endTable.name },
                {
                    name: 'constraintName',
                    value: `FK_${startTable.name}_TO_${endTable.name}`.toLowerCase(),
                },
                { name: 'deferrable', value: 'false' },
                { name: 'initiallyDeferred', value: 'false' },
                { name: 'referencedColumnNames', value: formatNames$1(columns.start) },
                { name: 'referencedTableName', value: startTable.name },
            ]);
        }
        return new XMLNode('');
    };
    /**
     * Creating index
     */
    const createIndex$1 = ({ table, index }) => {
        // gets real columns, using id
        const colsWithIndex = index.columns
            .map(indexColumn => {
            const column = getData(table.columns, indexColumn.id);
            if (column) {
                return {
                    name: `${column.name}`,
                    descending: indexColumn.orderType === 'DESC',
                };
            }
            return null;
        })
            .filter(columnName => columnName !== null);
        if (colsWithIndex.length !== 0) {
            var createIndex = new XMLNode('createIndex');
            let indexName = index.name;
            if (index.name.trim() === '') {
                indexName = `${table.name}`;
            }
            createIndex.addAttribute({ name: 'indexName', value: indexName }, { name: 'tableName', value: table.name });
            if (index.unique)
                createIndex.addAttribute({
                    name: 'unique',
                    value: index.unique.toString(),
                });
            colsWithIndex.forEach(column => {
                var columnXML = new XMLNode('column', [
                    { name: 'name', value: column.name },
                ]);
                if (column.descending)
                    columnXML.addAttribute({
                        name: 'descending',
                        value: column.descending.toString(),
                    });
                createIndex.addChildren(columnXML);
            });
            return createIndex;
        }
        return new XMLNode('');
    };
    const dropTable = (table) => {
        return new XMLNode('dropTable', [{ name: 'tableName', value: table.name }]);
    };
    const addColumn = (table, columns, dialect) => {
        var addColumn = new XMLNode('addColumn', [
            { name: 'tableName', value: table.name },
        ]);
        columns.forEach(column => {
            addColumn.addChildren(formatColumn$d({ table, column, dialect }));
        });
        return addColumn;
    };
    const dropColumn = (table, column) => {
        return new XMLNode('dropColumn', [
            { name: 'tableName', value: table.name },
            { name: 'columnName', value: column.name },
        ]);
    };
    const modifyDataType = (table, newColumn, dialectTo) => {
        return new XMLNode('modifyDataType', [
            { name: 'tableName', value: table.name },
            { name: 'columnName', value: newColumn.name },
            {
                name: 'newDataType',
                value: translate('postgresql', dialectTo, newColumn.dataType),
            },
        ]);
    };
    const renameColumn = (table, newColumn, oldColumn) => {
        return new XMLNode('renameColumn', [
            { name: 'tableName', value: table.name },
            { name: 'newColumnName', value: newColumn.name },
            { name: 'oldColumnName', value: oldColumn.name },
        ]);
    };
    const renameTable = (newTable, oldTable) => {
        return new XMLNode('renameTable', [
            { name: 'newTableName', value: newTable.name },
            { name: 'oldTableName', value: oldTable.name },
        ]);
    };
    const dropIndex = (table, index) => {
        return new XMLNode('dropIndex', [
            { name: 'indexName', value: index.name },
            { name: 'tableName', value: table.name },
        ]);
    };
    function dropForeignKeyConstraint(table, relationship) {
        return new XMLNode('dropForeignKeyConstraint', [
            { name: 'baseTableName', value: table.name },
            { name: 'constraintName', value: relationship.constraintName || '???' },
        ]);
    }
    function addPrimaryKey(table, columns) {
        return new XMLNode('addPrimaryKey', [
            { name: 'tableName', value: table.name },
            { name: 'columnNames', value: formatNames$1(columns) },
        ]);
    }
    function dropPrimaryKey(table) {
        return new XMLNode('dropPrimaryKey', [
            { name: 'tableName', value: table.name },
        ]);
    }
    function addUniqueConstraint(table, columns) {
        return new XMLNode('addUniqueConstraint', [
            { name: 'tableName', value: table.name },
            { name: 'columnNames', value: formatNames$1(columns) },
        ]);
    }
    function dropUniqueConstraint(table) {
        return new XMLNode('dropUniqueConstraint', [
            { name: 'tableName', value: table.name },
            { name: 'constraintName', value: '???' },
        ]);
    }

    function formatNames(list, backtick, backtick2) {
        const buf = [];
        list.forEach((v, i) => {
            if (backtick) {
                if (backtick2) {
                    buf.push(`${backtick}${v.name}${backtick2}`);
                }
                else {
                    buf.push(`${backtick}${v.name}${backtick}`);
                }
            }
            else {
                buf.push(v.name);
            }
            if (list.length !== i + 1) {
                buf.push(', ');
            }
        });
        return buf.join('');
    }
    function formatSize(columns) {
        let name = 0;
        let dataType = 0;
        columns.forEach(column => {
            if (name < column.name.length) {
                name = column.name.length;
            }
            if (dataType < column.dataType.length) {
                dataType = column.dataType.length;
            }
        });
        return {
            name,
            dataType,
        };
    }
    function formatSpace(size) {
        const buf = [];
        for (let i = 0; i < size; i++) {
            buf.push(' ');
        }
        return buf.join('');
    }
    function primaryKey(columns) {
        return columns.some(column => column.option.primaryKey);
    }
    function primaryKeyColumns(columns) {
        return columns.filter(column => column.option.primaryKey);
    }
    function unique(columns) {
        return columns.some(column => column.option.unique);
    }
    function uniqueColumns(columns) {
        return columns.filter(column => column.option.unique);
    }
    function getBracket(bracketType) {
        var _a;
        return (_a = bracketTypeMap[bracketType]) !== null && _a !== void 0 ? _a : '';
    }

    function createDDL$6({ tableState, relationshipState, canvasState, }) {
        const fkNames = [];
        const indexNames = [];
        const stringBuffer = [''];
        const bracket = getBracket(canvasState.bracketType);
        const tables = orderByNameASC(tableState.tables);
        const relationships = relationshipState.relationships;
        const indexes = tableState.indexes;
        tables.forEach(table => {
            formatTable$c({ table, buffer: stringBuffer, bracket });
            stringBuffer.push('');
            // unique
            if (unique(table.columns)) {
                const uqColumns = uniqueColumns(table.columns);
                uqColumns.forEach(column => {
                    stringBuffer.push(`ALTER TABLE ${bracket}${table.name}${bracket}`);
                    stringBuffer.push(`  ADD CONSTRAINT ${bracket}UQ_${column.name}${bracket} UNIQUE (${bracket}${column.name}${bracket});`);
                    stringBuffer.push('');
                });
            }
        });
        relationships.forEach(relationship => {
            formatRelation$6({
                tables,
                relationship,
                buffer: stringBuffer,
                fkNames,
                bracket,
            });
            stringBuffer.push('');
        });
        indexes.forEach(index => {
            const table = getData(tables, index.tableId);
            if (table) {
                formatIndex$5({
                    table,
                    index,
                    buffer: stringBuffer,
                    indexNames,
                    bracket,
                });
                stringBuffer.push('');
            }
        });
        return stringBuffer.join('\n');
    }
    function formatTable$c({ table, buffer, bracket }) {
        buffer.push(`CREATE TABLE ${bracket}${table.name}${bracket}`);
        buffer.push(`(`);
        const pk = primaryKey(table.columns);
        const spaceSize = formatSize(table.columns);
        table.columns.forEach((column, i) => {
            if (pk) {
                formatColumn$c({
                    column,
                    isComma: true,
                    spaceSize,
                    buffer,
                    bracket,
                });
            }
            else {
                formatColumn$c({
                    column,
                    isComma: table.columns.length !== i + 1,
                    spaceSize,
                    buffer,
                    bracket,
                });
            }
        });
        if (pk) {
            const pkColumns = primaryKeyColumns(table.columns);
            buffer.push(`  PRIMARY KEY (${formatNames(pkColumns, bracket)})`);
        }
        if (table.comment.trim() === '') {
            buffer.push(`);`);
        }
        else {
            buffer.push(`) COMMENT '${table.comment}';`);
        }
    }
    function formatColumn$c({ column, isComma, spaceSize, buffer, bracket, }) {
        const stringBuffer = [];
        stringBuffer.push(`  ${bracket}${column.name}${bracket}` +
            formatSpace(spaceSize.name - column.name.length));
        stringBuffer.push(`${column.dataType}` +
            formatSpace(spaceSize.dataType - column.dataType.length));
        stringBuffer.push(`${column.option.notNull ? 'NOT NULL' : 'NULL    '}`);
        if (column.option.autoIncrement) {
            stringBuffer.push(`AUTO_INCREMENT`);
        }
        else {
            if (column.default.trim() !== '') {
                stringBuffer.push(`DEFAULT ${column.default}`);
            }
        }
        if (column.comment.trim() !== '') {
            stringBuffer.push(`COMMENT '${column.comment}'`);
        }
        buffer.push(stringBuffer.join(' ') + `${isComma ? ',' : ''}`);
    }
    function formatRelation$6({ tables, relationship, buffer, fkNames, bracket, }) {
        const startTable = getData(tables, relationship.start.tableId);
        const endTable = getData(tables, relationship.end.tableId);
        if (startTable && endTable) {
            buffer.push(`ALTER TABLE ${bracket}${endTable.name}${bracket}`);
            // FK
            let fkName = `FK_${startTable.name}_TO_${endTable.name}`;
            fkName = autoName(fkNames, '', fkName);
            fkNames.push({
                id: v4(),
                name: fkName,
            });
            buffer.push(`  ADD CONSTRAINT ${bracket}${fkName}${bracket}`);
            // key
            const columns = {
                start: [],
                end: [],
            };
            relationship.end.columnIds.forEach(columnId => {
                const column = getData(endTable.columns, columnId);
                if (column) {
                    columns.end.push(column);
                }
            });
            relationship.start.columnIds.forEach(columnId => {
                const column = getData(startTable.columns, columnId);
                if (column) {
                    columns.start.push(column);
                }
            });
            buffer.push(`    FOREIGN KEY (${formatNames(columns.end, bracket)})`);
            buffer.push(`    REFERENCES ${bracket}${startTable.name}${bracket} (${formatNames(columns.start, bracket)});`);
        }
    }
    function formatIndex$5({ table, index, buffer, indexNames, bracket, }) {
        const columnNames = index.columns
            .map(indexColumn => {
            const column = getData(table.columns, indexColumn.id);
            if (column) {
                return {
                    name: `${bracket}${column.name}${bracket} ${indexColumn.orderType}`,
                };
            }
            return null;
        })
            .filter(columnName => columnName !== null);
        if (columnNames.length !== 0) {
            let indexName = index.name;
            if (index.name.trim() === '') {
                indexName = `IDX_${table.name}`;
                indexName = autoName(indexNames, '', indexName);
                indexNames.push({
                    id: v4(),
                    name: indexName,
                });
            }
            if (index.unique) {
                buffer.push(`CREATE UNIQUE INDEX ${bracket}${indexName}${bracket}`);
            }
            else {
                buffer.push(`CREATE INDEX ${bracket}${indexName}${bracket}`);
            }
            buffer.push(`  ON ${bracket}${table.name}${bracket} (${formatNames(columnNames)});`);
        }
    }

    function createDDL$5({ tableState, relationshipState, canvasState, }) {
        const fkNames = [];
        const indexNames = [];
        const stringBuffer = [''];
        const bracket = getBracket(canvasState.bracketType);
        const tables = orderByNameASC(tableState.tables);
        const relationships = relationshipState.relationships;
        const indexes = tableState.indexes;
        tables.forEach(table => {
            formatTable$b({ table, buffer: stringBuffer, bracket });
            stringBuffer.push('');
            // unique
            if (unique(table.columns)) {
                const uqColumns = uniqueColumns(table.columns);
                uqColumns.forEach(column => {
                    stringBuffer.push(`ALTER TABLE ${bracket}${table.name}${bracket}`);
                    stringBuffer.push(`  ADD CONSTRAINT ${bracket}UQ_${column.name}${bracket} UNIQUE (${bracket}${column.name}${bracket})\nGO`);
                    stringBuffer.push('');
                });
            }
            formatComment$2({ table, buffer: stringBuffer, bracket });
        });
        relationships.forEach(relationship => {
            formatRelation$5({
                tables,
                relationship,
                buffer: stringBuffer,
                fkNames,
                bracket,
            });
            stringBuffer.push('');
        });
        indexes.forEach(index => {
            const table = getData(tables, index.tableId);
            if (table) {
                formatIndex$4({ table, index, buffer: stringBuffer, indexNames, bracket });
                stringBuffer.push('');
            }
        });
        return stringBuffer.join('\n');
    }
    function formatTable$b({ table, buffer, bracket }) {
        buffer.push(`CREATE TABLE ${bracket}${table.name}${bracket}`);
        buffer.push(`(`);
        const pk = primaryKey(table.columns);
        const spaceSize = formatSize(table.columns);
        table.columns.forEach((column, i) => {
            if (pk) {
                formatColumn$b({ column, isComma: true, spaceSize, buffer, bracket });
            }
            else {
                formatColumn$b({
                    column,
                    isComma: table.columns.length !== i + 1,
                    spaceSize,
                    buffer,
                    bracket,
                });
            }
        });
        // PK
        if (pk) {
            const pkColumns = primaryKeyColumns(table.columns);
            buffer.push(`  CONSTRAINT ${bracket}PK_${table.name}${bracket} PRIMARY KEY (${formatNames(pkColumns, bracket)})`);
        }
        buffer.push(`)\nGO`);
    }
    function formatColumn$b({ column, isComma, spaceSize, buffer, bracket, }) {
        const stringBuffer = [];
        stringBuffer.push(`  ${bracket}${column.name}${bracket}` +
            formatSpace(spaceSize.name - column.name.length));
        stringBuffer.push(`${column.dataType}` +
            formatSpace(spaceSize.dataType - column.dataType.length));
        if (column.option.notNull) {
            stringBuffer.push(`NOT NULL`);
        }
        if (column.option.autoIncrement) {
            stringBuffer.push(`IDENTITY(1,1)`);
        }
        else {
            if (column.default.trim() !== '') {
                stringBuffer.push(`DEFAULT ${column.default}`);
            }
        }
        buffer.push(stringBuffer.join(' ') + `${isComma ? ',' : ''}`);
    }
    function formatComment$2({ table, buffer }) {
        if (table.comment.trim() !== '') {
            buffer.push(`EXECUTE sys.sp_addextendedproperty 'MS_Description',`);
            buffer.push(`  '${table.comment}', 'user', dbo, 'table', '${table.name}'\nGO`);
            buffer.push('');
        }
        table.columns.forEach(column => {
            if (column.comment.trim() !== '') {
                buffer.push(`EXECUTE sys.sp_addextendedproperty 'MS_Description',`);
                buffer.push(`  '${column.comment}', 'user', dbo, 'table', '${table.name}', 'column', '${column.name}'\nGO`);
                buffer.push('');
            }
        });
    }
    function formatRelation$5({ tables, relationship, buffer, fkNames, bracket, }) {
        const startTable = getData(tables, relationship.start.tableId);
        const endTable = getData(tables, relationship.end.tableId);
        if (startTable && endTable) {
            buffer.push(`ALTER TABLE ${bracket}${endTable.name}${bracket}`);
            // FK
            let fkName = `FK_${startTable.name}_TO_${endTable.name}`;
            fkName = autoName(fkNames, '', fkName);
            fkNames.push({
                id: v4(),
                name: fkName,
            });
            buffer.push(`  ADD CONSTRAINT ${bracket}${fkName}${bracket}`);
            // key
            const columns = {
                start: [],
                end: [],
            };
            relationship.end.columnIds.forEach(columnId => {
                const column = getData(endTable.columns, columnId);
                if (column) {
                    columns.end.push(column);
                }
            });
            relationship.start.columnIds.forEach(columnId => {
                const column = getData(startTable.columns, columnId);
                if (column) {
                    columns.start.push(column);
                }
            });
            buffer.push(`    FOREIGN KEY (${formatNames(columns.end, bracket)})`);
            buffer.push(`    REFERENCES ${bracket}${startTable.name}${bracket} (${formatNames(columns.start, bracket)})\nGO`);
        }
    }
    function formatIndex$4({ table, index, buffer, indexNames, bracket, }) {
        const columnNames = index.columns
            .map(indexColumn => {
            const column = getData(table.columns, indexColumn.id);
            if (column) {
                return {
                    name: `${bracket}${column.name}${bracket} ${indexColumn.orderType}`,
                };
            }
            return null;
        })
            .filter(columnName => columnName !== null);
        if (columnNames.length !== 0) {
            let indexName = index.name;
            if (indexName.trim() === '') {
                indexName = `IDX_${table.name}`;
                indexName = autoName(indexNames, '', indexName);
                indexNames.push({
                    id: v4(),
                    name: indexName,
                });
            }
            if (index.unique) {
                buffer.push(`CREATE UNIQUE INDEX ${bracket}${indexName}${bracket}`);
            }
            else {
                buffer.push(`CREATE INDEX ${bracket}${indexName}${bracket}`);
            }
            buffer.push(`  ON ${bracket}${table.name}${bracket} (${formatNames(columnNames)})\nGO`);
        }
    }

    function createDDL$4({ tableState, relationshipState, canvasState, }) {
        const fkNames = [];
        const indexNames = [];
        const stringBuffer = [''];
        const bracket = getBracket(canvasState.bracketType);
        const tables = orderByNameASC(tableState.tables);
        const relationships = relationshipState.relationships;
        const indexes = tableState.indexes;
        tables.forEach(table => {
            formatTable$a({ table, buffer: stringBuffer, bracket });
            stringBuffer.push('');
            // unique
            if (unique(table.columns)) {
                const uqColumns = uniqueColumns(table.columns);
                uqColumns.forEach(column => {
                    stringBuffer.push(`ALTER TABLE ${bracket}${table.name}${bracket}`);
                    stringBuffer.push(`  ADD CONSTRAINT ${bracket}UQ_${column.name}${bracket} UNIQUE (${bracket}${column.name}${bracket});`);
                    stringBuffer.push('');
                });
            }
        });
        relationships.forEach(relationship => {
            formatRelation$4({
                tables,
                relationship,
                buffer: stringBuffer,
                fkNames,
                bracket,
            });
            stringBuffer.push('');
        });
        indexes.forEach(index => {
            const table = getData(tables, index.tableId);
            if (table) {
                formatIndex$3({
                    table,
                    index,
                    buffer: stringBuffer,
                    indexNames,
                    bracket,
                });
                stringBuffer.push('');
            }
        });
        return stringBuffer.join('\n');
    }
    function formatTable$a({ table, buffer, bracket }) {
        buffer.push(`CREATE TABLE ${bracket}${table.name}${bracket}`);
        buffer.push(`(`);
        const pk = primaryKey(table.columns);
        const spaceSize = formatSize(table.columns);
        table.columns.forEach((column, i) => {
            if (pk) {
                formatColumn$a({
                    column,
                    isComma: true,
                    spaceSize,
                    buffer,
                    bracket,
                });
            }
            else {
                formatColumn$a({
                    column,
                    isComma: table.columns.length !== i + 1,
                    spaceSize,
                    buffer,
                    bracket,
                });
            }
        });
        // PK
        if (pk) {
            const pkColumns = primaryKeyColumns(table.columns);
            buffer.push(`  PRIMARY KEY (${formatNames(pkColumns, bracket)})`);
        }
        if (table.comment.trim() === '') {
            buffer.push(`);`);
        }
        else {
            buffer.push(`) COMMENT '${table.comment}';`);
        }
    }
    function formatColumn$a({ column, isComma, spaceSize, buffer, bracket, }) {
        const stringBuffer = [];
        stringBuffer.push(`  ${bracket}${column.name}${bracket}` +
            formatSpace(spaceSize.name - column.name.length));
        stringBuffer.push(`${column.dataType}` +
            formatSpace(spaceSize.dataType - column.dataType.length));
        stringBuffer.push(`${column.option.notNull ? 'NOT NULL' : 'NULL    '}`);
        if (column.option.autoIncrement) {
            stringBuffer.push(`AUTO_INCREMENT`);
        }
        else {
            if (column.default.trim() !== '') {
                stringBuffer.push(`DEFAULT ${column.default}`);
            }
        }
        if (column.comment.trim() !== '') {
            stringBuffer.push(`COMMENT '${column.comment}'`);
        }
        buffer.push(stringBuffer.join(' ') + `${isComma ? ',' : ''}`);
    }
    function formatRelation$4({ tables, relationship, buffer, fkNames, bracket, }) {
        const startTable = getData(tables, relationship.start.tableId);
        const endTable = getData(tables, relationship.end.tableId);
        if (startTable && endTable) {
            buffer.push(`ALTER TABLE ${bracket}${endTable.name}${bracket}`);
            // FK
            let fkName = `FK_${startTable.name}_TO_${endTable.name}`;
            fkName = autoName(fkNames, '', fkName);
            fkNames.push({
                id: v4(),
                name: fkName,
            });
            buffer.push(`  ADD CONSTRAINT ${bracket}${fkName}${bracket}`);
            // key
            const columns = {
                start: [],
                end: [],
            };
            relationship.end.columnIds.forEach(columnId => {
                const column = getData(endTable.columns, columnId);
                if (column) {
                    columns.end.push(column);
                }
            });
            relationship.start.columnIds.forEach(columnId => {
                const column = getData(startTable.columns, columnId);
                if (column) {
                    columns.start.push(column);
                }
            });
            buffer.push(`    FOREIGN KEY (${formatNames(columns.end, bracket)})`);
            buffer.push(`    REFERENCES ${bracket}${startTable.name}${bracket} (${formatNames(columns.start, bracket)});`);
        }
    }
    function formatIndex$3({ table, index, buffer, indexNames, bracket, }) {
        const columnNames = index.columns
            .map(indexColumn => {
            const column = getData(table.columns, indexColumn.id);
            if (column) {
                return {
                    name: `${bracket}${column.name}${bracket} ${indexColumn.orderType}`,
                };
            }
            return null;
        })
            .filter(columnName => columnName !== null);
        if (columnNames.length !== 0) {
            let indexName = index.name;
            if (index.name.trim() === '') {
                indexName = `IDX_${table.name}`;
                indexName = autoName(indexNames, '', indexName);
                indexNames.push({
                    id: v4(),
                    name: indexName,
                });
            }
            if (index.unique) {
                buffer.push(`CREATE UNIQUE INDEX ${bracket}${indexName}${bracket}`);
            }
            else {
                buffer.push(`CREATE INDEX ${bracket}${indexName}${bracket}`);
            }
            buffer.push(`  ON ${bracket}${table.name}${bracket} (${formatNames(columnNames)});`);
        }
    }

    function createDDL$3({ tableState, relationshipState, canvasState, }) {
        const fkNames = [];
        const aiNames = [];
        const trgNames = [];
        const indexNames = [];
        const stringBuffer = [''];
        const bracket = getBracket(canvasState.bracketType);
        const tables = orderByNameASC(tableState.tables);
        const relationships = relationshipState.relationships;
        const indexes = tableState.indexes;
        tables.forEach(table => {
            formatTable$9({ table, buffer: stringBuffer, bracket });
            stringBuffer.push('');
            // unique
            if (unique(table.columns)) {
                const uqColumns = uniqueColumns(table.columns);
                uqColumns.forEach(column => {
                    stringBuffer.push(`ALTER TABLE ${bracket}${table.name}${bracket}`);
                    stringBuffer.push(`  ADD CONSTRAINT ${bracket}UQ_${column.name}${bracket} UNIQUE (${bracket}${column.name}${bracket});`);
                    stringBuffer.push('');
                });
            }
            // Sequence
            table.columns.forEach(column => {
                if (column.option.autoIncrement) {
                    let aiName = `SEQ_${table.name}`;
                    aiName = autoName(aiNames, '', aiName);
                    aiNames.push({
                        id: v4(),
                        name: aiName,
                    });
                    stringBuffer.push(`CREATE SEQUENCE ${aiName}`);
                    stringBuffer.push(`START WITH 1`);
                    stringBuffer.push(`INCREMENT BY 1;`);
                    stringBuffer.push('');
                    let trgName = `SEQ_TRG_${table.name}`;
                    trgName = autoName(aiNames, '', trgName);
                    trgNames.push({
                        id: v4(),
                        name: trgName,
                    });
                    stringBuffer.push(`CREATE OR REPLACE TRIGGER ${trgName}`);
                    stringBuffer.push(`BEFORE INSERT ON ${table.name}`);
                    stringBuffer.push(`REFERENCING NEW AS NEW FOR EACH ROW`);
                    stringBuffer.push(`BEGIN`);
                    stringBuffer.push(`  SELECT ${aiName}.NEXTVAL`);
                    stringBuffer.push(`  INTO: NEW.${column.name}`);
                    stringBuffer.push(`  FROM DUAL;`);
                    stringBuffer.push(`END;`);
                    stringBuffer.push('');
                }
            });
            formatComment$1({ table, buffer: stringBuffer, bracket });
        });
        relationships.forEach(relationship => {
            formatRelation$3({
                tables,
                relationship,
                buffer: stringBuffer,
                fkNames,
                bracket,
            });
            stringBuffer.push('');
        });
        indexes.forEach(index => {
            const table = getData(tables, index.tableId);
            if (table) {
                formatIndex$2({ table, index, buffer: stringBuffer, indexNames, bracket });
                stringBuffer.push('');
            }
        });
        return stringBuffer.join('\n');
    }
    function formatTable$9({ table, buffer, bracket }) {
        buffer.push(`CREATE TABLE ${bracket}${table.name}${bracket}`);
        buffer.push(`(`);
        const pk = primaryKey(table.columns);
        const spaceSize = formatSize(table.columns);
        table.columns.forEach((column, i) => {
            if (pk) {
                formatColumn$9({ column, isComma: true, spaceSize, buffer, bracket });
            }
            else {
                formatColumn$9({
                    column,
                    isComma: table.columns.length !== i + 1,
                    spaceSize,
                    buffer,
                    bracket,
                });
            }
        });
        // PK
        if (pk) {
            const pkColumns = primaryKeyColumns(table.columns);
            buffer.push(`  CONSTRAINT ${bracket}PK_${table.name}${bracket} PRIMARY KEY (${formatNames(pkColumns, bracket)})`);
        }
        buffer.push(`);`);
    }
    function formatColumn$9({ column, isComma, spaceSize, buffer, bracket, }) {
        const stringBuffer = [];
        stringBuffer.push(`  ${bracket}${column.name}${bracket}` +
            formatSpace(spaceSize.name - column.name.length));
        stringBuffer.push(`${column.dataType}` +
            formatSpace(spaceSize.dataType - column.dataType.length));
        if (column.default.trim() !== '') {
            stringBuffer.push(`DEFAULT ${column.default}`);
        }
        if (column.option.notNull) {
            stringBuffer.push(`NOT NULL`);
        }
        buffer.push(stringBuffer.join(' ') + `${isComma ? ',' : ''}`);
    }
    function formatComment$1({ table, buffer, bracket }) {
        if (table.comment.trim() !== '') {
            buffer.push(`COMMENT ON TABLE ${bracket}${table.name}${bracket} IS '${table.comment}';`);
            buffer.push('');
        }
        table.columns.forEach(column => {
            if (column.comment.trim() !== '') {
                buffer.push(`COMMENT ON COLUMN ${bracket}${table.name}${bracket}.${bracket}${column.name}${bracket} IS '${column.comment}';`);
                buffer.push('');
            }
        });
    }
    function formatRelation$3({ tables, relationship, buffer, fkNames, bracket, }) {
        const startTable = getData(tables, relationship.start.tableId);
        const endTable = getData(tables, relationship.end.tableId);
        if (startTable && endTable) {
            buffer.push(`ALTER TABLE ${bracket}${endTable.name}${bracket}`);
            // FK
            let fkName = `FK_${startTable.name}_TO_${endTable.name}`;
            fkName = autoName(fkNames, '', fkName);
            fkNames.push({
                id: v4(),
                name: fkName,
            });
            buffer.push(`  ADD CONSTRAINT ${bracket}${fkName}${bracket}`);
            // key
            const columns = {
                start: [],
                end: [],
            };
            relationship.end.columnIds.forEach(columnId => {
                const column = getData(endTable.columns, columnId);
                if (column) {
                    columns.end.push(column);
                }
            });
            relationship.start.columnIds.forEach(columnId => {
                const column = getData(startTable.columns, columnId);
                if (column) {
                    columns.start.push(column);
                }
            });
            buffer.push(`    FOREIGN KEY (${formatNames(columns.end, bracket)})`);
            buffer.push(`    REFERENCES ${bracket}${startTable.name}${bracket} (${formatNames(columns.start, bracket)});`);
        }
    }
    function formatIndex$2({ table, index, buffer, indexNames, bracket, }) {
        const columnNames = index.columns
            .map(indexColumn => {
            const column = getData(table.columns, indexColumn.id);
            if (column) {
                return {
                    name: `${bracket}${column.name}${bracket} ${indexColumn.orderType}`,
                };
            }
            return null;
        })
            .filter(columnName => columnName !== null);
        if (columnNames.length !== 0) {
            let indexName = index.name;
            if (index.name.trim() === '') {
                indexName = `IDX_${table.name}`;
                indexName = autoName(indexNames, '', indexName);
                indexNames.push({
                    id: v4(),
                    name: indexName,
                });
            }
            if (index.unique) {
                buffer.push(`CREATE UNIQUE INDEX ${bracket}${indexName}${bracket}`);
            }
            else {
                buffer.push(`CREATE INDEX ${bracket}${indexName}${bracket}`);
            }
            buffer.push(`  ON ${bracket}${table.name}${bracket} (${formatNames(columnNames)});`);
        }
    }

    function createDDL$2({ tableState, relationshipState, canvasState, }) {
        const fkNames = [];
        const indexNames = [];
        const stringBuffer = [''];
        const bracket = getBracket(canvasState.bracketType);
        const tables = orderByNameASC(tableState.tables);
        const relationships = relationshipState.relationships;
        const indexes = tableState.indexes;
        tables.forEach(table => {
            formatTable$8({ table, buffer: stringBuffer, bracket });
            stringBuffer.push('');
            formatComment({ table, buffer: stringBuffer, bracket });
        });
        relationships.forEach(relationship => {
            formatRelation$2({
                tables,
                relationship,
                buffer: stringBuffer,
                fkNames,
                bracket,
            });
            stringBuffer.push('');
        });
        indexes.forEach(index => {
            const table = getData(tables, index.tableId);
            if (table) {
                formatIndex$1({ table, index, buffer: stringBuffer, indexNames, bracket });
                stringBuffer.push('');
            }
        });
        return stringBuffer.join('\n');
    }
    function formatTable$8({ table, buffer, bracket }) {
        buffer.push(`CREATE TABLE ${bracket}${table.name}${bracket}`);
        buffer.push(`(`);
        const pk = primaryKey(table.columns);
        const spaceSize = formatSize(table.columns);
        table.columns.forEach((column, i) => {
            if (pk) {
                formatColumn$8({ column, isComma: true, spaceSize, buffer, bracket });
            }
            else {
                formatColumn$8({
                    column,
                    isComma: table.columns.length !== i + 1,
                    spaceSize,
                    buffer,
                    bracket,
                });
            }
        });
        // PK
        if (pk) {
            const pkColumns = primaryKeyColumns(table.columns);
            buffer.push(`  PRIMARY KEY (${formatNames(pkColumns, bracket)})`);
        }
        buffer.push(`);`);
    }
    function formatColumn$8({ column, isComma, spaceSize, buffer, bracket, }) {
        const stringBuffer = [];
        stringBuffer.push(`  ${bracket}${column.name}${bracket}` +
            formatSpace(spaceSize.name - column.name.length));
        stringBuffer.push(`${column.dataType}` +
            formatSpace(spaceSize.dataType - column.dataType.length));
        if (column.option.notNull) {
            stringBuffer.push(`NOT NULL`);
        }
        if (column.option.autoIncrement) {
            stringBuffer.push(`GENERATED ALWAYS AS IDENTITY`);
        }
        else {
            if (column.default.trim() !== '') {
                stringBuffer.push(`DEFAULT ${column.default}`);
            }
        }
        if (column.option.unique) {
            stringBuffer.push(`UNIQUE`);
        }
        buffer.push(stringBuffer.join(' ') + `${isComma ? ',' : ''}`);
    }
    function formatComment({ table, buffer, bracket }) {
        if (table.comment.trim() !== '') {
            buffer.push(`COMMENT ON TABLE ${bracket}${table.name}${bracket} IS '${table.comment}';`);
            buffer.push('');
        }
        table.columns.forEach(column => {
            if (column.comment.trim() !== '') {
                buffer.push(`COMMENT ON COLUMN ${bracket}${table.name}${bracket}.${bracket}${column.name}${bracket} IS '${column.comment}';`);
                buffer.push('');
            }
        });
    }
    function formatRelation$2({ tables, relationship, buffer, fkNames, bracket, }) {
        const startTable = getData(tables, relationship.start.tableId);
        const endTable = getData(tables, relationship.end.tableId);
        if (startTable && endTable) {
            buffer.push(`ALTER TABLE ${bracket}${endTable.name}${bracket}`);
            // FK  
            let fkName = `FK_${startTable.name}_TO_${endTable.name}`;
            fkName = autoName(fkNames, '', fkName);
            fkNames.push({
                id: v4(),
                name: fkName,
            });
            buffer.push(`  ADD CONSTRAINT ${bracket}${fkName}${bracket}`);
            // key
            const columns = {
                start: [],
                end: [],
            };
            relationship.end.columnIds.forEach(columnId => {
                const column = getData(endTable.columns, columnId);
                if (column) {
                    columns.end.push(column);
                }
            });
            relationship.start.columnIds.forEach(columnId => {
                const column = getData(startTable.columns, columnId);
                if (column) {
                    columns.start.push(column);
                }
            });
            buffer.push(`    FOREIGN KEY (${formatNames(columns.end, bracket)})`);
            buffer.push(`    REFERENCES ${bracket}${startTable.name}${bracket} (${formatNames(columns.start, bracket)});`);
        }
    }
    function formatIndex$1({ table, index, buffer, indexNames, bracket, }) {
        const columnNames = index.columns
            .map(indexColumn => {
            const column = getData(table.columns, indexColumn.id);
            if (column) {
                return {
                    name: `${bracket}${column.name}${bracket} ${indexColumn.orderType}`,
                };
            }
            return null;
        })
            .filter(columnName => columnName !== null);
        if (columnNames.length !== 0) {
            let indexName = index.name;
            if (index.name.trim() === '') {
                indexName = `IDX_${table.name}`;
                indexName = autoName(indexNames, '', indexName);
                indexNames.push({
                    id: v4(),
                    name: indexName,
                });
            }
            if (index.unique) {
                buffer.push(`CREATE UNIQUE INDEX ${bracket}${indexName}${bracket}`);
            }
            else {
                buffer.push(`CREATE INDEX ${bracket}${indexName}${bracket}`);
            }
            buffer.push(`  ON ${bracket}${table.name}${bracket} (${formatNames(columnNames)});`);
        }
    }

    function createDDL$1({ tableState, relationshipState, canvasState, }) {
        const indexNames = [];
        const stringBuffer = [''];
        const bracket = getBracket(canvasState.bracketType);
        const relationships = relationshipState.relationships;
        const indexes = tableState.indexes;
        const tables = orderByRelationship(orderByNameASC(tableState.tables), relationships);
        tables.forEach(table => {
            formatTable$7({
                table,
                tables,
                relationships: relationships.filter(relationship => relationship.end.tableId === table.id),
                buffer: stringBuffer,
                bracket,
            });
            stringBuffer.push('');
        });
        indexes.forEach(index => {
            const table = getData(tables, index.tableId);
            if (table) {
                formatIndex({ table, index, buffer: stringBuffer, indexNames, bracket });
                stringBuffer.push('');
            }
        });
        return stringBuffer.join('\n');
    }
    function formatTable$7({ table, tables, relationships, buffer, bracket, }) {
        if (table.comment.trim() !== '') {
            buffer.push(`-- ${table.comment}`);
        }
        buffer.push(`CREATE TABLE ${bracket}${table.name}${bracket}`);
        buffer.push(`(`);
        const pk = primaryKey(table.columns);
        const spaceSize = formatSize(table.columns);
        table.columns.forEach((column, i) => {
            if (pk || relationships.length !== 0) {
                formatColumn$7({ column, isComma: true, spaceSize, buffer, bracket });
            }
            else {
                formatColumn$7({
                    column,
                    isComma: table.columns.length !== i + 1,
                    spaceSize,
                    buffer,
                    bracket,
                });
            }
        });
        // PK
        if (pk) {
            const pkColumns = primaryKeyColumns(table.columns);
            if (relationships.length !== 0) {
                if (pkColumns.length === 1) {
                    const autoIncrement = pkColumns[0].option.autoIncrement
                        ? ' AUTOINCREMENT'
                        : '';
                    buffer.push(`  PRIMARY KEY (${formatNames(pkColumns, bracket)}${autoIncrement}),`);
                }
                else {
                    buffer.push(`  PRIMARY KEY (${formatNames(pkColumns, bracket)}),`);
                }
            }
            else {
                if (pkColumns.length === 1) {
                    const autoIncrement = pkColumns[0].option.autoIncrement
                        ? ' AUTOINCREMENT'
                        : '';
                    buffer.push(`  PRIMARY KEY (${formatNames(pkColumns, bracket)}${autoIncrement})`);
                }
                else {
                    buffer.push(`  PRIMARY KEY (${formatNames(pkColumns, bracket)})`);
                }
            }
        }
        relationships.forEach((relationship, i) => {
            const startTable = getData(tables, relationship.start.tableId);
            const endTable = getData(tables, relationship.end.tableId);
            if (startTable && endTable) {
                // key
                const columns = {
                    start: [],
                    end: [],
                };
                relationship.end.columnIds.forEach(columnId => {
                    const column = getData(endTable.columns, columnId);
                    if (column) {
                        columns.end.push(column);
                    }
                });
                relationship.start.columnIds.forEach(columnId => {
                    const column = getData(startTable.columns, columnId);
                    if (column) {
                        columns.start.push(column);
                    }
                });
                if (relationships.length - 1 > i) {
                    buffer.push(`  FOREIGN KEY (${formatNames(columns.end, bracket)}) REFERENCES ${bracket}${startTable.name}${bracket} (${formatNames(columns.start, bracket)}),`);
                }
                else {
                    buffer.push(`  FOREIGN KEY (${formatNames(columns.end, bracket)}) REFERENCES ${bracket}${startTable.name}${bracket} (${formatNames(columns.start, bracket)})`);
                }
            }
        });
        buffer.push(`);`);
    }
    function formatColumn$7({ column, isComma, spaceSize, buffer, bracket, }) {
        if (column.comment.trim() !== '') {
            buffer.push(`  -- ${column.comment}`);
        }
        const stringBuffer = [];
        stringBuffer.push(`  ${bracket}${column.name}${bracket}` +
            formatSpace(spaceSize.name - column.name.length));
        stringBuffer.push(`${column.dataType}` +
            formatSpace(spaceSize.dataType - column.dataType.length));
        stringBuffer.push(`${column.option.notNull ? 'NOT NULL' : 'NULL    '}`);
        if (column.option.unique) {
            stringBuffer.push(`UNIQUE`);
        }
        if (!column.option.autoIncrement && column.default.trim() !== '') {
            stringBuffer.push(`DEFAULT ${column.default}`);
        }
        buffer.push(stringBuffer.join(' ') + `${isComma ? ',' : ''}`);
    }
    function formatIndex({ table, index, buffer, indexNames, bracket, }) {
        const columnNames = index.columns
            .map(indexColumn => {
            const column = getData(table.columns, indexColumn.id);
            if (column) {
                return {
                    name: `${bracket}${column.name}${bracket} ${indexColumn.orderType}`,
                };
            }
            return null;
        })
            .filter(columnName => columnName !== null);
        if (columnNames.length !== 0) {
            let indexName = index.name;
            if (index.name.trim() === '') {
                indexName = `IDX_${table.name}`;
                indexName = autoName(indexNames, '', indexName);
                indexNames.push({
                    id: v4(),
                    name: indexName,
                });
            }
            if (index.unique) {
                buffer.push(`CREATE UNIQUE INDEX ${bracket}${indexName}${bracket}`);
            }
            else {
                buffer.push(`CREATE INDEX ${bracket}${indexName}${bracket}`);
            }
            buffer.push(`  ON ${bracket}${table.name}${bracket} (${formatNames(columnNames)});`);
        }
    }

    function createDDL(store, database) {
        const currentDatabase = database ? database : store.canvasState.database;
        switch (currentDatabase) {
            case 'MariaDB':
                return createDDL$6(store);
            case 'MSSQL':
                return createDDL$5(store);
            case 'MySQL':
                return createDDL$4(store);
            case 'Oracle':
                return createDDL$3(store);
            case 'PostgreSQL':
                return createDDL$2(store);
            case 'SQLite':
                return createDDL$1(store);
        }
        return '';
    }
    function createDDLTable({ canvasState, tableState, relationshipState }, table) {
        const stringBuffer = [''];
        const database = canvasState.database;
        const indexNames = [];
        const indexes = tableState.indexes.filter(index => index.tableId === table.id);
        const relationships = relationshipState.relationships;
        const tables = tableState.tables;
        const bracket = getBracket(canvasState.bracketType);
        switch (database) {
            case 'MariaDB':
                formatTable$c({ table, buffer: stringBuffer, bracket });
                stringBuffer.push('');
                indexes.forEach(index => {
                    formatIndex$5({
                        table,
                        index,
                        buffer: stringBuffer,
                        indexNames,
                        bracket,
                    });
                    stringBuffer.push('');
                });
                break;
            case 'MSSQL':
                formatTable$b({ table, buffer: stringBuffer, bracket });
                stringBuffer.push('');
                indexes.forEach(index => {
                    formatIndex$4({
                        table,
                        index,
                        buffer: stringBuffer,
                        indexNames,
                        bracket,
                    });
                    stringBuffer.push('');
                });
                break;
            case 'MySQL':
                formatTable$a({ table, buffer: stringBuffer, bracket });
                stringBuffer.push('');
                indexes.forEach(index => {
                    formatIndex$3({
                        table,
                        index,
                        buffer: stringBuffer,
                        indexNames,
                        bracket,
                    });
                    stringBuffer.push('');
                });
                break;
            case 'Oracle':
                formatTable$9({ table, buffer: stringBuffer, bracket });
                stringBuffer.push('');
                indexes.forEach(index => {
                    formatIndex$2({
                        table,
                        index,
                        buffer: stringBuffer,
                        indexNames,
                        bracket,
                    });
                    stringBuffer.push('');
                });
                break;
            case 'PostgreSQL':
                formatTable$8({ table, buffer: stringBuffer, bracket });
                stringBuffer.push('');
                indexes.forEach(index => {
                    formatIndex$1({
                        table,
                        index,
                        buffer: stringBuffer,
                        indexNames,
                        bracket,
                    });
                    stringBuffer.push('');
                });
                break;
            case 'SQLite':
                formatTable$7({
                    table,
                    tables,
                    relationships: relationships.filter(relationship => relationship.end.tableId === table.id),
                    buffer: stringBuffer,
                    bracket,
                });
                stringBuffer.push('');
                indexes.forEach(index => {
                    formatIndex({
                        table,
                        index,
                        buffer: stringBuffer,
                        indexNames,
                        bracket,
                    });
                    stringBuffer.push('');
                });
                break;
        }
        return stringBuffer.join('\n');
    }

    const defaultOptions$f = {
        nameWidth: 60,
        keymapWidth: 0,
    };
    const getLatestSnapshot = (context) => {
        if (context.snapshots.length) {
            return context.snapshots[context.snapshots.length - 1];
        }
        else {
            const snapshot = {
                data: createStoreCopy(context.store),
                metadata: { type: 'user', filename: '' },
            };
            snapshot.data.relationship.relationships = [];
            snapshot.data.table.indexes = [];
            snapshot.data.table.tables = [];
            return snapshot;
        }
    };
    const createExportMenus = (context, canvas) => {
        const { store, snapshots, showPrompt, eventBus } = context;
        return [
            {
                icon: {
                    prefix: 'mdi',
                    name: 'code-json',
                    size: 18,
                },
                name: 'json',
                execute: () => exportJSON(createJsonStringify(store, 2), store.canvasState.databaseName),
            },
            {
                icon: {
                    prefix: 'mdi',
                    name: 'database-export',
                    size: 18,
                },
                name: 'SQL DDL',
                execute: () => exportSQLDDL(createDDL(store), store.canvasState.databaseName),
            },
            {
                icon: {
                    prefix: 'fas',
                    name: 'file-image',
                },
                name: 'png',
                execute: () => exportPNG(canvas, store.canvasState.databaseName),
            },
            {
                icon: {
                    prefix: 'mdi',
                    name: 'xml',
                    size: 18,
                },
                name: 'Liquibase',
                execute: () => {
                    if (store.canvasState.database === 'PostgreSQL') {
                        showPrompt('Please enter the name of changeset:', id => showPrompt('Please enter name of the author:', name => {
                            id = id.replace(/\\/g, '/');
                            const fileName = `${id.replace(/\.xml$/g, '')}.xml`;
                            createSnapshot(context, {
                                type: 'before-export',
                                filename: fileName,
                            });
                            const liquibase = createLiquibase(context, id, name);
                            exportXML(liquibase, fileName);
                            if (liquibase) {
                                createSnapshot(context, {
                                    type: 'after-export',
                                    filename: fileName,
                                });
                            }
                        }));
                    }
                    else {
                        eventBus.emit(Bus.ToastBar.add, {
                            bodyTpl: html `Export from ${store.canvasState.database} dialect not
            supported, please use PostgreSQL`,
                        });
                    }
                },
            },
        ].map(menu => (Object.assign(Object.assign({}, menu), { options: Object.assign({}, defaultOptions$f) })));
    };

    const createMemoState = () => ({
        memos: [],
    });

    const oneRelationshipTypes = [
        'ZeroOne',
        'OneOnly',
        'One',
    ];
    const nRelationshipTypes = [
        'ZeroOneN',
        'ZeroN',
        'OneN',
        'N',
    ];
    const createRelationshipState = () => ({
        relationships: [],
    });

    const createTableState = () => ({
        tables: [],
        indexes: [],
    });

    /**
     * Sorts statements and adds them to shape
     * @param statements List of statements
     * @param shape (optional) Already existing shape that will just add new statements to itself
     * @returns Shape with sorted statements
     */
    function reshape(statements, shape = {
        tables: [],
        indexes: [],
        primaryKeys: [],
        foreignKeys: [],
        dropForeignKeys: [],
        uniques: [],
        addColumns: [],
        dropColumns: [],
        dropTable: [],
    }) {
        statements.forEach(statement => {
            switch (statement.type) {
                case 'create.table':
                    const table = statement;
                    const duplicateTable = findByName(shape.tables, table.name);
                    if (!duplicateTable && table.name) {
                        shape.tables.push(table);
                    }
                    break;
                case 'create.index':
                    const index = statement;
                    const duplicateIndex = findByName(shape.indexes, index.name);
                    if (!duplicateIndex && index.tableName && index.columns.length) {
                        shape.indexes.push(index);
                    }
                    break;
                case 'alter.table.add.primaryKey':
                    const primaryKey = statement;
                    const duplicatePK = findByName(shape.primaryKeys, primaryKey.name);
                    if (!duplicatePK && primaryKey.name && primaryKey.columnNames.length) {
                        shape.primaryKeys.push(primaryKey);
                    }
                    break;
                case 'alter.table.add.foreignKey':
                    const foreignKey = statement;
                    const duplicateFK = findByConstraintName(shape.foreignKeys, foreignKey.constraintName);
                    if (!duplicateFK &&
                        foreignKey.name &&
                        foreignKey.columnNames.length &&
                        foreignKey.refTableName &&
                        foreignKey.refColumnNames.length &&
                        foreignKey.columnNames.length === foreignKey.refColumnNames.length) {
                        shape.foreignKeys.push(foreignKey);
                    }
                    break;
                case 'alter.table.add.unique':
                    const unique = statement;
                    const duplicateUnique = findByName(shape.uniques, unique.name);
                    if (!duplicateUnique && unique.name && unique.columnNames.length) {
                        shape.uniques.push(unique);
                    }
                    break;
                case 'alter.table.add.column':
                    const addColumns = statement;
                    const duplicateAddColumns = findByName(shape.addColumns, addColumns.name);
                    if (!duplicateAddColumns &&
                        addColumns.name &&
                        addColumns.columns.length) {
                        shape.addColumns.push(addColumns);
                    }
                    break;
                case 'alter.table.drop.column':
                    const dropColumns = statement;
                    const duplicateDropColumns = findByName(shape.dropColumns, dropColumns.name);
                    if (!duplicateDropColumns &&
                        dropColumns.name &&
                        dropColumns.columns.length) {
                        shape.dropColumns.push(dropColumns);
                    }
                    break;
                case 'drop.table':
                    const dropTable = statement;
                    const duplicateDropTable = findByName(shape.dropTable, dropTable.name);
                    if (!duplicateDropTable && dropTable.name) {
                        shape.dropTable.push(dropTable);
                    }
                    break;
                case 'alter.table.drop.foreignKey':
                    const dropForeignKey = statement;
                    const duplicateDropFK = findByName(shape.dropForeignKeys, dropForeignKey.name);
                    if (!duplicateDropFK &&
                        dropForeignKey.name &&
                        dropForeignKey.baseTableName) {
                        shape.dropForeignKeys.push(dropForeignKey);
                    }
                    break;
            }
        });
        return shape;
    }
    function findByName(list, name) {
        for (const item of list) {
            if (item.name.toUpperCase() === name.toUpperCase()) {
                return item;
            }
        }
        return null;
    }
    function findByConstraintName(list, constraintName) {
        var _a;
        if (!constraintName)
            return null;
        for (const item of list) {
            if (((_a = item.constraintName) === null || _a === void 0 ? void 0 : _a.toUpperCase()) === (constraintName === null || constraintName === void 0 ? void 0 : constraintName.toUpperCase())) {
                return item;
            }
        }
        return null;
    }
    /**
     * Adds all statements to CreateTable[]
     * @param shape Shape with all statements
     * @returns Final list of CreateTable[]
     */
    function mergeTable(shape) {
        const { indexes, primaryKeys, foreignKeys, uniques, addColumns, dropColumns, dropForeignKeys, dropTable, } = shape;
        var { tables } = shape;
        indexes.forEach(index => {
            const table = findByName(tables, index.tableName);
            if (table) {
                table.indexes.push({
                    name: index.name,
                    unique: index.unique,
                    columns: index.columns,
                    id: index.id,
                });
            }
        });
        primaryKeys.forEach(primaryKey => {
            const table = findByName(tables, primaryKey.name);
            if (table) {
                primaryKey.columnNames.forEach(columnName => {
                    const column = findByName(table.columns, columnName);
                    if (column) {
                        column.primaryKey = true;
                    }
                });
            }
        });
        uniques.forEach(unique => {
            const table = findByName(tables, unique.name);
            if (table) {
                unique.columnNames.forEach(columnName => {
                    const column = findByName(table.columns, columnName);
                    if (column) {
                        column.unique = true;
                    }
                });
            }
        });
        foreignKeys.forEach(foreignKey => {
            const table = findByName(tables, foreignKey.name);
            if (table) {
                table.foreignKeys.push({
                    columnNames: foreignKey.columnNames,
                    refTableName: foreignKey.refTableName,
                    refColumnNames: foreignKey.refColumnNames,
                    constraintName: foreignKey.constraintName,
                    visible: foreignKey.visible,
                    id: foreignKey.id,
                });
            }
        });
        addColumns.forEach(addColumn => {
            const table = findByName(tables, addColumn.name);
            if (table) {
                addColumn.columns.forEach(column => {
                    const duplicateColumn = findByName(table.columns, column.name);
                    if (!duplicateColumn) {
                        table.columns.push(column);
                    }
                });
            }
        });
        dropColumns.forEach(dropColumn => {
            const table = findByName(tables, dropColumn.name);
            if (table) {
                dropColumn.columns.forEach(columnToDrop => {
                    table.columns = table.columns.filter(column => columnToDrop.name !== column.name);
                });
            }
        });
        dropTable.forEach(dropTable => {
            tables = tables.filter(table => table.name !== dropTable.name);
        });
        dropForeignKeys.forEach(dropForeignKey => {
            const table = findByName(tables, dropForeignKey.baseTableName);
            if (table) {
                table.foreignKeys = table.foreignKeys.filter(fk => fk.constraintName !== dropForeignKey.name);
            }
        });
        return tables;
    }
    /**
     * Converts latest snapshot to shape, so there can be added more new statements
     * @param snaphot Latest snapshot
     * @returns Shape with all statements needed to replicate latest snapshot
     */
    function snapshotToShape({ table, relationship }) {
        const shape = {
            tables: [],
            indexes: [],
            primaryKeys: [],
            foreignKeys: [],
            dropForeignKeys: [],
            uniques: [],
            addColumns: [],
            dropColumns: [],
            dropTable: [],
        };
        shape.tables.push(...table.tables.map(table => {
            const columns = table.columns.map(column => {
                return {
                    name: column.name,
                    dataType: column.dataType,
                    default: column.default,
                    comment: column.comment,
                    primaryKey: column.option.primaryKey,
                    autoIncrement: column.option.autoIncrement,
                    unique: column.option.unique,
                    nullable: !column.option.notNull,
                    id: column.id,
                };
            });
            var createTable = {
                type: 'create.table',
                id: table.id,
                columns: columns,
                comment: table.comment,
                foreignKeys: [],
                indexes: [],
                name: table.name,
                visible: table.visible,
            };
            return createTable;
        }));
        shape.indexes.push(...table.indexes.map(index => {
            const indexedTable = getData(table.tables, index.tableId);
            const indexedColumns = [];
            if (indexedTable) {
                index.columns.forEach(col => {
                    const column = getData(indexedTable.columns, col.id);
                    if (column)
                        indexedColumns.push({ name: column.name, sort: col.orderType });
                });
            }
            var createIndex = {
                type: 'create.index',
                id: index.id,
                name: index.name,
                unique: index.unique,
                tableName: (indexedTable === null || indexedTable === void 0 ? void 0 : indexedTable.name) || '',
                columns: indexedColumns,
            };
            return createIndex;
        }));
        shape.foreignKeys.push(...relationship.relationships.map(relationship => {
            var _a;
            const baseTable = getData(table.tables, relationship.end.tableId);
            const baseColumnNames = relationship.end.columnIds.map(colId => {
                var _a;
                return ((_a = getData((baseTable === null || baseTable === void 0 ? void 0 : baseTable.columns) || [], colId)) === null || _a === void 0 ? void 0 : _a.name) || '';
            });
            const refTable = getData(table.tables, relationship.start.tableId);
            const refColumnNames = relationship.start.columnIds.map(colId => {
                var _a;
                return ((_a = getData((refTable === null || refTable === void 0 ? void 0 : refTable.columns) || [], colId)) === null || _a === void 0 ? void 0 : _a.name) || '';
            });
            const fk = {
                type: 'alter.table.add.foreignKey',
                id: relationship.id,
                name: (baseTable === null || baseTable === void 0 ? void 0 : baseTable.name) || '',
                columnNames: baseColumnNames,
                refTableName: (refTable === null || refTable === void 0 ? void 0 : refTable.name) || '',
                refColumnNames: refColumnNames,
                constraintName: (_a = relationship.constraintName) !== null && _a !== void 0 ? _a : '',
                visible: relationship.visible,
            };
            return fk;
        }));
        return shape;
    }
    function createJsonFormat$1(canvasSize, database, originalCanvas, originalMemo) {
        const canvas = createCanvasState();
        canvas.width = canvasSize;
        canvas.height = canvasSize;
        canvas.database = database;
        return {
            canvas: originalCanvas ? originalCanvas : canvas,
            table: createTableState(),
            memo: originalMemo ? originalMemo : createMemoState(),
            relationship: createRelationshipState(),
        };
    }
    function createJson(statements, helper, database, snapshot) {
        var shape;
        if (snapshot) {
            shape = snapshotToShape(snapshot);
            shape = reshape(statements, shape);
        }
        else {
            shape = reshape(statements);
        }
        const tables = mergeTable(shape);
        let canvasSize = tables.length * 100;
        if (canvasSize < SIZE_CANVAS_MIN) {
            canvasSize = SIZE_CANVAS_MIN;
        }
        if (canvasSize > SIZE_CANVAS_MAX) {
            canvasSize = SIZE_CANVAS_MAX;
        }
        var store;
        if (snapshot) {
            store = createJsonFormat$1(canvasSize, database, snapshot.canvas, snapshot.memo);
        }
        else {
            store = createJsonFormat$1(canvasSize, database);
        }
        tables.forEach(table => {
            store.table.tables.push(createTable(helper, table, snapshot === null || snapshot === void 0 ? void 0 : snapshot.table.tables));
        });
        createRelationship(store, tables);
        createIndex(store, tables);
        return JSON.stringify(store);
    }
    function createTable(helper, table, snapTables) {
        const originalTable = findByName(snapTables || [], table.name);
        const newTable = {
            id: table.id || v4(),
            name: table.name,
            comment: table.comment,
            columns: [],
            ui: originalTable
                ? originalTable.ui
                : {
                    active: false,
                    top: 0,
                    left: 0,
                    widthName: SIZE_MIN_WIDTH,
                    widthComment: SIZE_MIN_WIDTH,
                    zIndex: 2,
                },
            visible: table.visible === undefined ? true : table.visible,
        };
        const widthName = helper.getFastTextWidth(newTable.name);
        if (SIZE_MIN_WIDTH < widthName) {
            newTable.ui.widthName = widthName;
        }
        const widthComment = helper.getFastTextWidth(newTable.comment);
        if (SIZE_MIN_WIDTH < widthComment) {
            newTable.ui.widthComment = widthComment;
        }
        table.columns.forEach(column => {
            newTable.columns.push(createColumn(helper, column));
        });
        return newTable;
    }
    function createColumn(helper, column) {
        const newColumn = {
            id: column.id || v4(),
            name: column.name,
            comment: column.comment,
            dataType: column.dataType,
            default: column.default,
            option: {
                autoIncrement: column.autoIncrement,
                primaryKey: column.primaryKey,
                unique: column.unique,
                notNull: !column.nullable,
            },
            ui: {
                active: false,
                pk: column.primaryKey,
                fk: false,
                pfk: false,
                widthName: SIZE_MIN_WIDTH,
                widthComment: SIZE_MIN_WIDTH,
                widthDataType: SIZE_MIN_WIDTH,
                widthDefault: SIZE_MIN_WIDTH,
            },
        };
        const widthName = helper.getFastTextWidth(newColumn.name);
        if (SIZE_MIN_WIDTH < widthName) {
            newColumn.ui.widthName = widthName;
        }
        const widthComment = helper.getFastTextWidth(newColumn.comment);
        if (SIZE_MIN_WIDTH < widthComment) {
            newColumn.ui.widthComment = widthComment;
        }
        const widthDataType = helper.getFastTextWidth(newColumn.dataType);
        if (SIZE_MIN_WIDTH < widthDataType) {
            newColumn.ui.widthDataType = widthDataType;
        }
        const widthDefault = helper.getFastTextWidth(newColumn.default);
        if (SIZE_MIN_WIDTH < widthDefault) {
            newColumn.ui.widthDefault = widthDefault;
        }
        return newColumn;
    }
    function createRelationship(data, tables) {
        tables.forEach(table => {
            if (table.foreignKeys) {
                const endTable = findByName(data.table.tables, table.name);
                if (endTable) {
                    table.foreignKeys.forEach(foreignKey => {
                        const startTable = findByName(data.table.tables, foreignKey.refTableName);
                        if (startTable) {
                            const startColumns = [];
                            const endColumns = [];
                            foreignKey.refColumnNames.forEach(refColumnName => {
                                const column = findByName(startTable.columns, refColumnName);
                                if (column) {
                                    startColumns.push(column);
                                }
                            });
                            foreignKey.columnNames.forEach(columnName => {
                                const column = findByName(endTable.columns, columnName);
                                if (column) {
                                    endColumns.push(column);
                                    if (column.ui.pk) {
                                        column.ui.pk = false;
                                        column.ui.pfk = true;
                                    }
                                    else {
                                        column.ui.fk = true;
                                    }
                                }
                            });
                            if (startTable.visible && endTable.visible) {
                                foreignKey.visible = true;
                            }
                            else {
                                foreignKey.visible = false;
                            }
                            data.relationship.relationships.push({
                                id: foreignKey.id || v4(),
                                identification: !endColumns.some(column => !column.ui.pfk),
                                relationshipType: 'ZeroOneN',
                                start: {
                                    tableId: startTable.id,
                                    columnIds: startColumns.map(column => column.id),
                                    x: 0,
                                    y: 0,
                                    direction: 'top',
                                },
                                end: {
                                    tableId: endTable.id,
                                    columnIds: endColumns.map(column => column.id),
                                    x: 0,
                                    y: 0,
                                    direction: 'top',
                                },
                                constraintName: foreignKey.constraintName,
                                visible: foreignKey.visible,
                            });
                        }
                    });
                }
            }
        });
    }
    function createIndex(data, tables) {
        tables.forEach(table => {
            if (table.indexes) {
                table.indexes.forEach(index => {
                    const targetTable = findByName(data.table.tables, table.name);
                    if (targetTable) {
                        const indexColumns = [];
                        index.columns.forEach(column => {
                            const targetColumn = findByName(targetTable.columns, column.name);
                            if (targetColumn) {
                                indexColumns.push({
                                    id: targetColumn.id,
                                    orderType: column.sort,
                                });
                            }
                        });
                        if (indexColumns.length !== 0) {
                            data.table.indexes.push({
                                id: index.id || v4(),
                                name: index.name,
                                tableId: targetTable.id,
                                columns: indexColumns,
                                unique: index.unique,
                            });
                        }
                    }
                });
            }
        });
    }

    function calculateLatestDiff(context) {
        const newest = createStoreCopy(context.store);
        const snapshot = getLatestSnapshot(context);
        if (!snapshot)
            return [];
        const diffs = calculateDiff(snapshot, { data: newest });
        return diffs;
    }
    function calculateDiff({ data: oldSnapshot }, { data: newSnapshot }) {
        const newTables = newSnapshot.table.tables;
        const oldTables = oldSnapshot.table.tables;
        const newRelationships = newSnapshot.relationship.relationships;
        const oldRelationships = oldSnapshot.relationship.relationships;
        const newIndexes = newSnapshot.table.indexes;
        const oldIndexes = oldSnapshot.table.indexes;
        const diffs = [];
        // TABLES
        newTables.forEach(newTable => {
            var oldTable = getData(oldTables, newTable.id);
            if (!oldTable)
                diffs.push({
                    type: 'table',
                    changes: 'add',
                    newTable: newTable,
                });
            // table was modified
            else if (oldTable != newTable) {
                // check columns
                newTable.columns.forEach(newColumn => {
                    var oldColumn = getData(oldTable ? oldTable === null || oldTable === void 0 ? void 0 : oldTable.columns : [], newColumn.id);
                    // column is new
                    if (!oldColumn)
                        diffs.push({
                            type: 'column',
                            changes: 'add',
                            table: newTable,
                            newColumn: newColumn,
                        });
                    // column was modified
                    else if ((oldColumn === null || oldColumn === void 0 ? void 0 : oldColumn.dataType) !== newColumn.dataType ||
                        (oldColumn === null || oldColumn === void 0 ? void 0 : oldColumn.name) !== newColumn.name ||
                        !isEqual_1(oldColumn === null || oldColumn === void 0 ? void 0 : oldColumn.option, newColumn.option)) {
                        diffs.push({
                            type: 'column',
                            changes: 'modify',
                            table: newTable,
                            oldColumn: oldColumn,
                            newColumn: newColumn,
                        });
                    }
                });
                // check for drop column
                oldTable === null || oldTable === void 0 ? void 0 : oldTable.columns.forEach(oldColumn => {
                    var newColumn = getData(newTable.columns, oldColumn.id);
                    // if drop column
                    if (!newColumn && oldTable) {
                        diffs.push({
                            type: 'column',
                            changes: 'remove',
                            table: oldTable,
                            oldColumn: oldColumn,
                        });
                    }
                });
                // if rename table
                if (oldTable && oldTable.name !== newTable.name) {
                    diffs.push({
                        type: 'table',
                        changes: 'modify',
                        oldTable: oldTable,
                        newTable: newTable,
                    });
                }
            }
        });
        // check for drop table
        oldTables.forEach(oldTable => {
            var newTable = getData(newTables, oldTable.id);
            // old table was dropped
            if (!newTable)
                diffs.push({
                    type: 'table',
                    changes: 'remove',
                    oldTable: oldTable,
                });
        });
        // INDEXES
        if (newIndexes != oldIndexes) {
            // check for new index
            newIndexes.forEach(newIndex => {
                const oldIndex = getData(oldIndexes, newIndex.id);
                // if new index
                if (oldIndex === undefined) {
                    var newTable = getData(newTables, newIndex.tableId);
                    if (newTable)
                        diffs.push({
                            type: 'index',
                            changes: 'add',
                            newIndex: newIndex,
                            table: newTable,
                        });
                }
            });
            // check for drop index
            oldIndexes.forEach(oldIndex => {
                const newIndex = getData(newIndexes, oldIndex.id);
                // if drop index
                if (newIndex === undefined) {
                    const oldTable = getData(oldTables, oldIndex.tableId);
                    if (oldTable)
                        diffs.push({
                            type: 'index',
                            changes: 'remove',
                            oldIndex: oldIndex,
                            table: oldTable,
                        });
                }
            });
        }
        // RELATIONSHIP
        if (newRelationships != oldRelationships) {
            // relationship drop
            oldRelationships.forEach(oldRelationship => {
                const newRelationship = getData(newRelationships, oldRelationship.id);
                if (!newRelationship) {
                    const table = getData(oldTables, oldRelationship.end.tableId);
                    if (!table)
                        return;
                    diffs.push({
                        type: 'relationship',
                        changes: 'remove',
                        oldRelationship: oldRelationship,
                        table: table,
                    });
                }
            });
            // add relationship
            newRelationships.forEach(newRelationship => {
                const oldRelationship = getData(oldRelationships, newRelationship.id);
                if (!oldRelationship) {
                    const startTable = getData(newTables, newRelationship.start.tableId);
                    const endTable = getData(newTables, newRelationship.end.tableId);
                    if (!startTable || !endTable)
                        return;
                    diffs.push({
                        type: 'relationship',
                        changes: 'add',
                        newRelationship: newRelationship,
                        startTable: startTable,
                        endTable: endTable,
                    });
                }
            });
        }
        return diffs;
    }
    function mergeDiffs(...diffs) {
        let currentDiffs = [];
        diffs.reverse().forEach((changes, index) => {
            if (index === 0) {
                currentDiffs = changes;
            }
            else {
                changes.forEach(diff => {
                    // TODO: add more checks
                    // deduplication
                    //  --  add table ONE -> drop table ONE -> should result to: no change
                    //  --  add table ONE -> rename table ONE to TWO -> should result to: add table TWO
                    if (diff.type === 'table' && diff.changes === 'remove') {
                        currentDiffs = currentDiffs.filter(origDiff => !(origDiff.type === 'table' &&
                            origDiff.changes === 'add' &&
                            origDiff.newTable.name === diff.oldTable.name));
                    }
                    else if (diff.type === 'column' && diff.changes === 'remove') {
                        currentDiffs = currentDiffs.filter(origDiff => !(origDiff.type === 'column' &&
                            origDiff.changes === 'add' &&
                            origDiff.newColumn.name === diff.oldColumn.name));
                    }
                    else {
                        currentDiffs.push(diff);
                    }
                });
            }
        });
        return currentDiffs;
    }
    function statementsToDiff(snapshot, context) {
        var _a;
        if (!((_a = snapshot.metadata) === null || _a === void 0 ? void 0 : _a.statements))
            return [];
        const { helper } = context;
        const statements = snapshot.metadata.statements;
        const diffs = [];
        const { tables: snapTables, indexes: snapIndexes } = snapshot.data.table;
        const { relationships: snapRelationships } = snapshot.data.relationship;
        statements.forEach(statement => {
            switch (statement.type) {
                case 'create.table':
                    const table = statement;
                    const originalTable = findByName(snapTables || [], table.name);
                    const columns = table.columns.map(column => {
                        const newColumn = {
                            id: column.id || v4(),
                            name: column.name,
                            comment: column.comment,
                            dataType: column.dataType,
                            default: column.default,
                            option: {
                                autoIncrement: column.autoIncrement,
                                primaryKey: column.primaryKey,
                                unique: column.unique,
                                notNull: !column.nullable,
                            },
                            ui: {
                                active: false,
                                pk: column.primaryKey,
                                fk: false,
                                pfk: false,
                                widthName: SIZE_MIN_WIDTH,
                                widthComment: SIZE_MIN_WIDTH,
                                widthDataType: SIZE_MIN_WIDTH,
                                widthDefault: SIZE_MIN_WIDTH,
                            },
                        };
                        return newColumn;
                    });
                    const loadTable = {
                        id: table.id || v4(),
                        name: table.name,
                        comment: table.comment,
                        columns: columns,
                        ui: originalTable
                            ? originalTable.ui
                            : {
                                active: false,
                                top: 0,
                                left: 0,
                                widthName: SIZE_MIN_WIDTH,
                                widthComment: SIZE_MIN_WIDTH,
                                zIndex: 2,
                            },
                    };
                    const canvasState = context.store.canvasState;
                    const newTable = new TableModel({ loadTable: loadTable }, canvasState.show);
                    diffs.push({
                        type: 'table',
                        changes: 'add',
                        newTable: newTable,
                    });
                    break;
                case 'create.index':
                    const index = statement;
                    const duplicateIndex = findByName(snapIndexes, index.name);
                    const targetTable = findByName(snapTables, index.tableName);
                    if (duplicateIndex && targetTable) {
                        diffs.push({
                            type: 'index',
                            changes: 'add',
                            newIndex: duplicateIndex,
                            table: targetTable,
                        });
                        break;
                    }
                    if (!targetTable)
                        break;
                    const indexColumns = [];
                    index.columns.forEach(column => {
                        const targetColumn = findByName(targetTable.columns, column.name);
                        if (targetColumn) {
                            indexColumns.push({
                                id: targetColumn.id,
                                orderType: column.sort,
                            });
                        }
                    });
                    diffs.push({
                        type: 'index',
                        changes: 'add',
                        newIndex: {
                            id: index.id || v4(),
                            name: index.name,
                            tableId: targetTable.id,
                            columns: indexColumns,
                            unique: index.unique,
                        },
                        table: targetTable,
                    });
                    break;
                case 'alter.table.add.primaryKey':
                    const primaryKey = statement;
                    const pkTable = findByName(snapTables, primaryKey.name);
                    if (!pkTable)
                        break;
                    primaryKey.columnNames.forEach(pkColumnName => {
                        const oldPKColumn = findByName(pkTable.columns, pkColumnName);
                        if (!oldPKColumn)
                            return;
                        const newPKColumn = cloneDeep(oldPKColumn);
                        newPKColumn.option.primaryKey = true;
                        diffs.push({
                            type: 'column',
                            changes: 'modify',
                            table: pkTable,
                            oldColumn: oldPKColumn,
                            newColumn: newPKColumn,
                        });
                    });
                    break;
                case 'alter.table.add.foreignKey':
                    const foreignKey = statement;
                    const endTable = findByName(snapTables, foreignKey.name);
                    const startTable = findByName(snapTables, foreignKey.refTableName);
                    if (endTable && startTable) {
                        const startColumns = [];
                        const endColumns = [];
                        foreignKey.refColumnNames.forEach(refColumnName => {
                            const column = findByName(startTable.columns, refColumnName);
                            if (column) {
                                startColumns.push(column);
                            }
                        });
                        foreignKey.columnNames.forEach(columnName => {
                            const column = findByName(endTable.columns, columnName);
                            if (column) {
                                endColumns.push(column);
                                if (column.ui.pk) {
                                    column.ui.pk = false;
                                    column.ui.pfk = true;
                                }
                                else {
                                    column.ui.fk = true;
                                }
                            }
                        });
                        if (startTable.visible && endTable.visible) {
                            foreignKey.visible = true;
                        }
                        else {
                            foreignKey.visible = false;
                        }
                        const newRelationship = {
                            id: foreignKey.id || v4(),
                            identification: !endColumns.some(column => !column.ui.pfk),
                            relationshipType: 'ZeroOneN',
                            start: {
                                tableId: startTable.id,
                                columnIds: startColumns.map(column => column.id),
                                x: 0,
                                y: 0,
                                direction: 'top',
                            },
                            end: {
                                tableId: endTable.id,
                                columnIds: endColumns.map(column => column.id),
                                x: 0,
                                y: 0,
                                direction: 'top',
                            },
                            constraintName: foreignKey.constraintName,
                            visible: foreignKey.visible,
                        };
                        diffs.push({
                            type: 'relationship',
                            changes: 'add',
                            newRelationship: newRelationship,
                            startTable: startTable,
                            endTable: endTable,
                        });
                    }
                    break;
                case 'alter.table.add.unique':
                    const unique = statement;
                    const uqTable = findByName(snapTables, unique.name);
                    if (!uqTable)
                        break;
                    unique.columnNames.forEach(uqColumnName => {
                        const oldUQColumn = findByName(uqTable.columns, uqColumnName);
                        if (!oldUQColumn)
                            return;
                        const newUQColumn = cloneDeep(oldUQColumn);
                        newUQColumn.option.unique = true;
                        diffs.push({
                            type: 'column',
                            changes: 'modify',
                            table: uqTable,
                            oldColumn: oldUQColumn,
                            newColumn: newUQColumn,
                        });
                    });
                    break;
                case 'alter.table.add.column':
                    const addColumns = statement;
                    const acTable = findByName(snapTables, addColumns.name);
                    if (!acTable)
                        break;
                    addColumns.columns.forEach(col => {
                        const addColumn = createColumn(helper, col);
                        diffs.push({
                            type: 'column',
                            changes: 'add',
                            table: acTable,
                            newColumn: addColumn,
                        });
                    });
                    break;
                case 'alter.table.drop.column':
                    const dropColumns = statement;
                    const dcTable = findByName(snapTables, dropColumns.name);
                    dcTable === null || dcTable === void 0 ? void 0 : dcTable.columns.forEach(col => {
                        diffs.push({
                            type: 'column',
                            changes: 'remove',
                            table: dcTable,
                            oldColumn: col,
                        });
                    });
                    break;
                case 'drop.table':
                    const { name: tableName } = statement;
                    const dropTable = findByName(snapTables, tableName);
                    if (dropTable) {
                        diffs.push({
                            type: 'table',
                            changes: 'remove',
                            oldTable: dropTable,
                        });
                    }
                    break;
                case 'alter.table.drop.foreignKey':
                    const dropForeignKey = statement;
                    const duplicateDropFK = findByConstraintName(snapRelationships, dropForeignKey.name);
                    if (!duplicateDropFK)
                        break;
                    const dfkTable = getData(snapTables, duplicateDropFK.end.tableId);
                    if (!dfkTable)
                        break;
                    diffs.push({
                        type: 'relationship',
                        changes: 'remove',
                        oldRelationship: duplicateDropFK,
                        table: dfkTable,
                    });
                    break;
            }
        });
        return diffs;
    }

    const dialectTo = 'postgresql';
    const defaultDialect = 'postgresql';
    /**
     * Parser for Liquibase XML file
     * @param input Entire XML file
     * @param dialect Dialect that the result will have datataypes in
     * @returns List of Statements to execute
     */
    const LiquibaseParser = (context, files, dialect = defaultDialect, rootFile) => {
        const { store, eventBus, helper } = context;
        const zoom = JSON.parse(JSON.stringify(store.canvasState.zoomLevel));
        store.dispatchSync(zoomCanvas(0.7));
        store.canvasState.zoomLevel = 0.7;
        createSnapshot(context, {
            filename: (rootFile === null || rootFile === void 0 ? void 0 : rootFile.path) || '',
            type: (rootFile === null || rootFile === void 0 ? void 0 : rootFile.path) ? 'before-import' : 'user',
        });
        setTimeout(async () => {
            async function parseFile(file) {
                eventBus.emit(Bus.Liquibase.progress, file.path);
                // workaround so code is non-blocking
                await new Promise(resolve => setTimeout(resolve, 0));
                var parser = new DOMParser();
                var xmlDoc = parser.parseFromString(file.value, 'text/xml');
                const databaseChangeLog = xmlDoc.querySelector('databaseChangeLog');
                if (!databaseChangeLog)
                    return;
                for (const element of databaseChangeLog.children) {
                    if (element.tagName === 'changeSet') {
                        handleChangeSetParsing(element, file);
                    }
                    else if (element.tagName === 'include') {
                        await handleImportParsing(element, file);
                    }
                }
            }
            async function handleImportParsing(include, file) {
                const fileName = include.getAttribute('file');
                var myDirectory = file.path.split('/').slice(0, -1).join('/');
                if (myDirectory)
                    myDirectory += '/';
                const dstDirectory = `${myDirectory}${fileName}`;
                const dstFile = files.find(file => file.path === dstDirectory);
                if (dstFile)
                    await parseFile(dstFile);
            }
            function handleChangeSetParsing(element, file) {
                const dbms = element.getAttribute('dbms') || '';
                if (dbms === '' || dbms == dialect) {
                    var statements = [];
                    if (parseChangeSet(element, statements, dialect)) {
                        createSnapshot(context, {
                            filename: file.path,
                            type: 'before-import',
                            statements: statements,
                        });
                        applyStatements(context, statements);
                    }
                }
            }
            if (rootFile) {
                await parseFile(rootFile);
            }
            else {
                for (const file of files) {
                    await parseFile(file);
                }
            }
            eventBus.emit(Bus.Liquibase.progressEnd);
            setTimeout(async () => {
                store.dispatchSync(zoomCanvas(zoom));
                createSnapshot(context, {
                    filename: (rootFile === null || rootFile === void 0 ? void 0 : rootFile.path) || '',
                    type: 'after-import',
                });
            }, 0);
        }, 10);
    };
    const applyStatements = (context, statements) => {
        var { store, helper } = context;
        const json = createJson(statements, helper, store.canvasState.database, getLatestSnapshot(context).data);
        store.dispatchSync(initLoadJson$(json));
    };
    const parseChangeSet = (changeSet, statements, dialect) => {
        if (!checkPreConditions(changeSet, dialect))
            return false;
        function parse(operation) {
            parseElement(operation, changeSet, statements, parsers[operation], dialect);
        }
        parse('createTable');
        parse('createIndex');
        parse('addForeignKeyConstraint');
        parse('addPrimaryKey');
        parse('addColumn');
        parse('dropColumn');
        parse('dropTable');
        parse('dropForeignKeyConstraint');
        parse('addUniqueConstraint');
        return true;
    };
    const checkPreConditions = (changeSet, dialect) => {
        const preConditions = changeSet.getElementsByTagName('preConditions')[0];
        if (!preConditions)
            return true;
        const preConditionsOr = preConditions.getElementsByTagName('or')[0];
        var preConditionsDbms;
        if (preConditionsOr) {
            preConditionsDbms = preConditionsOr.getElementsByTagName('dbms');
        }
        else {
            preConditionsDbms = preConditions.getElementsByTagName('dbms');
        }
        for (const dbms of preConditionsDbms) {
            if (dbms.getAttribute('type') === dialect) {
                return true;
            }
        }
        return false;
    };
    const parseElement = (type, element, statements, parser, dialect) => {
        const elements = element.getElementsByTagName(type);
        for (let i = 0; i < elements.length; i++) {
            parser(elements[i], statements, dialect);
        }
    };
    const parseCreateTable = (createTable, statements, dialect = defaultDialect) => {
        var columns = parseColumns(createTable, dialect);
        statements.push({
            type: 'create.table',
            name: createTable.getAttribute('tableName') || '',
            comment: createTable.getAttribute('remarks') || '',
            columns: columns,
            indexes: [],
            foreignKeys: [],
        });
    };
    const parseColumns = (element, dialect) => {
        var columns = [];
        const cols = element.getElementsByTagName('column');
        for (let i = 0; i < cols.length; i++) {
            columns.push(parseSingleColumn(cols[i], dialect));
        }
        return columns;
    };
    const parseSingleColumn = (column, dialect) => {
        const constr = column.getElementsByTagName('constraints')[0];
        var constraints;
        if (constr) {
            constraints = {
                primaryKey: constr.getAttribute('primaryKey') === 'true',
                nullable: !(constr.getAttribute('nullable') === 'true'),
                unique: constr.getAttribute('unique') === 'true',
            };
        }
        else {
            constraints = {
                primaryKey: false,
                nullable: true,
                unique: false,
            };
        }
        var dataType = translate(dialect, dialectTo, column.getAttribute('type') || '');
        return {
            name: column.getAttribute('name') || '',
            dataType: dataType,
            default: column.getAttribute('defaultValue') || '',
            comment: column.getAttribute('remarks') || '',
            primaryKey: constraints.primaryKey,
            autoIncrement: column.getAttribute('autoIncrement') === 'true',
            unique: constraints.unique,
            nullable: constraints.nullable,
        };
    };
    const parseSingleIndexColumn = (column) => {
        return {
            name: column.getAttribute('name') || '',
            sort: column.getAttribute('descending') ? 'DESC' : 'ASC',
        };
    };
    const parseCreateIndex = (createIndex, statements) => {
        var indexColumns = [];
        const cols = createIndex.getElementsByTagName('column');
        for (let i = 0; i < cols.length; i++) {
            indexColumns.push(parseSingleIndexColumn(cols[i]));
        }
        statements.push({
            type: 'create.index',
            name: createIndex.getAttribute('indexName') || '',
            unique: createIndex.getAttribute('unique') === 'true',
            tableName: createIndex.getAttribute('tableName') || '',
            columns: indexColumns,
        });
    };
    const parseAddForeignKeyConstraint = (addForeignKey, statements) => {
        var _a, _b;
        var refColumnNames = ((_a = addForeignKey
            .getAttribute('referencedColumnNames')) === null || _a === void 0 ? void 0 : _a.split(',').map(item => item.trim())) || [];
        var columnNames = ((_b = addForeignKey
            .getAttribute('baseColumnNames')) === null || _b === void 0 ? void 0 : _b.split(',').map(item => item.trim())) || [];
        statements.push({
            type: 'alter.table.add.foreignKey',
            name: addForeignKey.getAttribute('baseTableName') || '',
            columnNames: columnNames,
            refTableName: addForeignKey.getAttribute('referencedTableName') || '',
            refColumnNames: refColumnNames,
            constraintName: addForeignKey.getAttribute('constraintName') || '',
        });
    };
    const parseAddPrimaryKey = (addPrimaryKey, statements) => {
        var _a;
        var columnNames = ((_a = addPrimaryKey
            .getAttribute('columnNames')) === null || _a === void 0 ? void 0 : _a.split(',').map(item => item.trim())) || [];
        statements.push({
            type: 'alter.table.add.primaryKey',
            name: addPrimaryKey.getAttribute('tableName') || '',
            columnNames: columnNames,
        });
    };
    const parseAddColumn = (addColumn, statements, dialect = defaultDialect) => {
        const tableName = addColumn.getAttribute('tableName') || '';
        statements.push({
            type: 'alter.table.add.column',
            name: tableName,
            columns: parseColumns(addColumn, dialect),
        });
    };
    const parseDropColumn = (dropColumn, statements, dialect = defaultDialect) => {
        const tableName = dropColumn.getAttribute('tableName') || '';
        const column = {
            name: dropColumn.getAttribute('columnName') || '',
            dataType: '',
            default: '',
            comment: '',
            primaryKey: false,
            autoIncrement: false,
            unique: false,
            nullable: false,
        };
        statements.push({
            type: 'alter.table.drop.column',
            name: tableName,
            columns: [column, ...parseColumns(dropColumn, dialect)],
        });
    };
    const parseDropTable = (dropTable, statements) => {
        const tableName = dropTable.getAttribute('tableName') || '';
        statements.push({
            type: 'drop.table',
            name: tableName,
        });
    };
    const parseDropForeignKeyConstraint = (dropFk, statements) => {
        statements.push({
            type: 'alter.table.drop.foreignKey',
            name: dropFk.getAttribute('constraintName') || '',
            baseTableName: dropFk.getAttribute('baseTableName') || '',
        });
    };
    const parseAddUniqueConstraint = (addUniqueConstraint, statements) => {
        const columnNames = addUniqueConstraint.getAttribute('columnNames');
        if (!columnNames)
            return;
        const columns = columnNames.split(',').map(col => col.trim());
        statements.push({
            type: 'alter.table.add.unique',
            name: addUniqueConstraint.getAttribute('tableName') || '',
            columnNames: columns,
        });
    };
    const parsers = {
        createTable: parseCreateTable,
        createIndex: parseCreateIndex,
        addForeignKeyConstraint: parseAddForeignKeyConstraint,
        addPrimaryKey: parseAddPrimaryKey,
        addColumn: parseAddColumn,
        dropColumn: parseDropColumn,
        dropTable: parseDropTable,
        dropForeignKeyConstraint: parseDropForeignKeyConstraint,
        addUniqueConstraint: parseAddUniqueConstraint,
    };

    let executeExportFileExtra = null;
    let executeImportFileExtra = null;
    const createJsonFormat = ({ canvasState, tableState, memoState, relationshipState, }) => ({
        canvas: canvasState,
        table: tableState,
        memo: memoState,
        relationship: relationshipState,
    });
    function createSnapshot(context, metadata) {
        context.snapshots.push({
            data: createStoreCopy(context.store),
            metadata: metadata,
        });
    }
    function createStoreCopy(store) {
        return JSON.parse(createJsonStringify(store));
    }
    const createJsonStringify = (store, space) => JSON.stringify(createJsonFormat(store), (key, value) => (key.startsWith('_') ? undefined : value), space);
    function exportPNG(root, name) {
        const options = {
            fileName: (name === null || name === void 0 ? void 0 : name.trim()) === ''
                ? `unnamed-${new Date().getTime()}.png`
                : `${name}-${new Date().getTime()}.png`,
        };
        domToImage.toBlob(root).then(blob => {
            executeExport(blob, options);
        });
    }
    const exportJSON = (json, name) => {
        const options = {
            fileName: (name === null || name === void 0 ? void 0 : name.trim()) === ''
                ? `unnamed-${new Date().getTime()}.vuerd.json`
                : `${name}-${new Date().getTime()}.vuerd.json`,
        };
        executeExport(new Blob([json], { type: 'application/json' }), options);
    };
    const exportSQLDDL = (sql, name) => {
        const options = {
            fileName: (name === null || name === void 0 ? void 0 : name.trim()) === ''
                ? `unnamed-${new Date().getTime()}.sql`
                : `${name}-${new Date().getTime()}.sql`,
        };
        executeExport(new Blob([sql]), options);
    };
    const exportXML = (xml, name, saveDirectly) => {
        const options = {
            saveDirectly: name ? true : false,
            fileName: (name === null || name === void 0 ? void 0 : name.trim()) === '' ? `unnamed-${new Date().getTime()}.xml` : `${name}`,
        };
        if (xml)
            executeExport(new Blob([xml]), options);
    };
    const executeExport = (blob, options) => executeExportFileExtra
        ? executeExportFileExtra(blob, options)
        : executeExportBuiltin(blob, options);
    function executeExportBuiltin(blob, options) {
        const exportHelper = document.createElement('a');
        exportHelper.href = window.URL.createObjectURL(blob);
        exportHelper.download = options.fileName;
        exportHelper.click();
    }
    function setExportFileCallback(callback) {
        executeExportFileExtra = callback;
    }
    function setImportFileCallback(callback) {
        executeImportFileExtra = callback;
    }
    function importJSON({ store, eventBus }) {
        if (executeImportFileExtra) {
            executeImportFileExtra({ accept: '.json', type: 'json' });
            return;
        }
        const importHelperJSON = document.createElement('input');
        importHelperJSON.setAttribute('type', 'file');
        importHelperJSON.setAttribute('accept', '.json');
        importHelperJSON.addEventListener('change', event => {
            const input = event.target;
            if (input.files && input.files.length) {
                const file = input.files[0];
                if (/\.(json)$/i.test(file.name)) {
                    const reader = new FileReader();
                    reader.readAsText(file);
                    reader.onload = () => {
                        const value = reader.result;
                        if (typeof value === 'string') {
                            store.dispatch(loadJson$(value));
                        }
                    };
                }
                else {
                    eventBus.emit(Bus.ToastBar.add, {
                        bodyTpl: html `Just import the json file`,
                    });
                }
            }
        });
        importHelperJSON.click();
    }
    function importSQLDDL(context) {
        if (executeImportFileExtra) {
            executeImportFileExtra({ accept: '.sql', type: 'sql' });
            return;
        }
        const importHelper = document.createElement('input');
        importHelper.setAttribute('type', 'file');
        importHelper.setAttribute('accept', `.sql`);
        importHelper.addEventListener('change', event => {
            const input = event.target;
            if (input.files && input.files.length) {
                const file = input.files[0];
                const { helper, store, eventBus } = context;
                if (/\.(sql)$/i.test(file.name)) {
                    const reader = new FileReader();
                    reader.readAsText(file);
                    reader.onload = () => {
                        const value = reader.result;
                        if (typeof value === 'string') {
                            const statements = DDLParser(value);
                            const json = createJson(
                            // @ts-ignore
                            statements, helper, store.canvasState.database);
                            store.dispatchSync(loadJson$(json), sortTable());
                            createSnapshot(context);
                        }
                    };
                }
                else {
                    eventBus.emit(Bus.ToastBar.add, {
                        bodyTpl: html `Just import the sql file`,
                    });
                }
            }
        });
        importHelper.click();
    }
    function importLiquibase(context, dialect) {
        if (calculateLatestDiff(context).length === 0 ||
            window.confirm('Found changes, are you sure you want to loose them? If you want to save changes (diff), please, make sure to EXPORT them first.\nPress OK to continue importing file, press CANCEL to abort importing.')) {
            const importHelper = document.createElement('input');
            importHelper.setAttribute('type', 'file');
            importHelper.setAttribute('multiple', 'true');
            importHelper.setAttribute('accept', `.xml`);
            importHelper.addEventListener('change', async (event) => {
                const input = event.target;
                if (input.files && input.files.length) {
                    const files = Array.from(input.files).sort((a, b) => a.name.localeCompare(b.name));
                    var liquiFiles = [];
                    for (const file of files) {
                        try {
                            liquiFiles.push({
                                path: file.name,
                                value: await loadFileSync(file, 'xml'),
                            });
                        }
                        catch (e) { }
                    }
                    LiquibaseParser(context, liquiFiles, dialect);
                }
            });
            importHelper.click();
        }
    }
    async function loadFileSync(file, type) {
        const regex = new RegExp(`\.(${type})$`, 'i');
        if (regex.test(file.name)) {
            return await new Promise(resolve => {
                let reader = new FileReader();
                reader.readAsText(file);
                reader.onload = () => {
                    const value = reader.result;
                    if (typeof value === 'string')
                        resolve(value);
                };
            });
        }
        else
            throw new Error();
    }
    function loadLiquibaseChangelog(context, { files, type }, dialect) {
        var root = undefined;
        if (type === 'vscode' && files[0].path === 'changelog.xml') {
            root = files[0];
        }
        LiquibaseParser(context, files, dialect, root);
    }

    function executeLoadJson(store, batchUndoCommand) {
        batchUndoCommand.push(loadJson$(createJsonStringify(store)));
    }
    function executeClear(store, batchUndoCommand) {
        batchUndoCommand.push(loadJson$(createJsonStringify(store)));
    }
    const executeEditorCommandMap = {
        'editor.loadJson': executeLoadJson,
        'editor.clear': executeClear,
    };

    function executeAddMemo(store, batchUndoCommand, data) {
        batchUndoCommand.push(removeMemo(store, data.id));
    }
    function executeRemoveMemo({ memoState: { memos } }, batchUndoCommand, { memoIds }) {
        const targetMemos = memoIds
            .map(memoId => getData(memos, memoId))
            .filter(memo => !!memo);
        if (!targetMemos.length)
            return;
        batchUndoCommand.push(...targetMemos.map(memo => loadMemo(cloneDeep(memo))));
    }
    function executeChangeMemoValue({ memoState: { memos } }, batchUndoCommand, data) {
        const memo = getData(memos, data.memoId);
        if (!memo)
            return;
        batchUndoCommand.push(changeMemoValue(memo.id, memo.value));
    }
    const executeMemoCommandMap = {
        'memo.add': executeAddMemo,
        'memo.remove': executeRemoveMemo,
        'memo.changeValue': executeChangeMemoValue,
    };

    function executeAddRelationship(store, batchUndoCommand, data) {
        batchUndoCommand.push(removeRelationship([data.id]));
    }
    function executeRemoveRelationship({ relationshipState: { relationships } }, batchUndoCommand, { relationshipIds }) {
        const targetRelationships = relationshipIds
            .map(id => getData(relationships, id))
            .filter(relationship => !!relationship);
        if (!targetRelationships.length)
            return;
        batchUndoCommand.push(...targetRelationships.map(relationship => loadRelationship(cloneDeep(relationship))));
    }
    function executeChangeRelationshipType({ relationshipState: { relationships } }, batchUndoCommand, data) {
        const relationship = getData(relationships, data.relationshipId);
        if (!relationship)
            return;
        batchUndoCommand.push(createCommand$1('relationship.changeRelationshipType', {
            relationshipId: relationship.id,
            relationshipType: relationship.relationshipType,
        }));
    }
    function executeChangeStartRelationshipType({ relationshipState: { relationships } }, batchUndoCommand, data) {
        var _a;
        const relationship = getData(relationships, data.relationshipId);
        if (!relationship)
            return;
        batchUndoCommand.push(createCommand$1('relationship.changeStartRelationshipType', {
            relationshipId: relationship.id,
            startRelationshipType: (_a = relationship.startRelationshipType) !== null && _a !== void 0 ? _a : 'Dash',
        }));
    }
    function executeChangeIdentification(store, batchUndoCommand, { relationshipId, identification }) {
        batchUndoCommand.push(changeIdentification(relationshipId, !identification));
    }
    function executeHideRelationship(store, batchUndoCommand, { relationshipId }) {
        batchUndoCommand.push(showRelationship(relationshipId));
    }
    function executeShowRelationship(store, batchUndoCommand, { relationshipId }) {
        batchUndoCommand.push(hideRelationship(relationshipId));
    }
    const executeRelationshipCommandMap = {
        'relationship.add': executeAddRelationship,
        'relationship.remove': executeRemoveRelationship,
        'relationship.changeRelationshipType': executeChangeRelationshipType,
        'relationship.changeStartRelationshipType': executeChangeStartRelationshipType,
        'relationship.changeIdentification': executeChangeIdentification,
        'relationship.hide': executeHideRelationship,
        'relationship.show': executeShowRelationship,
    };

    const MOVE_MIN = 20;
    function executeMoveTable(commands, batchUndoCommand, batchRedoCommand) {
        const moveTableCommands = commands.filter(command => command.name === 'table.move');
        if (!moveTableCommands.length)
            return;
        const data = moveTableCommands[0].data;
        const tableIds = data.tableIds;
        const memoIds = data.memoIds;
        let movementX = 0;
        let movementY = 0;
        moveTableCommands.forEach(moveTableCommand => {
            const data = moveTableCommand.data;
            movementX += data.movementX;
            movementY += data.movementY;
        });
        if (Math.abs(movementX) + Math.abs(movementY) < MOVE_MIN)
            return;
        batchUndoCommand.push(createCommand$1('table.move', {
            movementX: -1 * movementX,
            movementY: -1 * movementY,
            tableIds,
            memoIds,
        }));
        batchRedoCommand.push(createCommand$1('table.move', {
            movementX,
            movementY,
            tableIds,
            memoIds,
        }));
    }
    function executeMoveMemo(commands, batchUndoCommand, batchRedoCommand) {
        const moveMemoCommands = commands.filter(command => command.name === 'memo.move');
        if (!moveMemoCommands.length)
            return;
        const data = moveMemoCommands[0].data;
        const tableIds = data.tableIds;
        const memoIds = data.memoIds;
        let movementX = 0;
        let movementY = 0;
        moveMemoCommands.forEach(moveTableCommand => {
            const data = moveTableCommand.data;
            movementX += data.movementX;
            movementY += data.movementY;
        });
        if (Math.abs(movementX) + Math.abs(movementY) < MOVE_MIN)
            return;
        batchUndoCommand.push(createCommand$1('memo.move', {
            movementX: -1 * movementX,
            movementY: -1 * movementY,
            tableIds,
            memoIds,
        }));
        batchRedoCommand.push(createCommand$1('memo.move', {
            movementX,
            movementY,
            tableIds,
            memoIds,
        }));
    }
    function executeResizeMemo(commands, batchUndoCommand, batchRedoCommand) {
        const resizeMemoCommands = commands.filter(command => command.name === 'memo.resize');
        if (resizeMemoCommands.length < 2)
            return;
        batchUndoCommand.push(resizeMemoCommands[0]);
        batchRedoCommand.push(resizeMemoCommands[resizeMemoCommands.length - 1]);
    }
    function executeMovementCanvas(commands, batchUndoCommand, batchRedoCommand) {
        const moveCanvasCommands = commands.filter(command => command.name === 'canvas.movement');
        if (!moveCanvasCommands.length)
            return;
        let movementX = 0;
        let movementY = 0;
        moveCanvasCommands.forEach(moveCanvasCommand => {
            const data = moveCanvasCommand.data;
            movementX += data.movementX;
            movementY += data.movementY;
        });
        if (Math.abs(movementX) + Math.abs(movementY) < MOVE_MIN)
            return;
        batchUndoCommand.push(movementCanvas(-1 * movementX, -1 * movementY));
        batchRedoCommand.push(movementCanvas(movementX, movementY));
    }
    function executeMovementZoomCanvas(commands, batchUndoCommand, batchRedoCommand) {
        const zoomCanvasCommands = commands.filter(command => command.name === 'canvas.movementZoom');
        if (!zoomCanvasCommands.length)
            return;
        const movementZoomLevel = zoomCanvasCommands
            .map(zoomCanvasCommand => zoomCanvasCommand.data.movementZoomLevel)
            .reduce((acc, cur) => acc + cur, 0);
        batchUndoCommand.push(movementZoomCanvas(-1 * movementZoomLevel));
        batchRedoCommand.push(movementZoomCanvas(movementZoomLevel));
    }
    const executeStreamCommandMap = {
        'table.move': executeMoveTable,
        'memo.move': executeMoveMemo,
        'memo.resize': executeResizeMemo,
        'canvas.movement': executeMovementCanvas,
        'canvas.movementZoom': executeMovementZoomCanvas,
    };

    function executeAddTable(store, batchUndoCommand, data) {
        batchUndoCommand.push(removeTable(store, data.id));
    }
    function executeRemoveTable({ tableState: { tables, indexes }, relationshipState: { relationships }, }, batchUndoCommand, { tableIds }) {
        const targetTables = [];
        const targetRelationships = [];
        const targetIndexes = [];
        tableIds.forEach(tableId => {
            const table = getData(tables, tableId);
            if (!table)
                return;
            targetTables.push(cloneDeep(table));
            relationships.forEach(relationship => {
                const { start, end } = relationship;
                if (tableId === start.tableId || tableId === end.tableId) {
                    targetRelationships.push(cloneDeep(relationship));
                }
            });
            const tableIndexes = indexes.filter(index => index.tableId === table.id);
            tableIndexes.forEach(index => targetIndexes.push(cloneDeep(index)));
        });
        if (!targetTables.length)
            return;
        batchUndoCommand.push(...targetTables.map(table => loadTable(table)));
        if (targetRelationships.length) {
            batchUndoCommand.push(removeRelationship(targetRelationships.map(relationship => relationship.id)), ...targetRelationships.map(relationship => loadRelationship(relationship)));
        }
        if (targetIndexes.length) {
            batchUndoCommand.push(removeIndex(targetIndexes.map(index => index.id)), ...targetIndexes.map(index => loadIndex(index)));
        }
    }
    function executeChangeTableName({ tableState: { tables } }, batchUndoCommand, data) {
        const table = getData(tables, data.tableId);
        if (!table)
            return;
        batchUndoCommand.push(createCommand$1('table.changeName', {
            tableId: table.id,
            value: table.name,
            width: table.ui.widthName,
        }));
    }
    function executeChangeTableComment({ tableState: { tables } }, batchUndoCommand, data) {
        const table = getData(tables, data.tableId);
        if (!table)
            return;
        batchUndoCommand.push(createCommand$1('table.changeComment', {
            tableId: table.id,
            value: table.comment,
            width: table.ui.widthComment,
        }));
    }
    function executeSortTable(store, batchUndoCommand) {
        batchUndoCommand.push(loadJson$(createJsonStringify(store)));
    }
    function executeHideTable(store, batchUndoCommand, { tableId }) {
        batchUndoCommand.push(showTable(tableId));
    }
    function executeShowTable(store, batchUndoCommand, { tableId }) {
        batchUndoCommand.push(hideTable(tableId));
    }
    const executeTableCommandMap = {
        'table.add': executeAddTable,
        'table.remove': executeRemoveTable,
        'table.changeName': executeChangeTableName,
        'table.changeComment': executeChangeTableComment,
        'table.sort': executeSortTable,
        'table.hide': executeHideTable,
        'table.show': executeShowTable,
    };

    const executeCommandMap = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, executeCanvasCommandMap), executeMemoCommandMap), executeTableCommandMap), executeColumnCommandMap), executeEditorCommandMap), executeRelationshipCommandMap);
    function executeCommand(store, history, commands) {
        const batchUndoCommand = [];
        const batchRedoCommand = [];
        commands.forEach(command => {
            const execute = executeCommandMap[command.name];
            if (!execute)
                return;
            execute(store, batchUndoCommand, command.data);
            batchRedoCommand.push(command);
        });
        Object.keys(executeStreamCommandMap).forEach(key => executeStreamCommandMap[key](commands, batchUndoCommand, batchRedoCommand));
        if (!batchUndoCommand.length || !batchRedoCommand.length)
            return;
        history.push({
            undo: () => store.history$.next([...flat(batchUndoCommand)]),
            redo: () => store.history$.next([...flat(batchRedoCommand)]),
        });
    }
    const executeHistoryCommand = curry$1((store, history, commands) => {
        try {
            executeCommand(store, history, commands);
        }
        catch (err) {
            Logger.error(err);
        }
    });

    const hookKeys$2 = ['editor.loadJson', 'editor.initLoadJson'];
    const useRecalculatingTableWidth = (hook$, { tableState: { tables }, relationshipState: { relationships } }, helper) => hook$.pipe(commandsFilter(hookKeys$2), debounceTime(1000)).subscribe(() => {
        recalculatingTableWidth(tables, helper);
        relationshipSort(tables, relationships);
    });

    const hookKeys$1 = [
        'canvas.changeShow',
        'relationship.add',
        'memo.move',
        'table.move',
        'table.changeName',
        'table.changeComment',
        'table.sort',
        'column.add',
        'column.addCustom',
        'column.remove',
        'column.changeName',
        'column.changeComment',
        'column.changeDataType',
        'column.changeDefault',
        'column.move',
        'table.hide',
        'table.show',
    ];
    const useRelationshipSort = (hook$, { tableState: { tables }, relationshipState: { relationships } }, helper) => hook$
        .pipe(commandsFilter(hookKeys$1))
        .subscribe(() => relationshipSort(tables, relationships));

    const hookKeys = ['editor.loadJson', 'editor.initLoadJson'];
    const useResetZIndex = (hook$, { tableState: { tables }, memoState: { memos } }, helper) => hook$.pipe(commandsFilter(hookKeys), debounceTime(1000)).subscribe(() => {
        const uiList = [
            ...tables.map(table => table.ui),
            ...memos.map(memo => memo.ui),
        ];
        uiList.sort((a, b) => a.zIndex - b.zIndex);
        uiList.forEach((ui, index) => (ui.zIndex = index + 1));
    });

    const useHooks = (hook$, state, helper) => [
        useRecalculatingTableWidth(hook$, state, helper),
        useRelationshipSort(hook$, state),
        useResetZIndex(hook$, state),
    ];

    const createState = () => observable$1({
        canvasState: createCanvasState(),
        tableState: createTableState(),
        relationshipState: createRelationshipState(),
        memoState: createMemoState(),
        editorState: createEditorState(),
    });
    function createStore(helper) {
        const subscriptionHelper = createSubscriptionHelper();
        const state = createState();
        const { dispatch$, history$, change$, hook$ } = createStream();
        const dispatchSync = (...commands) => dispatch$.next([...flat(commands)]);
        const dispatch = (...commands) => queueMicrotask(() => dispatchSync(...commands));
        const history = createHistory(() => dispatch(hasUndoRedo(history.hasUndo(), history.hasRedo())));
        const undo = () => {
            if (!history.hasUndo() || state.editorState.readonly)
                return;
            dispatch(focusTableEnd());
            history.undo();
        };
        const redo = () => {
            if (!history.hasRedo() || state.editorState.readonly)
                return;
            dispatch(focusTableEnd());
            history.redo();
        };
        const destroy = () => {
            subscriptionHelper.destroy();
            history.clear();
        };
        const store = Object.assign(Object.assign({}, state), { dispatch,
            dispatchSync,
            undo,
            redo,
            history$,
            change$,
            destroy });
        const command = executeCommand$1(state);
        const historyCommand = executeHistoryCommand(store, history);
        subscriptionHelper.push(history$.pipe(notEmptyCommands).subscribe(command), dispatch$
            .pipe(readonlyCommands(state), commandsFilter(historyCommandTypes), groupByStreamCommands)
            .subscribe(historyCommand), dispatch$.pipe(readonlyCommands(state)).subscribe(command), ...useHooks(hook$, state, helper));
        return store;
    }

    const userAgent = window.navigator.userAgent.toLowerCase();
    const isRatio = ['macintosh', 'firefox'].every(target => userAgent.indexOf(target) === -1);
    function createGlobalEventObservable() {
        const mousedown$ = fromEvent(window, 'mousedown');
        const mousemove$ = fromEvent(window, 'mousemove');
        const mouseup$ = fromEvent(window, 'mouseup');
        const touchstart$ = fromEvent(window, 'touchstart');
        const touchmove$ = fromEvent(window, 'touchmove');
        const touchend$ = fromEvent(window, 'touchend');
        let touchX = 0;
        let touchY = 0;
        const subscription = touchstart$.subscribe(event => {
            touchX = event.touches[0].clientX;
            touchY = event.touches[0].clientY;
        });
        const move$ = merge(mousemove$.pipe(map(event => {
            let movementX = event.movementX;
            let movementY = event.movementY;
            if (isRatio) {
                movementX = event.movementX / window.devicePixelRatio;
                movementY = event.movementY / window.devicePixelRatio;
            }
            return {
                event,
                movementX,
                movementY,
                x: event.clientX,
                y: event.clientY,
            };
        })), touchmove$.pipe(filter$1(event => event.touches.length === 1), map(event => {
            const movementX = event.touches[0].clientX - touchX;
            const movementY = event.touches[0].clientY - touchY;
            touchX = event.touches[0].clientX;
            touchY = event.touches[0].clientY;
            return {
                event,
                movementX,
                movementY,
                x: event.touches[0].clientX,
                y: event.touches[0].clientY,
            };
        })));
        const moveStart$ = merge(mousedown$, touchstart$);
        const moveEnd$ = merge(mouseup$, touchend$);
        const drag$ = move$.pipe(takeUntil(moveEnd$));
        return {
            mousedown$,
            mouseup$,
            mousemove$,
            touchstart$,
            touchend$,
            touchmove$,
            moveStart$,
            moveEnd$,
            move$,
            drag$,
            destroy() {
                subscription.unsubscribe();
            },
        };
    }

    const createKeymap = () => ({
        edit: [
            {
                key: 'Enter',
            },
        ],
        stop: [
            {
                key: 'Escape',
            },
        ],
        find: [
            {
                ctrlKey: true,
                key: 'F',
                preventDefault: true,
                stopPropagation: true,
            },
            {
                metaKey: true,
                key: 'F',
                preventDefault: true,
                stopPropagation: true,
            },
        ],
        undo: [
            {
                ctrlKey: true,
                key: 'Z',
                preventDefault: true,
            },
            {
                metaKey: true,
                key: 'Z',
                preventDefault: true,
            },
        ],
        redo: [
            {
                ctrlKey: true,
                shiftKey: true,
                key: 'Z',
                preventDefault: true,
            },
            {
                metaKey: true,
                shiftKey: true,
                key: 'Z',
                preventDefault: true,
            },
        ],
        addTable: [
            {
                altKey: true,
                key: 'N',
            },
        ],
        addColumn: [
            {
                altKey: true,
                key: 'Enter',
            },
        ],
        addMemo: [
            {
                altKey: true,
                key: 'M',
            },
        ],
        removeTable: [
            {
                ctrlKey: true,
                key: 'Delete',
            },
            {
                ctrlKey: true,
                key: 'Backspace',
            },
            {
                metaKey: true,
                key: 'Delete',
            },
            {
                metaKey: true,
                key: 'Backspace',
            },
        ],
        hideTable: [
            {
                ctrlKey: true,
                shiftKey: true,
                key: 'H',
                preventDefault: true,
                stopPropagation: true,
            },
            {
                metaKey: true,
                shiftKey: true,
                key: 'H',
                preventDefault: true,
                stopPropagation: true,
            },
        ],
        removeColumn: [
            {
                altKey: true,
                key: 'Delete',
            },
            {
                altKey: true,
                key: 'Backspace',
            },
        ],
        primaryKey: [
            {
                altKey: true,
                key: 'K',
            },
        ],
        selectAllTable: [
            {
                ctrlKey: true,
                altKey: true,
                key: 'A',
            },
            {
                metaKey: true,
                altKey: true,
                key: 'A',
            },
        ],
        selectAllColumn: [
            {
                altKey: true,
                key: 'A',
            },
        ],
        copyColumn: [
            {
                ctrlKey: true,
                key: 'C',
            },
            {
                metaKey: true,
                key: 'C',
            },
        ],
        pasteColumn: [
            {
                ctrlKey: true,
                key: 'V',
            },
            {
                metaKey: true,
                key: 'V',
            },
        ],
        relationshipZeroOne: [
            {
                ctrlKey: true,
                altKey: true,
                key: '1',
            },
            {
                metaKey: true,
                altKey: true,
                key: '1',
            },
        ],
        relationshipZeroN: [
            {
                ctrlKey: true,
                altKey: true,
                key: '2',
            },
            {
                metaKey: true,
                altKey: true,
                key: '2',
            },
        ],
        relationshipOneOnly: [
            {
                ctrlKey: true,
                altKey: true,
                key: '3',
            },
            {
                metaKey: true,
                altKey: true,
                key: '3',
            },
        ],
        relationshipOneN: [
            {
                ctrlKey: true,
                altKey: true,
                key: '4',
            },
            {
                metaKey: true,
                altKey: true,
                key: '4',
            },
        ],
        tableProperties: [
            {
                altKey: true,
                key: 'Space',
            },
            {
                ctrlKey: true,
                key: 'Space',
            },
        ],
        zoomIn: [
            {
                ctrlKey: true,
                key: 'Equal',
                preventDefault: true,
                stopPropagation: true,
            },
            {
                metaKey: true,
                key: 'Equal',
                preventDefault: true,
                stopPropagation: true,
            },
        ],
        zoomOut: [
            {
                ctrlKey: true,
                key: 'Minus',
                preventDefault: true,
                stopPropagation: true,
            },
            {
                metaKey: true,
                key: 'Minus',
                preventDefault: true,
                stopPropagation: true,
            },
        ],
    });
    const multipleKeys = [
        'altKey',
        'metaKey',
        'ctrlKey',
        'shiftKey',
    ];
    const keyEquals = (event, key) => event.key.toUpperCase() === key.toUpperCase() ||
        event.code.toUpperCase() === key.toUpperCase() ||
        event.code.toUpperCase() === `Key${key}`.toUpperCase() ||
        event.code.toUpperCase() === `Digit${key}`.toUpperCase();
    const getKeymap = (event, keymapOptions) => keymapOptions.find(keymapOption => {
        const isMultipleKey = multipleKeys.every(multipleKey => !!keymapOption[multipleKey] === event[multipleKey]);
        return keymapOption.key
            ? isMultipleKey && keyEquals(event, keymapOption.key)
            : isMultipleKey;
    });
    function keymapMatchAndStop(event, keymapOptions) {
        const current = getKeymap(event, keymapOptions);
        (current === null || current === void 0 ? void 0 : current.preventDefault) && event.preventDefault();
        (current === null || current === void 0 ? void 0 : current.stopPropagation) && event.stopPropagation();
        return !!current;
    }
    function keymapOptionToString(keymapOption) {
        if (!keymapOption)
            return '';
        const result = [];
        if (keymapOption.metaKey) {
            result.push('Cmd');
        }
        if (keymapOption.ctrlKey) {
            result.push('Ctrl');
        }
        if (keymapOption.altKey) {
            result.push('Alt');
        }
        if (keymapOption.shiftKey) {
            result.push('Shift');
        }
        if (keymapOption.key) {
            result.push(keymapOption.key);
        }
        return result.join(' + ');
    }
    const keymapOptionsToString = (keymapOptions) => keymapOptions.map(option => keymapOptionToString(option)).join(', ');
    const loadKeymap = (keymap, newKeymap) => Object.keys(keymap)
        .filter(key => isArray$4(newKeymap[key]))
        .forEach(key => (keymap[key] = newKeymap[key]));

    function createdERDEditorContext() {
        const helper = createHelper();
        return {
            theme: observable$1(createTheme()),
            keymap: observable$1(createKeymap()),
            globalEvent: createGlobalEventObservable(),
            eventBus: createEventBus(),
            store: createStore(helper),
            command: createCommand(),
            helper,
            snapshots: [],
            showPrompt: noop$2,
            showAlert: noop$2,
        };
    }
    const omitERDEditorContext = pipe(omit$1(['globalEvent', 'eventBus', 'snapshots', 'showPrompt', 'showAlert']), dissocPath$1(['store', 'history$']), dissocPath$1(['store', 'change$']), dissocPath$1(['store', 'destroy']), dissocPath$1(['helper', 'keydown$']), dissocPath$1(['helper', 'setGhostText']), dissocPath$1(['helper', 'setGhostInput']), dissocPath$1(['helper', 'focus']), dissocPath$1(['helper', 'blur']), dissocPath$1(['helper', 'destroy']));

    defineComponent('vuerd-panel-view', {
        observedProps: [
            'panel',
            {
                name: 'width',
                default: 0,
            },
            {
                name: 'height',
                default: 0,
            },
        ],
        styleMap: {
            height: '100%',
            display: 'flex',
            position: 'relative',
        },
        render(props, ctx) {
            const contextRef = useContext$1(ctx);
            const { unmountedGroup } = useUnmounted();
            let panelInstance = null;
            const setHeight = () => {
                ctx.style.height = `${props.height}px`;
            };
            beforeMount(() => {
                setHeight();
                const api = omitERDEditorContext(contextRef.value);
                panelInstance = new props.panel.type(props, api);
                panelInstance.beforeMount && panelInstance.beforeMount();
                unmountedGroup.push(watch(props, propName => {
                    if (propName !== 'height')
                        return;
                    setHeight();
                }));
            });
            mounted(() => (panelInstance === null || panelInstance === void 0 ? void 0 : panelInstance.mounted) && panelInstance.mounted());
            unmounted(() => (panelInstance === null || panelInstance === void 0 ? void 0 : panelInstance.unmounted) && panelInstance.unmounted());
            beforeFirstUpdate(() => (panelInstance === null || panelInstance === void 0 ? void 0 : panelInstance.beforeFirstUpdate) && panelInstance.beforeFirstUpdate());
            firstUpdated(() => (panelInstance === null || panelInstance === void 0 ? void 0 : panelInstance.firstUpdated) && panelInstance.firstUpdated());
            beforeUpdate(() => (panelInstance === null || panelInstance === void 0 ? void 0 : panelInstance.beforeUpdate) && panelInstance.beforeUpdate());
            updated(() => (panelInstance === null || panelInstance === void 0 ? void 0 : panelInstance.updated) && panelInstance.updated());
            return () => html `${panelInstance === null || panelInstance === void 0 ? void 0 : panelInstance.render()}`;
        },
    });

    const ERD$1 = {
        title: 'Entity Relationship Diagram',
        canvasType: 'ERD',
        icon: {
            prefix: 'fas',
            name: 'project-diagram',
            size: 18,
        },
    };
    const panelToMenu = (panel) => {
        var _a;
        return ({
            title: (_a = panel.name) !== null && _a !== void 0 ? _a : '',
            canvasType: panel.key,
            icon: Object.assign({
                size: 18,
            }, panel.icon),
        });
    };
    function useMenubarPanels(ctx) {
        const contextRef = useContext$1(ctx);
        const onChangeCanvasType = (canvasType) => {
            const { store } = contextRef.value;
            if (canvasType === store.canvasState.canvasType)
                return;
            store.dispatch(changeCanvasType(canvasType));
        };
        const getMenus = () => {
            const { editorState } = contextRef.value.store;
            const menus = [ERD$1];
            [...contextPanelConfig.panels, ...editorState.panels]
                .filter(panel => !isRegExp(contextPanelConfig.exclude, panel.key) &&
                !isRegExp(editorState.excludePanel, panel.key))
                .forEach(panel => menus.push(panelToMenu(panel)));
            return menus;
        };
        return {
            panelMenusTpl: () => {
                const { canvasState } = contextRef.value.store;
                return getMenus().map(menu => html `
          <div
            class=${classMap({
                'vuerd-menubar-menu': true,
                active: canvasState.canvasType === menu.canvasType,
            })}
            data-tippy-content=${menu.title}
            @click=${() => onChangeCanvasType(menu.canvasType)}
          >
            <vuerd-icon
              .prefix=${menu.icon.prefix}
              .name=${menu.icon.name}
              .size=${menu.icon.size}
            ></vuerd-icon>
          </div>
        `);
            },
        };
    }

    const MenubarStyle = css `
  .vuerd-menubar {
    height: ${SIZE_MENUBAR_HEIGHT}px;
    display: flex;
    align-items: center;
    overflow: hidden;
    background-color: var(--vuerd-color-menubar);
    box-sizing: border-box;
  }

  .vuerd-editor-status {
    width: 10px;
    height: 10px;
    margin-left: 15px;
    border-radius: 50%;
    transition: box-shadow 0.4s ease-in-out, background-color 0.4s ease-in-out;
  }

  .vuerd-editor-status.focus {
    background-color: var(--vuerd-color-focus);
    box-shadow: 0 0 5px var(--vuerd-color-focus);
  }

  .vuerd-editor-status.edit {
    background-color: var(--vuerd-color-edit);
    box-shadow: 0 0 5px var(--vuerd-color-edit);
  }

  .vuerd-menubar-input {
    margin-left: 15px;
    outline: none;
    border: none;
    opacity: 0.9;
    font-size: ${SIZE_FONT}px;
    font-family: var(--vuerd-font-family);
    color: var(--vuerd-color-font-active);
    background-color: var(--vuerd-color-menubar);
  }

  .vuerd-menubar-menu {
    cursor: pointer;
    fill: var(--vuerd-color-font);
    margin-left: 10px;
    display: flex;
    align-items: center;
  }

  .vuerd-menubar-menu.active,
  .vuerd-menubar-menu:hover {
    fill: var(--vuerd-color-font-active);
  }

  .vuerd-menubar-menu.undo-redo {
    cursor: not-allowed;
    fill: var(--vuerd-color-font);
  }

  .vuerd-menubar-menu.undo-redo.active {
    cursor: pointer;
    fill: var(--vuerd-color-font-active);
  }

  .vuerd-menubar-menu-vertical {
    margin-left: 10px;
  }
`;

    const Menubar = (props, ctx) => {
        const contextRef = useContext$1(ctx);
        const { panelMenusTpl } = useMenubarPanels(ctx);
        const { resetTooltip } = useTooltip(['.vuerd-menubar-input', '.vuerd-menubar-menu', '.vuerd-editor-status'], ctx);
        const { unmountedGroup } = useUnmounted();
        const onChangeDatabaseName = (event) => {
            const input = event.target;
            const { store } = contextRef.value;
            store.dispatch(changeDatabaseName(input.value));
        };
        const onResizeCanvas = (event) => {
            const input = event.target;
            const size = canvasSizeRange(input.value);
            const { store } = contextRef.value;
            input.value = size.toString();
            store.dispatch(resizeCanvas(size, size));
        };
        const onZoomLevel = (event) => {
            const input = event.target;
            const zoomLevel = zoomLevelRange(Number(input.value.replace(/[^0-9]/g, '')) / 100);
            const { store } = contextRef.value;
            input.value = zoomDisplayFormat(zoomLevel);
            store.dispatch(zoomCanvas(zoomLevel));
        };
        const onFind = () => {
            const { store, eventBus } = contextRef.value;
            const { findActive } = store.editorState;
            if (findActive) {
                store.dispatch(findActiveEnd());
            }
            else {
                store.dispatch(findActive$());
            }
            eventBus.emit(Bus.Drawer.close);
        };
        const onUndo = () => {
            const { store } = contextRef.value;
            store.undo();
        };
        const onRedo = () => {
            const { store } = contextRef.value;
            store.redo();
        };
        const onFilter = () => {
            const { store, eventBus } = contextRef.value;
            const { filterState } = store.editorState;
            if (filterState.active) {
                store.dispatch(filterActiveEnd$());
            }
            else {
                store.dispatch(filterActive$());
            }
            eventBus.emit(Bus.Drawer.close);
        };
        const onOpenHelp = () => ctx.dispatchEvent(new CustomEvent('open-help'));
        const onOpenSetting = () => ctx.dispatchEvent(new CustomEvent('open-setting'));
        const onOpenTree = () => ctx.dispatchEvent(new CustomEvent('open-tree'));
        beforeMount(() => {
            const { editorState, canvasState } = contextRef.value.store;
            unmountedGroup.push(watch(editorState.panels, () => resetTooltip()), watch(editorState.excludePanel, () => resetTooltip()), watch(contextPanelConfig.panels, () => resetTooltip()), watch(contextPanelConfig.exclude, () => resetTooltip()), watch(canvasState, propName => {
                if (propName !== 'canvasType')
                    return;
                resetTooltip();
            }));
        });
        return () => {
            const { store, keymap } = contextRef.value;
            const { canvasState: { databaseName, width, zoomLevel, canvasType }, editorState: { hasUndo, hasRedo, readonly, filterState }, } = store;
            return html `
      <div class="vuerd-menubar">
        <div
          class=${classMap({
            'vuerd-editor-status': true,
            focus: props.focusState && readonly,
            edit: props.focusState && !readonly,
        })}
          data-tippy-content="Editor Status"
        ></div>
        <input
          class="vuerd-menubar-input"
          style="width: 45px;"
          type="text"
          data-tippy-content="canvas size"
          spellcheck="false"
          placeholder="canvas size"
          ?disabled=${readonly}
          .value=${width.toString()}
          @input=${onNumberOnly}
          @change=${onResizeCanvas}
        />
        <input
          class="vuerd-menubar-input"
          style="width: 45px;"
          type="text"
          data-tippy-content="zoom level"
          spellcheck="false"
          placeholder="zoom level"
          .value=${zoomDisplayFormat(zoomLevel)}
          @input=${onNumberOnly}
          @change=${onZoomLevel}
        />
            
      </div>`;
        };
    };
    defineComponent('vuerd-menubar', {
        observedProps: [
            {
                name: 'focusState',
                type: Boolean,
                default: false,
            },
        ],
        style: MenubarStyle,
        render: Menubar,
    });

    var colorpicker = {exports: {}};

    (function (module, exports) {
    (function (global, factory) {
    	module.exports = factory() ;
    }(commonjsGlobal$1, (function () {
    /**
     * @method format
     *
     * convert color to format string
     *
     *     // hex
     *     color.format({ r : 255, g : 255, b : 255, a: 1 }, 'hex')  // #FFFFFFFF
     *
     *     // rgb
     *     color.format({ r : 255, g : 255, b : 255 }, 'rgb') // rgba(255, 255, 255, 0.5);
     *
     *     // rgba
     *     color.format({ r : 255, g : 255, b : 255, a : 0.5 }, 'rgb') // rgba(255, 255, 255, 0.5);
     *
     * @param {Object} obj  obj has r, g, b and a attributes
     * @param {"hex"/"rgb"} type  format string type
     * @returns {*}
     */
    function format(obj, type) {
        var defaultColor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'rgba(0, 0, 0, 0)';


        if (Array.isArray(obj)) {
            obj = { r: obj[0], g: obj[1], b: obj[2], a: obj[3] };
        }

        if (type == 'hex') {
            return hex(obj);
        } else if (type == 'rgb') {
            return rgb(obj, defaultColor);
        } else if (type == 'hsl') {
            return hsl(obj);
        }

        return obj;
    }

    function hex(obj) {
        if (Array.isArray(obj)) {
            obj = { r: obj[0], g: obj[1], b: obj[2], a: obj[3] };
        }

        var r = obj.r.toString(16);
        if (obj.r < 16) r = "0" + r;

        var g = obj.g.toString(16);
        if (obj.g < 16) g = "0" + g;

        var b = obj.b.toString(16);
        if (obj.b < 16) b = "0" + b;

        var alphaValue = '';
        if (obj.a < 1) {
            var alpha = Math.floor(obj.a * 255);
            var alphaValue = alpha.toString(16);
            if (alpha < 16) alphaValue = "0" + alphaValue;
        }

        return '#' + r + g + b + alphaValue;
    }

    function rgb(obj) {
        var defaultColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'rgba(0, 0, 0, 0)';

        if (Array.isArray(obj)) {
            obj = { r: obj[0], g: obj[1], b: obj[2], a: obj[3] };
        }

        if (typeof obj == 'undefined') {
            return undefined;
        }

        if (obj.a == 1 || typeof obj.a == 'undefined') {
            if (isNaN(obj.r)) {
                return defaultColor;
            }
            return 'rgb(' + obj.r + ',' + obj.g + ',' + obj.b + ')';
        } else {
            return 'rgba(' + obj.r + ',' + obj.g + ',' + obj.b + ',' + obj.a + ')';
        }
    }

    function hsl(obj) {
        if (Array.isArray(obj)) {
            obj = { r: obj[0], g: obj[1], b: obj[2], a: obj[3] };
        }

        if (obj.a == 1 || typeof obj.a == 'undefined') {
            return 'hsl(' + obj.h + ',' + obj.s + '%,' + obj.l + '%)';
        } else {
            return 'hsla(' + obj.h + ',' + obj.s + '%,' + obj.l + '%,' + obj.a + ')';
        }
    }

    var formatter = {
        format: format,
        rgb: rgb,
        hsl: hsl,
        hex: hex
    };

    function round(n, k) {
        k = typeof k == 'undefined' ? 1 : k;
        return Math.round(n * k) / k;
    }

    function degreeToRadian(angle) {
        return angle * Math.PI / 180;
    }

    /**
     *
     * convert radian to degree
     *
     * @param {*} radian
     * @returns {Number} 0..360
     */
    function radianToDegree(radian) {
        var angle = radian * 180 / Math.PI;

        if (angle < 0) {
            //  0  360  .
            angle = 360 + angle;
        }

        return angle;
    }

    function getXInCircle(angle, radius) {
        var centerX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

        return centerX + radius * Math.cos(degreeToRadian(angle));
    }

    function getYInCircle(angle, radius) {
        var centerY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

        return centerY + radius * Math.sin(degreeToRadian(angle));
    }

    function getXYInCircle(angle, radius) {
        var centerX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var centerY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

        return {
            x: getXInCircle(angle, radius, centerX),
            y: getYInCircle(angle, radius, centerY)
        };
    }

    function caculateAngle(rx, ry) {
        return radianToDegree(Math.atan2(ry, rx));
    }

    var math = {
        round: round,
        radianToDegree: radianToDegree,
        degreeToRadian: degreeToRadian,
        getXInCircle: getXInCircle,
        getYInCircle: getYInCircle,
        caculateAngle: caculateAngle
    };

    var color_names = { aliceblue: "rgb(240, 248, 255)", antiquewhite: "rgb(250, 235, 215)", aqua: "rgb(0, 255, 255)", aquamarine: "rgb(127, 255, 212)", azure: "rgb(240, 255, 255)", beige: "rgb(245, 245, 220)", bisque: "rgb(255, 228, 196)", black: "rgb(0, 0, 0)", blanchedalmond: "rgb(255, 235, 205)", blue: "rgb(0, 0, 255)", blueviolet: "rgb(138, 43, 226)", brown: "rgb(165, 42, 42)", burlywood: "rgb(222, 184, 135)", cadetblue: "rgb(95, 158, 160)", chartreuse: "rgb(127, 255, 0)", chocolate: "rgb(210, 105, 30)", coral: "rgb(255, 127, 80)", cornflowerblue: "rgb(100, 149, 237)", cornsilk: "rgb(255, 248, 220)", crimson: "rgb(237, 20, 61)", cyan: "rgb(0, 255, 255)", darkblue: "rgb(0, 0, 139)", darkcyan: "rgb(0, 139, 139)", darkgoldenrod: "rgb(184, 134, 11)", darkgray: "rgb(169, 169, 169)", darkgrey: "rgb(169, 169, 169)", darkgreen: "rgb(0, 100, 0)", darkkhaki: "rgb(189, 183, 107)", darkmagenta: "rgb(139, 0, 139)", darkolivegreen: "rgb(85, 107, 47)", darkorange: "rgb(255, 140, 0)", darkorchid: "rgb(153, 50, 204)", darkred: "rgb(139, 0, 0)", darksalmon: "rgb(233, 150, 122)", darkseagreen: "rgb(143, 188, 143)", darkslateblue: "rgb(72, 61, 139)", darkslategray: "rgb(47, 79, 79)", darkslategrey: "rgb(47, 79, 79)", darkturquoise: "rgb(0, 206, 209)", darkviolet: "rgb(148, 0, 211)", deeppink: "rgb(255, 20, 147)", deepskyblue: "rgb(0, 191, 255)", dimgray: "rgb(105, 105, 105)", dimgrey: "rgb(105, 105, 105)", dodgerblue: "rgb(30, 144, 255)", firebrick: "rgb(178, 34, 34)", floralwhite: "rgb(255, 250, 240)", forestgreen: "rgb(34, 139, 34)", fuchsia: "rgb(255, 0, 255)", gainsboro: "rgb(220, 220, 220)", ghostwhite: "rgb(248, 248, 255)", gold: "rgb(255, 215, 0)", goldenrod: "rgb(218, 165, 32)", gray: "rgb(128, 128, 128)", grey: "rgb(128, 128, 128)", green: "rgb(0, 128, 0)", greenyellow: "rgb(173, 255, 47)", honeydew: "rgb(240, 255, 240)", hotpink: "rgb(255, 105, 180)", indianred: "rgb(205, 92, 92)", indigo: "rgb(75, 0, 130)", ivory: "rgb(255, 255, 240)", khaki: "rgb(240, 230, 140)", lavender: "rgb(230, 230, 250)", lavenderblush: "rgb(255, 240, 245)", lawngreen: "rgb(124, 252, 0)", lemonchiffon: "rgb(255, 250, 205)", lightblue: "rgb(173, 216, 230)", lightcoral: "rgb(240, 128, 128)", lightcyan: "rgb(224, 255, 255)", lightgoldenrodyellow: "rgb(250, 250, 210)", lightgreen: "rgb(144, 238, 144)", lightgray: "rgb(211, 211, 211)", lightgrey: "rgb(211, 211, 211)", lightpink: "rgb(255, 182, 193)", lightsalmon: "rgb(255, 160, 122)", lightseagreen: "rgb(32, 178, 170)", lightskyblue: "rgb(135, 206, 250)", lightslategray: "rgb(119, 136, 153)", lightslategrey: "rgb(119, 136, 153)", lightsteelblue: "rgb(176, 196, 222)", lightyellow: "rgb(255, 255, 224)", lime: "rgb(0, 255, 0)", limegreen: "rgb(50, 205, 50)", linen: "rgb(250, 240, 230)", magenta: "rgb(255, 0, 255)", maroon: "rgb(128, 0, 0)", mediumaquamarine: "rgb(102, 205, 170)", mediumblue: "rgb(0, 0, 205)", mediumorchid: "rgb(186, 85, 211)", mediumpurple: "rgb(147, 112, 219)", mediumseagreen: "rgb(60, 179, 113)", mediumslateblue: "rgb(123, 104, 238)", mediumspringgreen: "rgb(0, 250, 154)", mediumturquoise: "rgb(72, 209, 204)", mediumvioletred: "rgb(199, 21, 133)", midnightblue: "rgb(25, 25, 112)", mintcream: "rgb(245, 255, 250)", mistyrose: "rgb(255, 228, 225)", moccasin: "rgb(255, 228, 181)", navajowhite: "rgb(255, 222, 173)", navy: "rgb(0, 0, 128)", oldlace: "rgb(253, 245, 230)", olive: "rgb(128, 128, 0)", olivedrab: "rgb(107, 142, 35)", orange: "rgb(255, 165, 0)", orangered: "rgb(255, 69, 0)", orchid: "rgb(218, 112, 214)", palegoldenrod: "rgb(238, 232, 170)", palegreen: "rgb(152, 251, 152)", paleturquoise: "rgb(175, 238, 238)", palevioletred: "rgb(219, 112, 147)", papayawhip: "rgb(255, 239, 213)", peachpuff: "rgb(255, 218, 185)", peru: "rgb(205, 133, 63)", pink: "rgb(255, 192, 203)", plum: "rgb(221, 160, 221)", powderblue: "rgb(176, 224, 230)", purple: "rgb(128, 0, 128)", rebeccapurple: "rgb(102, 51, 153)", red: "rgb(255, 0, 0)", rosybrown: "rgb(188, 143, 143)", royalblue: "rgb(65, 105, 225)", saddlebrown: "rgb(139, 69, 19)", salmon: "rgb(250, 128, 114)", sandybrown: "rgb(244, 164, 96)", seagreen: "rgb(46, 139, 87)", seashell: "rgb(255, 245, 238)", sienna: "rgb(160, 82, 45)", silver: "rgb(192, 192, 192)", skyblue: "rgb(135, 206, 235)", slateblue: "rgb(106, 90, 205)", slategray: "rgb(112, 128, 144)", slategrey: "rgb(112, 128, 144)", snow: "rgb(255, 250, 250)", springgreen: "rgb(0, 255, 127)", steelblue: "rgb(70, 130, 180)", tan: "rgb(210, 180, 140)", teal: "rgb(0, 128, 128)", thistle: "rgb(216, 191, 216)", tomato: "rgb(255, 99, 71)", turquoise: "rgb(64, 224, 208)", violet: "rgb(238, 130, 238)", wheat: "rgb(245, 222, 179)", white: "rgb(255, 255, 255)", whitesmoke: "rgb(245, 245, 245)", yellow: "rgb(255, 255, 0)", yellowgreen: "rgb(154, 205, 50)", transparent: "rgba(0, 0, 0, 0)" };

    function isColorName(name) {
        return !!color_names[name];
    }

    function getColorByName(name) {
        return color_names[name];
    }

    var ColorNames = {
        isColorName: isColorName,
        getColorByName: getColorByName
    };

    function HUEtoRGB(p, q, t) {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1 / 6) return p + (q - p) * 6 * t;
        if (t < 1 / 2) return q;
        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
        return p;
    }

    function HSLtoHSV(h, s, l) {

        if (arguments.length == 1) {
            var _arguments$ = arguments[0],
                h = _arguments$.h,
                s = _arguments$.s,
                l = _arguments$.l;
        }
        var rgb = HSLtoRGB(h, s, l);

        return RGBtoHSV(rgb.r, rgb.g, rgb.b);
    }

    function HSLtoRGB(h, s, l) {

        if (arguments.length == 1) {
            var _arguments$2 = arguments[0],
                h = _arguments$2.h,
                s = _arguments$2.s,
                l = _arguments$2.l;
        }

        var r, g, b;

        h /= 360;
        s /= 100;
        l /= 100;

        if (s == 0) {
            r = g = b = l; // achromatic
        } else {
            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var p = 2 * l - q;
            r = HUEtoRGB(p, q, h + 1 / 3);
            g = HUEtoRGB(p, q, h);
            b = HUEtoRGB(p, q, h - 1 / 3);
        }

        return { r: round(r * 255), g: round(g * 255), b: round(b * 255) };
    }

    var fromHSL = {
        HUEtoRGB: HUEtoRGB,
        HSLtoHSV: HSLtoHSV,
        HSLtoRGB: HSLtoRGB
    };

    var classCallCheck = function (instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };

    var createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();





    var defineProperty = function (obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    };

    var _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    var get = function get(object, property, receiver) {
      if (object === null) object = Function.prototype;
      var desc = Object.getOwnPropertyDescriptor(object, property);

      if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);

        if (parent === null) {
          return undefined;
        } else {
          return get(parent, property, receiver);
        }
      } else if ("value" in desc) {
        return desc.value;
      } else {
        var getter = desc.get;

        if (getter === undefined) {
          return undefined;
        }

        return getter.call(receiver);
      }
    };

    var inherits = function (subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    };











    var possibleConstructorReturn = function (self, call) {
      if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return call && (typeof call === "object" || typeof call === "function") ? call : self;
    };





    var slicedToArray = function () {
      function sliceIterator(arr, i) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = undefined;

        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);

            if (i && _arr.length === i) break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"]) _i["return"]();
          } finally {
            if (_d) throw _e;
          }
        }

        return _arr;
      }

      return function (arr, i) {
        if (Array.isArray(arr)) {
          return arr;
        } else if (Symbol.iterator in Object(arr)) {
          return sliceIterator(arr, i);
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
    }();











    var toArray = function (arr) {
      return Array.isArray(arr) ? arr : Array.from(arr);
    };

    var toConsumableArray = function (arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

        return arr2;
      } else {
        return Array.from(arr);
      }
    };

    var color_regexp = /(#(?:[\da-f]{3}){1,2}|#(?:[\da-f]{8})|rgb\((?:\s*\d{1,3},\s*){2}\d{1,3}\s*\)|rgba\((?:\s*\d{1,3},\s*){3}\d*\.?\d+\s*\)|hsl\(\s*\d{1,3}(?:,\s*\d{1,3}%){2}\s*\)|hsla\(\s*\d{1,3}(?:,\s*\d{1,3}%){2},\s*\d*\.?\d+\s*\)|([\w_\-]+))/gi;
    var color_split = ',';

    function matches(str) {
        var matches = str.match(color_regexp);
        var result = [];

        if (!matches) {
            return result;
        }

        for (var i = 0, len = matches.length; i < len; i++) {

            if (matches[i].indexOf('#') > -1 || matches[i].indexOf('rgb') > -1 || matches[i].indexOf('hsl') > -1) {
                result.push({ color: matches[i] });
            } else {
                var nameColor = ColorNames.getColorByName(matches[i]);

                if (nameColor) {
                    result.push({ color: matches[i], nameColor: nameColor });
                }
            }
        }

        var pos = { next: 0 };
        result.forEach(function (item) {
            var startIndex = str.indexOf(item.color, pos.next);

            item.startIndex = startIndex;
            item.endIndex = startIndex + item.color.length;

            pos.next = item.endIndex;
        });

        return result;
    }

    function convertMatches(str) {
        var m = matches(str);

        m.forEach(function (it, index) {
            str = str.replace(it.color, '@' + index);
        });

        return { str: str, matches: m };
    }

    function convertMatchesArray(str) {
        var splitStr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ',';

        var ret = convertMatches(str);
        return ret.str.split(splitStr).map(function (it, index) {
            it = trim(it);

            if (ret.matches[index]) {
                it = it.replace('@' + index, ret.matches[index].color);
            }

            return it;
        });
    }

    function reverseMatches(str, matches) {
        matches.forEach(function (it, index) {
            str = str.replace('@' + index, it.color);
        });

        return str;
    }

    function trim(str) {
        return str.replace(/^\s+|\s+$/g, '');
    }

    /**
     * @method rgb
     *
     * parse string to rgb color
     *
     * 		color.parse("#FF0000") === { r : 255, g : 0, b : 0 }
     *
     * 		color.parse("rgb(255, 0, 0)") == { r : 255, g : 0, b :0 }
     * 		color.parse(0xff0000) == { r : 255, g : 0, b : 0 }
     * 		color.parse(0xff000000) == { r : 255, g : 0, b : 0, a: 0 }
     *
     * @param {String} str color string
     * @returns {Object}  rgb object
     */
    function parse(str) {
        if (typeof str == 'string') {

            if (ColorNames.isColorName(str)) {
                str = ColorNames.getColorByName(str);
            }

            if (str.indexOf("rgb(") > -1) {
                var arr = str.replace("rgb(", "").replace(")", "").split(",");

                for (var i = 0, len = arr.length; i < len; i++) {
                    arr[i] = parseInt(trim(arr[i]), 10);
                }

                var obj = { type: 'rgb', r: arr[0], g: arr[1], b: arr[2], a: 1 };

                obj = Object.assign(obj, RGBtoHSL(obj));

                return obj;
            } else if (str.indexOf("rgba(") > -1) {
                var arr = str.replace("rgba(", "").replace(")", "").split(",");

                for (var i = 0, len = arr.length; i < len; i++) {

                    if (len - 1 == i) {
                        arr[i] = parseFloat(trim(arr[i]));
                    } else {
                        arr[i] = parseInt(trim(arr[i]), 10);
                    }
                }

                var obj = { type: 'rgb', r: arr[0], g: arr[1], b: arr[2], a: arr[3] };

                obj = Object.assign(obj, RGBtoHSL(obj));

                return obj;
            } else if (str.indexOf("hsl(") > -1) {
                var arr = str.replace("hsl(", "").replace(")", "").split(",");

                for (var i = 0, len = arr.length; i < len; i++) {
                    arr[i] = parseFloat(trim(arr[i]));
                }

                var obj = { type: 'hsl', h: arr[0], s: arr[1], l: arr[2], a: 1 };

                obj = Object.assign(obj, HSLtoRGB(obj));

                return obj;
            } else if (str.indexOf("hsla(") > -1) {
                var arr = str.replace("hsla(", "").replace(")", "").split(",");

                for (var i = 0, len = arr.length; i < len; i++) {

                    if (len - 1 == i) {
                        arr[i] = parseFloat(trim(arr[i]));
                    } else {
                        arr[i] = parseInt(trim(arr[i]), 10);
                    }
                }

                var obj = { type: 'hsl', h: arr[0], s: arr[1], l: arr[2], a: arr[3] };

                obj = Object.assign(obj, HSLtoRGB(obj));

                return obj;
            } else if (str.indexOf("#") == 0) {

                str = str.replace("#", "");

                var arr = [];
                var a = 1;
                if (str.length == 3) {
                    for (var i = 0, len = str.length; i < len; i++) {
                        var char = str.substr(i, 1);
                        arr.push(parseInt(char + char, 16));
                    }
                } else if (str.length === 8) {
                    for (var i = 0, len = str.length; i < len; i += 2) {
                        arr.push(parseInt(str.substr(i, 2), 16));
                    }

                    a = arr.pop() / 255;
                } else {
                    for (var i = 0, len = str.length; i < len; i += 2) {
                        arr.push(parseInt(str.substr(i, 2), 16));
                    }
                }

                var obj = { type: 'hex', r: arr[0], g: arr[1], b: arr[2], a: a };

                obj = Object.assign(obj, RGBtoHSL(obj));

                return obj;
            }
        } else if (typeof str == 'number') {
            if (0x000000 <= str && str <= 0xffffff) {
                var r = (str & 0xff0000) >> 16;
                var g = (str & 0x00ff00) >> 8;
                var b = (str & 0x0000ff) >> 0;

                var obj = { type: 'hex', r: r, g: g, b: b, a: 1 };
                obj = Object.assign(obj, RGBtoHSL(obj));
                return obj;
            } else if (0x00000000 <= str && str <= 0xffffffff) {
                var _r = (str & 0xff000000) >> 24;
                var _g = (str & 0x00ff0000) >> 16;
                var _b = (str & 0x0000ff00) >> 8;
                var _a = (str & 0x000000ff) / 255;

                var obj = { type: 'hex', r: _r, g: _g, b: _b, a: _a };
                obj = Object.assign(obj, RGBtoHSL(obj));

                return obj;
            }
        }

        return str;
    }

    function parseGradient(colors) {
        if (typeof colors == 'string') {
            colors = convertMatchesArray(colors);
        }

        colors = colors.map(function (it) {
            if (typeof it == 'string') {
                var ret = convertMatches(it);
                var arr = trim(ret.str).split(' ');

                if (arr[1]) {
                    if (arr[1].includes('%')) {
                        arr[1] = parseFloat(arr[1].replace(/%/, '')) / 100;
                    } else {
                        arr[1] = parseFloat(arr[1]);
                    }
                } else {
                    arr[1] = '*';
                }

                arr[0] = reverseMatches(arr[0], ret.matches);

                return arr;
            } else if (Array.isArray(it)) {

                if (!it[1]) {
                    it[1] = '*';
                } else if (typeof it[1] == 'string') {
                    if (it[1].includes('%')) {
                        it[1] = parseFloat(it[1].replace(/%/, '')) / 100;
                    } else {
                        it[1] = +it[1];
                    }
                }

                return [].concat(toConsumableArray(it));
            }
        });

        var count = colors.filter(function (it) {
            return it[1] === '*';
        }).length;

        if (count > 0) {
            var sum = colors.filter(function (it) {
                return it[1] != '*' && it[1] != 1;
            }).map(function (it) {
                return it[1];
            }).reduce(function (total, cur) {
                return total + cur;
            }, 0);

            var dist = (1 - sum) / count;
            colors.forEach(function (it, index) {
                if (it[1] == '*' && index > 0) {
                    if (colors.length - 1 == index) ; else {
                        it[1] = dist;
                    }
                }
            });
        }

        return colors;
    }

    var parser = {
        matches: matches,
        convertMatches: convertMatches,
        convertMatchesArray: convertMatchesArray,
        reverseMatches: reverseMatches,
        parse: parse,
        parseGradient: parseGradient,
        trim: trim,
        color_regexp: color_regexp,
        color_split: color_split
    };

    /**
     * @method RGBtoHSV
     *
     * convert rgb to hsv
     *
     * 		color.RGBtoHSV(0, 0, 255) === { h : 240, s : 1, v : 1 } === '#FFFF00'
     *
     * @param {Number} R  red color value
     * @param {Number} G  green color value
     * @param {Number} B  blue color value
     * @return {Object}  hsv color code
     */
    function RGBtoHSV(r, g, b) {

        if (arguments.length == 1) {
            var _arguments$ = arguments[0],
                r = _arguments$.r,
                g = _arguments$.g,
                b = _arguments$.b;
        }

        var R1 = r / 255;
        var G1 = g / 255;
        var B1 = b / 255;

        var MaxC = Math.max(R1, G1, B1);
        var MinC = Math.min(R1, G1, B1);

        var DeltaC = MaxC - MinC;

        var H = 0;

        if (DeltaC == 0) {
            H = 0;
        } else if (MaxC == R1) {
            H = 60 * ((G1 - B1) / DeltaC % 6);
        } else if (MaxC == G1) {
            H = 60 * ((B1 - R1) / DeltaC + 2);
        } else if (MaxC == B1) {
            H = 60 * ((R1 - G1) / DeltaC + 4);
        }

        if (H < 0) {
            H = 360 + H;
        }

        var S = 0;

        if (MaxC == 0) S = 0;else S = DeltaC / MaxC;

        var V = MaxC;

        return { h: H, s: S, v: V };
    }

    function RGBtoCMYK(r, g, b) {

        if (arguments.length == 1) {
            var _arguments$2 = arguments[0],
                r = _arguments$2.r,
                g = _arguments$2.g,
                b = _arguments$2.b;
        }

        var R1 = r / 255;
        var G1 = g / 255;
        var B1 = b / 255;

        var K = 1 - Math.max(R1, G1, B1);
        var C = (1 - R1 - K) / (1 - K);
        var M = (1 - G1 - K) / (1 - K);
        var Y = (1 - B1 - K) / (1 - K);

        return { c: C, m: M, y: Y, k: K };
    }

    function RGBtoHSL(r, g, b) {

        if (arguments.length == 1) {
            var _arguments$3 = arguments[0],
                r = _arguments$3.r,
                g = _arguments$3.g,
                b = _arguments$3.b;
        }

        r /= 255, g /= 255, b /= 255;
        var max = Math.max(r, g, b),
            min = Math.min(r, g, b);
        var h,
            s,
            l = (max + min) / 2;

        if (max == min) {
            h = s = 0; // achromatic
        } else {
            var d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);break;
                case g:
                    h = (b - r) / d + 2;break;
                case b:
                    h = (r - g) / d + 4;break;
            }
            h /= 6;
        }

        return { h: round(h * 360), s: round(s * 100), l: round(l * 100) };
    }

    function c(r, g, b) {

        if (arguments.length == 1) {
            var _arguments$4 = arguments[0],
                r = _arguments$4.r,
                g = _arguments$4.g,
                b = _arguments$4.b;
        }
        return gray((r + g + b) / 3 > 90 ? 0 : 255);
    }

    function gray(gray) {
        return { r: gray, g: gray, b: gray };
    }

    function RGBtoSimpleGray(r, g, b) {

        if (arguments.length == 1) {
            var _arguments$5 = arguments[0],
                r = _arguments$5.r,
                g = _arguments$5.g,
                b = _arguments$5.b;
        }
        return gray(Math.ceil((r + g + b) / 3));
    }

    function RGBtoGray(r, g, b) {

        if (arguments.length == 1) {
            var _arguments$6 = arguments[0],
                r = _arguments$6.r,
                g = _arguments$6.g,
                b = _arguments$6.b;
        }
        return gray(RGBtoYCrCb(r, g, b).y);
    }

    function brightness(r, g, b) {
        return Math.ceil(r * 0.2126 + g * 0.7152 + b * 0.0722);
    }







    function RGBtoYCrCb(r, g, b) {

        if (arguments.length == 1) {
            var _arguments$7 = arguments[0],
                r = _arguments$7.r,
                g = _arguments$7.g,
                b = _arguments$7.b;
        }
        var Y = brightness(r, g, b);
        var Cb = 0.564 * (b - Y);
        var Cr = 0.713 * (r - Y);

        return { y: Y, cr: Cr, cb: Cb };
    }

    function PivotRGB(n) {
        var point = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.04045;

        return (n > point ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92) * 100;
    }

    function RGBtoXYZ(r, g, b) {
        //sR, sG and sB (Standard RGB) input range = 0  255
        //X, Y and Z output refer to a D65/2 standard illuminant.
        if (arguments.length == 1) {
            var _arguments$8 = arguments[0],
                r = _arguments$8.r,
                g = _arguments$8.g,
                b = _arguments$8.b;
        }

        var R = r / 255;
        var G = g / 255;
        var B = b / 255;

        R = PivotRGB(R);
        G = PivotRGB(G);
        B = PivotRGB(B);

        var x = R * 0.4124 + G * 0.3576 + B * 0.1805;
        var y = R * 0.2126 + G * 0.7152 + B * 0.0722;
        var z = R * 0.0193 + G * 0.1192 + B * 0.9505;

        return { x: x, y: y, z: z };
    }

    function RGBtoLAB(r, g, b) {
        if (arguments.length == 1) {
            var _arguments$9 = arguments[0],
                r = _arguments$9.r,
                g = _arguments$9.g,
                b = _arguments$9.b;
        }
        return XYZtoLAB(RGBtoXYZ(r, g, b));
    }

    var fromRGB = {
        RGBtoCMYK: RGBtoCMYK,
        RGBtoGray: RGBtoGray,
        RGBtoHSL: RGBtoHSL,
        RGBtoHSV: RGBtoHSV,
        RGBtoLAB: RGBtoLAB,
        RGBtoSimpleGray: RGBtoSimpleGray,
        RGBtoXYZ: RGBtoXYZ,
        RGBtoYCrCb: RGBtoYCrCb,
        c: c,
        brightness: brightness,
        gray: gray
    };

    function CMYKtoRGB(c, m, y, k) {

        if (arguments.length == 1) {
            var _arguments$ = arguments[0],
                c = _arguments$.c,
                m = _arguments$.m,
                y = _arguments$.y,
                k = _arguments$.k;
        }

        var R = 255 * (1 - c) * (1 - k);
        var G = 255 * (1 - m) * (1 - k);
        var B = 255 * (1 - y) * (1 - k);

        return { r: R, g: G, b: B };
    }

    var fromCMYK = {
        CMYKtoRGB: CMYKtoRGB
    };

    function ReverseXyz(n) {
        return Math.pow(n, 3) > 0.008856 ? Math.pow(n, 3) : (n - 16 / 116) / 7.787;
    }

    function ReverseRGB(n) {
        return n > 0.0031308 ? 1.055 * Math.pow(n, 1 / 2.4) - 0.055 : 12.92 * n;
    }

    function XYZtoRGB(x, y, z) {
        if (arguments.length == 1) {
            var _arguments$ = arguments[0],
                x = _arguments$.x,
                y = _arguments$.y,
                z = _arguments$.z;
        }
        //X, Y and Z input refer to a D65/2 standard illuminant.
        //sR, sG and sB (standard RGB) output range = 0  255

        var X = x / 100.0;
        var Y = y / 100.0;
        var Z = z / 100.0;

        var R = X * 3.2406 + Y * -1.5372 + Z * -0.4986;
        var G = X * -0.9689 + Y * 1.8758 + Z * 0.0415;
        var B = X * 0.0557 + Y * -0.2040 + Z * 1.0570;

        R = ReverseRGB(R);
        G = ReverseRGB(G);
        B = ReverseRGB(B);

        var r = round(R * 255);
        var g = round(G * 255);
        var b = round(B * 255);

        return { r: r, g: g, b: b };
    }

    function LABtoXYZ(l, a, b) {
        if (arguments.length == 1) {
            var _arguments$2 = arguments[0],
                l = _arguments$2.l,
                a = _arguments$2.a,
                b = _arguments$2.b;
        }
        //Reference-X, Y and Z refer to specific illuminants and observers.
        //Common reference values are available below in this same page.

        var Y = (l + 16) / 116;
        var X = a / 500 + Y;
        var Z = Y - b / 200;

        Y = ReverseXyz(Y);
        X = ReverseXyz(X);
        Z = ReverseXyz(Z);

        var x = X * 95.047;
        var y = Y * 100.000;
        var z = Z * 108.883;

        return { x: x, y: y, z: z };
    }





    function LABtoRGB(l, a, b) {
        if (arguments.length == 1) {
            var _arguments$4 = arguments[0],
                l = _arguments$4.l,
                a = _arguments$4.a,
                b = _arguments$4.b;
        }
        return XYZtoRGB(LABtoXYZ(l, a, b));
    }

    var fromLAB = {
        XYZtoRGB: XYZtoRGB,
        LABtoRGB: LABtoRGB,
        LABtoXYZ: LABtoXYZ
    };

    /**
     * @method HSVtoRGB
     *
     * convert hsv to rgb
     *
     * 		color.HSVtoRGB(0,0,1) === #FFFFF === { r : 255, g : 0, b : 0 }
     *
     * @param {Number} H  hue color number  (min : 0, max : 360)
     * @param {Number} S  Saturation number  (min : 0, max : 1)
     * @param {Number} V  Value number 		(min : 0, max : 1 )
     * @returns {Object}
     */
    function HSVtoRGB(h, s, v) {

        if (arguments.length == 1) {
            var _arguments$ = arguments[0],
                h = _arguments$.h,
                s = _arguments$.s,
                v = _arguments$.v;
        }

        var H = h;
        var S = s;
        var V = v;

        if (H >= 360) {
            H = 0;
        }

        var C = S * V;
        var X = C * (1 - Math.abs(H / 60 % 2 - 1));
        var m = V - C;

        var temp = [];

        if (0 <= H && H < 60) {
            temp = [C, X, 0];
        } else if (60 <= H && H < 120) {
            temp = [X, C, 0];
        } else if (120 <= H && H < 180) {
            temp = [0, C, X];
        } else if (180 <= H && H < 240) {
            temp = [0, X, C];
        } else if (240 <= H && H < 300) {
            temp = [X, 0, C];
        } else if (300 <= H && H < 360) {
            temp = [C, 0, X];
        }

        return {
            r: round((temp[0] + m) * 255),
            g: round((temp[1] + m) * 255),
            b: round((temp[2] + m) * 255)
        };
    }

    function HSVtoHSL(h, s, v) {

        if (arguments.length == 1) {
            var _arguments$2 = arguments[0],
                h = _arguments$2.h,
                s = _arguments$2.s,
                v = _arguments$2.v;
        }

        var rgb = HSVtoRGB(h, s, v);

        return RGBtoHSL(rgb.r, rgb.g, rgb.b);
    }

    var fromHSV = {
        HSVtoHSL: HSVtoHSL,
        HSVtoRGB: HSVtoRGB
    };

    function YCrCbtoRGB(y, cr, cb, bit) {

        if (arguments.length == 1) {
            var _arguments$ = arguments[0],
                y = _arguments$.y,
                cr = _arguments$.cr,
                cb = _arguments$.cb,
                bit = _arguments$.bit;

            bit = bit || 0;
        }
        var R = y + 1.402 * (cr - bit);
        var G = y - 0.344 * (cb - bit) - 0.714 * (cr - bit);
        var B = y + 1.772 * (cb - bit);

        return { r: Math.ceil(R), g: Math.ceil(G), b: Math.ceil(B) };
    }

    var fromYCrCb = {
        YCrCbtoRGB: YCrCbtoRGB
    };

    /**
     * @deprecated
     *
     * instead of this,  use blend function
     *
     * @param {*} startColor
     * @param {*} endColor
     * @param {*} t
     */
    function interpolateRGB(startColor, endColor) {
        var t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;
        var exportFormat = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'hex';

        var obj = {
            r: round(startColor.r + (endColor.r - startColor.r) * t),
            g: round(startColor.g + (endColor.g - startColor.g) * t),
            b: round(startColor.b + (endColor.b - startColor.b) * t),
            a: round(startColor.a + (endColor.a - startColor.a) * t, 100)
        };

        return format(obj, obj.a < 1 ? 'rgb' : exportFormat);
    }

    function scale$1(scale) {
        var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;

        if (!scale) return [];

        if (typeof scale === 'string') {
            scale = convertMatchesArray(scale);
        }

        scale = scale || [];
        var len = scale.length;

        var colors = [];
        for (var i = 0; i < len - 1; i++) {
            for (var index = 0; index < count; index++) {
                colors.push(blend(scale[i], scale[i + 1], index / count));
            }
        }
        return colors;
    }

    function blend(startColor, endColor) {
        var ratio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;
        var format$$1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'hex';

        var s = parse(startColor);
        var e = parse(endColor);

        return interpolateRGB(s, e, ratio, format$$1);
    }

    function mix(startcolor, endColor) {
        var ratio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;
        var format$$1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'hex';

        return blend(startcolor, endColor, ratio, format$$1);
    }

    /**
     *
     * @param {Color|String} c
     */
    function contrast(c$$1) {
        c$$1 = parse(c$$1);
        return (Math.round(c$$1.r * 299) + Math.round(c$$1.g * 587) + Math.round(c$$1.b * 114)) / 1000;
    }

    function contrastColor(c$$1) {
        return contrast(c$$1) >= 128 ? 'black' : 'white';
    }

    function gradient(colors) {
        var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;

        colors = parseGradient(colors);

        var newColors = [];
        var maxCount = count - (colors.length - 1);
        var allCount = maxCount;

        for (var i = 1, len = colors.length; i < len; i++) {

            var startColor = colors[i - 1][0];
            var endColor = colors[i][0];

            // if it is second color
            var rate = i == 1 ? colors[i][1] : colors[i][1] - colors[i - 1][1];

            // if it is last color
            var colorCount = i == colors.length - 1 ? allCount : Math.floor(rate * maxCount);

            newColors = newColors.concat(scale$1([startColor, endColor], colorCount), [endColor]);

            allCount -= colorCount;
        }
        return newColors;
    }

    function scaleHSV(color) {
        var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'h';
        var count = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 9;
        var exportFormat = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'rgb';
        var min = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
        var max = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
        var dist = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 100;

        var colorObj = parse(color);
        var hsv = RGBtoHSV(colorObj);
        var unit = (max - min) * dist / count;

        var results = [];
        for (var i = 1; i <= count; i++) {
            hsv[target] = Math.abs((dist - unit * i) / dist);
            results.push(format(HSVtoRGB(hsv), exportFormat));
        }

        return results;
    }

    function scaleH(color) {
        var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 9;
        var exportFormat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'rgb';
        var min = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var max = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 360;

        return scaleHSV(color, 'h', count, exportFormat, min, max, 1);
    }

    function scaleS(color) {
        var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 9;
        var exportFormat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'rgb';
        var min = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var max = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;

        return scaleHSV(color, 's', count, exportFormat, min, max, 100);
    }

    function scaleV(color) {
        var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 9;
        var exportFormat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'rgb';
        var min = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var max = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;

        return scaleHSV(color, 'v', count, exportFormat, min, max, 100);
    }

    /* predefined scale colors */
    scale$1.parula = function (count) {
        return scale$1(['#352a87', '#0f5cdd', '#00b5a6', '#ffc337', '#fdff00'], count);
    };

    scale$1.jet = function (count) {
        return scale$1(['#00008f', '#0020ff', '#00ffff', '#51ff77', '#fdff00', '#ff0000', '#800000'], count);
    };

    scale$1.hsv = function (count) {
        return scale$1(['#ff0000', '#ffff00', '#00ff00', '#00ffff', '#0000ff', '#ff00ff', '#ff0000'], count);
    };

    scale$1.hot = function (count) {
        return scale$1(['#0b0000', '#ff0000', '#ffff00', '#ffffff'], count);
    };
    scale$1.pink = function (count) {
        return scale$1(['#1e0000', '#bd7b7b', '#e7e5b2', '#ffffff'], count);
    };

    scale$1.bone = function (count) {
        return scale$1(['#000000', '#4a4a68', '#a6c6c6', '#ffffff'], count);
    };

    scale$1.copper = function (count) {
        return scale$1(['#000000', '#3d2618', '#9d623e', '#ffa167', '#ffc77f'], count);
    };

    var mixin = {
        interpolateRGB: interpolateRGB,
        blend: blend,
        mix: mix,
        scale: scale$1,
        contrast: contrast,
        contrastColor: contrastColor,
        gradient: gradient,
        scaleHSV: scaleHSV,
        scaleH: scaleH,
        scaleS: scaleS,
        scaleV: scaleV
    };

    function array_equals(v1, v2) {
        if (v1.length !== v2.length) return false;
        for (var i = 0, len = v1.length; i < len; ++i) {
            if (v1[i] !== v2[i]) return false;
        }
        return true;
    }

    function euclidean(v1, v2) {
        var total = 0;

        for (var i = 0, len = v1.length; i < len; i++) {
            total += Math.pow(v2[i] - v1[i], 2);
        }

        return Math.sqrt(total);
    }

    function manhattan(v1, v2) {
        var total = 0;

        for (var i = 0, len = v1.length; i < len; i++) {
            total += Math.abs(v2[i] - v1[i]);
        }

        return total;
    }

    function max(v1, v2) {
        var max = 0;
        for (var i = 0, len = v1.length; i < len; i++) {
            max = Math.max(max, Math.abs(v2[i] - v1[i]));
        }

        return max;
    }

    var distances = {
        euclidean: euclidean,
        manhattan: manhattan,
        max: max
    };

    var create_random_number = {
        linear: function linear(num, count) {
            var centeroids = [];
            var start = Math.round(Math.random() * num);
            var dist = Math.floor(num / count);

            do {

                centeroids.push(start);

                start = (start + dist) % num;
            } while (centeroids.length < count);

            return centeroids;
        },

        shuffle: function shuffle(num, count) {
            var centeroids = [];

            while (centeroids.length < count) {

                var index = Math.round(Math.random() * num);

                if (centeroids.indexOf(index) == -1) {
                    centeroids.push(index);
                }
            }

            return centeroids;
        }

    };

    function randomCentroids(points, k) {
        var method = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'linear';


        var centeroids = create_random_number[method](points.length, k);

        return centeroids.map(function (i) {
            return points[i];
        });

        // var centeroids = points.slice(0);

        // centeroids.sort(function () {
        //     return (Math.round(Math.random()) - 0.5);
        // })

        // return centeroids.slice(0, k);
    }

    function closestCenteroid(point, centeroids, distance) {
        var min = Infinity,
            kIndex = 0;

        centeroids.forEach(function (center, i) {
            var dist = distance(point, center);

            if (dist < min) {
                min = dist;
                kIndex = i;
            }
        });

        return kIndex;
    }

    function getCenteroid(assigned) {

        if (!assigned.length) return [];

        // initialize centeroid list
        var centeroid = new Array(assigned[0].length);
        for (var i = 0, len = centeroid.length; i < len; i++) {
            centeroid[i] = 0;
        }

        for (var index = 0, len = assigned.length; index < len; index++) {
            var it = assigned[index];

            var last = index + 1;

            for (var j = 0, jLen = it.length; j < jLen; j++) {
                centeroid[j] += (it[j] - centeroid[j]) / last;
            }
        }

        centeroid = centeroid.map(function (it) {
            return Math.floor(it);
        });

        return centeroid;
    }

    function unique_array(arrays) {
        return arrays;
    }

    function splitK(k, points, centeroids, distance) {
        var assignment = new Array(k);

        for (var i = 0; i < k; i++) {
            assignment[i] = [];
        }

        for (var idx = 0, pointLength = points.length; idx < pointLength; idx++) {
            var point = points[idx];
            var index = closestCenteroid(point, centeroids, distance);
            assignment[index].push(point);
        }

        return assignment;
    }

    function setNewCenteroid(k, points, assignment, centeroids, movement, randomFunction) {

        for (var i = 0; i < k; i++) {
            var assigned = assignment[i];

            var centeroid = centeroids[i];
            var newCenteroid = new Array(centeroid.length);

            if (assigned.length > 0) {
                newCenteroid = getCenteroid(assigned);
            } else {
                var idx = Math.floor(randomFunction() * points.length);
                newCenteroid = points[idx];
            }

            if (array_equals(newCenteroid, centeroid)) {
                movement = false;
            } else {
                movement = true;
            }

            centeroids[i] = newCenteroid;
        }

        return movement;
    }

    function kmeans(points, k, distanceFunction) {
        var period = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;
        var initialRandom = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'linear';

        points = unique_array(points);

        k = k || Math.max(2, Math.ceil(Math.sqrt(points.length / 2)));

        var distance = distanceFunction || 'euclidean';
        if (typeof distance == 'string') {
            distance = distances[distance];
        }

        var rng_seed = 0;
        var random = function random() {
            rng_seed = (rng_seed * 9301 + 49297) % 233280;
            return rng_seed / 233280;
        };

        var centeroids = randomCentroids(points, k, initialRandom);

        var movement = true;
        var iterations = 0;
        while (movement) {
            var assignment = splitK(k, points, centeroids, distance);

            movement = setNewCenteroid(k, points, assignment, centeroids, false, random);

            iterations++;

            if (iterations % period == 0) {
                break;
            }
        }

        return centeroids;
    }

    function each(len, callback) {
        for (var i = 0; i < len; i += 4) {
            callback(i);
        }
    }

    function pack(bitmap, callback) {

        each(bitmap.pixels.length, function (i) {
            callback(bitmap.pixels, i);
        });
    }

    var Canvas = {
        create: function create(width, height) {
            var canvas = document.createElement('canvas');
            canvas.width = width || 0;
            canvas.height = height || 0;

            return canvas;
        },
        drawPixels: function drawPixels(bitmap) {
            var canvas = this.create(bitmap.width, bitmap.height);

            var context = canvas.getContext('2d');
            var imagedata = context.getImageData(0, 0, canvas.width, canvas.height);

            imagedata.data.set(bitmap.pixels);

            context.putImageData(imagedata, 0, 0);

            return canvas;
        },
        createHistogram: function createHistogram(width, height, histogram, callback) {
            var opt = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : { black: true, red: false, green: false, blue: false };

            var canvas = this.create(width, height);
            var context = canvas.getContext('2d');
            context.clearRect(0, 0, width, height);
            context.fillStyle = "white";
            context.fillRect(0, 0, width, height);
            context.globalAlpha = 0.7;

            var omit = { black: false };
            if (opt.black) {
                omit.black = false;
            } else {
                omit.black = true;
            }
            if (opt.red) {
                omit.red = false;
            } else {
                omit.red = true;
            }
            if (opt.green) {
                omit.green = false;
            } else {
                omit.green = true;
            }
            if (opt.blue) {
                omit.blue = false;
            } else {
                omit.blue = true;
            }

            Object.keys(histogram).forEach(function (color) {

                if (!omit[color]) {

                    var array = histogram[color];
                    var ymax = Math.max.apply(Math, array);
                    var unitWith = width / array.length;

                    context.fillStyle = color;
                    array.forEach(function (it, index) {
                        var currentHeight = height * (it / ymax);
                        var x = index * unitWith;

                        context.fillRect(x, height - currentHeight, unitWith, currentHeight);
                    });
                }
            });

            if (typeof callback == 'function') callback(canvas);
        },
        getHistogram: function getHistogram(bitmap) {
            var black = new Array(256);
            var red = new Array(256);
            var green = new Array(256);
            var blue = new Array(256);
            for (var i = 0; i < 256; i++) {
                black[i] = 0;
                red[i] = 0;
                green[i] = 0;
                blue[i] = 0;
            }

            pack(bitmap, function (pixels, i) {
                // gray scale
                var grayIndex = Math.round(Color$1.brightness(pixels[i], pixels[i + 1], pixels[i + 2]));
                black[grayIndex]++;

                red[pixels[i]]++;
                green[pixels[i + 1]]++;
                blue[pixels[i + 2]]++;
            });

            return { black: black, red: red, green: green, blue: blue };
        },
        getBitmap: function getBitmap(bitmap, area) {
            var canvas = this.drawPixels(bitmap);

            var context = canvas.getContext('2d');
            var pixels = context.getImageData(area.x || 0, area.y || 0, area.width || canvas.width, area.height || canvas.height).data;

            return { pixels: pixels, width: area.width, height: area.height };
        },
        putBitmap: function putBitmap(bitmap, subBitmap, area) {

            var canvas = this.drawPixels(bitmap);
            var subCanvas = this.drawPixels(subBitmap);

            var context = canvas.getContext('2d');
            context.drawImage(subCanvas, area.x, area.y);

            bitmap.pixels = context.getImageData(0, 0, bitmap.width, bitmap.height).data;

            return bitmap;
        }
    };

    var ImageLoader = function () {
        function ImageLoader(url) {
            var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            classCallCheck(this, ImageLoader);

            this.isLoaded = false;
            this.imageUrl = url;
            this.opt = opt;
            this.initialize();
        }

        createClass(ImageLoader, [{
            key: 'initialize',
            value: function initialize() {
                this.canvas = this.createCanvas();
                this.context = this.canvas.getContext('2d');
            }
        }, {
            key: 'createCanvas',
            value: function createCanvas() {
                return document.createElement('canvas');
            }
        }, {
            key: 'load',
            value: function load(callback) {
                this.loadImage(callback);
            }
        }, {
            key: 'loadImage',
            value: function loadImage(callback) {
                var _this = this;

                var ctx = this.context;
                this.newImage = new Image();
                var img = this.newImage;
                img.onload = function () {
                    var ratio = img.height / img.width;

                    if (_this.opt.canvasWidth && _this.opt.canvasHeight) {
                        _this.canvas.width = _this.opt.canvasWidth;
                        _this.canvas.height = _this.opt.canvasHeight;
                    } else {
                        _this.canvas.width = _this.opt.maxWidth ? _this.opt.maxWidth : img.width;
                        _this.canvas.height = _this.canvas.width * ratio;
                    }

                    ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, _this.canvas.width, _this.canvas.height);
                    _this.isLoaded = true;
                    callback && callback();
                };

                this.getImageUrl(function (url) {
                    img.src = url;
                });
            }
        }, {
            key: 'load',
            value: function load(callback) {
                var _this2 = this;

                this.newImage = new Image();
                var img = this.newImage;
                img.onload = function () {
                    _this2.isLoaded = true;
                    callback && callback();
                };

                this.getImageUrl(function (url) {
                    img.src = url;
                });
            }
        }, {
            key: 'getImageUrl',
            value: function getImageUrl(callback) {
                if (typeof this.imageUrl == 'string') {
                    return callback(this.imageUrl);
                } else if (this.imageUrl instanceof Blob) {
                    var reader = new FileReader();

                    reader.onload = function (ev) {
                        callback(ev.target.result);
                    };

                    reader.readAsDataURL(this.imageUrl);
                }
            }
        }, {
            key: 'getRGBA',
            value: function getRGBA(r, g, b, a) {
                return [r, g, b, a];
            }
        }, {
            key: 'toArray',
            value: function toArray$$1(filter, callback) {
                var opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

                var imagedata = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);
                var width = imagedata.width;
                var height = imagedata.height;

                var pixels = new Uint8ClampedArray(imagedata.data);

                var bitmap = { pixels: pixels, width: width, height: height };

                if (!filter) {
                    filter = function () {
                        return function (bitmap, done) {
                            done(bitmap);
                        };
                    }();
                }

                filter(bitmap, function (newBitmap) {
                    var tmpCanvas = Canvas.drawPixels(newBitmap);

                    if (opt.returnTo == 'canvas') {
                        callback(tmpCanvas);
                    } else {
                        callback(tmpCanvas.toDataURL(opt.outputFormat || 'image/png'));
                    }
                }, opt);
            }
        }, {
            key: 'toHistogram',
            value: function toHistogram(opt) {
                var imagedata = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);
                var width = imagedata.width;
                var height = imagedata.height;

                var pixels = new Uint8ClampedArray(imagedata.data);

                var bitmap = { pixels: pixels, width: width, height: height };

                return Canvas.getHistogram(bitmap);
            }
        }, {
            key: 'toRGB',
            value: function toRGB() {
                var imagedata = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);

                var rgba = imagedata.data;
                var results = [];
                for (var i = 0, len = rgba.length; i < len; i += 4) {
                    results[results.length] = [rgba[i + 0], rgba[i + 1], rgba[i + 2], rgba[i + 3]];
                }

                return results;
            }
        }]);
        return ImageLoader;
    }();

    // import GL from '../GL'
    function palette(colors) {
        var k = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6;
        var exportFormat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'hex';


        if (colors.length > k) {
            colors = kmeans(colors, k);
        }

        return colors.map(function (c) {
            return format(c, exportFormat);
        });
    }

    function ImageToRGB(url) {
        var callbackOrOption = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var callback = arguments[2];


        if (!callback) {
            var img = new ImageLoader(url);
            img.loadImage(function () {
                if (typeof callbackOrOption == 'function') {
                    callbackOrOption(img.toRGB());
                }
            });
        } else if (callback) {
            var img = new ImageLoader(url, callbackOrOption);
            img.loadImage(function () {
                if (typeof callback == 'function') {
                    callback(img.toRGB());
                }
            });
        }
    }

    function ImageToCanvas(url, filter, callback) {
        var opt = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : { frameTimer: 'full' };

        ImageToURL(url, filter, callback, Object.assign({
            returnTo: 'canvas'
        }, opt));
    }

    function ImageToURL(url, filter, callback) {
        var opt = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : { frameTimer: 'full' };

        var img = new ImageLoader(url);
        img.loadImage(function () {
            img.toArray(filter, function (datauri) {
                if (typeof callback == 'function') {
                    callback(datauri);
                }
            }, opt);
        });
    }

    // export function GLToCanvas (url, filter, callback, opt = {}) {
    //     var img = new ImageLoader(url);
    //     img.load(() => {
    //         GL.filter(img.newImage, filter, function done (datauri) {
    //             if (typeof callback == 'function') {
    //                 callback(datauri)
    //             }
    //         }, opt)
    //     })
    // }

    function histogram(url, callback) {
        var opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        var img = new ImageLoader(url);
        img.loadImage(function () {
            if (typeof callback == 'function') {
                callback(img.toHistogram(opt));
            }
        });
    }

    function histogramToPoints(points) {
        var tension = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.2;


        var controlPoints = [];
        for (var i = 0; i < points.length; i++) {
            var p = points[i];
            if (i == 0) {
                controlPoints[i] = [];
                continue;
            }

            if (i == points.length - 1) {
                controlPoints[i] = [];
                continue;
            }

            var prevPoint = points[i - 1];
            var nextPoint = points[i + 1];

            // 
            (nextPoint[1] - prevPoint[1]) / (nextPoint[0] - prevPoint[0]);

            var newControlPoint = [prevPoint[0] + (nextPoint[0] - prevPoint[0]) * tension, prevPoint[1] + (nextPoint[1] - prevPoint[1]) * tension];

            var controlPoint = [[].concat(toConsumableArray(prevPoint)), /* start */
            [].concat(newControlPoint) /* end */
            ];

            var P = Math.sqrt(Math.pow(p[0] - prevPoint[0], 2) + Math.pow(p[1] - prevPoint[1], 2));
            var N = Math.sqrt(Math.pow(nextPoint[0] - p[0], 2) + Math.pow(nextPoint[1] - p[1], 2));

            var rate = P / N;

            var dx = controlPoint[0][0] + (controlPoint[1][0] - controlPoint[0][0]) * rate;
            var dy = controlPoint[0][1] + (controlPoint[1][1] - controlPoint[0][1]) * rate;

            controlPoint[0][0] += p[0] - dx;
            controlPoint[0][1] += p[1] - dy;
            controlPoint[1][0] += p[0] - dx;
            controlPoint[1][1] += p[1] - dy;

            controlPoints[i] = controlPoint;
        }

        return controlPoints;
    }

    function ImageToHistogram(url, callback) {
        var opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { width: 200, height: 100 };


        var img = new ImageLoader(url);
        img.loadImage(function () {
            Canvas.createHistogram(opt.width || 200, opt.height || 100, img.toHistogram(opt), function (canvas) {
                if (typeof callback == 'function') callback(canvas.toDataURL('image/png'));
            }, opt);
        });
    }

    var image = {
        palette: palette,
        ImageToCanvas: ImageToCanvas,
        ImageToHistogram: ImageToHistogram,
        ImageToRGB: ImageToRGB,
        ImageToURL: ImageToURL,
        // GLToCanvas,
        histogram: histogram,
        histogramToPoints: histogramToPoints
    };

    var Color$1 = _extends({}, formatter, math, mixin, parser, fromYCrCb, fromRGB, fromCMYK, fromHSV, fromHSL, fromLAB, image);

    function isUndefined$1(value) {
        return typeof value == 'undefined' || value === null;
    }

    function isNotUndefined(value) {
        return isUndefined$1(value) === false;
    }





    function isString$1(value) {
        return typeof value == 'string';
    }





    function isFunction(value) {
        return typeof value == 'function';
    }

    function isNumber(value) {
        return typeof value == 'number';
    }

    var hue_color = [{ rgb: '#ff0000', start: .0 }, { rgb: '#ffff00', start: .17 }, { rgb: '#00ff00', start: .33 }, { rgb: '#00ffff', start: .50 }, { rgb: '#0000ff', start: .67 }, { rgb: '#ff00ff', start: .83 }, { rgb: '#ff0000', start: 1 }];

    function checkHueColor(p) {
        var startColor, endColor;

        for (var i = 0; i < hue_color.length; i++) {
            if (hue_color[i].start >= p) {
                startColor = hue_color[i - 1];
                endColor = hue_color[i];
                break;
            }
        }

        if (startColor && endColor) {
            return Color$1.mix(startColor.rgb, endColor.rgb, (p - startColor.start) / (endColor.start - startColor.start));
        }
        return hue_color[0].rgb;
    }

    function getHueScale(p) {
        var minScale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.1;
        var maxScale = arguments[2];


        var start = isUndefined$1(maxScale) ? p - minScale : minScale;
        var end = isUndefined$1(maxScale) ? p + scale : maxScale;

        var list = [];

        // console.log(start, checkHueColor(start));

        for (var i = 0; i < hue_color.length; i++) {
            var currentHue = hue_color[i];

            if (start <= currentHue.start && currentHue.start < end) {
                list.push({ rgb: currentHue.rgb, start: currentHue.start });
                // list.push({ rgb: checkHueColor(start), start })
            } else if (hue_color[i + 1] && currentHue.start < start && start < hue_color[i + 1].start) {
                list.push({ rgb: checkHueColor(start), start: start });
            } else if (hue_color[i - 1] && hue_color[i - 1].start < end && end < currentHue.start) {
                list.push({ rgb: checkHueColor(end), start: end });
            } else if (currentHue.start < start || currentHue.start > end) ; else {
                list.push({ rgb: currentHue.rgb, start: currentHue.start });
            }
        }

        return list;
    }

    function initHueColors() {
        for (var i = 0, len = hue_color.length; i < len; i++) {
            var hue = hue_color[i];

            var obj = Color$1.parse(hue.rgb);

            hue.r = obj.r;
            hue.g = obj.g;
            hue.b = obj.b;
        }
    }

    initHueColors();

    var HueColor = {
        colors: hue_color,
        checkHueColor: checkHueColor,
        getHueScale: getHueScale
    };

    var CONSTANT = {
        identity: function identity() {
            return [1, 0, 0, 0, 1, 0, 0, 0, 1];
        },
        stretching: function stretching(k) {
            return [k, 0, 0, 0, 1, 0, 0, 0, 1];
        },
        squeezing: function squeezing(k) {
            return [k, 0, 0, 0, 1 / k, 0, 0, 0, 1];
        },
        scale: function scale() {
            var sx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var sy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

            sx = sx || sx === 0 ? sx : 1;
            sy = sy || sy === 0 ? sy : 1;
            return [sx, 0, 0, 0, sy, 0, 0, 0, 1];
        },
        scaleX: function scaleX(sx) {
            return this.scale(sx);
        },
        scaleY: function scaleY(sy) {
            return this.scale(1, sy);
        },
        translate: function translate(tx, ty) {
            return [1, 0, tx, 0, 1, ty, 0, 0, 1];
        },
        rotate: function rotate(angle) {
            var r = this.radian(angle);
            return [Math.cos(r), -Math.sin(r), 0, Math.sin(r), Math.cos(r), 0, 0, 0, 1];
        },
        rotate90: function rotate90() {
            return [0, -1, 0, 1, 0, 0, 0, 0, 1];
        },
        rotate180: function rotate180() {
            return [-1, 0, 0, 0, -1, 0, 0, 0, 1];
        },
        rotate270: function rotate270() {
            return [0, 1, 0, -1, 0, 0, 0, 0, 1];
        },
        radian: function radian(degree) {
            return degree * Math.PI / 180;
        },
        skew: function skew(degreeX, degreeY) {
            var radianX = this.radian(degreeX);
            var radianY = this.radian(degreeY);
            return [1, Math.tan(radianX), 0, Math.tan(radianY), 1, 0, 0, 0, 1];
        },
        skewX: function skewX(degreeX) {
            var radianX = this.radian(degreeX);

            return [1, Math.tan(radianX), 0, 0, 1, 0, 0, 0, 1];
        },
        skewY: function skewY(degreeY) {
            var radianY = this.radian(degreeY);

            return [1, 0, 0, Math.tan(radianY), 1, 0, 0, 0, 1];
        },
        shear1: function shear1(angle) {
            return [1, -Math.tan(this.radian(angle) / 2), 0, 0, 1, 0, 0, 0, 1];
        },
        shear2: function shear2(angle) {
            return [1, 0, 0, Math.sin(this.radian(angle)), 1, 0, 0, 0, 1];
        }
    };

    var Matrix = {
        CONSTANT: CONSTANT,

        radian: function radian(angle) {
            return CONSTANT.radian(angle);
        },
        multiply: function multiply(A, C) {
            // console.log(JSON.stringify(A), JSON.stringify(C))
            return [A[0] * C[0] + A[1] * C[1] + A[2] * C[2], A[3] * C[0] + A[4] * C[1] + A[5] * C[2], A[6] * C[0] + A[7] * C[1] + A[8] * C[2]];
        },
        identity: function identity(B) {
            return this.multiply(CONSTANT.identity(), B);
        },
        translate: function translate(x, y, B) {
            return this.multiply(CONSTANT.translate(x, y), B);
        },
        rotate: function rotate(angle, B) {
            return this.multiply(CONSTANT.rotate(angle), B);
        },
        shear1: function shear1(angle, B) {
            return this.multiply(CONSTANT.shear1(angle), B);
        },
        shear2: function shear2(angle, B) {
            return this.multiply(CONSTANT.shear2(angle), B);
        },
        rotateShear: function rotateShear(angle, B) {

            var arr = B;

            arr = this.shear1(angle, arr);
            arr = this.shear2(angle, arr);
            arr = this.shear1(angle, arr);

            return arr;
        }
    };

    function crop() {
        var startX = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var startY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var width = arguments[2];
        var height = arguments[3];


        var newBitmap = createBitmap(width * height * 4, width, height);

        return function (bitmap, done) {
            for (var y = startY, realY = 0; y < height; y++, realY++) {
                for (var x = startX, realX = 0; x < width; x++, realX++) {
                    newBitmap.pixels[realY * width * realX] = bitmap.pixels[y * width * x];
                }
            }

            done(newBitmap);
        };
    }

    // Image manupulate
    function resize(dstWidth, dstHeight) {
        return function (bitmap, done) {
            var c = Canvas.drawPixels(bitmap);
            var context = c.getContext('2d');

            c.width = dstWidth;
            c.height = dstHeight;

            done({
                pixels: new Uint8ClampedArray(context.getImageData(0, 0, dstWidth, dstHeight).data),
                width: dstWidth,
                height: dstHeight
            });
        };
    }

    function flipV() {
        return function (bitmap, done) {
            var width = bitmap.width;
            var height = bitmap.height;
            var isCenter = height % 2 == 1 ? 1 : 0;

            var halfHeight = isCenter ? Math.floor(height / 2) : height / 2;

            for (var y = 0; y < halfHeight; y++) {
                for (var x = 0; x < width; x++) {

                    var startIndex = y * width + x << 2;
                    var endIndex = (height - 1 - y) * width + x << 2;
                    swapColor(bitmap.pixels, startIndex, endIndex);
                }
            }

            done(bitmap);
        };
    }

    function flipH() {
        return function (bitmap, done) {
            var width = bitmap.width;
            var height = bitmap.height;
            var isCenter = width % 2 == 1 ? 1 : 0;

            var halfWidth = isCenter ? Math.floor(width / 2) : width / 2;

            for (var y = 0; y < height; y++) {
                for (var x = 0; x < halfWidth; x++) {

                    var startIndex = y * width + x << 2;
                    var endIndex = y * width + (width - 1 - x) << 2;
                    swapColor(bitmap.pixels, startIndex, endIndex);
                }
            }

            done(bitmap);
        };
    }

    function rotateDegree(angle) {
        var cx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'center';
        var cy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'center';

        // const r = F.radian(angle)

        return function (bitmap, done) {
            var opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

            var newBitmap = createBitmap(bitmap.pixels.length, bitmap.width, bitmap.height);
            var width = bitmap.width;
            var height = bitmap.height;

            if (cx == 'center') {
                cx = Math.floor(width / 2);
            }

            if (cy == 'center') {
                cy = Math.floor(height / 2);
            }

            var translateMatrix = Matrix.CONSTANT.translate(-cx, -cy);
            var translateMatrix2 = Matrix.CONSTANT.translate(cx, cy);
            var shear1Matrix = Matrix.CONSTANT.shear1(angle);
            var shear2Matrix = Matrix.CONSTANT.shear2(angle);

            packXY(function (pixels, i, x, y) {
                // console.log(x, y, i)
                var arr = Matrix.multiply(translateMatrix, [x, y, 1]);

                arr = Matrix.multiply(shear1Matrix, arr).map(Math.round);
                arr = Matrix.multiply(shear2Matrix, arr).map(Math.round);
                arr = Matrix.multiply(shear1Matrix, arr).map(Math.round);
                arr = Matrix.multiply(translateMatrix2, arr);

                var _arr = arr,
                    _arr2 = slicedToArray(_arr, 2),
                    x1 = _arr2[0],
                    y1 = _arr2[1];

                if (x1 < 0) return;
                if (y1 < 0) return;
                if (x1 > width - 1) return;
                if (y1 > height - 1) return;

                var endIndex = y1 * width + x1 << 2; //  bit 2 shift is  * 4

                fillPixelColor(pixels, endIndex, bitmap.pixels, i);
            })(newBitmap, function () {
                done(newBitmap);
            }, opt);
        };
    }

    function rotate() {
        var degree = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        degree = parseParamNumber(degree);
        degree = degree % 360;
        return function (bitmap, done) {
            var opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};


            if (degree == 0) return bitmap;

            if (degree == 90 || degree == 270) {
                var newBitmap = createBitmap(bitmap.pixels.length, bitmap.height, bitmap.width);
            } else if (degree == 180) {
                var newBitmap = createBitmap(bitmap.pixels.length, bitmap.width, bitmap.height);
            } else {
                return rotateDegree(degree)(bitmap, done, opt);
            }
            packXY(function (pixels, i, x, y) {

                if (degree == 90) {
                    var endIndex = x * newBitmap.width + (newBitmap.width - 1 - y) << 2; //  << 2 is equals to (multiply)* 4
                } else if (degree == 270) {
                    var endIndex = (newBitmap.height - 1 - x) * newBitmap.width + y << 2;
                } else if (degree == 180) {
                    var endIndex = (newBitmap.height - 1 - y) * newBitmap.width + (newBitmap.width - 1 - x) << 2;
                }

                fillPixelColor(newBitmap.pixels, endIndex, bitmap.pixels, i);
            })(bitmap, function () {
                done(newBitmap);
            }, opt);
        };
    }

    function histogram$1() {
        var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'gray';
        var points = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

        var $realPoints = [];

        for (var i = 0; i < points.length - 1; i++) {
            var sp = points[i];
            var ep = points[i + 1];

            var distX = ep[0] - sp[0];
            var distY = ep[1] - sp[1];

            var rate = distY / distX;

            for (var realIndex = 0, start = sp[0]; realIndex < distX; realIndex++, start++) {
                $realPoints[start] = sp[1] + realIndex * rate;
            }
        }

        $realPoints[255] = 255;

        if (type === 'red') {
            return pixel(function () {
                $r = $realPoints[$r];
            }, {}, { $realPoints: $realPoints });
        } else if (type === 'green') {
            return pixel(function () {
                $g = $realPoints[$g];
            }, {}, { $realPoints: $realPoints });
        } else if (type === 'blue') {
            return pixel(function () {
                $b = $realPoints[$b];
            }, {}, { $realPoints: $realPoints });
        } else {
            return pixel(function () {

                var l = Color.RGBtoYCrCb($r, $g, $b);
                var c = Color.YCrCbtoRGB(clamp($realPoints[clamp(l.y)]), l.cr, l.cb, 0);
                $r = c.r;
                $g = c.g;
                $b = c.b;
            }, {}, { $realPoints: $realPoints });
        }
    }

    var image$1 = {
        crop: crop,
        resize: resize,
        flipH: flipH,
        flipV: flipV,
        rotate: rotate,
        rotateDegree: rotateDegree,
        histogram: histogram$1,
        'rotate-degree': rotateDegree
    };

    function bitonal(darkColor, lightColor) {
        var threshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;

        var $darkColor = Color$1.parse(darkColor);
        var $lightColor = Color$1.parse(lightColor);
        var $threshold = threshold;

        return pixel('        \n        const thresholdColor = ( $r + $g + $b ) <= $threshold ? $darkColor : $lightColor\n\n        $r = thresholdColor.r;\n        $g = thresholdColor.g;\n        $b = thresholdColor.b; \n    ', {
            $threshold: $threshold
        }, {
            $darkColor: $darkColor,
            $lightColor: $lightColor
        });
    }

    /*
     * @param {Number} amount  -100..100  ,  value < 0  is darken, value > 0 is brighten
     */
    function brightness$1() {
        var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

        amount = parseParamNumber(amount);
        var $C = Math.floor(255 * (amount / 100));

        return pixel('\n        $r += $C;\n        $g += $C;\n        $b += $C;\n    ', { $C: $C });
    }

    function brownie() {

        var $matrix = [0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0, -0.037703249837783157, 0.8609577587992641, 0.15059552388459913, 0, 0.24113635128153335, -0.07441037908422492, 0.44972182064877153, 0, 0, 0, 0, 1];

        return pixel('\n        $r = $matrix[0] * $r + $matrix[1] * $g + $matrix[2] * $b + $matrix[3] * $a;\n        $g = $matrix[4] * $r + $matrix[5] * $g + $matrix[6] * $b + $matrix[7] * $a;\n        $b = $matrix[8] * $r + $matrix[9] * $g + $matrix[10] * $b + $matrix[11] * $a;\n        $a = $matrix[12] * $r + $matrix[13] * $g + $matrix[14] * $b + $matrix[15] * $a;        \n    ', {
            $matrix: $matrix
        });
    }

    /**
     *
     * @param {Number} amount from 0 to 100
     */
    function clip() {
        var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        amount = parseParamNumber(amount);
        var $C = Math.abs(amount) * 2.55;

        return pixel('\n\n        $r = ($r > 255 - $C) ? 255 : 0;\n        $g = ($g > 255 - $C) ? 255 : 0;\n        $b = ($b > 255 - $C) ? 255 : 0;\n\n    ', { $C: $C });
    }

    /**
     *
     * @param {*} amount   min = -128, max = 128
     */
    function contrast$1() {
        var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        amount = parseParamNumber(amount);
        var $C = Math.max((128 + amount) / 128, 0);

        return pixel('\n        $r *= $C;\n        $g *= $C;\n        $b *= $C;\n    ', { $C: $C });
    }

    function gamma() {
        var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

        var $C = parseParamNumber(amount);
        return pixel('\n        $r = Math.pow($r / 255, $C) * 255;\n        $g = Math.pow($g / 255, $C) * 255;\n        $b = Math.pow($b / 255, $C) * 255;\n    ', { $C: $C });
    }

    /**
     * F.gradient('red', 'blue', 'yellow', 'white', 10)
     * F.gradient('red, blue, yellow, white, 10')
     */
    function gradient$1() {
        //    
        //     scale  

        var params = [].concat(Array.prototype.slice.call(arguments));

        if (params.length === 1 && typeof params[0] === 'string') {
            params = Color$1.convertMatchesArray(params[0]);
        }

        params = params.map(function (arg) {
            var res = Color$1.matches(arg);

            if (!res.length) {
                return { type: 'scale', value: arg };
            }

            return { type: 'param', value: arg };
        });

        var $scale = params.filter(function (it) {
            return it.type == 'scale';
        })[0];
        $scale = $scale ? +$scale.value : 256;

        params = params.filter(function (it) {
            return it.type == 'param';
        }).map(function (it) {
            return it.value;
        }).join(',');

        var $colors = Color$1.gradient(params, $scale).map(function (c) {
            var _Color$parse = Color$1.parse(c),
                r = _Color$parse.r,
                g = _Color$parse.g,
                b = _Color$parse.b,
                a = _Color$parse.a;

            return { r: r, g: g, b: b, a: a };
        });

        return pixel('\n        const colorIndex = clamp(Math.ceil($r * 0.2126 + $g * 0.7152 + $b * 0.0722));\n        const newColorIndex = clamp(Math.floor(colorIndex * ($scale / 256)));\n        const color = $colors[newColorIndex];\n\n        $r = color.r; \n        $g = color.g; \n        $b = color.b; \n        $a = clamp(Math.floor(color.a * 256));\n    ', {}, { $colors: $colors, $scale: $scale });
    }

    function grayscale(amount) {
        amount = parseParamNumber(amount);
        var C = amount / 100;

        if (C > 1) C = 1;

        var $matrix = [0.2126 + 0.7874 * (1 - C), 0.7152 - 0.7152 * (1 - C), 0.0722 - 0.0722 * (1 - C), 0, 0.2126 - 0.2126 * (1 - C), 0.7152 + 0.2848 * (1 - C), 0.0722 - 0.0722 * (1 - C), 0, 0.2126 - 0.2126 * (1 - C), 0.7152 - 0.7152 * (1 - C), 0.0722 + 0.9278 * (1 - C), 0, 0, 0, 0, 1];

        return pixel('\n        $r = $matrix[0] * $r + $matrix[1] * $g + $matrix[2] * $b + $matrix[3] * $a;\n        $g = $matrix[4] * $r + $matrix[5] * $g + $matrix[6] * $b + $matrix[7] * $a;\n        $b = $matrix[8] * $r + $matrix[9] * $g + $matrix[10] * $b + $matrix[11] * $a;\n        $a = $matrix[12] * $r + $matrix[13] * $g + $matrix[14] * $b + $matrix[15] * $a;\n    ', {
            $matrix: $matrix
        });
    }

    /*
     * @param {Number} amount   0..360
     */
    function hue() {
        var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 360;

        var $C = parseParamNumber(amount);
        return pixel('\n        var hsv = Color.RGBtoHSV($r, $g, $b);\n\n        // 0 ~ 360 \n        var h = hsv.h;\n        h += Math.abs($C);\n        h = h % 360;\n        hsv.h = h;\n\n        var rgb = Color.HSVtoRGB(hsv);\n\n        $r = rgb.r;\n        $g = rgb.g;\n        $b = rgb.b;\n    ', {
            $C: $C
        });
    }

    function invert() {
        var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;

        amount = parseParamNumber(amount);
        var $C = amount / 100;

        return pixel('\n        $r = (255 - $r) * $C;\n        $g = (255 - $g) * $C;\n        $b = (255 - $b) * $C;\n    ', {
            $C: $C
        });
    }

    function kodachrome() {

        var $matrix = [1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 0, 0, 0, 1];

        return pixel('\n        $r = $matrix[0] * $r + $matrix[1] * $g + $matrix[2] * $b + $matrix[3] * $a;\n        $g = $matrix[4] * $r + $matrix[5] * $g + $matrix[6] * $b + $matrix[7] * $a;\n        $b = $matrix[8] * $r + $matrix[9] * $g + $matrix[10] * $b + $matrix[11] * $a;\n        $a = $matrix[12] * $r + $matrix[13] * $g + $matrix[14] * $b + $matrix[15] * $a;\n    ', {
            $matrix: $matrix
        });
    }

    function matrix() {
        var $a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var $b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var $c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var $d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var $e = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
        var $f = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
        var $g = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
        var $h = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
        var $i = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
        var $j = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
        var $k = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 0;
        var $l = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : 0;
        var $m = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : 0;
        var $n = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : 0;
        var $o = arguments.length > 14 && arguments[14] !== undefined ? arguments[14] : 0;
        var $p = arguments.length > 15 && arguments[15] !== undefined ? arguments[15] : 0;


        var $matrix = [$a, $b, $c, $d, $e, $f, $g, $h, $i, $j, $k, $l, $m, $n, $o, $p];

        return pixel('\n        $r = $matrix[0] * $r + $matrix[1] * $g + $matrix[2] * $b + $matrix[3] * $a;\n        $g = $matrix[4] * $r + $matrix[5] * $g + $matrix[6] * $b + $matrix[7] * $a;\n        $b = $matrix[8] * $r + $matrix[9] * $g + $matrix[10] * $b + $matrix[11] * $a;\n        $a = $matrix[12] * $r + $matrix[13] * $g + $matrix[14] * $b + $matrix[15] * $a;\n    ', {
            $matrix: $matrix
        });
    }

    /**
     *
     * @param {Number} amount 1..100
     */
    function noise() {
        var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

        var $C = parseParamNumber(amount);
        return pixel('\n        const C = Math.abs($C) * 5;\n        const min = -C;\n        const max = C;\n        const noiseValue = Math.round(min + (Math.random() * (max - min)));\n\n        $r += noiseValue;\n        $g += noiseValue;\n        $b += noiseValue;\n    ', {
            $C: $C
        });
    }

    function opacity() {
        var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;

        amount = parseParamNumber(amount);
        var $C = amount / 100;

        return pixel('\n        $a *= $C; \n    ', { $C: $C });
    }

    function polaroid() {

        var $matrix = [1.438, -0.062, -0.062, 0, -0.122, 1.378, -0.122, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 1];

        return pixel('\n        $r = $matrix[0] * $r + $matrix[1] * $g + $matrix[2] * $b + $matrix[3] * $a;\n        $g = $matrix[4] * $r + $matrix[5] * $g + $matrix[6] * $b + $matrix[7] * $a;\n        $b = $matrix[8] * $r + $matrix[9] * $g + $matrix[10] * $b + $matrix[11] * $a;\n        $a = $matrix[12] * $r + $matrix[13] * $g + $matrix[14] * $b + $matrix[15] * $a;\n    ', {
            $matrix: $matrix
        });
    }

    /*
     * @param {Number} amount  -100..100
     */
    function saturation() {
        var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;

        amount = parseParamNumber(amount);
        var C = amount / 100;
        var L = 1 - Math.abs(C);

        var $matrix = [L, 0, 0, 0, 0, L, 0, 0, 0, 0, L, 0, 0, 0, 0, L];

        return pixel('\n        $r = $matrix[0] * $r + $matrix[1] * $g + $matrix[2] * $b + $matrix[3] * $a;\n        $g = $matrix[4] * $r + $matrix[5] * $g + $matrix[6] * $b + $matrix[7] * $a;\n        $b = $matrix[8] * $r + $matrix[9] * $g + $matrix[10] * $b + $matrix[11] * $a;\n        $a = $matrix[12] * $r + $matrix[13] * $g + $matrix[14] * $b + $matrix[15] * $a;        \n    ', {
            $matrix: $matrix
        });
    }

    /*
     * @param {Number} amount  0..1
     */
    function sepia() {
        var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

        var C = parseParamNumber(amount);
        if (C > 1) C = 1;

        var $matrix = [0.393 + 0.607 * (1 - C), 0.769 - 0.769 * (1 - C), 0.189 - 0.189 * (1 - C), 0, 0.349 - 0.349 * (1 - C), 0.686 + 0.314 * (1 - C), 0.168 - 0.168 * (1 - C), 0, 0.272 - 0.272 * (1 - C), 0.534 - 0.534 * (1 - C), 0.131 + 0.869 * (1 - C), 0, 0, 0, 0, 1];

        return pixel('\n        $r = $matrix[0] * $r + $matrix[1] * $g + $matrix[2] * $b + $matrix[3] * $a;\n        $g = $matrix[4] * $r + $matrix[5] * $g + $matrix[6] * $b + $matrix[7] * $a;\n        $b = $matrix[8] * $r + $matrix[9] * $g + $matrix[10] * $b + $matrix[11] * $a;\n        $a = $matrix[12] * $r + $matrix[13] * $g + $matrix[14] * $b + $matrix[15] * $a;        \n    ', {
            $matrix: $matrix
        });
    }

    function shade() {
        var redValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
        var greenValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        var blueValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

        var $redValue = parseParamNumber(redValue);
        var $greenValue = parseParamNumber(greenValue);
        var $blueValue = parseParamNumber(blueValue);

        return pixel('\n        $r *= $redValue;\n        $g *= $greenValue;\n        $b *= $blueValue;\n    ', {
            $redValue: $redValue,
            $greenValue: $greenValue,
            $blueValue: $blueValue
        });
    }

    function shift() {

        var $matrix = [1.438, -0.062, -0.062, 0, -0.122, 1.378, -0.122, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 1];

        return pixel('\n        $r = $matrix[0] * $r + $matrix[1] * $g + $matrix[2] * $b + $matrix[3] * $a;\n        $g = $matrix[4] * $r + $matrix[5] * $g + $matrix[6] * $b + $matrix[7] * $a;\n        $b = $matrix[8] * $r + $matrix[9] * $g + $matrix[10] * $b + $matrix[11] * $a;\n        $a = $matrix[12] * $r + $matrix[13] * $g + $matrix[14] * $b + $matrix[15] * $a;        \n    ', {
            $matrix: $matrix
        });
    }

    /**
     * change the relative darkness of (a part of an image) by overexposure to light.
     * @param {*} r
     * @param {*} g
     * @param {*} b
     */
    function solarize(redValue, greenValue, blueValue) {
        var $redValue = parseParamNumber(redValue);
        var $greenValue = parseParamNumber(greenValue);
        var $blueValue = parseParamNumber(blueValue);
        return pixel('\n        $r = ($r < $redValue) ? 255 - $r: $r;\n        $g = ($g < $greenValue) ? 255 - $g: $g;\n        $b = ($b < $blueValue) ? 255 - $b: $b;\n    ', {
            $redValue: $redValue, $greenValue: $greenValue, $blueValue: $blueValue
        });
    }

    function technicolor() {

        var $matrix = [1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0, -0.3087833385928097, 1.7658908555458428, -0.10601743074722245, 0, -0.231103377548616, -0.7501899197440212, 1.847597816108189, 0, 0, 0, 0, 1];

        return pixel('\n        $r = $matrix[0] * $r + $matrix[1] * $g + $matrix[2] * $b + $matrix[3] * $a;\n        $g = $matrix[4] * $r + $matrix[5] * $g + $matrix[6] * $b + $matrix[7] * $a;\n        $b = $matrix[8] * $r + $matrix[9] * $g + $matrix[10] * $b + $matrix[11] * $a;\n        $a = $matrix[12] * $r + $matrix[13] * $g + $matrix[14] * $b + $matrix[15] * $a;\n    ', {
            $matrix: $matrix
        });
    }

    function thresholdColor() {
        var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 200;
        var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
        var hasColor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

        var $scale = parseParamNumber(scale);
        amount = parseParamNumber(amount);
        var $C = amount / 100;
        var $hasColor = hasColor;

        return pixel('\n        // refer to Color.brightness \n        const v = ($C * Math.ceil($r * 0.2126 + $g * 0.7152 + $b * 0.0722) ) >= $scale ? 255 : 0;\n\n        if ($hasColor) {\n\n            if (v == 0) {\n                $r = 0; \n                $g = 0; \n                $b = 0;\n            }\n            \n        } else {\n            const value = Math.round(v);\n            $r = value; \n            $g = value;\n            $b = value; \n        }\n        \n    ', {
            $C: $C, $scale: $scale, $hasColor: $hasColor
        });
    }

    /*
     * @param {Number} amount  0..100
     */
    function threshold() {
      var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 200;
      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;

      return thresholdColor(scale, amount, false);
    }

    function tint () {
        var redTint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
        var greenTint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        var blueTint = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

        var $redTint = parseParamNumber(redTint);
        var $greenTint = parseParamNumber(greenTint);
        var $blueTint = parseParamNumber(blueTint);
        return pixel("\n\n        $r += (255 - $r) * $redTint;\n        $g += (255 - $g) * $greenTint;\n        $b += (255 - $b) * $blueTint;\n\n    ", {
            $redTint: $redTint,
            $greenTint: $greenTint,
            $blueTint: $blueTint
        });
    }

    var pixel$1 = {
        bitonal: bitonal,
        brightness: brightness$1,
        brownie: brownie,
        clip: clip,
        contrast: contrast$1,
        gamma: gamma,
        gradient: gradient$1,
        grayscale: grayscale,
        hue: hue,
        invert: invert,
        kodachrome: kodachrome,
        matrix: matrix,
        noise: noise,
        opacity: opacity,
        polaroid: polaroid,
        saturation: saturation,
        sepia: sepia,
        shade: shade,
        shift: shift,
        solarize: solarize,
        technicolor: technicolor,
        threshold: threshold,
        'threshold-color': thresholdColor,
        tint: tint
    };

    function blur () {
        var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;
        amount = parseParamNumber(amount);

        return convolution(createBlurMatrix(amount));
    }

    /*
     * carve, mold, or stamp a design on (a surface) so that it stands out in relief.
     *
     * @param {Number} amount   0.0 .. 4.0
     */
    function emboss() {
        var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 4;

        amount = parseParamNumber(amount);
        return convolution([amount * -2.0, -amount, 0.0, -amount, 1.0, amount, 0.0, amount, amount * 2.0]);
    }

    function gaussianBlur() {
        var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;

        amount = parseParamNumber(amount);
        var C = amount / 100;

        return convolution(weight([1, 2, 1, 2, 4, 2, 1, 2, 1], 1 / 16 * C));
    }

    function gaussianBlur5x() {
        var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;

        amount = parseParamNumber(amount);
        var C = amount / 100;
        return convolution(weight([1, 4, 6, 4, 1, 4, 16, 24, 16, 4, 6, 24, 36, 24, 6, 4, 16, 24, 16, 4, 1, 4, 6, 4, 1], 1 / 256 * C));
    }

    function grayscale2() {
        var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;

        amount = parseParamNumber(amount);
        return convolution(weight([0.3, 0.3, 0.3, 0, 0, 0.59, 0.59, 0.59, 0, 0, 0.11, 0.11, 0.11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], amount / 100));
    }

    function identity() {
        return convolution([0, 0, 0, 0, 1, 0, 0, 0, 0]);
    }

    function kirschHorizontal() {
        var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

        count = parseParamNumber(count);
        return convolution([5, 5, 5, -3, 0, -3, -3, -3, -3]);
    }

    function kirschVertical() {
        var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

        count = parseParamNumber(count);
        return convolution([5, -3, -3, 5, 0, -3, 5, -3, -3]);
    }

    function laplacian() {
        var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;

        amount = parseParamNumber(amount);
        return convolution(weight([-1, -1, -1, -1, 8, -1, -1, -1, -1], amount / 100));
    }

    function laplacian5x() {
        var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;

        amount = parseParamNumber(amount);
        return convolution(weight([-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 24, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], amount / 100));
    }

    function motionBlur() {
        return convolution(weight([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], 1 / 9));
    }

    function motionBlur2() {
        return convolution(weight([1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], 1 / 9));
    }

    function motionBlur3() {
        return convolution(weight([1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1], 1 / 9));
    }

    function negative() {
        var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;

        amount = parseParamNumber(amount);
        return convolution(weight([-1, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1], amount / 100));
    }

    function sepia2() {
        var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;

        amount = parseParamNumber(amount);
        return convolution(weight([0.393, 0.349, 0.272, 0, 0, 0.769, 0.686, 0.534, 0, 0, 0.189, 0.168, 0.131, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], amount / 100));
    }

    function sharpen() {
        var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;

        amount = parseParamNumber(amount);
        return convolution(weight([0, -1, 0, -1, 5, -1, 0, -1, 0], amount / 100));
    }

    function sobelHorizontal() {
        return convolution([-1, -2, -1, 0, 0, 0, 1, 2, 1]);
    }

    function sobelVertical() {
        return convolution([-1, 0, 1, -2, 0, 2, -1, 0, 1]);
    }

    /*

    StackBlur - a fast almost Gaussian Blur For Canvas

    Version: 	0.5
    Author:		Mario Klingemann
    Contact: 	mario@quasimondo.com
    Website:	http://www.quasimondo.com/StackBlurForCanvas
    Twitter:	@quasimondo

    In case you find this class useful - especially in commercial projects -
    I am not totally unhappy for a small donation to my PayPal account
    mario@quasimondo.de

    Or support me on flattr:
    https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript

    Copyright (c) 2010 Mario Klingemann

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation
    files (the "Software"), to deal in the Software without
    restriction, including without limitation the rights to use,
    copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following
    conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.
    */

    var mul_table = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259];

    var shg_table = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];

    function BlurStack() {
        this.r = 0;
        this.g = 0;
        this.b = 0;
        this.a = 0;
        this.next = null;
    }

    function stackBlurImage(bitmap, radius, blurAlphaChannel) {

        if (blurAlphaChannel) return stackBlurCanvasRGBA(bitmap, 0, 0, radius);else return stackBlurCanvasRGB(bitmap, 0, 0, radius);
    }

    function stackBlurCanvasRGBA(bitmap, top_x, top_y, radius) {
        if (isNaN(radius) || radius < 1) return bitmap;
        radius |= 0;

        var pixels = bitmap.pixels,
            width = bitmap.width,
            height = bitmap.height;

        var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum, r_out_sum, g_out_sum, b_out_sum, a_out_sum, r_in_sum, g_in_sum, b_in_sum, a_in_sum, pr, pg, pb, pa, rbs;

        var div = radius + radius + 1;
        var widthMinus1 = width - 1;
        var heightMinus1 = height - 1;
        var radiusPlus1 = radius + 1;
        var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;

        var stackStart = new BlurStack();
        var stack = stackStart;
        for (i = 1; i < div; i++) {
            stack = stack.next = new BlurStack();
            if (i == radiusPlus1) var stackEnd = stack;
        }
        stack.next = stackStart;
        var stackIn = null;
        var stackOut = null;

        yw = yi = 0;

        var mul_sum = mul_table[radius];
        var shg_sum = shg_table[radius];

        for (y = 0; y < height; y++) {
            r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;

            r_out_sum = radiusPlus1 * (pr = pixels[yi]);
            g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
            b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
            a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);

            r_sum += sumFactor * pr;
            g_sum += sumFactor * pg;
            b_sum += sumFactor * pb;
            a_sum += sumFactor * pa;

            stack = stackStart;

            for (i = 0; i < radiusPlus1; i++) {
                stack.r = pr;
                stack.g = pg;
                stack.b = pb;
                stack.a = pa;
                stack = stack.next;
            }

            for (i = 1; i < radiusPlus1; i++) {
                p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
                r_sum += (stack.r = pr = pixels[p]) * (rbs = radiusPlus1 - i);
                g_sum += (stack.g = pg = pixels[p + 1]) * rbs;
                b_sum += (stack.b = pb = pixels[p + 2]) * rbs;
                a_sum += (stack.a = pa = pixels[p + 3]) * rbs;

                r_in_sum += pr;
                g_in_sum += pg;
                b_in_sum += pb;
                a_in_sum += pa;

                stack = stack.next;
            }

            stackIn = stackStart;
            stackOut = stackEnd;
            for (x = 0; x < width; x++) {
                pixels[yi + 3] = pa = a_sum * mul_sum >> shg_sum;
                if (pa != 0) {
                    pa = 255 / pa;
                    pixels[yi] = (r_sum * mul_sum >> shg_sum) * pa;
                    pixels[yi + 1] = (g_sum * mul_sum >> shg_sum) * pa;
                    pixels[yi + 2] = (b_sum * mul_sum >> shg_sum) * pa;
                } else {
                    pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
                }

                r_sum -= r_out_sum;
                g_sum -= g_out_sum;
                b_sum -= b_out_sum;
                a_sum -= a_out_sum;

                r_out_sum -= stackIn.r;
                g_out_sum -= stackIn.g;
                b_out_sum -= stackIn.b;
                a_out_sum -= stackIn.a;

                p = yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1) << 2;

                r_in_sum += stackIn.r = pixels[p];
                g_in_sum += stackIn.g = pixels[p + 1];
                b_in_sum += stackIn.b = pixels[p + 2];
                a_in_sum += stackIn.a = pixels[p + 3];

                r_sum += r_in_sum;
                g_sum += g_in_sum;
                b_sum += b_in_sum;
                a_sum += a_in_sum;

                stackIn = stackIn.next;

                r_out_sum += pr = stackOut.r;
                g_out_sum += pg = stackOut.g;
                b_out_sum += pb = stackOut.b;
                a_out_sum += pa = stackOut.a;

                r_in_sum -= pr;
                g_in_sum -= pg;
                b_in_sum -= pb;
                a_in_sum -= pa;

                stackOut = stackOut.next;

                yi += 4;
            }
            yw += width;
        }

        for (x = 0; x < width; x++) {
            g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;

            yi = x << 2;
            r_out_sum = radiusPlus1 * (pr = pixels[yi]);
            g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
            b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
            a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);

            r_sum += sumFactor * pr;
            g_sum += sumFactor * pg;
            b_sum += sumFactor * pb;
            a_sum += sumFactor * pa;

            stack = stackStart;

            for (i = 0; i < radiusPlus1; i++) {
                stack.r = pr;
                stack.g = pg;
                stack.b = pb;
                stack.a = pa;
                stack = stack.next;
            }

            yp = width;

            for (i = 1; i <= radius; i++) {
                yi = yp + x << 2;

                r_sum += (stack.r = pr = pixels[yi]) * (rbs = radiusPlus1 - i);
                g_sum += (stack.g = pg = pixels[yi + 1]) * rbs;
                b_sum += (stack.b = pb = pixels[yi + 2]) * rbs;
                a_sum += (stack.a = pa = pixels[yi + 3]) * rbs;

                r_in_sum += pr;
                g_in_sum += pg;
                b_in_sum += pb;
                a_in_sum += pa;

                stack = stack.next;

                if (i < heightMinus1) {
                    yp += width;
                }
            }

            yi = x;
            stackIn = stackStart;
            stackOut = stackEnd;
            for (y = 0; y < height; y++) {
                p = yi << 2;
                pixels[p + 3] = pa = a_sum * mul_sum >> shg_sum;
                if (pa > 0) {
                    pa = 255 / pa;
                    pixels[p] = (r_sum * mul_sum >> shg_sum) * pa;
                    pixels[p + 1] = (g_sum * mul_sum >> shg_sum) * pa;
                    pixels[p + 2] = (b_sum * mul_sum >> shg_sum) * pa;
                } else {
                    pixels[p] = pixels[p + 1] = pixels[p + 2] = 0;
                }

                r_sum -= r_out_sum;
                g_sum -= g_out_sum;
                b_sum -= b_out_sum;
                a_sum -= a_out_sum;

                r_out_sum -= stackIn.r;
                g_out_sum -= stackIn.g;
                b_out_sum -= stackIn.b;
                a_out_sum -= stackIn.a;

                p = x + ((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width << 2;

                r_sum += r_in_sum += stackIn.r = pixels[p];
                g_sum += g_in_sum += stackIn.g = pixels[p + 1];
                b_sum += b_in_sum += stackIn.b = pixels[p + 2];
                a_sum += a_in_sum += stackIn.a = pixels[p + 3];

                stackIn = stackIn.next;

                r_out_sum += pr = stackOut.r;
                g_out_sum += pg = stackOut.g;
                b_out_sum += pb = stackOut.b;
                a_out_sum += pa = stackOut.a;

                r_in_sum -= pr;
                g_in_sum -= pg;
                b_in_sum -= pb;
                a_in_sum -= pa;

                stackOut = stackOut.next;

                yi += width;
            }
        }

        return bitmap;
    }

    function stackBlurCanvasRGBA(bitmap, top_x, top_y, radius) {
        if (isNaN(radius) || radius < 1) return bitmap;
        radius |= 0;

        var pixels = bitmap.pixels,
            width = bitmap.width,
            height = bitmap.height;

        var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, r_out_sum, g_out_sum, b_out_sum, r_in_sum, g_in_sum, b_in_sum, pr, pg, pb, rbs;

        var div = radius + radius + 1;
        var widthMinus1 = width - 1;
        var heightMinus1 = height - 1;
        var radiusPlus1 = radius + 1;
        var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;

        var stackStart = new BlurStack();
        var stack = stackStart;
        for (i = 1; i < div; i++) {
            stack = stack.next = new BlurStack();
            if (i == radiusPlus1) var stackEnd = stack;
        }
        stack.next = stackStart;
        var stackIn = null;
        var stackOut = null;

        yw = yi = 0;

        var mul_sum = mul_table[radius];
        var shg_sum = shg_table[radius];

        for (y = 0; y < height; y++) {
            r_in_sum = g_in_sum = b_in_sum = r_sum = g_sum = b_sum = 0;

            r_out_sum = radiusPlus1 * (pr = pixels[yi]);
            g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
            b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);

            r_sum += sumFactor * pr;
            g_sum += sumFactor * pg;
            b_sum += sumFactor * pb;

            stack = stackStart;

            for (i = 0; i < radiusPlus1; i++) {
                stack.r = pr;
                stack.g = pg;
                stack.b = pb;
                stack = stack.next;
            }

            for (i = 1; i < radiusPlus1; i++) {
                p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
                r_sum += (stack.r = pr = pixels[p]) * (rbs = radiusPlus1 - i);
                g_sum += (stack.g = pg = pixels[p + 1]) * rbs;
                b_sum += (stack.b = pb = pixels[p + 2]) * rbs;

                r_in_sum += pr;
                g_in_sum += pg;
                b_in_sum += pb;

                stack = stack.next;
            }

            stackIn = stackStart;
            stackOut = stackEnd;
            for (x = 0; x < width; x++) {
                pixels[yi] = r_sum * mul_sum >> shg_sum;
                pixels[yi + 1] = g_sum * mul_sum >> shg_sum;
                pixels[yi + 2] = b_sum * mul_sum >> shg_sum;

                r_sum -= r_out_sum;
                g_sum -= g_out_sum;
                b_sum -= b_out_sum;

                r_out_sum -= stackIn.r;
                g_out_sum -= stackIn.g;
                b_out_sum -= stackIn.b;

                p = yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1) << 2;

                r_in_sum += stackIn.r = pixels[p];
                g_in_sum += stackIn.g = pixels[p + 1];
                b_in_sum += stackIn.b = pixels[p + 2];

                r_sum += r_in_sum;
                g_sum += g_in_sum;
                b_sum += b_in_sum;

                stackIn = stackIn.next;

                r_out_sum += pr = stackOut.r;
                g_out_sum += pg = stackOut.g;
                b_out_sum += pb = stackOut.b;

                r_in_sum -= pr;
                g_in_sum -= pg;
                b_in_sum -= pb;

                stackOut = stackOut.next;

                yi += 4;
            }
            yw += width;
        }

        for (x = 0; x < width; x++) {
            g_in_sum = b_in_sum = r_in_sum = g_sum = b_sum = r_sum = 0;

            yi = x << 2;
            r_out_sum = radiusPlus1 * (pr = pixels[yi]);
            g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
            b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);

            r_sum += sumFactor * pr;
            g_sum += sumFactor * pg;
            b_sum += sumFactor * pb;

            stack = stackStart;

            for (i = 0; i < radiusPlus1; i++) {
                stack.r = pr;
                stack.g = pg;
                stack.b = pb;
                stack = stack.next;
            }

            yp = width;

            for (i = 1; i <= radius; i++) {
                yi = yp + x << 2;

                r_sum += (stack.r = pr = pixels[yi]) * (rbs = radiusPlus1 - i);
                g_sum += (stack.g = pg = pixels[yi + 1]) * rbs;
                b_sum += (stack.b = pb = pixels[yi + 2]) * rbs;

                r_in_sum += pr;
                g_in_sum += pg;
                b_in_sum += pb;

                stack = stack.next;

                if (i < heightMinus1) {
                    yp += width;
                }
            }

            yi = x;
            stackIn = stackStart;
            stackOut = stackEnd;
            for (y = 0; y < height; y++) {
                p = yi << 2;
                pixels[p] = r_sum * mul_sum >> shg_sum;
                pixels[p + 1] = g_sum * mul_sum >> shg_sum;
                pixels[p + 2] = b_sum * mul_sum >> shg_sum;

                r_sum -= r_out_sum;
                g_sum -= g_out_sum;
                b_sum -= b_out_sum;

                r_out_sum -= stackIn.r;
                g_out_sum -= stackIn.g;
                b_out_sum -= stackIn.b;

                p = x + ((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width << 2;

                r_sum += r_in_sum += stackIn.r = pixels[p];
                g_sum += g_in_sum += stackIn.g = pixels[p + 1];
                b_sum += b_in_sum += stackIn.b = pixels[p + 2];

                stackIn = stackIn.next;

                r_out_sum += pr = stackOut.r;
                g_out_sum += pg = stackOut.g;
                b_out_sum += pb = stackOut.b;

                r_in_sum -= pr;
                g_in_sum -= pg;
                b_in_sum -= pb;

                stackOut = stackOut.next;

                yi += width;
            }
        }

        return bitmap;
    }

    function stackBlur () {
        var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
        var hasAlphaChannel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        radius = parseParamNumber(radius);

        return function (bitmap, done) {
            var newBitmap = stackBlurImage(bitmap, radius, hasAlphaChannel);

            done(newBitmap);
        };
    }

    function transparency() {
        var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;

        amount = parseParamNumber(amount);
        return convolution(weight([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0.3, 0, 0, 0, 0, 0, 1], amount / 100));
    }

    function unsharpMasking() {
        var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 256;

        amount = parseParamNumber(amount);
        return convolution(weight([1, 4, 6, 4, 1, 4, 16, 24, 16, 4, 6, 24, -476, 24, 6, 4, 16, 24, 16, 4, 1, 4, 6, 4, 1], -1 / amount));
    }

    var matrix$1 = {
         blur: blur,
         emboss: emboss,
         gaussianBlur: gaussianBlur,
         'gaussian-blur': gaussianBlur,
         gaussianBlur5x: gaussianBlur5x,
         'gaussian-blur-5x': gaussianBlur5x,
         grayscale2: grayscale2,
         normal: identity,
         kirschHorizontal: kirschHorizontal,
         'kirsch-horizontal': kirschHorizontal,
         kirschVertical: kirschVertical,
         'kirsch-vertical': kirschVertical,
         laplacian: laplacian,
         laplacian5x: laplacian5x,
         'laplacian-5x': laplacian5x,
         motionBlur: motionBlur,
         'motion-blur': motionBlur,
         motionBlur2: motionBlur2,
         'motion-blur-2': motionBlur2,
         motionBlur3: motionBlur3,
         'motion-blur-3': motionBlur3,
         negative: negative,
         sepia2: sepia2,
         sharpen: sharpen,
         sobelHorizontal: sobelHorizontal,
         'sobel-horizontal': sobelHorizontal,
         sobelVertical: sobelVertical,
         'sobel-vertical': sobelVertical,
         stackBlur: stackBlur,
         'stack-blur': stackBlur,
         transparency: transparency,
         unsharpMasking: unsharpMasking,
         'unsharp-masking': unsharpMasking
    };

    function kirsch() {
        return filter('kirsch-horizontal kirsch-vertical');
    }

    function sobel() {
        return filter('sobel-horizontal sobel-vertical');
    }

    function vintage() {
        return filter('brightness(15) saturation(-20) gamma(1.8)');
    }

    var multi$1 = {
        kirsch: kirsch,
        sobel: sobel,
        vintage: vintage
    };

    var ImageFilter$1 = _extends({}, image$1, pixel$1, matrix$1, multi$1);

    var _functions;

    var makeId = 0;

    var functions = (_functions = {
        partial: partial,
        multi: multi,
        merge: merge,
        weight: weight,
        repeat: repeat$1,
        colorMatrix: colorMatrix,
        each: each$1,
        eachXY: eachXY,
        createRandomCount: createRandomCount,
        createRandRange: createRandRange,
        createBitmap: createBitmap,
        createBlurMatrix: createBlurMatrix,
        pack: pack$1,
        packXY: packXY,
        pixel: pixel,
        getBitmap: getBitmap,
        putBitmap: putBitmap,
        radian: radian,
        convolution: convolution,
        parseParamNumber: parseParamNumber,
        filter: filter,
        clamp: clamp$1,
        fillColor: fillColor,
        fillPixelColor: fillPixelColor
    }, defineProperty(_functions, 'multi', multi), defineProperty(_functions, 'merge', merge), defineProperty(_functions, 'matches', matches$1), defineProperty(_functions, 'parseFilter', parseFilter), defineProperty(_functions, 'partial', partial), _functions);

    var LocalFilter = functions;

    function weight(arr) {
        var num = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

        return arr.map(function (i) {
            return i * num;
        });
    }

    function repeat$1(value, num) {
        var arr = new Array(num);
        for (var i = 0; i < num; i++) {
            arr[i] = value;
        }
        return arr;
    }

    function colorMatrix(pixels, i, matrix) {
        var r = pixels[i],
            g = pixels[i + 1],
            b = pixels[i + 2],
            a = pixels[i + 3];

        fillColor(pixels, i, matrix[0] * r + matrix[1] * g + matrix[2] * b + matrix[3] * a, matrix[4] * r + matrix[5] * g + matrix[6] * b + matrix[7] * a, matrix[8] * r + matrix[9] * g + matrix[10] * b + matrix[11] * a, matrix[12] * r + matrix[13] * g + matrix[14] * b + matrix[15] * a);
    }

    function makeFilter(filter) {

        if (typeof filter == 'function') {
            return filter;
        }

        if (typeof filter == 'string') {
            filter = [filter];
        }

        filter = filter.slice(0);
        var filterName = filter.shift();

        if (typeof filterName == 'function') {
            return filterName;
        }

        var params = filter;

        var filterFunction = ImageFilter$1[filterName] || LocalFilter[filterName];

        if (!filterFunction) {
            throw new Error(filterName + ' is not filter. please check filter name.');
        }
        return filterFunction.apply(filterFunction, params);
    }

    function forLoop(max) {
        var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
        var callback = arguments[3];
        var done = arguments[4];
        var functionDumpCount = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 10000;
        var frameTimer = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'full';
        var loopCount = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 50;

        var runIndex = index;
        var timer = function timer(callback) {
            setTimeout(callback, 0);
        };

        if (frameTimer == 'requestAnimationFrame') {
            timer = requestAnimationFrame;
            functionDumpCount = 1000;
        }

        if (frameTimer == 'full') {
            /* only for loop  */
            timer = null;
            functionDumpCount = max;
        }

        function makeFunction() {
            var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;

            var arr = [].concat(toConsumableArray(Array(count)));

            var functionStrings = arr.map(function (countIndex) {
                return 'cri = ri + i * s; if (cri >= mx) return {currentRunIndex: cri, i: null}; c(cri); i++;';
            }).join('\n');

            var smallLoopFunction = new Function('ri', 'i', 's', 'mx', 'c', '\n            let cri = ri;\n            \n            ' + functionStrings + '\n            \n            return {currentRunIndex: cri, i: i} \n        ');

            return smallLoopFunction;
        }

        function runCallback() {

            var smallLoopFunction = makeFunction(loopCount); // loop is call  20 callbacks at once

            var currentRunIndex = runIndex;
            var ret = {};
            var i = 0;
            while (i < functionDumpCount) {
                ret = smallLoopFunction(runIndex, i, step, max, callback);

                if (ret.i == null) {
                    currentRunIndex = ret.currentRunIndex;
                    break;
                }

                i = ret.i;
                currentRunIndex = ret.currentRunIndex;
            }

            nextCallback(currentRunIndex);
        }

        function nextCallback(currentRunIndex) {
            if (currentRunIndex) {
                runIndex = currentRunIndex;
            } else {
                runIndex += step;
            }

            if (runIndex >= max) {
                done();
                return;
            }

            if (timer) timer(runCallback);else runCallback();
        }

        runCallback();
    }

    function each$1(len, callback, done) {
        var opt = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};


        forLoop(len, 0, 4, function (i) {
            callback(i, i >> 2 /* xyIndex */);
        }, function () {
            done();
        }, opt.functionDumpCount, opt.frameTimer, opt.loopCount);
    }

    function eachXY(len, width, callback, done) {
        var opt = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};


        forLoop(len, 0, 4, function (i) {
            var xyIndex = i >> 2;
            callback(i, xyIndex % width, Math.floor(xyIndex / width));
        }, function () {
            done();
        }, opt.functionDumpCount, opt.frameTimer, opt.loopCount);
    }

    function createRandRange(min, max, count) {
        var result = [];

        for (var i = 1; i <= count; i++) {
            var num = Math.random() * (max - min) + min;
            var sign = Math.floor(Math.random() * 10) % 2 == 0 ? -1 : 1;
            result.push(sign * num);
        }

        result.sort();

        var centerIndex = Math.floor(count >> 1);
        var a = result[centerIndex];
        result[centerIndex] = result[0];
        result[0] = a;

        return result;
    }

    function createRandomCount() {
        return [3 * 3, 4 * 4, 5 * 5, 6 * 6, 7 * 7, 8 * 8, 9 * 9, 10 * 10].sort(function (a, b) {
            return 0.5 - Math.random();
        })[0];
    }

    function createBitmap(length, width, height) {
        return { pixels: new Uint8ClampedArray(length), width: width, height: height };
    }

    function putPixel(dstBitmap, srcBitmap, startX, startY) {

        var len = srcBitmap.pixels.length / 4;
        var dstX = 0,
            dstY = 0,
            x = 0,
            y = 0,
            srcIndex = 0,
            dstIndex = 0;
        for (var i = 0; i < len; i++) {
            x = i % srcBitmap.width, y = Math.floor(i / srcBitmap.width);

            dstX = startX + x;
            dstY = startY + y;

            if (dstX > dstBitmap.width) continue;
            if (dstY > dstBitmap.height) continue;

            srcIndex = y * srcBitmap.width + x << 2;
            dstIndex = dstY * dstBitmap.width + dstX << 2;

            dstBitmap.pixels[dstIndex] = srcBitmap.pixels[srcIndex];
            dstBitmap.pixels[dstIndex + 1] = srcBitmap.pixels[srcIndex + 1];
            dstBitmap.pixels[dstIndex + 2] = srcBitmap.pixels[srcIndex + 2];
            dstBitmap.pixels[dstIndex + 3] = srcBitmap.pixels[srcIndex + 3];
        }
    }

    function getPixel(srcBitmap, dstBitmap, startX, startY) {
        var len = dstBitmap.pixels.length >> 2;
        var srcX = 0,
            srcY = 0,
            x = 0,
            y = 0,
            srcIndex = 0,
            dstIndex = 0;
        for (var i = 0; i < len; i++) {
            var x = i % dstBitmap.width,
                y = Math.floor(i / dstBitmap.width);

            srcX = startX + x;
            srcY = startY + y;

            if (srcX > srcBitmap.width) continue;
            if (srcY > srcBitmap.height) continue;

            srcIndex = srcY * srcBitmap.width + srcX << 2;
            dstIndex = y * dstBitmap.width + x << 2;

            dstBitmap.pixels[dstIndex] = srcBitmap.pixels[srcIndex];
            dstBitmap.pixels[dstIndex + 1] = srcBitmap.pixels[srcIndex + 1];
            dstBitmap.pixels[dstIndex + 2] = srcBitmap.pixels[srcIndex + 2];
            dstBitmap.pixels[dstIndex + 3] = srcBitmap.pixels[srcIndex + 3];
        }
    }

    function cloneBitmap(bitmap) {
        var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;


        var width = bitmap.width + padding;
        var height = bitmap.height + padding;

        var newBitmap = { pixels: new Uint8ClampedArray(width * height * 4), width: width, height: height };

        return newBitmap;
    }

    function getBitmap(bitmap, area) {
        return Canvas.getBitmap(bitmap, area);
    }

    function putBitmap(bitmap, subBitmap, area) {
        return Canvas.putBitmap(bitmap, subBitmap, area);
    }

    function parseParamNumber(param) {
        if (typeof param === 'string') {
            param = param.replace(/deg/, '');
            param = param.replace(/px/, '');
        }
        return +param;
    }

    var filter_regexp = /(([\w_\-]+)(\(([^\)]*)\))?)+/gi;
    function pack$1(callback) {
        return function (bitmap, done) {
            each$1(bitmap.pixels.length, function (i, xyIndex) {
                callback(bitmap.pixels, i, xyIndex, bitmap.pixels[i], bitmap.pixels[i + 1], bitmap.pixels[i + 2], bitmap.pixels[i + 3]);
            }, function () {
                done(bitmap);
            });
        };
    }

    function makePrebuildUserFilterList(arr) {

        var codeString = arr.map(function (it) {
            return ' \n            ' + it.userFunction.$preContext + '\n\n            ' + it.userFunction.$preCallbackString + '\n\n            $r = clamp($r); $g = clamp($g); $b = clamp($b); $a = clamp($a);\n        ';
        }).join('\n\n');

        var rootContextObject = { clamp: clamp$1, Color: Color$1 };
        arr.forEach(function (it) {
            Object.assign(rootContextObject, it.userFunction.rootContextObject);
        });

        var rootContextDefine = 'const ' + Object.keys(rootContextObject).map(function (key) {
            return ' ' + key + ' = $rc.' + key + ' ';
        }).join(',');

        var FunctionCode = ' \n    let $r = $p[$pi], $g = $p[$pi+1], $b = $p[$pi+2], $a = $p[$pi+3];\n    \n    ' + rootContextDefine + '\n\n    ' + codeString + '\n    \n    $p[$pi] = $r; $p[$pi+1] = $g; $p[$pi+2] = $b; $p[$pi+3] = $a;\n    ';

        var userFunction = new Function('$p', '$pi', '$rc', FunctionCode);

        return function ($pixels, $pixelIndex) {
            userFunction($pixels, $pixelIndex, rootContextObject);
        };
    }

    function makeUserFilterFunctionList(arr) {
        var rootContextObject = {};
        var list = arr.map(function (it) {
            var newKeys = [];

            Object.keys(it.context).forEach(function (key, i) {
                newKeys[key] = 'n$' + makeId++ + key + '$';
            });

            Object.keys(it.rootContext).forEach(function (key, i) {
                newKeys[key] = 'r$' + makeId++ + key + '$';

                rootContextObject[newKeys[key]] = it.rootContext[key];
            });

            var preContext = Object.keys(it.context).filter(function (key) {
                if (typeof it.context[key] === 'number' || typeof it.context[key] === 'string') {
                    return false;
                } else if (Array.isArray(it.context[key])) {
                    if (typeof it.context[key][0] == 'number' || typeof it.context[key][0] == 'string') {
                        return false;
                    }
                }

                return true;
            }).map(function (key, i) {
                return [newKeys[key], JSON.stringify(it.context[key])].join(' = ');
            });

            var preCallbackString = it.callback;

            if (typeof it.callback === 'function') {
                preCallbackString = it.callback.toString().split("{");

                preCallbackString.shift();
                preCallbackString = preCallbackString.join("{");
                preCallbackString = preCallbackString.split("}");
                preCallbackString.pop();
                preCallbackString = preCallbackString.join("}");
            }

            Object.keys(newKeys).forEach(function (key) {
                var newKey = newKeys[key];

                if (typeof it.context[key] === 'number' || typeof it.context[key] === 'string') {
                    preCallbackString = preCallbackString.replace(new RegExp("\\" + key, "g"), it.context[key]);
                } else if (Array.isArray(it.context[key])) {
                    if (typeof it.context[key][0] == 'number' || typeof it.context[key][0] == 'string') {
                        it.context[key].forEach(function (item, index) {
                            preCallbackString = preCallbackString.replace(new RegExp("\\" + key + '\\[' + index + '\\]', "g"), item);
                        });
                    } else {
                        preCallbackString = preCallbackString.replace(new RegExp("\\" + key, "g"), newKey);
                    }
                } else {
                    preCallbackString = preCallbackString.replace(new RegExp("\\" + key, "g"), newKey);
                }
            });

            return { preCallbackString: preCallbackString, preContext: preContext };
        });

        var preContext = list.map(function (it, i) {
            return it.preContext.length ? 'const ' + it.preContext + ';' : "";
        }).join('\n\n');

        var preCallbackString = list.map(function (it) {
            return it.preCallbackString;
        }).join('\n\n');

        var FunctionCode = ' \n    let $r = $pixels[$pixelIndex], $g = $pixels[$pixelIndex+1], $b = $pixels[$pixelIndex+2], $a = $pixels[$pixelIndex+3];\n\n    ' + preContext + '\n\n    ' + preCallbackString + '\n    \n    $pixels[$pixelIndex] = $r\n    $pixels[$pixelIndex+1] = $g \n    $pixels[$pixelIndex+2] = $b   \n    $pixels[$pixelIndex+3] = $a   \n    ';

        var userFunction = new Function('$pixels', '$pixelIndex', '$clamp', '$Color', FunctionCode);

        userFunction.$preCallbackString = preCallbackString;
        userFunction.$preContext = preContext;
        userFunction.rootContextObject = rootContextObject;

        return userFunction;
    }

    function makeUserFilterFunction(callback) {
        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var rootContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        return makeUserFilterFunctionList([{ callback: callback, context: context, rootContext: rootContext }]);
    }

    function pixel(callback) {
        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var rootContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        var userFunction = makeUserFilterFunction(callback, context, rootContext);

        var returnCallback = function returnCallback(bitmap, done) {};

        returnCallback.userFunction = userFunction;

        return returnCallback;
    }

    var ColorListIndex = [0, 1, 2, 3];

    function swapColor(pixels, startIndex, endIndex) {

        ColorListIndex.forEach(function (i) {
            var temp = pixels[startIndex + i];
            pixels[startIndex + i] = pixels[endIndex + i];
            pixels[endIndex + i] = temp;
        });
    }

    function packXY(callback) {
        return function (bitmap, done) {
            var opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

            eachXY(bitmap.pixels.length, bitmap.width, function (i, x, y) {
                callback(bitmap.pixels, i, x, y);
            }, function () {
                done(bitmap);
            }, opt);
        };
    }

    function radian(degree) {
        return Matrix.CONSTANT.radian(degree);
    }

    function createBlurMatrix() {
        var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;

        var count = Math.pow(amount, 2);
        var value = 1 / count;
        return repeat$1(value, count);
    }

    function fillColor(pixels, i, r, g, b, a) {
        if (arguments.length == 3) {
            var _arguments$ = arguments[2],
                r = _arguments$.r,
                g = _arguments$.g,
                b = _arguments$.b,
                a = _arguments$.a;
        }

        if (typeof r == 'number') {
            pixels[i] = r;
        }
        if (typeof g == 'number') {
            pixels[i + 1] = g;
        }
        if (typeof b == 'number') {
            pixels[i + 2] = b;
        }
        if (typeof a == 'number') {
            pixels[i + 3] = a;
        }
    }

    function fillPixelColor(targetPixels, targetIndex, sourcePixels, sourceIndex) {
        fillColor(targetPixels, targetIndex, sourcePixels[sourceIndex], sourcePixels[sourceIndex + 1], sourcePixels[sourceIndex + 2], sourcePixels[sourceIndex + 3]);
    }



    function createWeightTable(weights) {
        var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 255;

        var weightTable = [];

        weightTable = weights.map(function (w, i) {
            return [];
        });

        weights.forEach(function (w, i) {

            if (w != 0) {
                var data = weightTable[i];

                for (var i = min; i <= max; i++) {
                    data[i] = w * i;
                }
            }
        });

        return weightTable;
    }

    function createSubPixelWeightFunction(weights, weightTable, width, height, opaque) {

        var side = Math.round(Math.sqrt(weights.length));
        var halfSide = Math.floor(side / 2);
        var alphaFac = opaque ? 1 : 0;

        var FunctionCode = 'let r = 0, g = 0, b = 0, a = 0, scy = 0, scx =0, si = 0; ';
        var R = [];
        var G = [];
        var B = [];
        var A = [];
        weights.forEach(function (wt, index) {
            var cy = Math.floor(index / side);
            var cx = index % side;
            var distY = cy - halfSide;
            var distX = cx - halfSide;

            if (wt == 0) {
                return;
            }

            R.push('$t[' + index + '][$sp[(($sy + (' + distY + ')) * ' + width + ' + ($sx + (' + distX + '))) * 4]]');
            G.push('$t[' + index + '][$sp[(($sy + (' + distY + ')) * ' + width + ' + ($sx + (' + distX + '))) * 4 + 1]]');
            B.push('$t[' + index + '][$sp[(($sy + (' + distY + ')) * ' + width + ' + ($sx + (' + distX + '))) * 4 + 2]]');
            A.push('$t[' + index + '][$sp[(($sy + (' + distY + ')) * ' + width + ' + ($sx + (' + distX + '))) * 4 + 3]]');
        });

        FunctionCode += 'r = ' + R.join(' + ') + '; g = ' + G.join(' + ') + '; b = ' + B.join(' + ') + '; a = ' + A.join(' + ') + ';';
        FunctionCode += '$dp[$di] = r; $dp[$di+1] = g;$dp[$di+2] = b;$dp[$di+3] = a + (' + alphaFac + ')*(255-a); ';

        // console.log(FunctionCode)

        var subPixelFunction = new Function('$dp', '$sp', '$di', '$sx', '$sy', '$t', FunctionCode);

        return function ($dp, $sp, $di, $sx, $sy) {
            subPixelFunction($dp, $sp, $di, $sx, $sy, weightTable);
        };
    }

    function convolution(weights) {
        var opaque = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        var weightTable = createWeightTable(weights);
        return function (bitmap, done) {
            var side = Math.round(Math.sqrt(weights.length));
            var padding = side * 2;

            //   
            var sourceBitmap = cloneBitmap(bitmap, padding);

            //   
            putPixel(sourceBitmap, bitmap, side, side);

            //  
            var newBitmap = createBitmap(sourceBitmap.pixels.length, sourceBitmap.width, sourceBitmap.height);

            //   
            var returnBitmap = createBitmap(bitmap.pixels.length, bitmap.width, bitmap.height);

            var subPixelWeightFunction = createSubPixelWeightFunction(weights, weightTable, sourceBitmap.width, sourceBitmap.height, opaque);

            var len = bitmap.pixels.length / 4;
            for (var i = 0; i < len; i++) {
                var xyIndex = i,
                    x = xyIndex % bitmap.width + side,
                    y = Math.floor(xyIndex / bitmap.width) + side;

                subPixelWeightFunction(newBitmap.pixels, sourceBitmap.pixels, (y * sourceBitmap.width + x) * 4, x, y);
            }

            getPixel(newBitmap, returnBitmap, side, side);
            done(returnBitmap);
        };
    }

    function matches$1(str) {
        var ret = Color$1.convertMatches(str);
        var matches = ret.str.match(filter_regexp);
        var result = [];

        if (!matches) {
            return result;
        }

        result = matches.map(function (it) {
            return { filter: it, origin: Color$1.reverseMatches(it, ret.matches) };
        });

        var pos = { next: 0 };
        result = result.map(function (item) {

            var startIndex = str.indexOf(item.origin, pos.next);

            item.startIndex = startIndex;
            item.endIndex = startIndex + item.origin.length;

            item.arr = parseFilter(item.origin);

            pos.next = item.endIndex;

            return item;
        }).filter(function (it) {
            if (!it.arr.length) return false;
            return true;
        });

        return result;
    }

    /**
     * Filter Parser
     *
     * F.parseFilter('blur(30)') == ['blue', '30']
     * F.parseFilter('gradient(white, black, 3)') == ['gradient', 'white', 'black', '3']
     *
     * @param {String} filterString
     */
    function parseFilter(filterString) {

        var ret = Color$1.convertMatches(filterString);
        var matches = ret.str.match(filter_regexp);

        if (!matches[0]) {
            return [];
        }

        var arr = matches[0].split('(');

        var filterName = arr.shift();
        var filterParams = [];

        if (arr.length) {
            filterParams = arr.shift().split(')')[0].split(',').map(function (f) {
                return Color$1.reverseMatches(f, ret.matches);
            });
        }

        var result = [filterName].concat(toConsumableArray(filterParams)).map(Color$1.trim);

        return result;
    }

    function clamp$1(num) {
        return Math.min(255, num);
    }

    function filter(str) {
        return merge(matches$1(str).map(function (it) {
            return it.arr;
        }));
    }

    function makeGroupedFilter() {
        var filters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

        var groupedFilter = [];
        var group = [];
        for (var i = 0, len = filters.length; i < len; i++) {
            var f = filters[i];

            if (f.userFunction) {
                group.push(f);
            } else {
                if (group.length) {
                    groupedFilter.push([].concat(toConsumableArray(group)));
                }
                groupedFilter.push(f);
                group = [];
            }
        }

        if (group.length) {
            groupedFilter.push([].concat(toConsumableArray(group)));
        }

        groupedFilter.forEach(function (filter, index) {
            if (Array.isArray(filter)) {
                groupedFilter[index] = function () {
                    var userFunction = makePrebuildUserFilterList(filter);
                    // console.log(userFunction)
                    return function (bitmap, done) {

                        for (var i = 0, len = bitmap.pixels.length; i < len; i += 4) {
                            userFunction(bitmap.pixels, i);
                        }

                        done(bitmap);
                        // forLoop(bitmap.pixels.length, 0, 4, function (i) {
                        //     userFunction(bitmap.pixels, i)
                        // }, function () {
                        //     done(bitmap)
                        // })
                    };
                }();
            }
        });

        return groupedFilter;
    }

    /**
     *
     * multiply filters
     *
     * ImageFilter.multi('blur', 'grayscale', 'sharpen', ['blur', 3], function (bitmap) {  return bitmap });
     *
     */
    function multi() {
        for (var _len = arguments.length, filters = Array(_len), _key = 0; _key < _len; _key++) {
            filters[_key] = arguments[_key];
        }

        filters = filters.map(function (filter) {
            return makeFilter(filter);
        }).filter(function (f) {
            return f;
        });

        filters = makeGroupedFilter(filters);

        var max = filters.length;

        return function (bitmap, done) {
            var opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};


            var currentBitmap = bitmap;
            var index = 0;

            function runFilter() {
                filters[index].call(null, currentBitmap, function (nextBitmap) {
                    currentBitmap = nextBitmap;

                    nextFilter();
                }, opt);
            }

            function nextFilter() {
                index++;

                if (index >= max) {
                    done(currentBitmap);
                    return;
                }

                runFilter();
            }

            runFilter();
        };
    }

    function merge(filters) {
        return multi.apply(undefined, toConsumableArray(filters));
    }

    /**
     * apply filter into special area
     *
     * F.partial({x,y,width,height}, filter, filter, filter )
     * F.partial({x,y,width,height}, 'filter' )
     *
     * @param {{x, y, width, height}} area
     * @param {*} filters
     */
    function partial(area) {
        var allFilter = null;

        for (var _len2 = arguments.length, filters = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            filters[_key2 - 1] = arguments[_key2];
        }

        if (filters.length == 1 && typeof filters[0] === 'string') {
            allFilter = filter(filters[0]);
        } else {
            allFilter = merge(filters);
        }

        return function (bitmap, done) {
            var opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

            allFilter(getBitmap(bitmap, area), function (newBitmap) {
                done(putBitmap(bitmap, newBitmap, area));
            }, opt);
        };
    }

    // TODO: worker run
    var ImageFilter = _extends({}, ImageFilter$1, functions);

    var Util = {
        Color: Color$1,
        HueColor: HueColor,
        ColorNames: ColorNames,
        ImageFilter: ImageFilter,
        Canvas: Canvas,
        ImageLoader: ImageLoader
    };

    Color$1.color;

    var counter = 0;
    var cached = [];

    var Dom = function () {
        function Dom(tag, className, attr) {
            classCallCheck(this, Dom);


            if (typeof tag != 'string') {
                this.el = tag;
            } else {

                var el = document.createElement(tag);
                this.uniqId = counter++;

                if (className) {
                    el.className = className;
                }

                attr = attr || {};

                for (var k in attr) {
                    el.setAttribute(k, attr[k]);
                }

                this.el = el;
            }
        }

        createClass(Dom, [{
            key: 'attr',
            value: function attr(key, value) {
                if (arguments.length == 1) {
                    return this.el.getAttribute(key);
                }

                this.el.setAttribute(key, value);

                return this;
            }
        }, {
            key: 'closest',
            value: function closest(cls) {

                var temp = this;
                var checkCls = false;

                while (!(checkCls = temp.hasClass(cls))) {
                    if (temp.el.parentNode) {
                        temp = new Dom(temp.el.parentNode);
                    } else {
                        return null;
                    }
                }

                if (checkCls) {
                    return temp;
                }

                return null;
            }
        }, {
            key: 'checked',
            value: function checked() {
                return this.el.checked;
            }
        }, {
            key: 'removeClass',
            value: function removeClass(cls) {
                this.el.className = (' ' + this.el.className + ' ').replace(' ' + cls + ' ', ' ').trim();

                return this;
            }
        }, {
            key: 'hasClass',
            value: function hasClass(cls) {
                if (!this.el.className) {
                    return false;
                } else {
                    var newClass = ' ' + this.el.className + ' ';
                    return newClass.indexOf(' ' + cls + ' ') > -1;
                }
            }
        }, {
            key: 'addClass',
            value: function addClass(cls) {
                if (!this.hasClass(cls)) {
                    this.el.className = this.el.className + ' ' + cls;
                }

                return this;
            }
        }, {
            key: 'toggleClass',
            value: function toggleClass(cls) {
                if (this.hasClass(cls)) {
                    this.removeClass(cls);
                } else {
                    this.addClass(cls);
                }
            }
        }, {
            key: 'html',
            value: function html(_html) {
                try {
                    if (typeof _html == 'string') {
                        this.el.innerHTML = _html;
                    } else {
                        this.empty().append(_html);
                    }
                } catch (e) {
                    console.log(_html);
                }

                return this;
            }
        }, {
            key: 'find',
            value: function find(selector) {
                return this.el.querySelector(selector);
            }
        }, {
            key: '$',
            value: function $(selector) {
                return new Dom(this.find(selector));
            }
        }, {
            key: 'findAll',
            value: function findAll(selector) {
                return this.el.querySelectorAll(selector);
            }
        }, {
            key: '$$',
            value: function $$(selector) {
                return [].concat(toConsumableArray(this.findAll(selector))).map(function (el) {
                    return new Dom(el);
                });
            }
        }, {
            key: 'empty',
            value: function empty() {
                return this.html('');
            }
        }, {
            key: 'append',
            value: function append(el) {

                if (typeof el == 'string') {
                    this.el.appendChild(document.createTextNode(el));
                } else {
                    this.el.appendChild(el.el || el);
                }

                return this;
            }
        }, {
            key: 'appendTo',
            value: function appendTo(target) {
                var t = target.el ? target.el : target;

                t.appendChild(this.el);

                return this;
            }
        }, {
            key: 'remove',
            value: function remove() {
                if (this.el.parentNode) {
                    this.el.parentNode.removeChild(this.el);
                }

                return this;
            }
        }, {
            key: 'text',
            value: function text() {
                return this.el.textContent;
            }
        }, {
            key: 'css',
            value: function css(key, value) {
                var _this = this;

                if (arguments.length == 2) {
                    this.el.style[key] = value;
                } else if (arguments.length == 1) {

                    if (typeof key == 'string') {
                        return getComputedStyle(this.el)[key];
                    } else {
                        var keys = key || {};
                        Object.keys(keys).forEach(function (k) {
                            _this.el.style[k] = keys[k];
                        });
                    }
                }

                return this;
            }
        }, {
            key: 'cssFloat',
            value: function cssFloat(key) {
                return parseFloat(this.css(key));
            }
        }, {
            key: 'cssInt',
            value: function cssInt(key) {
                return parseInt(this.css(key));
            }
        }, {
            key: 'px',
            value: function px(key, value) {
                return this.css(key, value + 'px');
            }
        }, {
            key: 'offset',
            value: function offset() {
                var rect = this.el.getBoundingClientRect();

                return {
                    top: rect.top + Dom.getScrollTop(),
                    left: rect.left + Dom.getScrollLeft()
                };
            }
        }, {
            key: 'rect',
            value: function rect() {
                return this.el.getBoundingClientRect();
            }
        }, {
            key: 'position',
            value: function position() {

                if (this.el.style.top) {
                    return {
                        top: parseFloat(this.css('top')),
                        left: parseFloat(this.css('left'))
                    };
                } else {
                    return this.el.getBoundingClientRect();
                }
            }
        }, {
            key: 'size',
            value: function size() {
                return [this.width(), this.height()];
            }
        }, {
            key: 'width',
            value: function width() {
                return this.el.offsetWidth || this.el.getBoundingClientRect().width;
            }
        }, {
            key: 'contentWidth',
            value: function contentWidth() {
                return this.width() - this.cssFloat('padding-left') - this.cssFloat('padding-right');
            }
        }, {
            key: 'height',
            value: function height() {
                return this.el.offsetHeight || this.el.getBoundingClientRect().height;
            }
        }, {
            key: 'contentHeight',
            value: function contentHeight() {
                return this.height() - this.cssFloat('padding-top') - this.cssFloat('padding-bottom');
            }
        }, {
            key: 'dataKey',
            value: function dataKey(key) {
                return this.uniqId + '.' + key;
            }
        }, {
            key: 'data',
            value: function data(key, value) {
                if (arguments.length == 2) {
                    cached[this.dataKey(key)] = value;
                } else if (arguments.length == 1) {
                    return cached[this.dataKey(key)];
                } else {
                    var keys = Object.keys(cached);

                    var uniqId = this.uniqId + ".";
                    return keys.filter(function (key) {
                        if (key.indexOf(uniqId) == 0) {
                            return true;
                        }

                        return false;
                    }).map(function (value) {
                        return cached[value];
                    });
                }

                return this;
            }
        }, {
            key: 'val',
            value: function val(value) {
                if (arguments.length == 0) {
                    return this.el.value;
                } else if (arguments.length == 1) {
                    this.el.value = value;
                }

                return this;
            }
        }, {
            key: 'int',
            value: function int() {
                return parseInt(this.val(), 10);
            }
        }, {
            key: 'float',
            value: function float() {
                return parseFloat(this.val());
            }
        }, {
            key: 'show',
            value: function show() {
                return this.css('display', 'block');
            }
        }, {
            key: 'hide',
            value: function hide() {
                return this.css('display', 'none');
            }
        }, {
            key: 'toggle',
            value: function toggle() {
                if (this.css('display') == 'none') {
                    return this.show();
                } else {
                    return this.hide();
                }
            }
        }, {
            key: 'scrollTop',
            value: function scrollTop() {
                if (this.el === document.body) {
                    return Dom.getScrollTop();
                }

                return this.el.scrollTop;
            }
        }, {
            key: 'scrollLeft',
            value: function scrollLeft() {
                if (this.el === document.body) {
                    return Dom.getScrollLeft();
                }

                return this.el.scrollLeft;
            }
        }, {
            key: 'on',
            value: function on(eventName, callback, opt1, opt2) {
                this.el.addEventListener(eventName, callback, opt1, opt2);

                return this;
            }
        }, {
            key: 'off',
            value: function off(eventName, callback) {
                this.el.removeEventListener(eventName, callback);

                return this;
            }
        }, {
            key: 'getElement',
            value: function getElement() {
                return this.el;
            }
        }, {
            key: 'createChild',
            value: function createChild(tag) {
                var className = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
                var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                var css = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

                var $element = new Dom(tag, className, attrs);
                $element.css(css);

                this.append($element);

                return $element;
            }
        }, {
            key: 'firstChild',
            value: function firstChild() {
                return new Dom(this.el.firstElementChild);
            }
        }, {
            key: 'replace',
            value: function replace(oldElement, newElement) {
                this.el.replaceChild(newElement, oldElement);

                return this;
            }
        }], [{
            key: 'getScrollTop',
            value: function getScrollTop() {
                return Math.max(window.pageYOffset, document.documentElement.scrollTop, document.body.scrollTop);
            }
        }, {
            key: 'getScrollLeft',
            value: function getScrollLeft() {
                return Math.max(window.pageXOffset, document.documentElement.scrollLeft, document.body.scrollLeft);
            }
        }]);
        return Dom;
    }();

    var BaseModule = function () {
        function BaseModule($store) {
            classCallCheck(this, BaseModule);

            this.$store = $store;
            this.initialize();
        }

        createClass(BaseModule, [{
            key: 'initialize',
            value: function initialize() {
                var _this = this;

                this.filterProps().forEach(function (key) {
                    _this.$store.action(key, _this);
                });
            }
        }, {
            key: 'filterProps',
            value: function filterProps() {
                var pattern = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '/';

                return Object.getOwnPropertyNames(this.__proto__).filter(function (key) {
                    return key.startsWith(pattern);
                });
            }
        }]);
        return BaseModule;
    }();

    var ColorSetsList = function (_BaseModule) {
        inherits(ColorSetsList, _BaseModule);

        function ColorSetsList() {
            classCallCheck(this, ColorSetsList);
            return possibleConstructorReturn(this, (ColorSetsList.__proto__ || Object.getPrototypeOf(ColorSetsList)).apply(this, arguments));
        }

        createClass(ColorSetsList, [{
            key: 'initialize',
            value: function initialize() {
                get(ColorSetsList.prototype.__proto__ || Object.getPrototypeOf(ColorSetsList.prototype), 'initialize', this).call(this);

                // set property
                this.$store.colorSetsList = [{ name: "Material",
                    colors: ['#F44336', '#E91E63', '#9C27B0', '#673AB7', '#3F51B5', '#2196F3', '#03A9F4', '#00BCD4', '#009688', '#4CAF50', '#8BC34A', '#CDDC39', '#FFEB3B', '#FFC107', '#FF9800', '#FF5722', '#795548', '#9E9E9E', '#607D8B'],
                    edit: true
                }, { name: "Custom", "edit": true, "colors": [] }, { name: "Color Scale", "scale": ['red', 'yellow', 'black'], count: 5 }];
                this.$store.currentColorSets = {};
            }
        }, {
            key: '/list',
            value: function list($store) {
                return Array.isArray($store.userList) && $store.userList.length ? $store.userList : $store.colorSetsList;
            }
        }, {
            key: '/setUserPalette',
            value: function setUserPalette($store, list) {
                $store.userList = list;

                $store.dispatch('/resetUserPalette');
                $store.dispatch('/setCurrentColorSets');
            }
        }, {
            key: '/resetUserPalette',
            value: function resetUserPalette($store) {
                if ($store.userList && $store.userList.length) {
                    $store.userList = $store.userList.map(function (element, index) {

                        if (typeof element.colors == 'function') {
                            var makeCallback = element.colors;

                            element.colors = makeCallback($store);
                            element._colors = makeCallback;
                        }

                        return Object.assign({
                            name: 'color-' + index,
                            colors: []
                        }, element);
                    });

                    $store.emit('changeUserList');
                }
            }
        }, {
            key: '/setCurrentColorSets',
            value: function setCurrentColorSets($store, nameOrIndex) {

                var _list = $store.dispatch('/list');

                if (typeof nameOrIndex == 'undefined') {
                    $store.currentColorSets = _list[0];
                } else if (typeof nameOrIndex == 'number') {
                    $store.currentColorSets = _list[nameOrIndex];
                } else {
                    $store.currentColorSets = _list.filter(function (obj) {
                        return obj.name == nameOrIndex;
                    })[0];
                }

                $store.emit('changeCurrentColorSets');
            }
        }, {
            key: '/getCurrentColorSets',
            value: function getCurrentColorSets($store) {
                return $store.currentColorSets;
            }
        }, {
            key: '/addCurrentColor',
            value: function addCurrentColor($store, color) {
                if (Array.isArray($store.currentColorSets.colors)) {
                    $store.currentColorSets.colors.push(color);
                    $store.emit('changeCurrentColorSets');
                    $store.emit("addCurrentColor", color);
                }
            }
        }, {
            key: '/setCurrentColorAll',
            value: function setCurrentColorAll($store) {
                var colors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

                $store.currentColorSets.colors = colors;
                $store.emit('changeCurrentColorSets');
            }
        }, {
            key: '/removeCurrentColor',
            value: function removeCurrentColor($store, index) {
                if ($store.currentColorSets.colors[index]) {
                    $store.currentColorSets.colors.splice(index, 1);
                    $store.emit('changeCurrentColorSets');
                }
            }
        }, {
            key: '/removeCurrentColorToTheRight',
            value: function removeCurrentColorToTheRight($store, index) {
                if ($store.currentColorSets.colors[index]) {
                    $store.currentColorSets.colors.splice(index, Number.MAX_VALUE);
                    $store.emit('changeCurrentColorSets');
                }
            }
        }, {
            key: '/clearPalette',
            value: function clearPalette($store) {
                if ($store.currentColorSets.colors) {
                    $store.currentColorSets.colors = [];
                    $store.emit('changeCurrentColorSets');
                }
            }
        }, {
            key: '/getCurrentColors',
            value: function getCurrentColors($store) {
                return $store.dispatch('/getColors', $store.currentColorSets);
            }
        }, {
            key: '/getColors',
            value: function getColors($store, element) {
                if (element.scale) {
                    return Color$1.scale(element.scale, element.count);
                }

                return element.colors || [];
            }
        }, {
            key: '/getColorSetsList',
            value: function getColorSetsList($store) {
                return $store.dispatch('/list').map(function (element) {
                    return {
                        name: element.name,
                        edit: element.edit,
                        colors: $store.dispatch('/getColors', element)
                    };
                });
            }
        }]);
        return ColorSetsList;
    }(BaseModule);

    var Event = {
        addEvent: function addEvent(dom, eventName, callback, options) {
            if (dom) {
                dom.addEventListener(eventName, callback, options);
            }
        },
        removeEvent: function removeEvent(dom, eventName, callback) {
            if (dom) {
                dom.removeEventListener(eventName, callback);
            }
        },
        pos: function pos(e) {
            if (e.touches && e.touches[0]) {
                return e.touches[0];
            }

            return e;
        },
        posXY: function posXY(e) {
            var pos = this.pos(e);
            return {
                x: pos.pageX,
                y: pos.pageY
            };
        }
    };

    var DELEGATE_SPLIT = '.';

    var State = function () {
      function State(masterObj) {
        var settingObj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        classCallCheck(this, State);


        this.masterObj = masterObj;
        this.settingObj = settingObj;
      }

      createClass(State, [{
        key: 'set',
        value: function set$$1(key, value) {
          var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

          this.settingObj[key] = value || defaultValue;
        }
      }, {
        key: 'init',
        value: function init(key) {

          if (!this.has(key) || !this.settingObj[key]) {

            var arr = key.split(DELEGATE_SPLIT);

            var obj = this.masterObj.refs[arr[0]] || this.masterObj[arr[0]] || this.masterObj;
            var method = arr.pop();

            if (obj[method]) {
              for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }

              var value = obj[method].apply(obj, args);

              this.set(key, value);
            }
          }
        }
      }, {
        key: 'get',
        value: function get$$1(key) {
          var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';


          this.init(key, defaultValue);

          return this.settingObj[key] || defaultValue;
        }
      }, {
        key: 'has',
        value: function has(key) {
          return !!this.settingObj[key];
        }
      }]);
      return State;
    }();

    var CHECK_EVENT_PATTERN = /^(click|mouse(down|up|move|enter|leave)|touch(start|move|end)|key(down|up|press)|contextmenu|change|input)/ig;
    var CHECK_LOAD_PATTERN = /^load (.*)/ig;
    var EVENT_SAPARATOR = ' ';
    var META_KEYS = ['Control', 'Shift', 'Alt', 'Meta'];

    var EventMachin = function () {
      function EventMachin() {
        classCallCheck(this, EventMachin);

        this.state = new State(this);
        this.refs = {};

        this.childComponents = this.components();
      }

      /**
       *    .
       *   $store   .
       *   $store  .
       */


      createClass(EventMachin, [{
        key: 'newChildComponents',
        value: function newChildComponents() {
          var _this = this;

          var childKeys = Object.keys(this.childComponents);
          childKeys.forEach(function (key) {
            var Component = _this.childComponents[key];

            _this[key] = new Component(_this);
          });
        }

        /**
         *   template         
         *  element  .
         *
         *   load    .
         */

      }, {
        key: 'render',
        value: function render() {
          // 1.  template  
          this.$el = this.parseTemplate(this.template());
          this.refs.$el = this.$el;

          //   
          this.parseTarget();

          //   
          this.load();

          this.afterRender();
        }
      }, {
        key: 'afterRender',
        value: function afterRender() {}

        /**
         *     
         */

      }, {
        key: 'components',
        value: function components() {
          return {};
        }

        /**
         * Class  $el   
         *  html  .
         *
         * @param {*} html
         */

      }, {
        key: 'parseTemplate',
        value: function parseTemplate(html) {
          var _this2 = this;

          var $el = new Dom("div").html(html).firstChild();

          // ref element 
          var refs = $el.findAll('[ref]');

          [].concat(toConsumableArray(refs)).forEach(function (node) {
            var name = node.getAttribute('ref');
            _this2.refs[name] = new Dom(node);
          });

          return $el;
        }

        /**
         * target     .
         */

      }, {
        key: 'parseTarget',
        value: function parseTarget() {
          var _this3 = this;

          var $el = this.$el;
          var targets = $el.findAll('[target]');

          [].concat(toConsumableArray(targets)).forEach(function (node) {
            var targetComponentName = node.getAttribute('target');
            var refName = node.getAttribute('ref') || targetComponentName;

            var Component = _this3.childComponents[targetComponentName];
            var instance = new Component(_this3);
            _this3[refName] = instance;
            _this3.refs[refName] = instance.$el;

            if (instance) {
              instance.render();
              var $parent = new Dom(node.parentNode);
              $parent.replace(node, instance.$el.el);
            }
          });
        }

        // load function   load  .

      }, {
        key: 'load',
        value: function load() {
          var _this4 = this;

          this.filterProps(CHECK_LOAD_PATTERN).forEach(function (callbackName) {
            var elName = callbackName.split('load ')[1];

            if (_this4.refs[elName]) {
              _this4.refs[elName].html(_this4.parseTemplate(_this4[callbackName].call(_this4)));
            }
          });
        }

        //   

      }, {
        key: 'template',
        value: function template() {
          return '<div></div>';
        }
      }, {
        key: 'initialize',
        value: function initialize() {}

        /**
         *  .
         */

      }, {
        key: 'initializeEvent',
        value: function initializeEvent() {
          var _this5 = this;

          this.initializeEventMachin();

          //     .
          //       .
          Object.keys(this.childComponents).forEach(function (key) {
            if (_this5[key]) _this5[key].initializeEvent();
          });
        }

        /**
         *  .
         *            .
         */

      }, {
        key: 'destroy',
        value: function destroy() {
          var _this6 = this;

          this.destroyEventMachin();
          // this.refs = {}

          Object.keys(this.childComponents).forEach(function (key) {
            if (_this6[key]) _this6[key].destroy();
          });
        }
      }, {
        key: 'destroyEventMachin',
        value: function destroyEventMachin() {
          this.removeEventAll();
        }
      }, {
        key: 'initializeEventMachin',
        value: function initializeEventMachin() {
          this.filterProps(CHECK_EVENT_PATTERN).forEach(this.parseEvent.bind(this));
        }

        /**
         * property 
         *    property   .
         */

      }, {
        key: 'collectProps',
        value: function collectProps() {

          if (!this.collapsedProps) {
            var p = this.__proto__;
            var results = [];
            do {
              results.push.apply(results, toConsumableArray(Object.getOwnPropertyNames(p)));
              p = p.__proto__;
            } while (p);

            this.collapsedProps = results;
          }

          return this.collapsedProps;
        }
      }, {
        key: 'filterProps',
        value: function filterProps(pattern) {
          return this.collectProps().filter(function (key) {
            return key.match(pattern);
          });
        }
      }, {
        key: 'parseEvent',
        value: function parseEvent(key) {
          var arr = key.split(EVENT_SAPARATOR);

          this.bindingEvent(arr, this[key].bind(this));
        }
      }, {
        key: 'getDefaultDomElement',
        value: function getDefaultDomElement(dom) {
          var el = void 0;

          if (dom) {
            el = this.refs[dom] || this[dom] || window[dom];
          } else {
            el = this.el || this.$el || this.$root;
          }

          if (el instanceof Dom) {
            return el.getElement();
          }

          return el;
        }
      }, {
        key: 'getDefaultEventObject',
        value: function getDefaultEventObject(eventName) {
          var _this7 = this;

          var arr = eventName.split('.');
          var realEventName = arr.shift();

          var isControl = arr.includes('Control');
          var isShift = arr.includes('Shift');
          var isAlt = arr.includes('Alt');
          var isMeta = arr.includes('Meta');

          arr = arr.filter(function (code) {
            return META_KEYS.includes(code) === false;
          });

          var checkMethodList = arr.filter(function (code) {
            return !!_this7[code];
          });

          arr = arr.filter(function (code) {
            return checkMethodList.includes(code) === false;
          }).map(function (code) {
            return code.toLowerCase();
          });

          return {
            eventName: realEventName,
            isControl: isControl,
            isShift: isShift,
            isAlt: isAlt,
            isMeta: isMeta,
            codes: arr,
            checkMethodList: checkMethodList
          };
        }
      }, {
        key: 'bindingEvent',
        value: function bindingEvent(_ref, callback) {
          var _ref2 = toArray(_ref),
              eventName = _ref2[0],
              dom = _ref2[1],
              delegate = _ref2.slice(2);

          dom = this.getDefaultDomElement(dom);
          var eventObject = this.getDefaultEventObject(eventName);

          eventObject.dom = dom;
          eventObject.delegate = delegate.join(EVENT_SAPARATOR);

          this.addEvent(eventObject, callback);
        }
      }, {
        key: 'matchPath',
        value: function matchPath(el, selector) {
          if (el) {
            if (el.matches(selector)) {
              return el;
            }
            return this.matchPath(el.parentElement, selector);
          }
          return null;
        }
      }, {
        key: 'getBindings',
        value: function getBindings() {

          if (!this._bindings) {
            this.initBindings();
          }

          return this._bindings;
        }
      }, {
        key: 'addBinding',
        value: function addBinding(obj) {
          this.getBindings().push(obj);
        }
      }, {
        key: 'initBindings',
        value: function initBindings() {
          this._bindings = [];
        }
      }, {
        key: 'checkEventType',
        value: function checkEventType(e, eventObject) {
          var _this8 = this;

          var onlyControl = eventObject.isControl ? e.ctrlKey : true;
          var onlyShift = eventObject.isShift ? e.shiftKey : true;
          var onlyAlt = eventObject.isAlt ? e.altKey : true;
          var onlyMeta = eventObject.isMeta ? e.metaKey : true;

          var hasKeyCode = true;
          if (eventObject.codes.length) {
            hasKeyCode = eventObject.codes.includes(e.code.toLowerCase()) || eventObject.codes.includes(e.key.toLowerCase());
          }

          var isAllCheck = true;
          if (eventObject.checkMethodList.length) {
            //      .
            isAllCheck = eventObject.checkMethodList.every(function (method) {
              return _this8[method].call(_this8, e);
            });
          }

          return onlyControl && onlyAlt && onlyShift && onlyMeta && hasKeyCode && isAllCheck;
        }
      }, {
        key: 'makeCallback',
        value: function makeCallback(eventObject, callback) {
          var _this9 = this;

          if (eventObject.delegate) {
            return function (e) {
              e.xy = Event.posXY(e);
              if (_this9.checkEventType(e, eventObject)) {
                var delegateTarget = _this9.matchPath(e.target || e.srcElement, eventObject.delegate);

                if (delegateTarget) {
                  // delegate target    callback 
                  e.delegateTarget = delegateTarget;
                  e.$delegateTarget = new Dom(delegateTarget);
                  return callback(e);
                }
              }
            };
          } else {
            return function (e) {
              e.xy = Event.posXY(e);
              if (_this9.checkEventType(e, eventObject)) {
                return callback(e);
              }
            };
          }
        }
      }, {
        key: 'addEvent',
        value: function addEvent(eventObject, callback) {
          eventObject.callback = this.makeCallback(eventObject, callback);
          this.addBinding(eventObject);

          var options = true;
          if (eventObject.eventName === 'touchstart') {
            options = { passive: true };
          }

          Event.addEvent(eventObject.dom, eventObject.eventName, eventObject.callback, options);
        }
      }, {
        key: 'removeEventAll',
        value: function removeEventAll() {
          var _this10 = this;

          this.getBindings().forEach(function (obj) {
            _this10.removeEvent(obj);
          });
          this.initBindings();
        }
      }, {
        key: 'removeEvent',
        value: function removeEvent(_ref3) {
          var eventName = _ref3.eventName,
              dom = _ref3.dom,
              callback = _ref3.callback;

          Event.removeEvent(dom, eventName, callback);
        }
      }]);
      return EventMachin;
    }();

    var CHECK_STORE_EVENT_PATTERN = /^@/;

    var UIElement = function (_EventMachin) {
        inherits(UIElement, _EventMachin);

        function UIElement(opt) {
            classCallCheck(this, UIElement);

            var _this = possibleConstructorReturn(this, (UIElement.__proto__ || Object.getPrototypeOf(UIElement)).call(this, opt));

            _this.opt = opt || {};

            if (opt && opt.$store) {
                _this.$store = opt.$store;
            }

            _this.initialize();

            _this.initializeStoreEvent();
            return _this;
        }

        /**
         * initialize store event
         *
         * you can define '@xxx' method(event) in UIElement
         *
         *
         */


        createClass(UIElement, [{
            key: 'initializeStoreEvent',
            value: function initializeStoreEvent() {
                var _this2 = this;

                this.storeEvents = {};
                this.filterProps(CHECK_STORE_EVENT_PATTERN).forEach(function (key) {
                    var arr = key.split('@');
                    arr.shift();
                    var event = arr.join('@');

                    _this2.storeEvents[event] = _this2[key].bind(_this2);
                    _this2.$store.on(event, _this2.storeEvents[event]);
                });
            }
        }, {
            key: 'destoryStoreEvent',
            value: function destoryStoreEvent() {
                var _this3 = this;

                Object.keys(this.storeEvents).forEach(function (event) {
                    _this3.$store.off(event, _this3.storeEvents[event]);
                });
            }
        }]);
        return UIElement;
    }(EventMachin);

    function isUndefined$2(v) {
        return typeof v == 'undefined' || v == null;
    }

    var ColorManager = function (_BaseModule) {
        inherits(ColorManager, _BaseModule);

        function ColorManager() {
            classCallCheck(this, ColorManager);
            return possibleConstructorReturn(this, (ColorManager.__proto__ || Object.getPrototypeOf(ColorManager)).apply(this, arguments));
        }

        createClass(ColorManager, [{
            key: 'initialize',
            value: function initialize() {
                get(ColorManager.prototype.__proto__ || Object.getPrototypeOf(ColorManager.prototype), 'initialize', this).call(this);

                this.$store.rgb = {};
                this.$store.hsl = {};
                this.$store.hsv = {};
                this.$store.alpha = 1;
                this.$store.format = 'hex';

                // this.$store.dispatch('/changeColor');
            }
        }, {
            key: '/changeFormat',
            value: function changeFormat($store, format) {
                $store.format = format;

                $store.emit('changeFormat');
            }
        }, {
            key: '/initColor',
            value: function initColor($store, colorObj, source) {
                $store.dispatch('/changeColor', colorObj, source, true);
                $store.emit('initColor');
            }
        }, {
            key: '/changeColor',
            value: function changeColor($store, colorObj, source, isNotEmit) {

                colorObj = colorObj || '#FF0000';

                if (typeof colorObj == 'string') {
                    colorObj = Color$1.parse(colorObj);
                }

                colorObj.source = colorObj.source || source;

                $store.alpha = isUndefined$2(colorObj.a) ? $store.alpha : colorObj.a;
                $store.format = colorObj.type != 'hsv' ? colorObj.type || $store.format : $store.format;

                if (colorObj.type == 'hsl') {
                    $store.hsl = Object.assign($store.hsl, colorObj);
                    $store.rgb = Color$1.HSLtoRGB($store.hsl);
                    $store.hsv = Color$1.HSLtoHSV(colorObj);
                } else if (colorObj.type == 'hex') {
                    $store.rgb = Object.assign($store.rgb, colorObj);
                    $store.hsl = Color$1.RGBtoHSL($store.rgb);
                    $store.hsv = Color$1.RGBtoHSV(colorObj);
                } else if (colorObj.type == 'rgb') {
                    $store.rgb = Object.assign($store.rgb, colorObj);
                    $store.hsl = Color$1.RGBtoHSL($store.rgb);
                    $store.hsv = Color$1.RGBtoHSV(colorObj);
                } else if (colorObj.type == 'hsv') {
                    $store.hsv = Object.assign($store.hsv, colorObj);
                    $store.rgb = Color$1.HSVtoRGB($store.hsv);
                    $store.hsl = Color$1.HSVtoHSL($store.hsv);
                }

                if (!isNotEmit) {
                    $store.emit('changeColor', colorObj.source);
                }
            }
        }, {
            key: '/getHueColor',
            value: function getHueColor($store) {
                return HueColor.checkHueColor($store.hsv.h / 360);
            }
        }, {
            key: '/toString',
            value: function toString($store, type) {
                type = type || $store.format;
                var colorObj = $store[type] || $store.rgb;
                return Color$1.format(_extends({}, colorObj, {
                    a: $store.alpha
                }), type);
            }
        }, {
            key: '/toColor',
            value: function toColor($store, type) {
                type = type || $store.format;

                if (type == 'rgb') {
                    return $store.dispatch('/toRGB');
                } else if (type == 'hsl') {
                    return $store.dispatch('/toHSL');
                } else if (type == 'hex') {
                    return $store.dispatch('/toHEX');
                }

                return $store.dispatch('/toString', type);
            }
        }, {
            key: '/toRGB',
            value: function toRGB($store) {
                return $store.dispatch('/toString', 'rgb');
            }
        }, {
            key: '/toHSL',
            value: function toHSL($store) {
                return $store.dispatch('/toString', 'hsl');
            }
        }, {
            key: '/toHEX',
            value: function toHEX($store) {
                return $store.dispatch('/toString', 'hex').toUpperCase();
            }
        }]);
        return ColorManager;
    }(BaseModule);

    var BaseStore = function () {
        function BaseStore(opt) {
            classCallCheck(this, BaseStore);

            this.callbacks = [];
            this.actions = [];
            this.modules = opt.modules || [];

            this.initialize();
        }

        createClass(BaseStore, [{
            key: 'initialize',
            value: function initialize() {
                this.initializeModule();
            }
        }, {
            key: 'initializeModule',
            value: function initializeModule() {
                var _this = this;

                this.modules.forEach(function (Module) {
                    new Module(_this);
                });
            }
        }, {
            key: 'action',
            value: function action(_action, context) {
                this.actions[_action] = { context: context, callback: context[_action] };
            }
        }, {
            key: 'dispatch',
            value: function dispatch(action) {
                var args = [].concat(Array.prototype.slice.call(arguments));
                var action = args.shift();

                var m = this.actions[action];

                if (m) {
                    return m.callback.apply(m.context, [this].concat(toConsumableArray(args)));
                }
            }
        }, {
            key: 'module',
            value: function module(ModuleObject) {
                // this.action()
            }
        }, {
            key: 'on',
            value: function on(event, callback) {
                this.callbacks.push({ event: event, callback: callback });
            }
        }, {
            key: 'off',
            value: function off(event, callback) {

                if (arguments.length == 0) {
                    this.callbacks = [];
                } else if (arguments.length == 1) {
                    this.callbacks = this.callbacks.filter(function (f) {
                        return f.event != event;
                    });
                } else if (arguments.length == 2) {
                    this.callbacks = this.callbacks.filter(function (f) {
                        return f.event != event && f.callback != callback;
                    });
                }
            }
        }, {
            key: 'emit',
            value: function emit() {
                var args = [].concat(Array.prototype.slice.call(arguments));
                var event = args.shift();

                this.callbacks.filter(function (f) {
                    return f.event == event;
                }).forEach(function (f) {
                    if (f && typeof f.callback == 'function') {
                        f.callback.apply(f, toConsumableArray(args));
                    }
                });
            }
        }]);
        return BaseStore;
    }();

    var BaseColorPicker = function (_UIElement) {
        inherits(BaseColorPicker, _UIElement);

        function BaseColorPicker(opt) {
            classCallCheck(this, BaseColorPicker);

            var _this = possibleConstructorReturn(this, (BaseColorPicker.__proto__ || Object.getPrototypeOf(BaseColorPicker)).call(this, opt));

            _this.isColorPickerShow = false;
            _this.isShortCut = false;
            _this.hideDelay = +(typeof _this.opt.hideDeplay == 'undefined' ? 2000 : _this.opt.hideDelay);
            _this.timerCloseColorPicker;
            _this.autoHide = _this.opt.autoHide || true;
            _this.outputFormat = _this.opt.outputFormat;
            _this.$checkColorPickerClass = _this.checkColorPickerClass.bind(_this);

            return _this;
        }

        createClass(BaseColorPicker, [{
            key: 'initialize',
            value: function initialize() {
                var _this2 = this;

                this.$body = null;
                this.$root = null;

                this.$store = new BaseStore({
                    modules: [ColorManager, ColorSetsList]
                });

                this.callbackChange = function () {
                    _this2.callbackColorValue();
                };

                this.callbackLastUpdate = function () {
                    _this2.callbackLastUpdateColorValue();
                };

                this.callbackAddCurrentColor = function (color) {
                    _this2.callbackAddCurrentColorValue(color);
                };

                this.colorpickerShowCallback = function () {};
                this.colorpickerHideCallback = function () {};
                this.colorpickerLastUpdateCallback = function () {};
                this.colorpickerAddCurrentColorCallback = function () {};

                this.$body = new Dom(this.getContainer());
                this.$root = new Dom('div', 'easylogic-colorpicker', {
                    tabIndex: -1
                });

                //  append colorpicker to container (ex : body)
                if (this.opt.position == 'inline') {
                    this.$body.append(this.$root);
                }

                if (this.opt.type) {
                    // to change css style
                    this.$root.addClass(this.opt.type);
                }

                if (this.opt.hideInformation) {
                    this.$root.addClass('hide-information');
                }

                if (this.opt.hideColorsets) {
                    this.$root.addClass('hide-colorsets');
                }

                this.$arrow = new Dom('div', 'arrow');

                this.$root.append(this.$arrow);

                if (this.opt.colorSets) {
                    this.$store.dispatch('/setUserPalette', this.opt.colorSet);
                } else if (isFunction(this.opt.onRetrievePreset)) {
                    this.$store.dispatch('/setUserPalette', this.opt.onRetrievePreset());
                } else {
                    this.$store.dispatch('/setUserPalette', []);
                }

                this.render();

                this.$root.append(this.$el);

                this.initColorWithoutChangeEvent(this.opt.color);

                //  
                this.initializeEvent();
            }
        }, {
            key: 'initColorWithoutChangeEvent',
            value: function initColorWithoutChangeEvent(color) {
                this.$store.dispatch('/initColor', color);
            }

            /**
             * public method
             *
             */

            /**
             *
             * show colorpicker with position
             *
             * @param {{left, top, hideDelay, isShortCut}} opt
             * @param {String|Object} color
             * @param {Function} showCallback  it is called when colorpicker is shown
             * @param {Function} hideCallback  it is called once when colorpicker is hidden
             * @param {Function} addCurrentColorCallback
             */

        }, {
            key: 'show',
            value: function show(opt, color, showCallback, hideCallback, lastUpdateCallback, addCurrentColorCallback) {

                //          .
                // this.destroy();
                // this.initializeEvent();
                // define colorpicker callback
                this.colorpickerShowCallback = showCallback;
                this.colorpickerHideCallback = hideCallback;
                this.colorpickerLastUpdateCallback = lastUpdateCallback;
                this.colorpickerAddCurrentColorCallback = addCurrentColorCallback;
                this.$root.css(this.getInitalizePosition()).show();

                this.isColorPickerShow = true;
                this.isShortCut = opt.isShortCut || false;
                this.outputFormat = opt.outputFormat;

                // define hide delay
                this.hideDelay = +(typeof opt.hideDelay == 'undefined' ? 2000 : opt.hideDelay);
                if (this.hideDelay > 0) {
                    this.setHideDelay(this.hideDelay);
                }

                this.$root.appendTo(this.$body);
                this.definePosition(opt);
                this.initColorWithoutChangeEvent(color);
            }

            /**
             *
             * initialize color for colorpicker
             *
             * @param {String|Object} newColor
             * @param {String} format  hex, rgb, hsl
             */

        }, {
            key: 'initColor',
            value: function initColor(newColor, format) {
                this.$store.dispatch('/changeColor', newColor, format);
            }

            /**
             * hide colorpicker
             *
             */

        }, {
            key: 'hide',
            value: function hide() {
                if (this.isColorPickerShow) {
                    // this.destroy();
                    this.$root.hide();
                    this.$root.remove(); // not empty
                    this.isColorPickerShow = false;

                    this.callbackHideColorValue();
                }
            }

            /**
             * set to colors in current sets that you see
             * @param {Array} colors
             */

        }, {
            key: 'setColorsInPalette',
            value: function setColorsInPalette() {
                var colors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

                this.$store.dispatch('/setCurrentColorAll', colors);
            }

            /**
             * refresh all color palette
             *
             * @param {*} list
             */

        }, {
            key: 'setUserPalette',
            value: function setUserPalette() {
                var list = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

                this.$store.dispatch('/setUserPalette', list);
            }

            /**
             * private method
             */

        }, {
            key: 'getOption',
            value: function getOption(key) {
                return this.opt[key];
            }
        }, {
            key: 'setOption',
            value: function setOption(key, value) {
                this.opt[key] = value;
            }
        }, {
            key: 'isType',
            value: function isType(key) {
                return this.getOption('type') == key;
            }
        }, {
            key: 'isPaletteType',
            value: function isPaletteType() {
                return this.isType('palette');
            }
        }, {
            key: 'isSketchType',
            value: function isSketchType() {
                return this.isType('sketch');
            }
        }, {
            key: 'getContainer',
            value: function getContainer() {
                return this.opt.container || document.body;
            }
        }, {
            key: 'getColor',
            value: function getColor(type) {
                return this.$store.dispatch('/toColor', type);
            }
        }, {
            key: 'definePositionForArrow',
            value: function definePositionForArrow(opt, elementScreenLeft, elementScreenTop) {
                // console.log(arguments)
            }
        }, {
            key: 'definePosition',
            value: function definePosition(opt) {

                var width = this.$root.width();
                var height = this.$root.height();

                // set left position for color picker
                var elementScreenLeft = opt.left - this.$body.scrollLeft();
                if (width + elementScreenLeft > window.innerWidth) {
                    elementScreenLeft -= width + elementScreenLeft - window.innerWidth;
                }
                if (elementScreenLeft < 0) {
                    elementScreenLeft = 0;
                }

                // set top position for color picker
                var elementScreenTop = opt.top - this.$body.scrollTop();
                if (height + elementScreenTop > window.innerHeight) {
                    elementScreenTop -= height + elementScreenTop - window.innerHeight;
                }
                if (elementScreenTop < 0) {
                    elementScreenTop = 0;
                }

                // set position
                this.$root.css({
                    left: elementScreenLeft + 'px',
                    top: elementScreenTop + 'px'
                });

                // this.definePositionForArrow(opt, elementScreenLeft, elementScreenTop);
            }
        }, {
            key: 'getInitalizePosition',
            value: function getInitalizePosition() {
                if (this.opt.position == 'inline') {
                    return {
                        position: 'relative',
                        left: 'auto',
                        top: 'auto',
                        display: 'inline-block'
                    };
                } else {
                    return {
                        position: 'fixed', // color picker has fixed position
                        left: '-10000px',
                        top: '-10000px'
                    };
                }
            }
        }, {
            key: 'isAbsolute',
            value: function isAbsolute() {
                return this.opt.position !== 'inline';
            }

            // Event Bindings

        }, {
            key: 'mouseup.isAbsolute document',
            value: function mouseupIsAbsoluteDocument(e) {

                this.__isMouseDown = false;
                // when color picker clicked in outside
                if (this.checkInHtml(e.target)) ; else if (this.checkColorPickerClass(e.target) == false) {
                    this.hide();
                } else {
                    if (!this.__isMouseIn) {
                        clearTimeout(this.timerCloseColorPicker);
                        this.timerCloseColorPicker = setTimeout(this.hide.bind(this), this.delayTime || this.hideDelay);
                    }
                }
            }
        }, {
            key: 'keyup.isAbsolute.escape $root',
            value: function keyupIsAbsoluteEscape$root(e) {
                this.hide();
            }
        }, {
            key: 'mouseover.isAbsolute $root',
            value: function mouseoverIsAbsolute$root(e) {
                clearTimeout(this.timerCloseColorPicker);
                // this.__isMouseDown = true;
            }
        }, {
            key: 'mousemove.isAbsolute $root',
            value: function mousemoveIsAbsolute$root(e) {
                clearTimeout(this.timerCloseColorPicker);
            }
        }, {
            key: 'mouseenter.isAbsolute $root',
            value: function mouseenterIsAbsolute$root(e) {
                clearTimeout(this.timerCloseColorPicker);
                this.__isMouseIn = true;
            }
        }, {
            key: 'mouseleave.isAbsolute $root',
            value: function mouseleaveIsAbsolute$root(e) {
                this.__isMouseIn = false;
                if (!this.__isMouseDown) {
                    clearTimeout(this.timerCloseColorPicker);
                    this.timerCloseColorPicker = setTimeout(this.hide.bind(this), this.delayTime || this.hideDelay);
                }
            }
        }, {
            key: 'mousedown.isAbsolute $root',
            value: function mousedownIsAbsolute$root(e) {
                this.__isMouseDown = true;
            }
        }, {
            key: 'setHideDelay',
            value: function setHideDelay(delayTime) {
                this.delayTime = delayTime || 0;
            }
        }, {
            key: 'runHideDelay',
            value: function runHideDelay() {

                if (this.isColorPickerShow) {
                    this.setHideDelay();
                    // const hideCallback = this.setHideDelay(delayTime);

                    // this.timerCloseColorPicker = setTimeout(hideCallback, delayTime);
                }
            }
        }, {
            key: 'callbackColorValue',
            value: function callbackColorValue(color) {
                color = color || this.getCurrentColor();

                if (typeof this.opt.onChange == 'function') {
                    this.opt.onChange.call(this, color);
                }

                if (typeof this.colorpickerShowCallback == 'function') {
                    this.colorpickerShowCallback(color);
                }
            }
        }, {
            key: 'callbackLastUpdateColorValue',
            value: function callbackLastUpdateColorValue(color) {
                color = color || this.getCurrentColor();

                if (typeof this.opt.onLastUpdate == 'function') {
                    this.opt.onLastUpdate.call(this, color);
                }

                if (typeof this.colorpickerLastUpdateCallback == 'function') {
                    this.colorpickerLastUpdateCallback(color);
                }
            }
        }, {
            key: 'callbackAddCurrentColorValue',
            value: function callbackAddCurrentColorValue(color) {
                if (typeof this.opt.onLastUpdate == 'function') {
                    this.opt.onAddPreset.call(this, color);
                }

                if (typeof this.colorpickerAddCurrentColorCallback == 'function') {
                    this.colorpickerAddCurrentColorCallback(color);
                }
            }
        }, {
            key: 'callbackHideColorValue',
            value: function callbackHideColorValue(color) {
                color = color || this.getCurrentColor();
                if (typeof this.opt.onHide == 'function') {
                    this.opt.onHide.call(this, color);
                }

                if (typeof this.colorpickerHideCallback == 'function') {
                    this.colorpickerHideCallback(color);
                }
            }
        }, {
            key: 'getCurrentColor',
            value: function getCurrentColor() {
                return this.$store.dispatch('/toColor', this.outputFormat);
            }
        }, {
            key: 'checkColorPickerClass',
            value: function checkColorPickerClass(el) {
                var hasColorView = new Dom(el).closest('codemirror-colorview');
                var hasColorPicker = new Dom(el).closest('easylogic-colorpicker');
                var hasCodeMirror = new Dom(el).closest('CodeMirror');
                el.nodeName == 'HTML';

                return !!(hasColorPicker || hasColorView || hasCodeMirror);
            }
        }, {
            key: 'checkInHtml',
            value: function checkInHtml(el) {
                var IsInHtml = el.nodeName == 'HTML';

                return IsInHtml;
            }
        }, {
            key: 'initializeStoreEvent',
            value: function initializeStoreEvent() {
                get(BaseColorPicker.prototype.__proto__ || Object.getPrototypeOf(BaseColorPicker.prototype), 'initializeStoreEvent', this).call(this);

                this.$store.on('changeColor', this.callbackChange);
                this.$store.on('lastUpdateColor', this.callbackLastUpdate);
                this.$store.on('changeFormat', this.callbackChange);
                this.$store.on('addCurrentColor', this.callbackAddCurrentColor);
            }
        }, {
            key: 'destroy',
            value: function destroy() {
                get(BaseColorPicker.prototype.__proto__ || Object.getPrototypeOf(BaseColorPicker.prototype), 'destroy', this).call(this);

                this.$store.off('changeColor', this.callbackChange);
                this.$store.off('lastUpdateColor', this.callbackLastUpdate);
                this.$store.off('changeFormat', this.callbackChange);
                this.$store.off('addCurrentColor', this.callbackAddCurrentColor);

                this.callbackChange = undefined;
                this.callbackLastUpdate = undefined;
                this.callbackAddCurrentColor = undefined;

                // remove color picker callback
                this.colorpickerShowCallback = undefined;
                this.colorpickerHideCallback = undefined;
            }
        }]);
        return BaseColorPicker;
    }(UIElement);

    var BaseBox = function (_UIElement) {
        inherits(BaseBox, _UIElement);

        function BaseBox(opt) {
            classCallCheck(this, BaseBox);

            var _this = possibleConstructorReturn(this, (BaseBox.__proto__ || Object.getPrototypeOf(BaseBox)).call(this, opt));

            _this.source = 'base-box';
            return _this;
        }

        createClass(BaseBox, [{
            key: 'refresh',
            value: function refresh() {}
        }, {
            key: 'refreshColorUI',
            value: function refreshColorUI(e) {}

            /** push change event  */

        }, {
            key: 'changeColor',
            value: function changeColor(opt) {
                this.$store.dispatch('/changeColor', Object.assign({
                    source: this.source
                }, opt || {}));
            }

            // Event Bindings

        }, {
            key: 'mouseup document',
            value: function mouseupDocument(e) {
                this.onDragEnd(e);
            }
        }, {
            key: 'mousemove document',
            value: function mousemoveDocument(e) {
                this.onDragMove(e);
            }
        }, {
            key: 'mousedown $bar',
            value: function mousedown$bar(e) {
                e.preventDefault();
                this.isDown = true;
            }
        }, {
            key: 'mousedown $container',
            value: function mousedown$container(e) {
                this.isDown = true;
                this.onDragStart(e);
            }
        }, {
            key: 'touchend document',
            value: function touchendDocument(e) {
                this.onDragEnd(e);
            }
        }, {
            key: 'touchmove document',
            value: function touchmoveDocument(e) {
                this.onDragMove(e);
            }
        }, {
            key: 'touchstart $bar',
            value: function touchstart$bar(e) {
                e.preventDefault();
                this.isDown = true;
            }
        }, {
            key: 'touchstart $container',
            value: function touchstart$container(e) {
                this.onDragStart(e);
            }
        }, {
            key: 'onDragStart',
            value: function onDragStart(e) {
                this.isDown = true;
                this.refreshColorUI(e);
            }
        }, {
            key: 'onDragMove',
            value: function onDragMove(e) {
                if (this.isDown) {
                    this.refreshColorUI(e);
                }
            }

            /* called when mouse is ended move  */

        }, {
            key: 'onDragEnd',
            value: function onDragEnd(e) {
                if (this.isDown) {
                    this.$store.emit('lastUpdateColor');
                    this.isDown = false;
                }
            }
        }, {
            key: '@changeColor',
            value: function changeColor(sourceType) {
                if (this.source != sourceType) {
                    this.refresh();
                }
            }
        }, {
            key: '@initColor',
            value: function initColor() {
                this.refresh();
            }
        }]);
        return BaseBox;
    }(UIElement);

    var BaseSlider = function (_BaseBox) {
        inherits(BaseSlider, _BaseBox);

        function BaseSlider(opt) {
            classCallCheck(this, BaseSlider);

            var _this = possibleConstructorReturn(this, (BaseSlider.__proto__ || Object.getPrototypeOf(BaseSlider)).call(this, opt));

            _this.minValue = 0; // min domain value
            _this.maxValue = 1; // max domain value
            _this.source = 'base-slider';
            return _this;
        }

        /* slider container's min and max position */


        createClass(BaseSlider, [{
            key: 'getMinMaxPosition',
            value: function getMinMaxPosition() {
                var min = this.getMinPosition();
                var width = this.getMaxDist();
                var max = min + width;

                return { min: min, max: max, width: width };
            }

            /** get current position on page  */

        }, {
            key: 'getCurrent',
            value: function getCurrent(value) {
                return min + this.getMaxDist() * value;
            }

            /** get min position on slider container  */

        }, {
            key: 'getMinPosition',
            value: function getMinPosition() {
                return this.refs.$container.offset().left;
            }
        }, {
            key: 'getMaxDist',
            value: function getMaxDist() {
                return this.state.get('$container.width');
            }

            /** get dist for position value */

        }, {
            key: 'getDist',
            value: function getDist(current) {
                var _getMinMaxPosition = this.getMinMaxPosition(),
                    min = _getMinMaxPosition.min,
                    max = _getMinMaxPosition.max;

                var dist;
                if (current < min) {
                    dist = 0;
                } else if (current > max) {
                    dist = 100;
                } else {
                    dist = (current - min) / (max - min) * 100;
                }

                return dist;
            }

            /** get caculated dist for domain value   */

        }, {
            key: 'getCaculatedDist',
            value: function getCaculatedDist(e) {
                var current = e ? this.getMousePosition(e) : this.getCurrent(this.getDefaultValue() / this.maxValue);
                var dist = this.getDist(current);

                return dist;
            }

            /** get default value used in slider container */

        }, {
            key: 'getDefaultValue',
            value: function getDefaultValue() {
                return 0;
            }

            /** set mosue position */

        }, {
            key: 'setMousePosition',
            value: function setMousePosition(x) {
                this.refs.$bar.css({ left: x + 'px' });
            }

            /** set mouse position in page */

        }, {
            key: 'getMousePosition',
            value: function getMousePosition(e) {
                return Event.pos(e).pageX;
            }
        }, {
            key: 'refresh',
            value: function refresh() {
                this.setColorUI();
            }

            /** set drag bar position  */

        }, {
            key: 'setColorUI',
            value: function setColorUI(v) {

                v = v || this.getDefaultValue();

                if (this.lastV === v) return true;

                this.lastV = v;

                if (v <= this.minValue) {
                    this.refs.$bar.addClass('first').removeClass('last');
                } else if (v >= this.maxValue) {
                    this.refs.$bar.addClass('last').removeClass('first');
                } else {
                    this.refs.$bar.removeClass('last').removeClass('first');
                }

                this.setMousePosition(this.getMaxDist() * ((v || 0) / this.maxValue));
            }
        }]);
        return BaseSlider;
    }(BaseBox);

    var Value = function (_BaseSlider) {
        inherits(Value, _BaseSlider);

        function Value(opt) {
            classCallCheck(this, Value);

            var _this = possibleConstructorReturn(this, (Value.__proto__ || Object.getPrototypeOf(Value)).call(this, opt));

            _this.minValue = 0;
            _this.maxValue = 1;
            _this.source = 'value-control';
            return _this;
        }

        createClass(Value, [{
            key: 'template',
            value: function template() {
                return '\n            <div class="value">\n                <div ref="$container" class="value-container">\n                    <div ref="$bar" class="drag-bar"></div>\n                </div>\n            </div>\n        ';
            }
        }, {
            key: 'setBackgroundColor',
            value: function setBackgroundColor() {
                this.refs.$container.css("background-color", this.$store.dispatch('/toRGB'));
            }
        }, {
            key: 'refresh',
            value: function refresh() {
                get(Value.prototype.__proto__ || Object.getPrototypeOf(Value.prototype), 'refresh', this).call(this);
                this.setBackgroundColor();
            }
        }, {
            key: 'getDefaultValue',
            value: function getDefaultValue() {
                return this.$store.hsv.v;
            }
        }, {
            key: 'refreshColorUI',
            value: function refreshColorUI(e) {
                var dist = this.getCaculatedDist(e);

                this.setColorUI(dist / 100 * this.maxValue);

                this.changeColor({
                    type: 'hsv',
                    v: dist / 100 * this.maxValue
                });
            }
        }]);
        return Value;
    }(BaseSlider);

    var Opacity = function (_BaseSlider) {
        inherits(Opacity, _BaseSlider);

        function Opacity(opt) {
            classCallCheck(this, Opacity);

            var _this = possibleConstructorReturn(this, (Opacity.__proto__ || Object.getPrototypeOf(Opacity)).call(this, opt));

            _this.minValue = 0;
            _this.maxValue = 1;
            _this.source = 'opacity-control';
            return _this;
        }

        createClass(Opacity, [{
            key: 'template',
            value: function template() {
                return '\n        <div class="opacity">\n            <div ref="$container" class="opacity-container">\n                <div ref="$colorbar" class="color-bar"></div>\n                <div ref="$bar" class="drag-bar2"></div>\n            </div>\n        </div>\n        ';
            }
        }, {
            key: 'refresh',
            value: function refresh() {
                get(Opacity.prototype.__proto__ || Object.getPrototypeOf(Opacity.prototype), 'refresh', this).call(this);
                this.setOpacityColorBar();
            }
        }, {
            key: 'setOpacityColorBar',
            value: function setOpacityColorBar() {
                var rgb = Object.assign({}, this.$store.rgb);

                rgb.a = 0;
                var start = Color$1.format(rgb, 'rgb');

                rgb.a = 1;
                var end = Color$1.format(rgb, 'rgb');

                this.setOpacityColorBarBackground(start, end);
            }
        }, {
            key: 'setOpacityColorBarBackground',
            value: function setOpacityColorBarBackground(start, end) {
                this.refs.$colorbar.css('background', 'linear-gradient(to right, ' + start + ', ' + end + ')');
            }
        }, {
            key: 'getDefaultValue',
            value: function getDefaultValue() {
                return this.$store.alpha;
            }
        }, {
            key: 'refreshColorUI',
            value: function refreshColorUI(e) {
                var dist = this.getCaculatedDist(e);

                this.setColorUI(dist / 100 * this.maxValue);

                this.changeColor({
                    a: Math.floor(dist) / 100 * this.maxValue
                });
            }
        }]);
        return Opacity;
    }(BaseSlider);

    var source = 'macos-control';

    var ColorControl = function (_UIElement) {
        inherits(ColorControl, _UIElement);

        function ColorControl() {
            classCallCheck(this, ColorControl);
            return possibleConstructorReturn(this, (ColorControl.__proto__ || Object.getPrototypeOf(ColorControl)).apply(this, arguments));
        }

        createClass(ColorControl, [{
            key: 'components',
            value: function components() {
                return { Value: Value, Opacity: Opacity };
            }
        }, {
            key: 'template',
            value: function template() {
                return '\n        <div class="control">\n            <div target="Value" ></div>\n            <div target="Opacity" ></div>\n            <div ref="$controlPattern" class="empty"></div>\n            <div ref="$controlColor" class="color"></div>\n        </div>\n        ';
            }
        }, {
            key: 'setBackgroundColor',
            value: function setBackgroundColor() {
                this.refs.$controlColor.css("background-color", this.$store.dispatch('/toRGB'));
            }
        }, {
            key: 'refresh',
            value: function refresh() {
                this.setColorUI();
                this.setBackgroundColor();
            }
        }, {
            key: 'setColorUI',
            value: function setColorUI() {
                this.Value.setColorUI();
                this.Opacity.setColorUI();
            }
        }, {
            key: '@changeColor',
            value: function changeColor(sourceType) {
                if (source != sourceType) {
                    this.refresh();
                }
            }
        }, {
            key: '@initColor',
            value: function initColor() {
                this.refresh();
            }
        }]);
        return ColorControl;
    }(UIElement);

    var ColorWheel = function (_UIElement) {
        inherits(ColorWheel, _UIElement);

        function ColorWheel(opt) {
            classCallCheck(this, ColorWheel);

            var _this = possibleConstructorReturn(this, (ColorWheel.__proto__ || Object.getPrototypeOf(ColorWheel)).call(this, opt));

            _this.width = 214;
            _this.height = 214;
            _this.thinkness = 0;
            _this.half_thinkness = 0;
            _this.source = 'colorwheel';
            return _this;
        }

        createClass(ColorWheel, [{
            key: 'template',
            value: function template() {
                return '\n        <div class="wheel">\n            <canvas class="wheel-canvas" ref="$colorwheel" ></canvas>\n            <div class="wheel-canvas" ref="$valuewheel" ></div>\n            <div class="drag-pointer" ref="$drag_pointer"></div>\n        </div>\n        ';
            }
        }, {
            key: 'refresh',
            value: function refresh(isEvent) {
                this.setColorUI(isEvent);
            }
        }, {
            key: 'setColorUI',
            value: function setColorUI(isEvent) {
                this.renderCanvas();
                this.renderValue();
                this.setHueColor(null, isEvent);
            }
        }, {
            key: 'renderValue',
            value: function renderValue() {
                var value = 1 - this.$store.hsv.v;
                this.refs.$valuewheel.css({
                    'background-color': 'rgba(0, 0, 0, ' + value + ')'
                });
            }
        }, {
            key: 'renderWheel',
            value: function renderWheel(width, height) {

                if (this.width && !width) width = this.width;
                if (this.height && !height) height = this.height;

                var $canvas = new Dom('canvas');
                var context = $canvas.el.getContext('2d');
                $canvas.el.width = width;
                $canvas.el.height = height;
                $canvas.css({ width: width + 'px', height: height + 'px' });

                var img = context.getImageData(0, 0, width, height);
                var pixels = img.data;
                var half_width = Math.floor(width / 2);
                var half_height = Math.floor(height / 2);

                var radius = width > height ? half_height : half_width;
                var cx = half_width;
                var cy = half_height;

                for (var y = 0; y < height; y++) {
                    for (var x = 0; x < width; x++) {
                        var rx = x - cx + 1,
                            ry = y - cy + 1,
                            d = rx * rx + ry * ry,
                            hue = caculateAngle(rx, ry);

                        var rgb = Color$1.HSVtoRGB(hue, // 0~360 hue
                        Math.min(Math.sqrt(d) / radius, 1), // 0..1 Saturation
                        1 //  0..1 Value
                        );

                        var index = (y * width + x) * 4;
                        pixels[index] = rgb.r;
                        pixels[index + 1] = rgb.g;
                        pixels[index + 2] = rgb.b;
                        pixels[index + 3] = 255;
                    }
                }

                context.putImageData(img, 0, 0);

                if (this.thinkness > 0) {
                    context.globalCompositeOperation = "destination-out"; // destination-out    .
                    context.fillStyle = 'black';
                    context.beginPath();
                    context.arc(cx, cy, radius - this.thinkness, 0, Math.PI * 2);
                    context.closePath();
                    context.fill();
                }

                return $canvas;
            }
        }, {
            key: 'renderCanvas',
            value: function renderCanvas() {

                // only once rendering
                if (this.$store.createdWheelCanvas) return;

                var $canvas = this.refs.$colorwheel;
                // console.log($canvas);
                var context = $canvas.el.getContext('2d');

                var _$canvas$size = $canvas.size(),
                    _$canvas$size2 = slicedToArray(_$canvas$size, 2),
                    width = _$canvas$size2[0],
                    height = _$canvas$size2[1];

                if (this.width && !width) width = this.width;
                if (this.height && !height) height = this.height;

                $canvas.el.width = width;
                $canvas.el.height = height;
                $canvas.css({ width: width + 'px', height: height + 'px' });

                var $wheelCanvas = this.renderWheel(width, height);

                context.drawImage($wheelCanvas.el, 0, 0);

                this.$store.createdWheelCanvas = true;
            }
        }, {
            key: 'getDefaultValue',
            value: function getDefaultValue() {
                return this.$store.hsv.h;
            }
        }, {
            key: 'getDefaultSaturation',
            value: function getDefaultSaturation() {
                return this.$store.hsv.s;
            }
        }, {
            key: 'getCurrentXY',
            value: function getCurrentXY(e, angle, radius, centerX, centerY) {
                return e ? Event.posXY(e) : getXYInCircle(angle, radius, centerX, centerY);
            }
        }, {
            key: 'getRectangle',
            value: function getRectangle() {
                var width = this.state.get('$el.width');
                var height = this.state.get('$el.height');
                var radius = this.state.get('$colorwheel.width') / 2;

                var minX = this.refs.$el.offset().left;
                var centerX = minX + width / 2;

                var minY = this.refs.$el.offset().top;
                var centerY = minY + height / 2;

                return { minX: minX, minY: minY, width: width, height: height, radius: radius, centerX: centerX, centerY: centerY };
            }
        }, {
            key: 'setHueColor',
            value: function setHueColor(e, isEvent) {

                if (!this.state.get('$el.width')) return;

                var _getRectangle = this.getRectangle(),
                    minX = _getRectangle.minX,
                    minY = _getRectangle.minY,
                    radius = _getRectangle.radius,
                    centerX = _getRectangle.centerX,
                    centerY = _getRectangle.centerY;

                var _getCurrentXY = this.getCurrentXY(e, this.getDefaultValue(), this.getDefaultSaturation() * radius, centerX, centerY),
                    x = _getCurrentXY.x,
                    y = _getCurrentXY.y;

                var rx = x - centerX,
                    ry = y - centerY,
                    d = rx * rx + ry * ry,
                    hue = caculateAngle(rx, ry);

                if (d > radius * radius) {
                    var _getCurrentXY2 = this.getCurrentXY(null, hue, radius, centerX, centerY),
                        x = _getCurrentXY2.x,
                        y = _getCurrentXY2.y;
                }

                // saturation 
                var saturation = Math.min(Math.sqrt(d) / radius, 1);

                // set drag pointer position
                this.refs.$drag_pointer.css({
                    left: x - minX + 'px',
                    top: y - minY + 'px'
                });

                if (!isEvent) {
                    this.changeColor({
                        type: 'hsv',
                        h: hue,
                        s: saturation
                    });
                }
            }
        }, {
            key: 'changeColor',
            value: function changeColor(opt) {
                this.$store.dispatch('/changeColor', Object.assign({
                    source: this.source
                }, opt || {}));
            }
        }, {
            key: '@changeColor',
            value: function changeColor(sourceType) {
                if (this.source != sourceType) {
                    this.refresh(true);
                }
            }
        }, {
            key: '@initColor',
            value: function initColor() {
                this.refresh(true);
            }

            // Event Bindings

        }, {
            key: 'mouseup document',
            value: function mouseupDocument(e) {
                if (this.isDown) {
                    this.isDown = false;
                    this.$store.emit('lastUpdateColor');
                }
            }
        }, {
            key: 'mousemove document',
            value: function mousemoveDocument(e) {
                if (this.isDown) {
                    this.setHueColor(e);
                }
            }
        }, {
            key: 'mousedown $drag_pointer',
            value: function mousedown$drag_pointer(e) {
                e.preventDefault();
                this.isDown = true;
            }
        }, {
            key: 'mousedown $el',
            value: function mousedown$el(e) {
                this.isDown = true;
                this.setHueColor(e);
            }
        }, {
            key: 'touchend document',
            value: function touchendDocument(e) {
                if (this.isDown) {
                    this.isDown = false;
                    this.$store.emit('lastUpdateColor');
                }
            }
        }, {
            key: 'touchmove document',
            value: function touchmoveDocument(e) {
                if (this.isDown) {
                    this.setHueColor(e);
                }
            }
        }, {
            key: 'touchstart $drag_pointer',
            value: function touchstart$drag_pointer(e) {
                e.preventDefault();
                this.isDown = true;
            }
        }, {
            key: 'touchstart $el',
            value: function touchstart$el(e) {
                e.preventDefault();
                this.isDown = true;
                this.setHueColor(e);
            }
        }]);
        return ColorWheel;
    }(UIElement);

    var source$2 = 'chromedevtool-information';

    var ColorInformation = function (_UIElement) {
        inherits(ColorInformation, _UIElement);

        function ColorInformation() {
            classCallCheck(this, ColorInformation);
            return possibleConstructorReturn(this, (ColorInformation.__proto__ || Object.getPrototypeOf(ColorInformation)).apply(this, arguments));
        }

        createClass(ColorInformation, [{
            key: 'template',
            value: function template() {
                return (/*html*/'\n        <div class="information hex">\n            <div ref="$informationChange" class="information-change">\n                <button ref="$formatChangeButton" type="button" class="format-change-button arrow-button"></button>\n            </div>\n            <div class="information-item hex">\n                <div class="input-field hex">\n                    <input ref="$hexCode" class="input" type="text" />\n                    <div class="title">HEX</div>\n                </div>\n            </div>\n            <div class="information-item rgb">\n                <div class="input-field rgb-r">\n                    <input ref="$rgb_r" class="input" type="number" step="1" min="0" max="255" />\n                    <div class="title">R</div>\n                </div>\n                <div class="input-field rgb-g">\n                    <input ref="$rgb_g" class="input" type="number" step="1" min="0" max="255" />\n                    <div class="title">G</div>\n                </div>\n                <div class="input-field rgb-b">\n                    <input ref="$rgb_b" class="input" type="number" step="1" min="0" max="255" />\n                    <div class="title">B</div>\n                </div>          \n                <div class="input-field rgb-a">\n                    <input ref="$rgb_a" class="input" type="number" step="0.01" min="0" max="1" />\n                    <div class="title">A</div>\n                </div>                                                            \n            </div>\n            <div class="information-item hsl">\n                <div class="input-field hsl-h">\n                    <input ref="$hsl_h" class="input" type="number" step="1" min="0" max="360" />\n                    <div class="title">H</div>\n                </div>\n                <div class="input-field hsl-s">\n                    <input ref="$hsl_s" class="input" type="number" step="1" min="0" max="100" />\n                    <div class="postfix">%</div>\n                    <div class="title">S</div>\n                </div>\n                <div class="input-field hsl-l">\n                    <input ref="$hsl_l" class="input" type="number" step="1" min="0" max="100" />\n                    <div class="postfix">%</div>                        \n                    <div class="title">L</div>\n                </div>\n                <div class="input-field hsl-a">\n                    <input ref="$hsl_a" class="input" type="number" step="0.01" min="0" max="1" />\n                    <div class="title">A</div>\n                </div>\n            </div>\n        </div>\n        '
                );
            }
        }, {
            key: 'setCurrentFormat',
            value: function setCurrentFormat(format) {
                this.format = format;

                this.initFormat();
            }
        }, {
            key: 'initFormat',
            value: function initFormat() {
                var _this2 = this;

                var current_format = this.format || 'hex';

                ['hex', 'rgb', 'hsl'].filter(function (it) {
                    return it !== current_format;
                }).forEach(function (formatString) {
                    _this2.$el.removeClass(formatString);
                });

                this.$el.addClass(current_format);
            }
        }, {
            key: 'nextFormat',
            value: function nextFormat() {
                var current_format = this.format || 'hex';

                var next_format = 'hex';
                if (current_format == 'hex') {
                    next_format = 'rgb';
                } else if (current_format == 'rgb') {
                    next_format = 'hsl';
                } else if (current_format == 'hsl') {
                    next_format = 'hex';
                }

                this.format = next_format;
                this.initFormat();

                this.$store.dispatch('/changeFormat', this.format);
                this.$store.emit('lastUpdateColor');
            }
        }, {
            key: 'goToFormat',
            value: function goToFormat(to_format) {
                this.format = to_format;
                if (to_format === 'rgb' || to_format === 'hsl') {
                    this.initFormat();
                }

                this.$store.dispatch('/changeFormat', this.format);
            }
        }, {
            key: 'getFormat',
            value: function getFormat() {
                return this.format || 'hex';
            }
        }, {
            key: 'checkNumberKey',
            value: function checkNumberKey(e) {
                var code = e.which,
                    isExcept = false;

                if (code == 37 || code == 39 || code == 8 || code == 46 || code == 9) isExcept = true;

                if (!isExcept && (code < 48 || code > 57)) return false;

                return true;
            }
        }, {
            key: 'checkNotNumberKey',
            value: function checkNotNumberKey(e) {
                return !this.checkNumberKey(e);
            }
        }, {
            key: 'changeRgbColor',
            value: function changeRgbColor() {
                this.$store.dispatch('/changeColor', {
                    type: 'rgb',
                    r: this.refs.$rgb_r.int(),
                    g: this.refs.$rgb_g.int(),
                    b: this.refs.$rgb_b.int(),
                    a: this.refs.$rgb_a.float(),
                    source: source$2
                });
                this.$store.emit('lastUpdateColor');
            }
        }, {
            key: 'changeHslColor',
            value: function changeHslColor() {
                this.$store.dispatch('/changeColor', {
                    type: 'hsl',
                    h: this.refs.$hsl_h.int(),
                    s: this.refs.$hsl_s.int(),
                    l: this.refs.$hsl_l.int(),
                    a: this.refs.$hsl_a.float(),
                    source: source$2
                });
                this.$store.emit('lastUpdateColor');
            }
        }, {
            key: '@changeColor',
            value: function changeColor(sourceType) {
                if (source$2 != sourceType) {
                    this.refresh();
                }
            }
        }, {
            key: '@initColor',
            value: function initColor() {
                this.refresh();
            }
        }, {
            key: 'input $rgb_r',
            value: function input$rgb_r(e) {
                this.changeRgbColor();
            }
        }, {
            key: 'input $rgb_g',
            value: function input$rgb_g(e) {
                this.changeRgbColor();
            }
        }, {
            key: 'input $rgb_b',
            value: function input$rgb_b(e) {
                this.changeRgbColor();
            }
        }, {
            key: 'input $rgb_a',
            value: function input$rgb_a(e) {
                this.changeRgbColor();
            }
        }, {
            key: 'input $hsl_h',
            value: function input$hsl_h(e) {
                this.changeHslColor();
            }
        }, {
            key: 'input $hsl_s',
            value: function input$hsl_s(e) {
                this.changeHslColor();
            }
        }, {
            key: 'input $hsl_l',
            value: function input$hsl_l(e) {
                this.changeHslColor();
            }
        }, {
            key: 'input $hsl_a',
            value: function input$hsl_a(e) {
                this.changeHslColor();
            }
        }, {
            key: 'keyup $hexCode',
            value: function keyup$hexCode(e) {
                var code = this.refs.$hexCode.val();

                if (code.charAt(0) == '#' && (code.length == 7 || code.length === 9)) {
                    this.$store.dispatch('/changeColor', code, source$2);
                    this.$store.emit('lastUpdateColor');
                }
            }
        }, {
            key: 'click $formatChangeButton',
            value: function click$formatChangeButton(e) {
                this.nextFormat();
            }
        }, {
            key: 'click $el .information-item.hex .input-field .title',
            value: function click$elInformationItemHexInputFieldTitle(e) {
                this.goToFormat('hex');
            }
        }, {
            key: 'click $el .information-item.rgb .input-field .title',
            value: function click$elInformationItemRgbInputFieldTitle(e) {
                this.goToFormat('hsl');
            }
        }, {
            key: 'click $el .information-item.hsl .input-field .title',
            value: function click$elInformationItemHslInputFieldTitle(e) {
                this.goToFormat('rgb');
            }
        }, {
            key: 'setRGBInput',
            value: function setRGBInput() {
                this.refs.$rgb_r.val(this.$store.rgb.r);
                this.refs.$rgb_g.val(this.$store.rgb.g);
                this.refs.$rgb_b.val(this.$store.rgb.b);
                this.refs.$rgb_a.val(this.$store.alpha);
            }
        }, {
            key: 'setHSLInput',
            value: function setHSLInput() {
                this.refs.$hsl_h.val(this.$store.hsl.h);
                this.refs.$hsl_s.val(this.$store.hsl.s);
                this.refs.$hsl_l.val(this.$store.hsl.l);
                this.refs.$hsl_a.val(this.$store.alpha);
            }
        }, {
            key: 'setHexInput',
            value: function setHexInput() {
                this.refs.$hexCode.val(this.$store.dispatch('/toHEX'));
            }
        }, {
            key: 'refresh',
            value: function refresh() {
                this.setCurrentFormat(this.$store.format);
                this.setRGBInput();
                this.setHSLInput();
                this.setHexInput();
            }
        }]);
        return ColorInformation;
    }(UIElement);

    var DATA_COLORSETS_INDEX = 'data-colorsets-index';

    var ColorSetsChooser = function (_UIElement) {
        inherits(ColorSetsChooser, _UIElement);

        function ColorSetsChooser() {
            classCallCheck(this, ColorSetsChooser);
            return possibleConstructorReturn(this, (ColorSetsChooser.__proto__ || Object.getPrototypeOf(ColorSetsChooser)).apply(this, arguments));
        }

        createClass(ColorSetsChooser, [{
            key: 'template',
            value: function template() {
                return '\n            <div class="color-chooser">\n                <div class="color-chooser-container">\n                    <div class="colorsets-item colorsets-item-header">\n                        <h1 class="title">Color Palettes</h1>\n                        <span ref="$toggleButton" class="items">&times;</span>\n                    </div>\n                    <div ref="$colorsetsList" class="colorsets-list"></div>\n                </div>\n            </div>\n        ';
            }
        }, {
            key: 'refresh',
            value: function refresh() {
                this.load();
            }
        }, {
            key: '@changeCurrentColorSets',
            value: function changeCurrentColorSets() {
                this.refresh();
            }
        }, {
            key: '@toggleColorChooser',
            value: function toggleColorChooser() {
                this.toggle();
            }

            // loadable

        }, {
            key: 'load $colorsetsList',
            value: function load$colorsetsList() {
                // colorsets
                var colorSets = this.$store.dispatch('/getColorSetsList');

                return '\n            <div>\n                ' + colorSets.map(function (element, index) {
                    return '\n                        <div class="colorsets-item" data-colorsets-index="' + index + '" >\n                            <h1 class="title">' + element.name + '</h1>\n                            <div class="items">\n                                <div>\n                                    ' + element.colors.filter(function (color, i) {
                        return i < 5;
                    }).map(function (color) {
                        color = color || 'rgba(255, 255, 255, 1)';
                        return '<div class="color-item" title="' + color + '">\n                                                <div class="color-view" style="background-color: ' + color + '"></div>\n                                            </div>';
                    }).join('') + '\n                                </div>\n                            </div>\n                        </div>';
                }).join('') + '\n            </div>\n        ';
            }
        }, {
            key: 'show',
            value: function show() {
                this.$el.addClass('open');
            }
        }, {
            key: 'hide',
            value: function hide() {
                this.$el.removeClass('open');
            }
        }, {
            key: 'toggle',
            value: function toggle() {
                this.$el.toggleClass('open');
            }
        }, {
            key: 'click $toggleButton',
            value: function click$toggleButton(e) {
                this.toggle();
            }
        }, {
            key: 'click $colorsetsList .colorsets-item',
            value: function click$colorsetsListColorsetsItem(e) {
                var $item = e.$delegateTarget;

                if ($item) {

                    var index = parseInt($item.attr(DATA_COLORSETS_INDEX));

                    this.$store.dispatch('/setCurrentColorSets', index);

                    this.hide();
                }
            }
        }, {
            key: 'destroy',
            value: function destroy() {
                get(ColorSetsChooser.prototype.__proto__ || Object.getPrototypeOf(ColorSetsChooser.prototype), 'destroy', this).call(this);

                this.hide();
            }
        }]);
        return ColorSetsChooser;
    }(UIElement);

    var CurrentColorSets = function (_UIElement) {
        inherits(CurrentColorSets, _UIElement);

        function CurrentColorSets() {
            classCallCheck(this, CurrentColorSets);
            return possibleConstructorReturn(this, (CurrentColorSets.__proto__ || Object.getPrototypeOf(CurrentColorSets)).apply(this, arguments));
        }

        createClass(CurrentColorSets, [{
            key: 'template',
            value: function template() {
                return '\n            <div class="colorsets">\n                <div class="menu" title="Open Color Palettes">\n                    <button ref="$colorSetsChooseButton" type="button" class="color-sets-choose-btn arrow-button"></button>\n                </div>\n                <div ref="$colorSetsColorList" class="color-list"></div>\n            </div>\n        ';
            }
        }, {
            key: 'load $colorSetsColorList',
            value: function load$colorSetsColorList() {
                var currentColorSets = this.$store.dispatch('/getCurrentColorSets');
                var colors = this.$store.dispatch('/getCurrentColors');

                return '\n            <div>\n                <h6>' + currentColorSets.name + '</h6>\n                <div class="current-color-sets">\n                ' + colors.map(function (color, i) {
                    return '<div class="color-item" title="' + color + '" data-index="' + i + '" data-color="' + color + '">\n                        <div class="empty"></div>\n                        <div class="color-view" style="background-color: ' + color + '"></div>\n                    </div>';
                }).join('') + '   \n                ' + (currentColorSets.edit ? '<div class="add-color-item">+</div>' : '') + '         \n                </div>\n            </div>\n            \n        ';
            }
        }, {
            key: 'refresh',
            value: function refresh() {
                this.load();
            }
        }, {
            key: 'addColor',
            value: function addColor(color) {
                this.$store.dispatch('/addCurrentColor', color);
            }
        }, {
            key: '@changeCurrentColorSets',
            value: function changeCurrentColorSets() {
                this.refresh();
            }
        }, {
            key: 'click $colorSetsChooseButton',
            value: function click$colorSetsChooseButton(e) {
                this.$store.emit('toggleColorChooser');
            }
        }, {
            key: 'contextmenu $colorSetsColorList',
            value: function contextmenu$colorSetsColorList(e) {
                e.preventDefault();
                var currentColorSets = this.$store.dispatch('/getCurrentColorSets');

                if (!currentColorSets.edit) {
                    return;
                }

                var $target = new Dom(e.target);

                var $item = $target.closest('color-item');

                if ($item) {
                    var index = parseInt($item.attr('data-index'));

                    this.$store.emit('showContextMenu', e, index);
                } else {
                    this.$store.emit('showContextMenu', e);
                }
            }
        }, {
            key: 'click $colorSetsColorList .add-color-item',
            value: function click$colorSetsColorListAddColorItem(e) {
                this.addColor(this.$store.dispatch('/toColor'));
            }
        }, {
            key: 'click $colorSetsColorList .color-item',
            value: function click$colorSetsColorListColorItem(e) {
                this.$store.dispatch('/changeColor', e.$delegateTarget.attr('data-color'));
                this.$store.emit('lastUpdateColor');
            }
        }]);
        return CurrentColorSets;
    }(UIElement);

    var CurrentColorSetsContextMenu = function (_UIElement) {
        inherits(CurrentColorSetsContextMenu, _UIElement);

        function CurrentColorSetsContextMenu() {
            classCallCheck(this, CurrentColorSetsContextMenu);
            return possibleConstructorReturn(this, (CurrentColorSetsContextMenu.__proto__ || Object.getPrototypeOf(CurrentColorSetsContextMenu)).apply(this, arguments));
        }

        createClass(CurrentColorSetsContextMenu, [{
            key: 'template',
            value: function template() {
                return '\n            <ul class="colorsets-contextmenu">\n                <li class="menu-item small-hide" data-type="remove-color">Remove color</li>\n                <li class="menu-item small-hide" data-type="remove-all-to-the-right">Remove all to the right</li>\n                <li class="menu-item" data-type="clear-palette">Clear palette</li>\n            </ul>\n        ';
            }
        }, {
            key: 'show',
            value: function show(e, index) {
                var $event = Event.pos(e);

                this.$el.css({
                    top: $event.clientY - 10 + 'px',
                    left: $event.clientX + 'px'
                });
                this.$el.addClass('show');
                this.selectedColorIndex = index;

                if (typeof this.selectedColorIndex == 'undefined') {
                    this.$el.addClass('small');
                } else {
                    this.$el.removeClass('small');
                }
            }
        }, {
            key: 'hide',
            value: function hide() {
                this.$el.removeClass('show');
            }
        }, {
            key: 'runCommand',
            value: function runCommand(command) {
                switch (command) {
                    case 'remove-color':
                        this.$store.dispatch('/removeCurrentColor', this.selectedColorIndex);
                        break;
                    case 'remove-all-to-the-right':
                        this.$store.dispatch('/removeCurrentColorToTheRight', this.selectedColorIndex);
                        break;
                    case 'clear-palette':
                        this.$store.dispatch('/clearPalette');
                        break;
                }
            }
        }, {
            key: '@showContextMenu',
            value: function showContextMenu(e, index) {
                this.show(e, index);
            }
        }, {
            key: 'click $el .menu-item',
            value: function click$elMenuItem(e) {
                e.preventDefault();

                this.runCommand(e.$delegateTarget.attr('data-type'));
                this.hide();
            }
        }]);
        return CurrentColorSetsContextMenu;
    }(UIElement);

    var MacOSColorPicker = function (_BaseColorPicker) {
        inherits(MacOSColorPicker, _BaseColorPicker);

        function MacOSColorPicker() {
            classCallCheck(this, MacOSColorPicker);
            return possibleConstructorReturn(this, (MacOSColorPicker.__proto__ || Object.getPrototypeOf(MacOSColorPicker)).apply(this, arguments));
        }

        createClass(MacOSColorPicker, [{
            key: 'template',
            value: function template() {
                return '\n            <div class=\'colorpicker-body\'>\n                <div target="colorwheel"></div>\n                <div target="control"></div>\n                <div target="information"></div>\n                <div target="currentColorSets"></div>\n                <div target="colorSetsChooser"></div>\n                <div target="contextMenu"></div>                \n            </div>\n        ';
            }
        }, {
            key: 'components',
            value: function components() {
                return {
                    colorwheel: ColorWheel,
                    control: ColorControl,
                    information: ColorInformation,
                    currentColorSets: CurrentColorSets,
                    colorSetsChooser: ColorSetsChooser,
                    contextMenu: CurrentColorSetsContextMenu
                };
            }
        }]);
        return MacOSColorPicker;
    }(BaseColorPicker);

    var Hue = function (_BaseSlider) {
        inherits(Hue, _BaseSlider);

        function Hue(opt) {
            classCallCheck(this, Hue);

            var _this = possibleConstructorReturn(this, (Hue.__proto__ || Object.getPrototypeOf(Hue)).call(this, opt));

            _this.minValue = 0;
            _this.maxValue = 360;
            _this.source = 'hue-control';
            return _this;
        }

        createClass(Hue, [{
            key: 'template',
            value: function template() {
                return (/*html*/'\n            <div class="hue"> \n                <div ref="$container" class="hue-container">\n                    <div ref="$bar" class="drag-bar"></div>\n                </div>\n            </div>\n        '
                );
            }
        }, {
            key: 'getDefaultValue',
            value: function getDefaultValue() {
                return this.$store.hsv.h;
            }
        }, {
            key: 'refreshColorUI',
            value: function refreshColorUI(e) {

                var dist = this.getCaculatedDist(e);

                var isDifferent = this.setColorUI(dist / 100 * this.maxValue);

                if (isDifferent !== true) {
                    this.changeColor({
                        h: dist / 100 * this.maxValue,
                        type: 'hsv'
                    });
                }
            }
        }]);
        return Hue;
    }(BaseSlider);

    var HueScale = function (_BaseSlider) {
        inherits(HueScale, _BaseSlider);

        function HueScale() {
            classCallCheck(this, HueScale);
            return possibleConstructorReturn(this, (HueScale.__proto__ || Object.getPrototypeOf(HueScale)).apply(this, arguments));
        }

        createClass(HueScale, [{
            key: "initialize",
            value: function initialize() {
                get(HueScale.prototype.__proto__ || Object.getPrototypeOf(HueScale.prototype), "initialize", this).call(this);
                this.minValue = 0;
                this.maxValue = 360;
                this.hueScaleDist = 0.05;
            }
        }, {
            key: "template",
            value: function template() {
                return (/*html*/"\n            <div class=\"hue-scale\">\n                <div ref=\"$container\" class=\"hue-scale-container\">\n                    <div ref=\"$bar\" class=\"drag-bar\"></div>\n                </div>\n            </div>\n        "
                );
            }
        }, {
            key: "getDefaultValue",
            value: function getDefaultValue() {
                return this.$store.hsv.h;
            }

            /** get calculated dist for domain value   */

        }, {
            key: "getCalculatedDist",
            value: function getCalculatedDist(e) {
                var current = e ? this.getMousePosition(e) : this.getCurrent(this.getDefaultValue() / this.maxValue);
                var dist = this.getDist(current);

                return dist;
            }
        }, {
            key: "refreshColorUI",
            value: function refreshColorUI(e) {

                var dist = this.getCalculatedDist(e);

                var isDifferent = this.setColorUI(dist / 100);

                // hue     changeColor   .
                if (isDifferent !== true) {
                    this.changeColor({
                        h: (this.minValue + this.fullDist * (dist / 100)) * 360,
                        type: 'hsv'
                    });
                }
            }
        }, {
            key: "setColorUI",
            value: function setColorUI(v) {
                var p = void 0;

                if (v) {
                    p = this.minValue + v * this.fullDist;

                    if (this.lastP === p) return true;

                    this.lastP = p;
                } else {

                    p = this.getDefaultValue() / 360;

                    if (this.lastP === p) return true;

                    this.lastP = p;

                    var maxP = p + 0.05;
                    var minP = p - 0.05;

                    if (maxP > 1) {
                        maxP = 1;
                        minP = 1 - this.hueScaleDist * 2;
                    } else if (minP < 0) {
                        var _dist = Math.abs(minP);
                        minP = 0;
                        maxP = maxP + _dist;
                    }

                    var list = HueColor.getHueScale(p, minP, maxP);

                    // console.log(list, p, minP, maxP);

                    this.list = list;

                    var minValue = list[0].start;
                    var maxValue = list[list.length - 1].start;

                    this.minValue = minValue;
                    this.maxValue = maxValue;

                    var fullDist = this.maxValue - this.minValue;
                    this.fullDist = fullDist;

                    var colorsteps = list.map(function (it) {
                        return {
                            color: it.rgb,
                            percent: (it.start - minValue) / fullDist * 100,
                            unit: '%'
                        };
                    });

                    // console.log(colorsteps);

                    this.refs.$container.css('background-image', "linear-gradient(to right, " + colorsteps.map(function (it) {
                        return it.color + " " + it.percent + it.unit;
                    }).join(',') + ")");
                }

                if (p <= this.minValue) {
                    p = this.minValue;
                    this.refs.$bar.addClass('first').removeClass('last');
                } else if (p >= this.maxValue) {
                    p = this.maxValue;
                    this.refs.$bar.addClass('last').removeClass('first');
                } else {
                    this.refs.$bar.removeClass('last').removeClass('first');
                }

                this.setMousePosition(this.getMaxDist() * ((p - this.minValue) / this.fullDist));
            }
        }]);
        return HueScale;
    }(BaseSlider);

    var source$3 = 'chromedevtool-control';

    var ColorControl$2 = function (_UIElement) {
        inherits(ColorControl, _UIElement);

        function ColorControl() {
            classCallCheck(this, ColorControl);
            return possibleConstructorReturn(this, (ColorControl.__proto__ || Object.getPrototypeOf(ColorControl)).apply(this, arguments));
        }

        createClass(ColorControl, [{
            key: 'components',
            value: function components() {
                return { Hue: Hue, Opacity: Opacity, HueScale: HueScale };
            }
        }, {
            key: 'template',
            value: function template() {
                return '\n        <div class="control">\n            <div target="Hue" ></div>\n            <div target="HueScale" ></div>\n            <div target="Opacity" ></div>\n            <div ref="$controlPattern" class="empty"></div>\n            <div ref="$controlColor" class="color"></div>\n            <div ref="$controlPattern2" class="empty2"></div>\n            <div ref="$controlColor2" class="color2"></div>            \n        </div>\n        ';
            }
        }, {
            key: 'setBackgroundColor',
            value: function setBackgroundColor() {
                this.refs.$controlColor.css("background-color", this.$store.dispatch('/toRGB'));
            }
        }, {
            key: 'setLastUpdateColor',
            value: function setLastUpdateColor() {
                this.refs.$controlColor2.css("background-color", this.$store.dispatch('/toRGB'));
            }
        }, {
            key: 'refresh',
            value: function refresh() {
                this.setColorUI();
                this.setBackgroundColor();
            }
        }, {
            key: 'setColorUI',
            value: function setColorUI() {
                this.Hue.setColorUI();
                this.Opacity.setColorUI();
            }
        }, {
            key: '@changeColor',
            value: function changeColor(sourceType) {
                if (source$3 != sourceType) {
                    this.refresh();
                }
            }
        }, {
            key: '@lastUpdateColor',
            value: function lastUpdateColor(sourceType) {
                if (source$3 != sourceType) {
                    this.setLastUpdateColor();
                }
            }
        }, {
            key: '@initColor',
            value: function initColor() {
                this.refresh();
            }
        }]);
        return ColorControl;
    }(UIElement);

    var source$4 = 'chromedevtool-palette';

    var ColorPalette = function (_UIElement) {
        inherits(ColorPalette, _UIElement);

        function ColorPalette() {
            classCallCheck(this, ColorPalette);
            return possibleConstructorReturn(this, (ColorPalette.__proto__ || Object.getPrototypeOf(ColorPalette)).apply(this, arguments));
        }

        createClass(ColorPalette, [{
            key: 'template',
            value: function template() {
                return (/*html*/'\n        <div class="color">\n            <div ref="$saturation" class="saturation">\n                <div ref="$value" class="value">\n                    <div ref="$drag_pointer" class="drag-pointer" data-axis-value="all">\n                        <div ref="$left_saturation" class="left-saturation" data-axis-value="saturation"></div>\n                        <div ref="$right_saturation" class="right-saturation" data-axis-value="saturation"></div>\n                        <div ref="$top_value" class="top-value" data-axis-value="value"></div>\n                        <div ref="$bottom_value" class="bottom-value" data-axis-value="value"></div>\n                    </div>\n                </div>\n            </div>        \n        </div>        \n        '
                );
            }
        }, {
            key: 'setBackgroundColor',
            value: function setBackgroundColor(color) {
                this.$el.css("background-color", color);
            }
        }, {
            key: 'refresh',
            value: function refresh() {
                this.cacheSize();
                this.setColorUI();
            }
        }, {
            key: 'calculateSV',
            value: function calculateSV() {
                var pos = this.drag_pointer_pos || { x: 0, y: 0 };

                var width = this.state.get('$el.width');
                var height = this.state.get('$el.height');

                var s = pos.x / width;
                var v = (height - pos.y) / height;

                this.$store.dispatch('/changeColor', {
                    type: 'hsv',
                    s: s,
                    v: v,
                    source: source$4
                });
            }
        }, {
            key: 'setColorUI',
            value: function setColorUI() {
                var x = this.w * this.$store.hsv.s,
                    y = this.h * (1 - this.$store.hsv.v);

                this.refs.$drag_pointer.css({
                    left: x + "px",
                    top: y + "px"
                });

                this.drag_pointer_pos = { x: x, y: y };

                this.setBackgroundColor(this.$store.dispatch('/getHueColor'));
            }
        }, {
            key: 'setSubColor',
            value: function setSubColor(e) {
                var localX = e.pageX;
                var localY = e.pageY;

                var distX = localX - this.x;
                var distY = localY - this.y;

                var w = this.$el.contentWidth();
                var h = this.$el.contentHeight();

                var x = this.refs.$drag_pointer.cssFloat("left");
                var y = this.refs.$drag_pointer.cssFloat("top");

                if (this.axis === 'saturation') {
                    x += distX;
                } else if (this.axis === 'value') {
                    y += distY;
                }

                if (x < 0) x = 0;else if (x > w) x = w;

                if (y < 0) y = 0;else if (y > h) y = h;

                this.refs.$drag_pointer.px("left", x);
                this.refs.$drag_pointer.px("top", y);

                this.drag_pointer_pos = { x: x, y: y };

                this.x = localX;
                this.y = localY;

                this.calculateSV();
            }
        }, {
            key: 'setMainColor',
            value: function setMainColor(e) {
                // e.preventDefault();
                var pos = this.$el.offset(); // position for screen
                var w = this.w;
                var h = this.h;

                var x = Event.pos(e).pageX - pos.left;
                var y = Event.pos(e).pageY - pos.top;

                if (x < 0) x = 0;else if (x > w) x = w;

                if (y < 0) y = 0;else if (y > h) y = h;

                this.refs.$drag_pointer.css({
                    left: x + 'px',
                    top: y + 'px'
                });

                this.drag_pointer_pos = { x: x, y: y };

                this.calculateSV();
            }
        }, {
            key: '@changeColor',
            value: function changeColor(sourceType) {
                if (source$4 != sourceType) {
                    this.refresh();
                }
            }
        }, {
            key: '@initColor',
            value: function initColor() {
                this.refresh();
            }
        }, {
            key: 'mouseup document',
            value: function mouseupDocument(e) {
                if (this.isDown) {
                    this.isDown = false;
                    this.$store.emit('lastUpdateColor');
                }
            }
        }, {
            key: 'mousemove document',
            value: function mousemoveDocument(e) {
                if (this.isDown) {
                    this.cacheSize();
                    if (this.axis === 'saturation' || this.axis === 'value') {
                        this.setSubColor(e);
                    } else {
                        this.setMainColor(e);
                    }
                }
            }
        }, {
            key: 'mousedown',
            value: function mousedown(e) {
                this.isDown = true;
                this.cacheSize();
                this.axis = new Dom(e.target).attr('data-axis-value');
                this.x = e.pageX;
                this.y = e.pageY;

                if (this.axis === 'saturation' || this.axis === 'value') {
                    this.setSubColor(e);
                } else {
                    this.setMainColor(e);
                }
            }
        }, {
            key: 'touchend document',
            value: function touchendDocument(e) {
                if (this.isDown) {
                    this.isDown = false;
                    this.$store.emit('lastUpdateColor');
                }
            }
        }, {
            key: 'touchmove document',
            value: function touchmoveDocument(e) {
                if (this.isDown) {
                    this.setMainColor(e);
                }
            }
        }, {
            key: 'touchstart',
            value: function touchstart(e) {
                e.preventDefault();
                this.isDown = true;
                this.cacheSize();
                this.setMainColor(e);
            }
        }, {
            key: 'cacheSize',
            value: function cacheSize() {
                this.w = this.state.get('$el.contentWidth');
                this.h = this.state.get('$el.contentHeight');
            }
        }]);
        return ColorPalette;
    }(UIElement);

    var ChromeDevToolColorPicker = function (_BaseColorPicker) {
        inherits(ChromeDevToolColorPicker, _BaseColorPicker);

        function ChromeDevToolColorPicker() {
            classCallCheck(this, ChromeDevToolColorPicker);
            return possibleConstructorReturn(this, (ChromeDevToolColorPicker.__proto__ || Object.getPrototypeOf(ChromeDevToolColorPicker)).apply(this, arguments));
        }

        createClass(ChromeDevToolColorPicker, [{
            key: 'template',
            value: function template() {
                return '\n            <div class=\'colorpicker-body\'>\n                <div target="palette"></div> \n                <div target="control"></div>\n                <div target="information"></div>\n                <div target="currentColorSets"></div>\n                <div target="colorSetsChooser"></div>\n                <div target="contextMenu"></div>\n            </div>\n        ';
            }
        }, {
            key: 'components',
            value: function components() {
                return {
                    palette: ColorPalette,
                    control: ColorControl$2,
                    information: ColorInformation,
                    currentColorSets: CurrentColorSets,
                    colorSetsChooser: ColorSetsChooser,
                    contextMenu: CurrentColorSetsContextMenu
                };
            }
        }]);
        return ChromeDevToolColorPicker;
    }(BaseColorPicker);

    var source$5 = 'mini-control';

    var ColorControl$4 = function (_UIElement) {
        inherits(ColorControl, _UIElement);

        function ColorControl() {
            classCallCheck(this, ColorControl);
            return possibleConstructorReturn(this, (ColorControl.__proto__ || Object.getPrototypeOf(ColorControl)).apply(this, arguments));
        }

        createClass(ColorControl, [{
            key: 'components',
            value: function components() {
                return { Hue: Hue, Opacity: Opacity };
            }
        }, {
            key: 'template',
            value: function template() {
                return '\n        <div class="control">\n            <div target="Hue" ></div>\n            <div target="Opacity" ></div>\n        </div>\n        ';
            }
        }, {
            key: 'refresh',
            value: function refresh() {
                this.setColorUI();
            }
        }, {
            key: 'setColorUI',
            value: function setColorUI() {
                this.Hue.setColorUI();
                this.Opacity.setColorUI();
            }
        }, {
            key: '@changeColor',
            value: function changeColor(sourceType) {
                if (source$5 != sourceType) {
                    this.refresh();
                }
            }
        }, {
            key: '@initColor',
            value: function initColor() {
                this.refresh();
            }
        }]);
        return ColorControl;
    }(UIElement);

    var MiniColorPicker = function (_BaseColorPicker) {
        inherits(MiniColorPicker, _BaseColorPicker);

        function MiniColorPicker() {
            classCallCheck(this, MiniColorPicker);
            return possibleConstructorReturn(this, (MiniColorPicker.__proto__ || Object.getPrototypeOf(MiniColorPicker)).apply(this, arguments));
        }

        createClass(MiniColorPicker, [{
            key: 'template',
            value: function template() {
                return '\n            <div class=\'colorpicker-body\'>\n                <div target="palette"></div>\n                <div target="control"></div>\n            </div>\n        ';
            }
        }, {
            key: 'components',
            value: function components() {
                return {
                    palette: ColorPalette,
                    control: ColorControl$4
                };
            }
        }]);
        return MiniColorPicker;
    }(BaseColorPicker);

    var VerticalSlider = function (_BaseSlider) {
        inherits(VerticalSlider, _BaseSlider);

        function VerticalSlider(opt) {
            classCallCheck(this, VerticalSlider);

            var _this = possibleConstructorReturn(this, (VerticalSlider.__proto__ || Object.getPrototypeOf(VerticalSlider)).call(this, opt));

            _this.source = 'vertical-slider';
            return _this;
        }

        /** get max height for vertical slider */


        createClass(VerticalSlider, [{
            key: 'getMaxDist',
            value: function getMaxDist() {
                return this.state.get('$container.height');
            }

            /** set mouse pointer for vertical slider */

        }, {
            key: 'setMousePosition',
            value: function setMousePosition(y) {
                this.refs.$bar.css({ top: y + 'px' });
            }

            /** get mouse position by pageY for vertical slider */

        }, {
            key: 'getMousePosition',
            value: function getMousePosition(e) {
                return Event.pos(e).pageY;
            }

            /** get min position for vertial slider */

        }, {
            key: 'getMinPosition',
            value: function getMinPosition() {
                return this.refs.$container.offset().top;
            }

            /** get caculated dist for domain value   */

        }, {
            key: 'getCaculatedDist',
            value: function getCaculatedDist(e) {
                var current = e ? this.getMousePosition(e) : this.getCurrent(this.getDefaultValue() / this.maxValue);
                var dist = 100 - this.getDist(current);

                return dist;
            }

            /** set drag bar position  */

        }, {
            key: 'setColorUI',
            value: function setColorUI(v) {

                v = v || this.getDefaultValue();

                if (v <= this.minValue) {
                    this.refs.$bar.addClass('first').removeClass('last');
                } else if (v >= this.maxValue) {
                    this.refs.$bar.addClass('last').removeClass('first');
                } else {
                    this.refs.$bar.removeClass('last').removeClass('first');
                }

                var per = 1 - (v || 0) / this.maxValue;

                this.setMousePosition(this.getMaxDist() * per);
            }
        }]);
        return VerticalSlider;
    }(BaseSlider);

    var VerticalHue = function (_VerticalSlider) {
        inherits(VerticalHue, _VerticalSlider);

        function VerticalHue(opt) {
            classCallCheck(this, VerticalHue);

            var _this = possibleConstructorReturn(this, (VerticalHue.__proto__ || Object.getPrototypeOf(VerticalHue)).call(this, opt));

            _this.minValue = 0;
            _this.maxValue = 360;
            _this.source = 'vertical-hue-control';
            return _this;
        }

        createClass(VerticalHue, [{
            key: 'template',
            value: function template() {
                return '\n            <div class="hue">\n                <div ref="$container" class="hue-container">\n                    <div ref="$bar" class="drag-bar"></div>\n                </div>\n            </div>\n        ';
            }
        }, {
            key: 'getDefaultValue',
            value: function getDefaultValue() {
                return this.$store.hsv.h;
            }
        }, {
            key: 'refreshColorUI',
            value: function refreshColorUI(e) {

                var dist = this.getCaculatedDist(e);

                this.setColorUI(dist / 100 * this.maxValue);

                this.changeColor({
                    h: dist / 100 * this.maxValue,
                    type: 'hsv'
                });
            }
        }]);
        return VerticalHue;
    }(VerticalSlider);

    var Opacity$2 = function (_VerticalSlider) {
        inherits(Opacity, _VerticalSlider);

        function Opacity(opt) {
            classCallCheck(this, Opacity);

            var _this = possibleConstructorReturn(this, (Opacity.__proto__ || Object.getPrototypeOf(Opacity)).call(this, opt));

            _this.source = 'vertical-opacity-control';
            return _this;
        }

        createClass(Opacity, [{
            key: 'template',
            value: function template() {
                return '\n        <div class="opacity">\n            <div ref="$container" class="opacity-container">\n                <div ref="$colorbar" class="color-bar"></div>\n                <div ref="$bar" class="drag-bar2"></div>\n            </div>\n        </div>\n        ';
            }
        }, {
            key: 'refresh',
            value: function refresh() {
                get(Opacity.prototype.__proto__ || Object.getPrototypeOf(Opacity.prototype), 'refresh', this).call(this);
                this.setOpacityColorBar();
            }
        }, {
            key: 'setOpacityColorBar',
            value: function setOpacityColorBar() {
                var rgb = Object.assign({}, this.$store.rgb);

                rgb.a = 0;
                var start = Color$1.format(rgb, 'rgb');

                rgb.a = 1;
                var end = Color$1.format(rgb, 'rgb');

                this.refs.$colorbar.css('background', 'linear-gradient(to top, ' + start + ', ' + end + ')');
            }
        }, {
            key: 'getDefaultValue',
            value: function getDefaultValue() {
                return this.$store.alpha;
            }
        }, {
            key: 'refreshColorUI',
            value: function refreshColorUI(e) {
                var dist = this.getCaculatedDist(e);

                this.setColorUI(dist / 100 * this.maxValue);

                this.changeColor({
                    a: Math.floor(dist) / 100 * this.maxValue
                });
            }
        }]);
        return Opacity;
    }(VerticalSlider);

    var source$6 = 'mini-control';

    var ColorControl$6 = function (_UIElement) {
        inherits(ColorControl, _UIElement);

        function ColorControl() {
            classCallCheck(this, ColorControl);
            return possibleConstructorReturn(this, (ColorControl.__proto__ || Object.getPrototypeOf(ColorControl)).apply(this, arguments));
        }

        createClass(ColorControl, [{
            key: 'components',
            value: function components() {
                return { Hue: VerticalHue, Opacity: Opacity$2 };
            }
        }, {
            key: 'template',
            value: function template() {
                return '<div class="control"><div target="Hue" ></div><div target="Opacity" ></div></div>';
            }
        }, {
            key: 'refresh',
            value: function refresh() {
                this.setColorUI();
            }
        }, {
            key: 'setColorUI',
            value: function setColorUI() {
                this.Hue.setColorUI();
                this.Opacity.setColorUI();
            }
        }, {
            key: '@changeColor',
            value: function changeColor(sourceType) {
                if (source$6 != sourceType) {
                    this.refresh();
                }
            }
        }, {
            key: '@initColor',
            value: function initColor() {
                this.refresh();
            }
        }]);
        return ColorControl;
    }(UIElement);

    var MiniColorPicker$2 = function (_BaseColorPicker) {
        inherits(MiniColorPicker, _BaseColorPicker);

        function MiniColorPicker() {
            classCallCheck(this, MiniColorPicker);
            return possibleConstructorReturn(this, (MiniColorPicker.__proto__ || Object.getPrototypeOf(MiniColorPicker)).apply(this, arguments));
        }

        createClass(MiniColorPicker, [{
            key: 'template',
            value: function template() {
                return '\n            <div class=\'colorpicker-body\'>\n                <div target="palette"></div><div target="control"></div>\n            </div>\n        ';
            }
        }, {
            key: 'components',
            value: function components() {
                return {
                    palette: ColorPalette,
                    control: ColorControl$6
                };
            }
        }]);
        return MiniColorPicker;
    }(BaseColorPicker);

    var source$7 = 'macos-control';

    var ColorControl$8 = function (_UIElement) {
        inherits(ColorControl, _UIElement);

        function ColorControl() {
            classCallCheck(this, ColorControl);
            return possibleConstructorReturn(this, (ColorControl.__proto__ || Object.getPrototypeOf(ColorControl)).apply(this, arguments));
        }

        createClass(ColorControl, [{
            key: 'components',
            value: function components() {
                return { Value: Value, Opacity: Opacity };
            }
        }, {
            key: 'template',
            value: function template() {
                return '\n        <div class="control">\n            <div target="Value" ></div>\n            <div target="Opacity" ></div>\n            <div ref="$controlPattern" class="empty"></div>\n            <div ref="$controlColor" class="color"></div>\n        </div>\n        ';
            }
        }, {
            key: 'setBackgroundColor',
            value: function setBackgroundColor() {
                this.refs.$controlColor.css("background-color", this.$store.dispatch('/toRGB'));
            }
        }, {
            key: 'refresh',
            value: function refresh() {
                this.setColorUI();
                this.setBackgroundColor();
            }
        }, {
            key: 'setColorUI',
            value: function setColorUI() {
                this.Value.setColorUI();
                this.Opacity.setColorUI();
            }
        }, {
            key: '@changeColor',
            value: function changeColor(sourceType) {
                if (source$7 != sourceType) {
                    this.refresh();
                }
            }
        }, {
            key: '@initColor',
            value: function initColor() {
                this.refresh();
            }
        }]);
        return ColorControl;
    }(UIElement);

    var ColorRing = function (_ColorWheel) {
        inherits(ColorRing, _ColorWheel);

        function ColorRing(opt) {
            classCallCheck(this, ColorRing);

            var _this = possibleConstructorReturn(this, (ColorRing.__proto__ || Object.getPrototypeOf(ColorRing)).call(this, opt));

            _this.width = 214;
            _this.height = 214;
            _this.thinkness = 16;
            _this.half_thinkness = _this.thinkness / 2;
            _this.source = 'colorring';
            return _this;
        }

        createClass(ColorRing, [{
            key: 'template',
            value: function template() {
                return '\n        <div class="wheel" data-type="ring">\n            <canvas class="wheel-canvas" ref="$colorwheel" ></canvas>\n            <div class="drag-pointer" ref="$drag_pointer"></div>\n        </div>\n        ';
            }
        }, {
            key: 'setColorUI',
            value: function setColorUI(isEvent) {
                this.renderCanvas();
                this.setHueColor(null, isEvent);
            }
        }, {
            key: 'getDefaultValue',
            value: function getDefaultValue() {
                return this.$store.hsv.h;
            }
        }, {
            key: 'setHueColor',
            value: function setHueColor(e, isEvent) {

                if (!this.state.get('$el.width')) return;

                var _getRectangle = this.getRectangle(),
                    minX = _getRectangle.minX,
                    minY = _getRectangle.minY,
                    radius = _getRectangle.radius,
                    centerX = _getRectangle.centerX,
                    centerY = _getRectangle.centerY;

                var _getCurrentXY = this.getCurrentXY(e, this.getDefaultValue(), radius, centerX, centerY),
                    x = _getCurrentXY.x,
                    y = _getCurrentXY.y;

                var rx = x - centerX,
                    ry = y - centerY,
                    hue = caculateAngle(rx, ry);

                {
                    var _getCurrentXY2 = this.getCurrentXY(null, hue, radius - this.half_thinkness, centerX, centerY),
                        x = _getCurrentXY2.x,
                        y = _getCurrentXY2.y;
                }

                // set drag pointer position
                this.refs.$drag_pointer.css({
                    left: x - minX + 'px',
                    top: y - minY + 'px'
                });

                if (!isEvent) {
                    this.changeColor({
                        type: 'hsv',
                        h: hue
                    });
                }
            }
        }]);
        return ColorRing;
    }(ColorWheel);

    // import ColorWheel from '../ui/ColorWheel'
    var RingColorPicker = function (_BaseColorPicker) {
        inherits(RingColorPicker, _BaseColorPicker);

        function RingColorPicker() {
            classCallCheck(this, RingColorPicker);
            return possibleConstructorReturn(this, (RingColorPicker.__proto__ || Object.getPrototypeOf(RingColorPicker)).apply(this, arguments));
        }

        createClass(RingColorPicker, [{
            key: 'template',
            value: function template() {
                return '\n            <div class=\'colorpicker-body\'>\n                <div target="colorring"></div>\n                <div target="palette"></div> \n                <div target="control"></div>\n                <div target="information"></div>\n                <div target="currentColorSets"></div>\n                <div target="colorSetsChooser"></div>\n                <div target="contextMenu"></div>\n            </div>\n        ';
            }
        }, {
            key: 'components',
            value: function components() {
                return {
                    colorring: ColorRing,
                    palette: ColorPalette,
                    control: ColorControl$8,
                    information: ColorInformation,
                    currentColorSets: CurrentColorSets,
                    colorSetsChooser: ColorSetsChooser,
                    contextMenu: CurrentColorSetsContextMenu
                };
            }
        }]);
        return RingColorPicker;
    }(BaseColorPicker);

    var ColorControl$10 = function (_UIElement) {
        inherits(ColorControl, _UIElement);

        function ColorControl() {
            classCallCheck(this, ColorControl);
            return possibleConstructorReturn(this, (ColorControl.__proto__ || Object.getPrototypeOf(ColorControl)).apply(this, arguments));
        }

        createClass(ColorControl, [{
            key: 'components',
            value: function components() {
                return { Hue: VerticalHue, Opacity: Opacity$2 };
            }
        }, {
            key: 'template',
            value: function template() {
                return '\n        <div class="control">\n            <div target="Hue" ></div>\n            <div target="Opacity" ></div>\n        </div>\n        ';
            }
        }, {
            key: 'refresh',
            value: function refresh() {
                this.setColorUI();
            }
        }, {
            key: 'setColorUI',
            value: function setColorUI() {
                this.Hue.setColorUI();
                this.Opacity.setColorUI();
            }
        }, {
            key: '@changeColor',
            value: function changeColor() {
                this.refresh();
            }
        }, {
            key: '@initColor',
            value: function initColor() {
                this.refresh();
            }
        }]);
        return ColorControl;
    }(UIElement);

    var XDColorPicker = function (_BaseColorPicker) {
        inherits(XDColorPicker, _BaseColorPicker);

        function XDColorPicker() {
            classCallCheck(this, XDColorPicker);
            return possibleConstructorReturn(this, (XDColorPicker.__proto__ || Object.getPrototypeOf(XDColorPicker)).apply(this, arguments));
        }

        createClass(XDColorPicker, [{
            key: 'template',
            value: function template() {
                return '\n            <div class=\'colorpicker-body\'>\n                <div target="palette"></div> \n                <div target="control"></div>\n                <div target="information"></div>\n                <div target="currentColorSets"></div>\n                <div target="colorSetsChooser"></div>\n                <div target="contextMenu"></div>\n            </div>\n        ';
            }
        }, {
            key: 'components',
            value: function components() {
                return {
                    palette: ColorPalette,
                    control: ColorControl$10,
                    information: ColorInformation,
                    currentColorSets: CurrentColorSets,
                    colorSetsChooser: ColorSetsChooser,
                    contextMenu: CurrentColorSetsContextMenu
                };
            }
        }]);
        return XDColorPicker;
    }(BaseColorPicker);

    var source$8 = 'mini-control';

    var ColorControl$12 = function (_UIElement) {
        inherits(ColorControl, _UIElement);

        function ColorControl() {
            classCallCheck(this, ColorControl);
            return possibleConstructorReturn(this, (ColorControl.__proto__ || Object.getPrototypeOf(ColorControl)).apply(this, arguments));
        }

        createClass(ColorControl, [{
            key: 'components',
            value: function components() {
                return { Hue: VerticalHue, Opacity: Opacity$2 };
            }
        }, {
            key: 'template',
            value: function template() {
                return (/*html*/'\n            <div class="control">\n                <div target="Opacity" ></div>            \n                <div target="Hue" ></div>\n            </div>\n        '
                );
            }
        }, {
            key: 'refresh',
            value: function refresh() {
                this.setColorUI();
            }
        }, {
            key: 'setColorUI',
            value: function setColorUI() {
                this.Hue.setColorUI();
                this.Opacity.setColorUI();
            }
        }, {
            key: '@changeColor',
            value: function changeColor(sourceType) {
                if (source$8 != sourceType) {
                    this.refresh();
                }
            }
        }, {
            key: '@initColor',
            value: function initColor() {
                this.refresh();
            }
        }]);
        return ColorControl;
    }(UIElement);

    var VSCodePicker = function (_BaseColorPicker) {
        inherits(VSCodePicker, _BaseColorPicker);

        function VSCodePicker() {
            classCallCheck(this, VSCodePicker);
            return possibleConstructorReturn(this, (VSCodePicker.__proto__ || Object.getPrototypeOf(VSCodePicker)).apply(this, arguments));
        }

        createClass(VSCodePicker, [{
            key: 'template',
            value: function template() {
                return (/*html*/'\n            <div class=\'colorpicker-body\'>\n                <div class=\'color-view\'>\n                    <div class=\'color-view-container\'  ref="$colorview"></div>\n                </div>\n                <div class=\'color-tool\'>\n                    <div target="palette"></div>\n                    <div target="control"></div>\n                </div>\n            </div>\n        '
                );
            }
        }, {
            key: 'components',
            value: function components() {
                return {
                    palette: ColorPalette,
                    control: ColorControl$12
                };
            }
        }, {
            key: 'initColorWithoutChangeEvent',
            value: function initColorWithoutChangeEvent(color) {
                this.$store.dispatch('/initColor', color);
                this.refresh();
            }
        }, {
            key: 'setBackgroundColor',
            value: function setBackgroundColor() {
                var color = this.$store.dispatch('/toColor');
                var rgb = this.$store.rgb;
                var bValue = Color$1.brightness(rgb.r, rgb.g, rgb.b);

                this.refs.$colorview.css({
                    "background-color": color,
                    'color': bValue > 127 ? 'black' : 'white'
                });
                this.refs.$colorview.html(color);
            }
        }, {
            key: 'click $colorview',
            value: function click$colorview(e) {
                this.nextFormat();
            }
        }, {
            key: 'nextFormat',
            value: function nextFormat() {
                var current_format = this.$store.format || 'hex';

                var next_format = 'hex';
                if (current_format == 'hex') {
                    next_format = 'rgb';
                } else if (current_format == 'rgb') {
                    next_format = 'hsl';
                } else if (current_format == 'hsl') {
                    next_format = 'hex';
                }

                this.$store.dispatch('/changeFormat', next_format);
                this.$store.emit('lastUpdateColor');
                this.refresh();
            }
        }, {
            key: 'refresh',
            value: function refresh() {
                this.setBackgroundColor();
            }
        }, {
            key: '@changeColor',
            value: function changeColor() {
                this.refresh();
            }
        }, {
            key: '@initColor',
            value: function initColor() {
                this.refresh();
            }
        }]);
        return VSCodePicker;
    }(BaseColorPicker);

    var ColorPickerUI = {
        create: function create(opts) {
            switch (opts.type) {
                case 'macos':
                    return new MacOSColorPicker(opts);
                case 'xd':
                    return new XDColorPicker(opts);
                case 'ring':
                    return new RingColorPicker(opts);
                case 'mini':
                    return new MiniColorPicker(opts);
                case 'vscode':
                    return new VSCodePicker(opts);
                case 'mini-vertical':
                    return new MiniColorPicker$2(opts);
                case 'sketch':
                case 'palette':
                default:
                    return new ChromeDevToolColorPicker(opts);
            }
        },

        ColorPicker: ChromeDevToolColorPicker,
        ChromeDevToolColorPicker: ChromeDevToolColorPicker,
        MacOSColorPicker: MacOSColorPicker,
        RingColorPicker: RingColorPicker,
        MiniColorPicker: MiniColorPicker,
        VSCodePicker: VSCodePicker,
        MiniVerticalColorPicker: MiniColorPicker$2
    };

    var EmbedColorPicker = function (_UIElement) {
      inherits(EmbedColorPicker, _UIElement);

      function EmbedColorPicker() {
        classCallCheck(this, EmbedColorPicker);
        return possibleConstructorReturn(this, (EmbedColorPicker.__proto__ || Object.getPrototypeOf(EmbedColorPicker)).apply(this, arguments));
      }

      createClass(EmbedColorPicker, [{
        key: "afterRender",
        value: function afterRender() {
          var _this2 = this;

          var parent = this.opt;

          var options = parent.opt.colorpickerOptions || {
            type: "sketch"
          };
          this.colorPicker = ColorPickerUI.create(_extends({
            position: "inline",
            container: this.refs.$el.el,
            onChange: function onChange(c) {
              _this2.changeColor(c);
            }
          }, options));
        }
      }, {
        key: "template",
        value: function template() {
          return "<div ref=\"$color\"></div>";
        }
      }, {
        key: "changeColor",
        value: function changeColor(color) {
          this.$store.emit('changeEmbedColorPicker', color);
        }
      }, {
        key: "setValue",
        value: function setValue(color) {
          this.colorPicker.initColorWithoutChangeEvent(color);
        }
      }]);
      return EmbedColorPicker;
    }(UIElement);

    function _traverse(obj) {
      var results = [];

      obj.layers.length && obj.layers.forEach(function (it) {
        results.push.apply(results, toConsumableArray(_traverse(it)));
      });

      results.push(obj);

      return results;
    }

    var Item = function () {
      function Item() {
        var _this = this;

        var json = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        classCallCheck(this, Item);

        if (json instanceof Item) {
          json = json.toJSON();
        }
        this.json = this.convert(_extends({}, this.getDefaultObject(), json));

        this.ref = new Proxy(this, {
          get: function get$$1(target, key) {
            var originMethod = target[key];
            if (isFunction(originMethod)) {
              // method tracking
              return function () {
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                return originMethod.apply(target, args);
              };
            } else {
              // getter or json property
              return originMethod || target.json[key];
            }
          },
          set: function set$$1(target, key, value) {
            // Dom     
            if (value && value.realVal && isFunction(value.realVal)) {
              value = value.realVal();
            }

            if (_this.checkField(key, value)) {
              target.json[key] = value;
            } else {
              throw new Error(value + " is invalid as " + key + " property value.");
            }

            return true;
          }
        });

        return this.ref;
      }

      /***********************************
       *
       * override
       *
       **********************************/

      createClass(Item, [{
        key: "getDefaultTitle",
        value: function getDefaultTitle() {
          return "Item";
        }

        /**
         * check attribute object
         */

      }, {
        key: "isAttribute",
        value: function isAttribute() {
          return false;
        }

        /***********************************
         *
         * getter
         *
         **********************************/

      }, {
        key: "is",
        value: function is() {
          if (!this.json) return false;

          for (var _len2 = arguments.length, itemType = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            itemType[_key2] = arguments[_key2];
          }

          return itemType.indexOf(this.json.itemType) > -1;
        }

        /***********************************
         *
         * action
         *
         **********************************/

        /**
         * when json is loaded, json object is be a new instance
         *
         * @param {*} json
         */

      }, {
        key: "convert",
        value: function convert(json) {

          return json;
        }

        /**
         * defence to set invalid key-value
         *
         * @param {*} key
         * @param {*} value
         */

      }, {
        key: "checkField",
        value: function checkField(key, value) {
          return true;
        }
      }, {
        key: "toCloneObject",
        value: function toCloneObject() {
          var json = {
            itemType: this.json.itemType,
            type: this.json.type,
            selected: this.json.selected
          };

          return json;
        }

        /**
         * clone Item
         */

      }, {
        key: "clone",
        value: function clone$$1() {

          var ItemClass = this.constructor;

          //        .
          //   screenX, Y      .
          var item = new ItemClass(this.toCloneObject());
          item.parent = this.json.parent;

          return item;
        }

        /**
         * set json content
         *
         * @param {object} obj
         */

      }, {
        key: "reset",
        value: function reset(obj) {
          if (obj instanceof Item) {
            obj = obj.toJSON();
          }

          this.json = this.convert(_extends({}, this.json, obj));
        }

        /**
         * define defaut object for item
         *
         * @param {object} obj
         */

      }, {
        key: "getDefaultObject",
        value: function getDefaultObject() {
          var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          return _extends({
            // id: uuidShort(),
            selected: false, //   
            type: '',
            itemType: ''
          }, obj);
        }
      }, {
        key: "add",
        value: function add(layer) {
          this.json.layers.push(layer);
          layer.parent = this.ref;
          return layer;
        }

        /**
         * toggle item's attribute
         *
         * @param {*} field
         * @param {*} toggleValue
         */

      }, {
        key: "toggle",
        value: function toggle(field, toggleValue) {
          if (isUndefined$1(toggleValue)) {
            this.json[field] = !this.json[field];
          } else {
            this.json[field] = !!toggleValue;
          }
        }

        /**
         * convert to json
         */

      }, {
        key: "toJSON",
        value: function toJSON() {
          return this.json;
        }
      }, {
        key: "resize",
        value: function resize() {}
      }, {
        key: "copy",
        value: function copy() {
          this.json.parent.copyItem(this.ref);
        }
      }, {
        key: "copyItem",
        value: function copyItem(childItem) {
          // clone   ?

          var child = childItem.clone();

          child.width.add(10);
          child.width.add(10);

          var layers = this.json.layers;

          var childIndex = -1;
          for (var i = 0, len = layers.length; i < len; i++) {
            if (layers[i] === childItem) {
              childIndex = i;
              break;
            }
          }

          if (childIndex > -1) {
            this.json.layers.splice(childIndex, 0, child);
          }
        }
      }, {
        key: "remove",
        value: function remove() {
          this.json.parent.removeItem(this.ref);
        }
      }, {
        key: "removeItem",
        value: function removeItem(childItem) {
          var layers = this.json.layers;

          var childIndex = -1;
          for (var i = 0, len = layers.length; i < len; i++) {
            if (layers[i] === childItem) {
              childIndex = i;
              break;
            }
          }

          if (childIndex > -1) {
            this.json.layers.splice(childIndex, 1);
          }
        }
      }, {
        key: "title",
        get: function get$$1() {
          return this.json.name || this.getDefaultTitle();
        }

        /**
         * get id
         */

      }, {
        key: "id",
        get: function get$$1() {
          return this.json.id;
        }
      }, {
        key: "layers",
        get: function get$$1() {
          return this.json.layers;
        }
      }, {
        key: "parent",
        get: function get$$1() {
          return this.json.parent;
        }
      }, {
        key: "html",
        get: function get$$1() {
          var _json = this.json,
              elementType = _json.elementType,
              id = _json.id,
              layers = _json.layers,
              itemType = _json.itemType;


          var tagName = elementType || 'div';

          return "\n    <" + tagName + " class='element-item " + itemType + "' data-id=\"" + id + "\">\n      " + layers.map(function (it) {
            return it.html;
          }).join('') + "\n    </" + tagName + ">\n    ";
        }
      }, {
        key: "allLayers",
        get: function get$$1() {
          return [].concat(toConsumableArray(_traverse(this.ref)));
        }
      }]);
      return Item;
    }();

    var ImageResource = function (_Item) {
      inherits(ImageResource, _Item);

      function ImageResource() {
        classCallCheck(this, ImageResource);
        return possibleConstructorReturn(this, (ImageResource.__proto__ || Object.getPrototypeOf(ImageResource)).apply(this, arguments));
      }

      createClass(ImageResource, [{
        key: "getDefaultObject",
        value: function getDefaultObject() {
          var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          return get(ImageResource.prototype.__proto__ || Object.getPrototypeOf(ImageResource.prototype), "getDefaultObject", this).call(this, _extends({
            itemType: "image-resource",
            type: "image"
          }, obj));
        }
      }, {
        key: "isGradient",
        value: function isGradient() {
          return false;
        }
      }, {
        key: "isLinear",
        value: function isLinear() {
          return false;
        }
      }, {
        key: "isRadial",
        value: function isRadial() {
          return false;
        }
      }, {
        key: "isConic",
        value: function isConic() {
          return false;
        }
      }, {
        key: "isStatic",
        value: function isStatic() {
          return false;
        }
      }, {
        key: "isImage",
        value: function isImage() {
          return false;
        }
      }, {
        key: "hasAngle",
        value: function hasAngle() {
          return false;
        }
      }, {
        key: "isUrl",
        value: function isUrl() {
          return false;
        }
      }, {
        key: "isFile",
        value: function isFile() {
          return false;
        }
      }, {
        key: "isAttribute",
        value: function isAttribute() {
          return true;
        }
      }, {
        key: "toString",
        value: function toString() {
          return "none";
        }
      }]);
      return ImageResource;
    }(Item);

    var _stringToPercent = {
      center: 50,
      top: 0,
      left: 0,
      right: 100,
      bottom: 100
    };

    var Position = function Position() {
      classCallCheck(this, Position);
    };

    Position.CENTER = "center";
    Position.TOP = "top";
    Position.RIGHT = "right";
    Position.LEFT = "left";
    Position.BOTTOM = "bottom";

    var REG_CSS_UNIT = /([\d.]+)(px|pt|fr|r?em|deg|vh|vw|m?s|%|g?rad|turn)/gi;

    var Length = function () {
      function Length() {
        var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        var unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        classCallCheck(this, Length);

        this.value = value;
        this.unit = unit;
      }

      createClass(Length, [{
        key: Symbol.toPrimitive,
        value: function value(hint) {
          if (hint == "number") {
            return this.value;
          }

          return this.toString();
        }
      }, {
        key: "toString",
        value: function toString() {

          switch (this.unit) {
            case 'string':
            case 'number':
              return this.value + '';
            case 'var':
              return "var(--" + this.value + ")";
            case 'calc':
              return "calc(" + this.value + ")";
            default:
              return this.value + this.unit;
          }
        }
      }, {
        key: "isUnitType",
        value: function isUnitType(unit) {
          return this.unit === unit;
        }
      }, {
        key: "isCalc",
        value: function isCalc() {
          return this.isUnitType('calc');
        }
      }, {
        key: "isFr",
        value: function isFr() {
          return this.isUnitType('fr');
        }
      }, {
        key: "isPercent",
        value: function isPercent() {
          return this.isUnitType('%');
        }
      }, {
        key: "isPx",
        value: function isPx() {
          return this.isUnitType('px');
        }
      }, {
        key: "isEm",
        value: function isEm() {
          return this.isUnitType('em');
        }
      }, {
        key: "isDeg",
        value: function isDeg() {
          return this.isUnitType('deg');
        }
      }, {
        key: "isSecond",
        value: function isSecond() {
          return this.isUnitType('s');
        }
      }, {
        key: "isMs",
        value: function isMs() {
          return this.isUnitType('ms');
        }
      }, {
        key: "isNumber",
        value: function isNumber$$1() {
          return this.isUnitType('number');
        }
      }, {
        key: "isString",
        value: function isString() {
          return this.isUnitType('');
        }
      }, {
        key: "isVar",
        value: function isVar() {
          return this.isUnitType('--');
        }
      }, {
        key: "set",
        value: function set$$1(value) {
          this.value = value;

          return this;
        }
      }, {
        key: "add",
        value: function add(obj) {
          this.value += +obj;
          return this;
        }
      }, {
        key: "sub",
        value: function sub(obj) {
          return this.add(-1 * obj);
        }
      }, {
        key: "mul",
        value: function mul(obj) {
          this.value *= +obj;
          return this;
        }
      }, {
        key: "div",
        value: function div(obj) {
          this.value /= +obj;
          return this;
        }
      }, {
        key: "mod",
        value: function mod(obj) {
          this.value %= +obj;
          return this;
        }
      }, {
        key: "clone",
        value: function clone$$1() {
          return new Length(this.value, this.unit);
        }
      }, {
        key: "getUnitName",
        value: function getUnitName() {
          return this.unit === "%" ? "percent" : this.unit;
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return { value: this.value, unit: this.unit };
        }
      }, {
        key: "rate",
        value: function rate(value) {
          return value / this.value;
        }
      }, {
        key: "stringToPercent",
        value: function stringToPercent() {
          if (isNotUndefined(_stringToPercent[this.value])) {
            return Length.percent(_stringToPercent[this.value]);
          }

          return Length.percent(0);
        }
      }, {
        key: "stringToEm",
        value: function stringToEm(maxValue) {
          return this.stringToPercent().toEm(maxValue);
        }
      }, {
        key: "stringToPx",
        value: function stringToPx(maxValue) {
          return this.stringToPercent().toPx(maxValue);
        }
      }, {
        key: "toPercent",
        value: function toPercent(maxValue) {
          var fontSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;

          if (this.isPercent()) {
            return this;
          } else if (this.isPx()) {
            return Length.percent(this.value * 100 / maxValue);
          } else if (this.isEm()) {
            return Length.percent(this.value * fontSize * 100 / maxValue);
          } else if (this.isString()) {
            return this.stringToPercent(maxValue);
          } else if (this.isDeg()) {
            return Length.percent(this.value / 360 * 100);
          }
        }
      }, {
        key: "toEm",
        value: function toEm(maxValue) {
          var fontSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;

          if (this.isPercent()) {
            return Length.em(this.value / 100 * maxValue / fontSize);
          } else if (this.isPx()) {
            return Length.em(this.value / fontSize);
          } else if (this.isEm()) {
            return this;
          } else if (this.isString()) {
            return this.stringToEm(maxValue);
          }
        }
      }, {
        key: "toPx",
        value: function toPx(maxValue) {
          if (this.isPercent()) {
            return Length.px(this.value / 100 * maxValue);
          } else if (this.isPx()) {
            return this;
          } else if (this.isEm()) {
            return Length.px(this.value / 100 * maxValue / 16);
          } else if (this.isString()) {
            return this.stringToPx(maxValue);
          }
        }
      }, {
        key: "toSecond",
        value: function toSecond() {
          if (this.isSecond()) {
            return this;
          } else if (this.isMs()) {
            return Length.second(this.value / 1000);
          }
        }
      }, {
        key: "toMs",
        value: function toMs() {
          if (this.isSecond()) {
            return Length.ms(this.value * 1000);
          } else if (this.isMs()) {
            return this;
          }
        }
      }, {
        key: "to",
        value: function to(unit, maxValue) {
          var fontSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 16;

          if (unit === "px") {
            return this.toPx(maxValue, fontSize);
          } else if (unit === "%" || unit === "percent") {
            return this.toPercent(maxValue, fontSize);
          } else if (unit === "em") {
            return this.toEm(maxValue, fontSize);
          }
        }
      }, {
        key: "toUnit",
        value: function toUnit(unit) {
          return new Length(this.value, unit);
        }
      }, {
        key: "calculate",
        value: function calculate(type, dist) {
          var func = this[type];

          if (func) {
            return func.call(this, dist);
          }

          return this;
        }
      }, {
        key: "includes",
        value: function includes() {
          for (var _len = arguments.length, arr = Array(_len), _key = 0; _key < _len; _key++) {
            arr[_key] = arguments[_key];
          }

          return arr.includes(this.value);
        }
      }, {
        key: "round",
        value: function round$$1(k) {
          return new Length(round(this.value, k), this.unit);
        }
      }, {
        key: "equals",
        value: function equals(t) {
          return this.value === t.value && this.unit === t.unit;
        }
      }], [{
        key: "min",
        value: function min() {
          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          var min = args.shift();

          for (var i = 0, len = args.length; i < len; i++) {
            if (min.value > args[i].value) {
              min = args[i];
            }
          }

          return min;
        }
      }, {
        key: "max",
        value: function max() {
          for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          var max = args.shift();

          for (var i = 0, len = args.length; i < len; i++) {
            if (max.value < args[i].value) {
              max = args[i];
            }
          }

          return max;
        }
      }, {
        key: "string",
        value: function string(value) {
          return new Length(value + "", "");
        }
      }, {
        key: "number",
        value: function number(value) {
          return new Length(+value, 'number');
        }
      }, {
        key: "px",
        value: function px(value) {
          return new Length(+value, "px");
        }
      }, {
        key: "em",
        value: function em(value) {
          return new Length(+value, "em");
        }
      }, {
        key: "percent",
        value: function percent(value) {
          return new Length(+value, "%");
        }
      }, {
        key: "deg",
        value: function deg(value) {
          return new Length(+value, "deg");
        }
      }, {
        key: "fr",
        value: function fr(value) {
          return new Length(+value, "fr");
        }
      }, {
        key: "second",
        value: function second(value) {
          return new Length(+value, 's');
        }
      }, {
        key: "ms",
        value: function ms(value) {
          return new Length(+value, 'ms');
        }
      }, {
        key: "var",
        value: function _var(value) {
          return new Length(value + '', '--');
        }

        /**
         * return calc()  css fuction string
         *
         * Length.calc(`${Length.percent(100)} - ${Length.px(10)}`)
         *
         * @param {*} str
         */

      }, {
        key: "calc",
        value: function calc(str) {
          return new Length(str, "calc");
        }
      }, {
        key: "parse",
        value: function parse(obj) {
          if (isString$1(obj)) {
            if (obj.indexOf("calc(") > -1) {
              return new Length(obj.split("calc(")[1].split(")")[0], "calc");
            } else {
              var arr = obj.replace(REG_CSS_UNIT, "$1 $2").split(" ");
              var isNumberString = +arr[0] == arr[0];
              if (isNumberString) {
                return new Length(+arr[0], arr[1]);
              } else {
                return new Length(arr[0]);
              }
            }
          }

          if (obj instanceof Length) {
            return obj;
          } else if (obj.unit) {
            if (obj.unit == "%" || obj.unit == "percent") {
              var value = 0;

              if (isNotUndefined(obj.percent)) {
                value = obj.percent;
              } else if (isNotUndefined(obj.value)) {
                value = obj.value;
              }

              return Length.percent(value);
            } else if (obj.unit == "px") {
              var value = 0;

              if (isNotUndefined(obj.px)) {
                value = obj.px;
              } else if (isNotUndefined(obj.value)) {
                value = obj.value;
              }

              return Length.px(value);
            } else if (obj.unit == "em") {
              var value = 0;

              if (isNotUndefined(obj.em)) {
                value = obj.em;
              } else if (isNotUndefined(obj.value)) {
                value = obj.value;
              }

              return Length.em(value);
            } else if (obj.unit == "deg") {
              var value = 0;

              if (isNotUndefined(obj.deg)) {
                value = obj.deg;
              } else if (isNotUndefined(obj.value)) {
                value = obj.value;
              }

              return Length.deg(value);
            } else if (obj.unit == "s") {
              var value = 0;

              if (isNotUndefined(obj.second)) {
                value = obj.second;
              } else if (isNotUndefined(obj.value)) {
                value = obj.value;
              }

              return Length.second(value);
            } else if (obj.unit == "ms") {
              var value = 0;

              if (isNotUndefined(obj.ms)) {
                value = obj.ms;
              } else if (isNotUndefined(obj.value)) {
                value = obj.value;
              }

              return Length.ms(value);
            } else if (obj.unit == "number") {
              var value = 0;

              if (isNotUndefined(obj.value)) {
                value = obj.value;
              }

              return Length.number(value);
            } else if (obj.unit == "--") {
              var value = 0;

              if (isNotUndefined(obj.value)) {
                value = obj.value;
              }

              return Length.var(value);
            } else if (obj.unit === "" || obj.unit === "string") {
              var value = "";

              if (isNotUndefined(obj.str)) {
                value = obj.str;
              } else if (isNotUndefined(obj.value)) {
                value = obj.value;
              }

              return Length.string(value);
            }
          }

          return Length.string(obj);
        }
      }]);
      return Length;
    }();

    Length.auto = Length.string("auto");

    var ColorStep = function (_Item) {
      inherits(ColorStep, _Item);

      function ColorStep() {
        classCallCheck(this, ColorStep);
        return possibleConstructorReturn(this, (ColorStep.__proto__ || Object.getPrototypeOf(ColorStep)).apply(this, arguments));
      }

      createClass(ColorStep, [{
        key: "getDefaultObject",
        value: function getDefaultObject() {
          return get(ColorStep.prototype.__proto__ || Object.getPrototypeOf(ColorStep.prototype), "getDefaultObject", this).call(this, {
            cut: false,
            percent: 0,
            unit: "%",
            px: 0,
            em: 0,
            color: "rgba(0, 0, 0, 0)",
            prevColorStep: null
          });
        }
      }, {
        key: "toCloneObject",
        value: function toCloneObject() {
          return _extends({}, get(ColorStep.prototype.__proto__ || Object.getPrototypeOf(ColorStep.prototype), "toCloneObject", this).call(this), {
            cut: this.json.cut,
            percent: this.json.percent,
            unit: this.json.unit,
            px: this.json.px,
            em: this.json.em,
            color: this.json.color
          });
        }
      }, {
        key: "on",
        value: function on() {
          this.json.cut = true;
        }
      }, {
        key: "off",
        value: function off() {
          this.json.cut = false;
        }
      }, {
        key: "toggle",
        value: function toggle() {
          this.json.cut = !this.json.cut;
        }
      }, {
        key: "getUnit",
        value: function getUnit() {
          return this.json.unit == "%" ? "percent" : this.json.unit;
        }
      }, {
        key: "add",
        value: function add(num) {
          var unit = this.getUnit();
          this.json[unit] += +num;

          return this;
        }
      }, {
        key: "sub",
        value: function sub(num) {
          var unit = this.getUnit();
          this.json[unit] -= +num;

          return this;
        }
      }, {
        key: "mul",
        value: function mul(num) {
          var unit = this.getUnit();
          this.json[unit] *= +num;

          return this;
        }
      }, {
        key: "div",
        value: function div(num) {
          var unit = this.getUnit();
          this.json[unit] /= +num;

          return this;
        }
      }, {
        key: "mod",
        value: function mod(num) {
          var unit = this.getUnit();
          this.json[unit] %= +num;

          return this;
        }
      }, {
        key: "toLength",


        /**
         * convert Length instance
         * @return {Length}
         */
        value: function toLength(maxValue) {
          // TODO: apply maxValue
          return Length.parse(this.json);
        }
      }, {
        key: "getPrevLength",
        value: function getPrevLength() {
          if (!this.json.prevColorStep) return '';

          return this.json.prevColorStep.toLength();
        }

        /**
         * get color string
         *
         * return {string}
         */

      }, {
        key: "toString",
        value: function toString() {
          var prev = this.json.cut ? this.getPrevLength() : '';
          return this.json.color + " " + prev + " " + this.toLength();
        }
      }, {
        key: "reset",
        value: function reset(json) {
          get(ColorStep.prototype.__proto__ || Object.getPrototypeOf(ColorStep.prototype), "reset", this).call(this, json);
          if (this.parent()) {
            this.parent().sortColorStep();
          }
        }
      }, {
        key: "isPx",
        get: function get$$1() {
          return this.json.unit == "px";
        }
      }, {
        key: "isPercent",
        get: function get$$1() {
          return this.json.unit == "%" || this.json.unit === "percent";
        }
      }, {
        key: "isEm",
        get: function get$$1() {
          return this.json.unit == "em";
        }
      }], [{
        key: "parse",
        value: function parse$$1(colorStepString) {
          var colorsteps = [];

          var results = convertMatches(colorStepString);

          var arr = results.str.split(' ').filter(function (it) {
            return it.trim();
          });
          var colorIndex = +arr[0].replace("@", "");
          var color = results.matches[colorIndex].color;

          if (arr.length === 1) {
            colorsteps.push(new ColorStep({
              color: color,
              unit: "%",
              percent: 0
            }));
          } else if (arr.length === 2) {
            var len = Length.parse(arr[1]);

            var data = { unit: len.unit };

            if (len.isPercent()) {
              data.percent = len.value;
            } else if (len.isPx()) {
              data.px = len.value;
            } else if (len.isEm()) {
              data.em = len.value;
            }

            colorsteps.push(new ColorStep(_extends({ color: color }, data)));
          } else if (arr.length === 3) {
            [1, 2].forEach(function (index) {
              var len = Length.parse(arr[index]);

              var data = { unit: len.unit };

              if (len.isPercent()) {
                data.percent = len.value;
              } else if (len.isPx()) {
                data.px = len.value;
              } else if (len.isEm()) {
                data.em = len.value;
              }

              colorsteps.push(new ColorStep(_extends({ color: color }, data)));
            });
          }

          return colorsteps;
        }
      }]);
      return ColorStep;
    }(Item);

    var DEFINED_ANGLES = {
      "to top": 0,
      "to top right": 45,
      "to right": 90,
      "to bottom right": 135,
      "to bottom": 180,
      "to bottom left": 225,
      "to left": 270,
      "to top left": 315
    };

    var Gradient = function (_ImageResource) {
      inherits(Gradient, _ImageResource);

      function Gradient() {
        classCallCheck(this, Gradient);
        return possibleConstructorReturn(this, (Gradient.__proto__ || Object.getPrototypeOf(Gradient)).apply(this, arguments));
      }

      createClass(Gradient, [{
        key: "isGradient",
        value: function isGradient() {
          return true;
        }
      }, {
        key: "toString",
        value: function toString() {
          return "none";
        }

        /**
         * colorsteps = [
         *    new ColorStep({color: 'red', percent: 0}),
         *    new ColorStep({color: 'red', percent: 0})
         * ]
         *
         * @param {*} obj
         */

      }, {
        key: "getDefaultObject",
        value: function getDefaultObject() {
          var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          return get(Gradient.prototype.__proto__ || Object.getPrototypeOf(Gradient.prototype), "getDefaultObject", this).call(this, _extends({
            type: "gradient",
            colorsteps: []
          }, obj));
        }
      }, {
        key: "toCloneObject",
        value: function toCloneObject() {
          return _extends({}, get(Gradient.prototype.__proto__ || Object.getPrototypeOf(Gradient.prototype), "toCloneObject", this).call(this), {
            colorsteps: this.json.colorsteps.map(function (color) {
              return color.clone();
            })
          });
        }
      }, {
        key: "convert",
        value: function convert(json) {
          json.colorsteps = json.colorsteps.map(function (c) {
            return new ColorStep(c);
          });

          return json;
        }
      }, {
        key: "calculateAngle",
        value: function calculateAngle() {
          var angle = this.json.angle;
          return isUndefined$1(DEFINED_ANGLES[angle]) ? angle : DEFINED_ANGLES[angle] || 0;
        }

        /**
         * add ColorStep
         *
         * @param {ColorStep} colorstep
         * @param {boolean} isSort
         */

      }, {
        key: "addColorStep",
        value: function addColorStep(colorstep) {
          var isSort = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

          this.json.colorsteps.push(colorstep);

          if (isSort) this.sortColorStep();

          return colorstep;
        }
      }, {
        key: "insertColorStep",
        value: function insertColorStep(percent) {
          var startColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "rgba(216,216,216,0)";
          var endColor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "rgba(216,216,216,1)";

          var colorsteps = this.colorsteps;
          if (!colorsteps.length) {
            this.addColorStepList([new ColorStep({ color: startColor, percent: percent, index: 0 }), new ColorStep({ color: endColor, percent: 100, index: 100 })]);
            return;
          }

          if (percent < colorsteps[0].percent) {
            colorsteps[0].index = 1;

            this.addColorStep(new ColorStep({ index: 0, color: colorsteps[0].color, percent: percent }));
            return;
          }

          var lastIndex = colorsteps.length - 1;
          if (colorsteps[lastIndex].percent < percent) {
            var color = colorsteps[lastIndex].color;
            var index = colorsteps[lastIndex].index + 1;

            this.addColorStep(new ColorStep({ index: index, color: color, percent: percent }));

            return;
          }

          for (var i = 0, len = colorsteps.length - 1; i < len; i++) {
            var step = colorsteps[i];
            var nextStep = colorsteps[i + 1];

            if (step.percent <= percent && percent <= nextStep.percent) {
              var color = Color.mix(step.color, nextStep.color, (percent - step.percent) / (nextStep.percent - step.percent), "rgb");

              this.addColorStep(new ColorStep({ index: step.index + 1, color: color, percent: percent }));

              return;
            }
          }
        }
      }, {
        key: "sortColorStep",
        value: function sortColorStep() {
          var children = this.colorsteps;

          children.sort(function (a, b) {
            if (a.percent > b.percent) return 1;
            if (a.percent < b.percent) return -1;
            if (a.percent == b.percent) {
              if (a.index === b.index) return 0;
              return a.index > b.index ? 1 : -1;
            }
          });

          children.forEach(function (it, index) {
            it.index = index * 100;
          });
        }

        /**
         * add ColorStep List
         * @param {Array<ColorStep>} colorstepList
         */

      }, {
        key: "addColorStepList",
        value: function addColorStepList() {
          var _this2 = this;

          var colorstepList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

          colorstepList.forEach(function (c) {
            _this2.addColorStep(c, false);
          });

          this.sortColorStep();
        }

        /**
         * get color step by id
         *
         * @param {string} id
         */

      }, {
        key: "getColorStep",
        value: function getColorStep(id) {
          return this.json.colorsteps.filter(function (c) {
            return c.id == id;
          })[0];
        }
      }, {
        key: "clear",
        value: function clear() {
          if (arguments.length) {
            this.json.colorsteps.splice(+(arguments.length <= 0 ? undefined : arguments[0]), 1);
          } else {
            this.json.colorsteps = [];
          }
        }

        /**
         * get colorstep list
         *
         * @return {Array<ColorStep>}
         */

      }, {
        key: "getColorString",


        /**
         * get color string
         *
         * @return {string}
         */
        value: function getColorString() {
          var colorsteps = this.colorsteps;
          if (!colorsteps.length) return '';

          var newColors = colorsteps.map(function (c, index) {
            c.prevColorStep = c.cut && index > 0 ? colorsteps[index - 1] : null;
            return c;
          });

          return newColors.map(function (f) {
            return "" + f;
          }).join(",");
        }
      }, {
        key: "colorsteps",
        get: function get$$1() {
          return this.json.colorsteps;
        }
      }], [{
        key: "random",
        value: function random() {
          var angle = Math.floor(Math.random() * 1000) % 360;
          return "linear-gradient(" + angle + "deg, " + Color.random() + " 0%, " + Color.random() + " 100%)";
        }
      }]);
      return Gradient;
    }(ImageResource);

    var radialTypeList = ['circle', 'circle closest-side', 'circle closest-corner', 'circle farthest-side', 'circle farthest-corner', 'ellipse', 'ellipse closest-side', 'ellipse closest-corner', 'ellipse farthest-side', 'ellipse farthest-corner'];

    var GradientEditor = function (_UIElement) {
      inherits(GradientEditor, _UIElement);

      function GradientEditor() {
        classCallCheck(this, GradientEditor);
        return possibleConstructorReturn(this, (GradientEditor.__proto__ || Object.getPrototypeOf(GradientEditor)).apply(this, arguments));
      }

      createClass(GradientEditor, [{
        key: "initialize",
        value: function initialize() {
          get(GradientEditor.prototype.__proto__ || Object.getPrototypeOf(GradientEditor.prototype), "initialize", this).call(this);

          var colorsteps = [{ offset: Length.percent(0), cut: false, color: 'yellow' }, { offset: Length.percent(100), cut: false, color: 'red' }];

          this.type = 'linear-gradient';
          this.index = 0;
          this.colorsteps = colorsteps;
          this.radialPosition = [Length.percent(50), Length.percent(50)];
          this.radialType = 'ellipse';
        }
      }, {
        key: '@setGradientEditor',
        value: function setGradientEditor(str) {
          var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'linear-gradient';
          var angle = arguments[3];
          var radialPosition = arguments[4];
          var radialType = arguments[5];

          var results = convertMatches(str);
          var colorsteps = results.str.split(',').map(function (it) {
            return it.trim();
          }).map(function (it) {
            var _it$split$filter = it.split(' ').filter(function (str) {
              return str.length;
            }),
                _it$split$filter2 = slicedToArray(_it$split$filter, 3),
                color = _it$split$filter2[0],
                offset1 = _it$split$filter2[1],
                offset2 = _it$split$filter2[2];

            color = reverseMatches(color, results.matches);
            var cut = false;
            if (offset2) {
              cut = true;
            }

            var offset = cut ? Length.parse(offset2) : Length.parse(offset1);

            if (offset.isDeg()) {
              offset = Length.percent(offset.value / 360 * 100);
            }

            return { color: color, offset: offset, cut: cut };
          });

          if (colorsteps.length == 1) {
            colorsteps.push({
              color: colorsteps[0].color,
              offset: Length.percent(100),
              cut: false
            });
          }

          this.cachedStepListRect = null;

          this.colorsteps = colorsteps;
          this.index = index;
          this.type = type;
          this.angle = Length.parse(angle || '90deg');
          this.radialPosition = radialPosition || [Length.percent(50), Length.percent(50)];
          this.radialType = radialType;

          this.refresh();

          this.selectStep(index);

          this.reloadInputValue();
        }
      }, {
        key: "template",
        value: function template() {
          var _this2 = this;

          return (/*html*/"\n        <div class='gradient-editor' data-selected-editor='" + this.type + "'>\n            <div class='gradient-steps' data-editor='gradient'>\n                <div class=\"hue-container\" ref=\"$back\"></div>            \n                <div class=\"hue\" ref=\"$steps\">\n                    <div class='step-list' ref=\"$stepList\" ></div>\n                </div>\n            </div>\n            <div class='tools' data-editor='tools'>\n              <label>Offset <input type='checkbox' ref='$cut' checked />  connected</label>\n              <div class='unit'>\n                <div><input type='range' data-key='length' min='0' max=\"100\" step='0.1' ref='$offset' /></div>\n                <div><input type='number' data-key='length' min='0' max=\"100\" step='0.1' ref='$offsetNumber' /></div>              \n                <div><select ref='$offsetSelect'>\n                  <option value='%'>%</option>\n                  <option value='px'>px</option>\n                  <option value='em'>em</option>\n                </select></div>\n              </div>\n            </div>\n            <div class='sub-editor' ref='$subEditor'> \n              <div data-editor='angle'>\n                <label>Angle</label>\n                <div class='unit'>                \n                  <div><input type='range' data-key='angle' min='-720' max=\"720\" step='0.1' ref='$angle' /> </div>\n                  <div><input type='number' data-key='angle' min='-720' max=\"720\" step='0.1' ref='$angleNumber' /></div> \n                  <span>deg</span>\n                </div>\n              </div>\n              <div data-editor='centerX'>\n                <label>Center X</label>\n                <div class='unit'>\n                  <div><input type='range' data-key='centerX' min='-100' max=\"100\" step='0.1' ref='$centerX' /></div>\n                  <div><input type='number' data-key='centerX' min='-100' max=\"100\" step='0.1' ref='$centerXNumber' /></div>\n                  <div><select ref='$centerXSelect'>\n                      <option value='%'>%</option>\n                      <option value='px'>px</option>\n                      <option value='em'>em</option>\n                    </select></div>\n                </div>\n              </div>                \n              <div data-editor='centerY'>           \n                <label>Center Y</label>                 \n                <div class='unit'>\n                  <div><input type='range' data-key='centerY' min='-100' max=\"100\" step='0.1' ref='$centerY' /></div>\n                  <div><input type='number' data-key='centerX' min='-100' max=\"100\" step='0.1' ref='$centerYNumber' /></div>\n                  <div><select ref='$centerYSelect'>\n                      <option value='%'>%</option>\n                      <option value='px'>px</option>\n                      <option value='em'>em</option>\n                    </select></div>\n                </div>\n              </div>                \n              <div data-editor='radialType'>       \n                <label>Radial Type</label>              \n                <div><select ref='$radialType'>\n                  " + radialTypeList.map(function (k) {
              var selected = _this2.radialType === k ? 'selected' : '';
              return "<option value=\"" + k + "\" " + selected + ">" + k + "</option>";
            }).join('') + "\n                </select></div>\n              </div>\n            </div>            \n        </div>\n      "
          );
        }
      }, {
        key: 'input $offset',
        value: function input$offset(e) {
          this.refs.$offsetNumber.val(this.refs.$offset.val());
          this['@changeColorStepOffset']('offset', new Length(this.refs.$offset.val(), this.refs.$offsetSelect.val()));
        }
      }, {
        key: 'input $offsetNumber',
        value: function input$offsetNumber(e) {
          this.refs.$offset.val(this.refs.$offsetNumber.val());
          this['@changeColorStepOffset']('offset', new Length(this.refs.$offset.val(), this.refs.$offsetSelect.val()));
        }
      }, {
        key: 'input $angle',
        value: function input$angle(e) {
          this.refs.$angleNumber.val(this.refs.$angle.val());
          this['@changeKeyValue']('angle', Length.deg(this.refs.$angle.val()));
        }
      }, {
        key: 'input $angleNumber',
        value: function input$angleNumber(e) {
          this.refs.$angle.val(this.refs.$angleNumber.val());
          this['@changeKeyValue']('angle', Length.deg(this.refs.$angle.val()));
        }
      }, {
        key: 'input $centerX',
        value: function input$centerX(e) {
          this.refs.$centerXNumber.val(this.refs.$centerX.val());
          this['@changeKeyValue']('radialPositionX');
        }
      }, {
        key: 'input $centerXNumber',
        value: function input$centerXNumber(e) {
          this.refs.$centerX.val(this.refs.$centerXNumber.val());
          this['@changeKeyValue']('radialPositionX');
        }
      }, {
        key: 'input $centerY',
        value: function input$centerY(e) {
          this.refs.$centerYNumber.val(this.refs.$centerY.val());
          this['@changeKeyValue']('radialPositionY');
        }
      }, {
        key: 'input $centerYNumber',
        value: function input$centerYNumber(e) {
          this.refs.$centerY.val(this.refs.$centerYNumber.val());
          this['@changeKeyValue']('radialPositionX');
        }
      }, {
        key: 'change $centerXSelect',
        value: function change$centerXSelect(e) {

          this['@changeKeyValue']('radialPositionX');
        }
      }, {
        key: 'change $centerYSelect',
        value: function change$centerYSelect(e) {
          this['@changeKeyValue']('radialPositionY');
        }
      }, {
        key: 'change $radialType',
        value: function change$radialType(e) {
          this['@changeKeyValue']('radialType', this.refs.$radialType.val());
        }
      }, {
        key: '@changeKeyValue',
        value: function changeKeyValue(key, value) {

          if (key === 'angle') {
            value = value.value;
          }

          if (key === 'radialPositionX' || key === 'radialPositionY') {
            this['radialPosition'] = [this.radialPositionX, this.radialPositionY];
          } else {
            this[key] = value;
          }

          this.updateData();
        }
      }, {
        key: '@changeColorStepOffset',
        value: function changeColorStepOffset(key, value) {
          if (this.currentStep) {
            this.currentStep.offset = value.clone();
            this.$currentStep.css({
              left: this.currentStep.offset
            });
            this.setColorUI();
            this.updateData();
          }
        }
      }, {
        key: 'click $back',
        value: function click$back(e) {
          if (this.startXY) return;

          var rect = this.refs.$stepList.rect();

          var minX = rect.x;
          var maxX = rect.right;

          var x = e.xy.x;

          if (x < minX) x = minX;else if (x > maxX) x = maxX;
          var percent = (x - minX) / rect.width * 100;

          var list = this.colorsteps.map(function (it, index) {
            return { index: index, color: it.color, offset: it.offset };
          });

          var prev = list.filter(function (it) {
            return it.offset.value <= percent;
          }).pop();
          var next = list.filter(function (it) {
            return it.offset.value >= percent;
          }).shift();

          if (prev && next) {
            this.colorsteps.splice(next.index, 0, {
              cut: false,
              offset: Length.percent(percent),
              color: Color.mix(prev.color, next.color, (percent - prev.offset.value) / (next.offset.value - prev.offset.value))
            });
          } else if (prev) {
            this.colorsteps.splice(prev.index + 1, 0, {
              cut: false,
              offset: Length.percent(percent),
              color: 'rgba(0, 0, 0, 1)'
            });
          } else if (next) {
            this.colorsteps.splice(next.index - 1, 0, {
              cut: false,
              offset: Length.percent(percent),
              color: 'rgba(0, 0, 0, 1)'
            });
          } else {
            this.colorsteps.push({
              cut: false,
              offset: Length.percent(0),
              color: 'rgba(0, 0, 0, 1)'
            });
          }

          this.refresh();
          this.updateData();
        }
      }, {
        key: "reloadStepList",
        value: function reloadStepList() {
          this.refs.$stepList.html(this.colorsteps.map(function (it, index) {
            return "<div class='step' data-index='" + index + "' data-cut='" + it.cut + "' style='left: " + it.offset + ";'>\n        <div class='color-view' style=\"background-color: " + it.color + "\"></div>\n        <div class='arrow' style=\"background-color: " + it.color + "\"></div>\n      </div>";
          }).join(''));
        }
      }, {
        key: 'click $cut',
        value: function click$cut() {
          if (this.currentStep) {
            this.currentStep.cut = this.refs.$cut.checked();
            this.$currentStep.attr('data-cut', this.currentStep.cut);
            this.setColorUI();
            this.updateData();
          }
        }
      }, {
        key: "removeStep",
        value: function removeStep(index) {
          if (this.colorsteps.length === 2) return;
          this.colorsteps.splice(index, 1);
          var currentStep = this.colorsteps[index];
          var currentIndex = index;
          if (!currentStep) {
            currentStep = this.colorsteps[index - 1];
            currentIndex = index - 1;
          }

          if (currentStep) {
            this.selectStep(currentIndex);
          }
          this.refresh();
          this.updateData();
        }
      }, {
        key: "selectStep",
        value: function selectStep(index) {
          this.index = index;
          this.currentStep = this.colorsteps[index];
          this.refs.$stepList.attr('data-selected-index', index);
          this.$currentStep = this.refs.$stepList.$("[data-index=\"" + index.toString() + "\"]");
          if (this.$currentStep) {
            this.$colorView = this.$currentStep.$('.color-view');
            this.$arrow = this.$currentStep.$('.arrow');
            this.refs.$cut.el.checked = this.currentStep.cut;
          }
          this.prev = this.colorsteps[index - 1];
          this.next = this.colorsteps[index + 1];
        }
      }, {
        key: 'mousedown $stepList .step',
        value: function mousedown$stepListStep(e) {
          var index = +e.$delegateTarget.attr('data-index');

          if (e.altKey) {
            this.removeStep(index);
            // return false;
          } else {

            this.selectStep(index);

            this.startXY = e.xy;
            this.$store.emit('selectColorStep', this.currentStep.color);
            this.refs.$cut.checked(this.currentStep.cut);
            this.refs.$offset.val(this.currentStep.offset.value);
            this.refs.$stepList.attr('data-selected-index', index);
            this.cachedStepListRect = this.refs.$stepList.rect();
          }
        }
      }, {
        key: "getStepListRect",
        value: function getStepListRect() {
          return this.cachedStepListRect;
        }
      }, {
        key: 'mouseup document',
        value: function mouseupDocument(e) {
          if (this.startXY) {
            this.startXY = null;
          }
        }
      }, {
        key: 'mousemove document',
        value: function mousemoveDocument(e) {
          if (!this.startXY) return;

          var dx = e.xy.x - this.startXY.x;
          e.xy.y - this.startXY.y;

          var rect = this.getStepListRect();

          var minX = rect.x;
          var maxX = rect.right;

          var x = this.startXY.x + dx;

          if (x < minX) x = minX;else if (x > maxX) x = maxX;
          var percent = (x - minX) / rect.width * 100;

          if (this.prev) {
            if (this.prev.offset.value > percent) {
              percent = this.prev.offset.value;
            }
          }

          if (this.next) {
            if (this.next.offset.value < percent) {
              percent = this.next.offset.value;
            }
          }

          this.currentStep.offset.set(round(percent, 100));
          this.$currentStep.css({
            left: Length.percent(percent)
          });
          this.refs.$offset.val(this.currentStep.offset.value);
          this.setColorUI();
          this.updateData();
        }
      }, {
        key: "refresh",
        value: function refresh() {
          this.reloadStepList();
          this.setColorUI();
        }
      }, {
        key: "getLinearGradient",
        value: function getLinearGradient() {
          var _this3 = this;

          if (this.colorsteps.length === 0) {
            return '';
          }

          if (this.colorsteps.length === 1) {
            var colorstep = this.colorsteps[0];
            return "linear-gradient(to right, " + colorstep.color + " " + colorstep.offset + ", " + colorstep.color + " 100%)";
          }

          return "linear-gradient(to right, " + this.colorsteps.map(function (it, index) {

            if (it.cut) {
              var prev = _this3.colorsteps[index - 1];
              if (prev) {
                return it.color + " " + prev.offset + " " + it.offset;
              } else {
                return it.color + " " + it.offset;
              }
            } else {
              return it.color + " " + it.offset;
            }
          }).join(',') + ")";
        }
      }, {
        key: "setColorUI",
        value: function setColorUI() {
          this.refs.$stepList.css("background-image", this.getLinearGradient());
          this.refs.$el.attr("data-selected-editor", this.type);
        }
      }, {
        key: "reloadInputValue",
        value: function reloadInputValue() {
          this.refs.$offset.val(this.currentStep.offset.value);
          this.refs.$offsetNumber.val(this.currentStep.offset.value);
          this.refs.$offsetSelect.val(this.currentStep.offset.unit);

          this.refs.$angle.val(this.angle.value);
          this.refs.$angleNumber.val(this.angle.value);

          this.refs.$centerX.val(this.radialPosition[0].value);
          this.refs.$centerXNumber.val(this.radialPosition[0].value);
          this.refs.$centerXSelect.val(this.radialPosition[0].unit);

          this.refs.$centerY.val(this.radialPosition[1].value);
          this.refs.$centerYNumber.val(this.radialPosition[1].value);
          this.refs.$centerYSelect.val(this.radialPosition[1].unit);

          this.refs.$radialType.val(this.radialType);
        }
      }, {
        key: '@setColorStepColor',
        value: function setColorStepColor(color) {

          if (this.currentStep) {
            this.currentStep.color = color;
            this.$colorView.css({
              'background-color': color
            });
            this.$arrow.css({
              'background-color': color
            });
            this.setColorUI();
            this.updateData();
          }
        }
      }, {
        key: "updateData",
        value: function updateData() {

          this.$store.emit('changeGradientEditor', {
            type: this.type,
            index: this.index,
            angle: this.angle,
            colorsteps: this.colorsteps,
            radialPosition: this.radialPosition,
            radialType: this.radialType
          });
        }
      }, {
        key: "radialPositionX",
        get: function get$$1() {
          return new Length(this.refs.$centerX.val(), this.refs.$centerXSelect.val());
        }
      }, {
        key: "radialPositionY",
        get: function get$$1() {
          return new Length(this.refs.$centerY.val(), this.refs.$centerYSelect.val());
        }
      }]);
      return GradientEditor;
    }(UIElement);

    var DEFINED_DIRECTIONS = {
      "0": "to top",
      "45": "to top right",
      "90": "to right",
      "135": "to bottom right",
      "180": "to bottom",
      "225": "to bottom left",
      "270": "to left",
      "315": "to top left"
    };

    var DEFINED_ANGLES$1 = {
      "to top": "0",
      "to top right": "45",
      "to right": "90",
      "to bottom right": "135",
      "to bottom": "180",
      "to bottom left": "225",
      "to left": "270",
      "to top left": "315"
    };

    var LinearGradient = function (_Gradient) {
      inherits(LinearGradient, _Gradient);

      function LinearGradient() {
        classCallCheck(this, LinearGradient);
        return possibleConstructorReturn(this, (LinearGradient.__proto__ || Object.getPrototypeOf(LinearGradient)).apply(this, arguments));
      }

      createClass(LinearGradient, [{
        key: "getDefaultObject",
        value: function getDefaultObject() {
          var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          return get(LinearGradient.prototype.__proto__ || Object.getPrototypeOf(LinearGradient.prototype), "getDefaultObject", this).call(this, _extends({
            type: "linear-gradient",
            angle: 0
          }, obj));
        }
      }, {
        key: "toCloneObject",
        value: function toCloneObject() {
          return _extends({}, get(LinearGradient.prototype.__proto__ || Object.getPrototypeOf(LinearGradient.prototype), "toCloneObject", this).call(this), {
            angle: this.json.angle
          });
        }
      }, {
        key: "isLinear",
        value: function isLinear() {
          return true;
        }
      }, {
        key: "hasAngle",
        value: function hasAngle() {
          return true;
        }
      }, {
        key: "toString",
        value: function toString() {
          if (this.colorsteps.length === 0) return '';
          var colorString = this.getColorString();

          var opt = '';
          var angle = this.json.angle || 0;

          opt = angle;

          if (isNumber(opt)) {
            opt = DEFINED_DIRECTIONS["" + opt] || opt;
          }

          if (isNumber(opt)) {
            opt = opt > 360 ? opt % 360 : opt;

            opt = opt + "deg";
          }

          var result = this.json.type + "(" + opt + ", " + colorString + ")";

          return result;
        }
      }], [{
        key: "toLinearGradient",
        value: function toLinearGradient(colorsteps) {
          if (colorsteps.length === 0) {
            return "none";
          }

          var gradient = new LinearGradient({
            angle: "to right",
            colorsteps: colorsteps
          });

          return gradient + "";
        }
      }, {
        key: "parse",
        value: function parse$$1(str) {
          var results = convertMatches(str);
          var angle = 0;
          var colorsteps = [];
          results.str.split("(")[1].split(")")[0].split(",").map(function (it) {
            return it.trim();
          }).forEach(function (newValue, index) {
            if (newValue.includes("@")) {
              // color 
              newValue = reverseMatches(newValue, results.matches);

              //  ColorStep  
              // ColorStep   colorsteps  ... ,  
              colorsteps.push.apply(colorsteps, toConsumableArray(ColorStep.parse(newValue)));
            } else {
              // direction
              angle = isUndefined$1(DEFINED_ANGLES$1[newValue]) ? Length.parse(newValue) : Length.deg(+DEFINED_ANGLES$1[newValue]);
            }
          });

          return new LinearGradient({ angle: angle, colorsteps: colorsteps });
        }
      }]);
      return LinearGradient;
    }(Gradient);

    var RepeatingLinearGradient = function (_LinearGradient) {
      inherits(RepeatingLinearGradient, _LinearGradient);

      function RepeatingLinearGradient() {
        classCallCheck(this, RepeatingLinearGradient);
        return possibleConstructorReturn(this, (RepeatingLinearGradient.__proto__ || Object.getPrototypeOf(RepeatingLinearGradient)).apply(this, arguments));
      }

      createClass(RepeatingLinearGradient, [{
        key: "getDefaultObject",
        value: function getDefaultObject() {
          return get(RepeatingLinearGradient.prototype.__proto__ || Object.getPrototypeOf(RepeatingLinearGradient.prototype), "getDefaultObject", this).call(this, {
            type: "repeating-linear-gradient",
            angle: 0
          });
        }
      }], [{
        key: "parse",
        value: function parse(str) {
          var linear = LinearGradient.parse(str);
          return new RepeatingLinearGradient({
            angle: linear.angle,
            colorsteps: linear.colorsteps
          });
        }
      }]);
      return RepeatingLinearGradient;
    }(LinearGradient);

    var _DEFINED_POSITIONS;

    var DEFINED_POSITIONS = (_DEFINED_POSITIONS = {}, defineProperty(_DEFINED_POSITIONS, "center", true), defineProperty(_DEFINED_POSITIONS, "top", true), defineProperty(_DEFINED_POSITIONS, "left", true), defineProperty(_DEFINED_POSITIONS, "right", true), defineProperty(_DEFINED_POSITIONS, "bottom", true), _DEFINED_POSITIONS);

    var RadialGradient = function (_Gradient) {
      inherits(RadialGradient, _Gradient);

      function RadialGradient() {
        classCallCheck(this, RadialGradient);
        return possibleConstructorReturn(this, (RadialGradient.__proto__ || Object.getPrototypeOf(RadialGradient)).apply(this, arguments));
      }

      createClass(RadialGradient, [{
        key: "getDefaultObject",
        value: function getDefaultObject() {
          var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          return get(RadialGradient.prototype.__proto__ || Object.getPrototypeOf(RadialGradient.prototype), "getDefaultObject", this).call(this, _extends({
            type: "radial-gradient",
            radialType: "ellipse",
            radialPosition: [Position.CENTER, Position.CENTER]
          }, obj));
        }
      }, {
        key: "toCloneObject",
        value: function toCloneObject() {

          var radialPosition = this.json.radialPosition || [Length.percent(50), Length.percent(50)];

          return _extends({}, get(RadialGradient.prototype.__proto__ || Object.getPrototypeOf(RadialGradient.prototype), "toCloneObject", this).call(this), {
            radialType: this.json.radialType || 'ellipse',
            radialPosition: JSON.parse(JSON.stringify(radialPosition))
          });
        }
      }, {
        key: "isRadial",
        value: function isRadial() {
          return true;
        }
      }, {
        key: "toString",
        value: function toString() {
          if (this.colorsteps.length === 0) return '';
          var colorString = this.getColorString();
          var json = this.json;
          var opt = '';
          var radialType = json.radialType;
          var radialPosition = json.radialPosition || ["center", "center"];

          radialPosition = DEFINED_POSITIONS[radialPosition] ? radialPosition : radialPosition.join(' ');

          opt = radialPosition ? radialType + " at " + radialPosition : radialType;

          return (json.type || "radial-gradient") + "(" + opt + ", " + colorString + ")";
        }
      }], [{
        key: "parse",
        value: function parse$$1(str) {
          var results = convertMatches(str);
          var radialType = "ellipse";
          var radialPosition = [Position.CENTER, Position.CENTER];
          var colorsteps = [];
          results.str.split("(")[1].split(")")[0].split(",").map(function (it) {
            return it.trim();
          }).forEach(function (newValue, index) {
            if (newValue.includes("@")) {
              // color 
              newValue = reverseMatches(newValue, results.matches);

              //  ColorStep  
              // ColorStep   colorsteps  ... ,  
              colorsteps.push.apply(colorsteps, toConsumableArray(ColorStep.parse(newValue)));
            } else {
              // direction
              if (newValue.includes("at")) {
                var _newValue$split$map = newValue.split("at").map(function (it) {
                  return it.trim();
                });
                // at   radialPosition   


                var _newValue$split$map2 = slicedToArray(_newValue$split$map, 2);

                radialType = _newValue$split$map2[0];
                radialPosition = _newValue$split$map2[1];
              } else {
                // at   radialPosition  center, center  
                radialType = newValue;
              }

              if (isString$1(radialPosition)) {
                var arr = radialPosition.split(' ');
                if (arr.length === 1) {
                  var len = Length.parse(arr[0]);

                  if (len.isString()) {
                    radialPosition = [len.value, len.value];
                  } else {
                    radialPosition = [len.clone(), len.clone()];
                  }
                } else if (arr.length === 2) {
                  radialPosition = arr.map(function (it) {
                    var len = Length.parse(it);
                    return len.isString() ? len.value : len;
                  });
                }
              }
            }
          });

          return new RadialGradient({ radialType: radialType, colorsteps: colorsteps });
        }
      }]);
      return RadialGradient;
    }(Gradient);

    var RepeatingRadialGradient = function (_RadialGradient) {
      inherits(RepeatingRadialGradient, _RadialGradient);

      function RepeatingRadialGradient() {
        classCallCheck(this, RepeatingRadialGradient);
        return possibleConstructorReturn(this, (RepeatingRadialGradient.__proto__ || Object.getPrototypeOf(RepeatingRadialGradient)).apply(this, arguments));
      }

      createClass(RepeatingRadialGradient, [{
        key: "getDefaultObject",
        value: function getDefaultObject() {
          return get(RepeatingRadialGradient.prototype.__proto__ || Object.getPrototypeOf(RepeatingRadialGradient.prototype), "getDefaultObject", this).call(this, {
            type: "repeating-radial-gradient"
          });
        }
      }], [{
        key: "parse",
        value: function parse(str) {
          var radial = RadialGradient.parse(str);

          return new RepeatingRadialGradient({
            radialType: radial.radialType,
            radialPosition: radial.radialPosition,
            colorsteps: radial.colorsteps
          });
        }
      }]);
      return RepeatingRadialGradient;
    }(RadialGradient);

    var _DEFINED_POSITIONS$1;

    var DEFINED_POSITIONS$1 = (_DEFINED_POSITIONS$1 = {}, defineProperty(_DEFINED_POSITIONS$1, "center", true), defineProperty(_DEFINED_POSITIONS$1, "top", true), defineProperty(_DEFINED_POSITIONS$1, "left", true), defineProperty(_DEFINED_POSITIONS$1, "right", true), defineProperty(_DEFINED_POSITIONS$1, "bottom", true), _DEFINED_POSITIONS$1);

    var DEFINED_ANGLES$2 = {
      "to top": 0,
      "to top right": 45,
      "to right": 90,
      "to bottom right": 135,
      "to bottom": 180,
      "to bottom left": 225,
      "to left": 270,
      "to top left": 315
    };

    var ConicGradient = function (_Gradient) {
      inherits(ConicGradient, _Gradient);

      function ConicGradient() {
        classCallCheck(this, ConicGradient);
        return possibleConstructorReturn(this, (ConicGradient.__proto__ || Object.getPrototypeOf(ConicGradient)).apply(this, arguments));
      }

      createClass(ConicGradient, [{
        key: "getDefaultObject",
        value: function getDefaultObject() {
          var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          return get(ConicGradient.prototype.__proto__ || Object.getPrototypeOf(ConicGradient.prototype), "getDefaultObject", this).call(this, _extends({
            type: "conic-gradient",
            angle: 0,
            radialPosition: [Position.CENTER, Position.CENTER]
          }, obj));
        }
      }, {
        key: "toCloneObject",
        value: function toCloneObject() {
          return _extends({}, get(ConicGradient.prototype.__proto__ || Object.getPrototypeOf(ConicGradient.prototype), "toCloneObject", this).call(this), {
            angle: this.json.angle,
            radialPosition: JSON.parse(JSON.stringify(this.json.radialPosition))
          });
        }
      }, {
        key: "isConic",
        value: function isConic() {
          return true;
        }
      }, {
        key: "hasAngle",
        value: function hasAngle() {
          return true;
        }
      }, {
        key: "getColorString",
        value: function getColorString() {
          if (this.colorsteps.length === 0) return '';
          var colorsteps = this.colorsteps;
          if (!colorsteps) return '';

          colorsteps.sort(function (a, b) {
            if (a.percent == b.percent) return 0;
            return a.percent > b.percent ? 1 : -1;
          });

          var newColors = colorsteps.map(function (c, index) {
            c.prevColorStep = c.cut && index > 0 ? colorsteps[index - 1] : null;
            return c;
          });

          return newColors.map(function (f) {
            var deg = Math.floor(f.percent * 3.6);
            var prev = '';

            if (f.cut && f.prevColorStep) {
              var prevDeg = Math.floor(f.prevColorStep.percent * 3.6);
              prev = prevDeg + "deg";
            }
            return f.color + " " + prev + " " + deg + "deg";
          }).join(",");
        }
      }, {
        key: "toString",
        value: function toString() {
          var colorString = this.getColorString();

          var opt = [];
          var json = this.json;

          var conicAngle = json.angle;
          var conicPosition = json.radialPosition || Position.CENTER;

          conicPosition = DEFINED_POSITIONS$1[conicPosition] ? conicPosition : conicPosition.join(' ');

          if (isNotUndefined(conicAngle)) {
            conicAngle = +(DEFINED_ANGLES$2[conicAngle] || conicAngle);
            opt.push("from " + conicAngle + "deg");
          }

          if (conicPosition) {
            opt.push("at " + conicPosition);
          }

          var optString = opt.length ? opt.join(' ') + "," : '';

          return json.type + "(" + optString + " " + colorString + ")";
        }
      }], [{
        key: "parse",
        value: function parse$$1(str) {
          var results = convertMatches(str);
          var angle = "0deg"; //
          var radialPosition = [Position.CENTER, Position.CENTER];
          var colorsteps = [];
          results.str.split("(")[1].split(")")[0].split(",").map(function (it) {
            return it.trim();
          }).forEach(function (newValue, index) {
            if (newValue.includes("@")) {
              // conic    deg   gradient    
              // deg  %     .
              newValue = newValue.split(' ').map(function (it) {
                return it.trim();
              }).map(function (it) {
                if (it.includes("deg")) {
                  return Length.parse(it).toPercent();
                } else {
                  return it;
                }
              }).join(' ');

              // color 
              newValue = reverseMatches(newValue, results.matches);

              //  ColorStep  
              // ColorStep   colorsteps  ... ,  
              colorsteps.push.apply(colorsteps, toConsumableArray(ColorStep.parse(newValue)));
            } else {
              // direction
              if (newValue.includes("at")) {
                var _newValue$split$map = newValue.split("at").map(function (it) {
                  return it.trim();
                });
                // at   radialPosition   


                var _newValue$split$map2 = slicedToArray(_newValue$split$map, 2);

                angle = _newValue$split$map2[0];
                radialPosition = _newValue$split$map2[1];
              } else {
                // at   radialPosition  center, center  
                angle = newValue;
              }

              if (isString(radialPosition)) {
                var arr = radialPosition.split(' ');
                if (arr.length === 1) {
                  var len = Length.parse(arr[0]);

                  if (len.isString()) {
                    radialPosition = [len.value, len.value];
                  } else {
                    radialPosition = [len.clone(), len.clone()];
                  }
                } else if (arr.length === 2) {
                  radialPosition = arr.map(function (it) {
                    var len = Length.parse(it);
                    return len.isString() ? len.value : len;
                  });
                }
              }

              if (isString(angle)) {
                if (angle.includes("from")) {
                  angle = angle.split("from")[1];

                  angle = isUndefined(DEFINED_ANGLES$2[angle]) ? Length.parse(angle) : Length.deg(+DEFINED_ANGLES$2[angle]);
                }
              }
            }
          });

          return new ConicGradient({ angle: angle, radialPosition: radialPosition, colorsteps: colorsteps });
        }
      }]);
      return ConicGradient;
    }(Gradient);

    var RepeatingConicGradient = function (_ConicGradient) {
      inherits(RepeatingConicGradient, _ConicGradient);

      function RepeatingConicGradient() {
        classCallCheck(this, RepeatingConicGradient);
        return possibleConstructorReturn(this, (RepeatingConicGradient.__proto__ || Object.getPrototypeOf(RepeatingConicGradient)).apply(this, arguments));
      }

      createClass(RepeatingConicGradient, [{
        key: "getDefaultObject",
        value: function getDefaultObject() {
          return get(RepeatingConicGradient.prototype.__proto__ || Object.getPrototypeOf(RepeatingConicGradient.prototype), "getDefaultObject", this).call(this, {
            type: "repeating-conic-gradient",
            angle: 0,
            radialPosition: [Position.CENTER, Position.CENTER]
          });
        }
      }], [{
        key: "parse",
        value: function parse(str) {
          var conic = ConicGradient.parse(str);

          return new RepeatingConicGradient({
            angle: conic.angle,
            radialPosition: conic.radialPosition,
            colorsteps: conic.colorsteps
          });
        }
      }]);
      return RepeatingConicGradient;
    }(ConicGradient);

    var tabs = [{ type: "linear-gradient", title: "Linear Gradient" }, { type: "repeating-linear-gradient", title: "Repeating Linear Gradient" }, { type: "radial-gradient", title: "Radial Gradient" }, { type: "repeating-radial-gradient", title: "Repeating Radial Gradient" }, { type: "conic-gradient", title: "Conic Gradient" }, { type: "repeating-conic-gradient", title: "Repeating Conic Gradient" }];
    var reg = /((linear\-gradient|repeating\-linear\-gradient|radial\-gradient|repeating\-radial\-gradient|conic\-gradient|repeating\-conic\-gradient|url)\(([^\)]*)\))/gi;

    var GradientPicker$1 = function (_BaseColorPicker) {
      inherits(GradientPicker, _BaseColorPicker);

      function GradientPicker() {
        classCallCheck(this, GradientPicker);
        return possibleConstructorReturn(this, (GradientPicker.__proto__ || Object.getPrototypeOf(GradientPicker)).apply(this, arguments));
      }

      createClass(GradientPicker, [{
        key: "components",
        value: function components() {
          return {
            EmbedColorPicker: EmbedColorPicker,
            gradientEditor: GradientEditor
          };
        }
      }, {
        key: "parseImage",
        value: function parseImage(str) {
          var results = convertMatches(str);
          var image = null;

          results.str.match(reg).forEach(function (value, index) {

            value = reverseMatches(value, results.matches);
            if (value.includes("repeating-linear-gradient")) {
              image = RepeatingLinearGradient.parse(value);
            } else if (value.includes("linear-gradient")) {
              image = LinearGradient.parse(value);
            } else if (value.includes("repeating-radial-gradient")) {
              image = RepeatingRadialGradient.parse(value);
            } else if (value.includes("radial")) {
              image = RadialGradient.parse(value);
            } else if (value.includes("repeating-conic-gradient")) {
              image = RepeatingConicGradient.parse(value);
            } else if (value.includes("conic")) {
              image = ConicGradient.parse(value);
            }
          });

          return image;
        }
      }, {
        key: "callbackColorValue",
        value: function callbackColorValue(color) {
          var gradientString = this.image.toString();
          if (typeof this.opt.onChange == 'function') {
            this.opt.onChange.call(this, gradientString, this.image);
          }

          if (typeof this.colorpickerShowCallback == 'function') {
            this.colorpickerShowCallback(gradientString, this.image);
          }
        }
      }, {
        key: "callbackHideColorValue",
        value: function callbackHideColorValue(color) {
          var gradientString = this.image.toString();
          if (typeof this.opt.onHide == 'function') {
            this.opt.onHide.call(this, gradientString, this.image);
          }

          if (typeof this.colorpickerHideCallback == 'function') {
            this.colorpickerHideCallback(gradientString, this.image);
          }
        }
      }, {
        key: "initialize",
        value: function initialize() {
          get(GradientPicker.prototype.__proto__ || Object.getPrototypeOf(GradientPicker.prototype), "initialize", this).call(this);

          this.$root.addClass('gradient-picker');
          this.selectedTab = "linear-gradient";

          this.setValue(this.opt.gradient || 'linear-gradient(to right, red 0%, yellow 100%)');
        }
      }, {
        key: "setValue",
        value: function setValue(gradientString) {
          this.gradient = gradientString;
          this.image = this.parseImage(this.gradient);
          this.selectTabContent(this.image.type);
        }
      }, {
        key: "getValue",
        value: function getValue() {
          return this.image.toString();
        }
      }, {
        key: "template",
        value: function template() {
          return "\n      <div class=\"gradient-body\">\n\n        <div class='box'>\n          <div class='gradient-preview'>\n            <div class='gradient-view' ref='$gradientView'></div>\n          </div>\n          <div class=\"picker-tab\">\n            <div class=\"picker-tab-list\" ref=\"$tab\" data-value=\"static-gradient\" data-is-image-hidden=\"false\">\n              " + tabs.map(function (it) {
            return "\n                  <span \n                    class='picker-tab-item " + (it.selected ? "selected" : '') + "' \n                    data-selected-value='" + it.type + "'\n                    title='" + it.title + "'\n                  > \n                  <div class='icon'></div>\n                  </span>";
          }).join('') + "\n            </div>\n          </div>\n          <div target='gradientEditor'></div>\n\n        </div>\n        <div class='box'>\n          <div target=\"EmbedColorPicker\"></div>\n        </div>\n      </div>\n     \n    ";
        }
      }, {
        key: "getColorString",
        value: function getColorString() {

          if (!this.image) return '';

          var value = this.image.getColorString();

          return value;
        }
      }, {
        key: "getCurrentStepColor",
        value: function getCurrentStepColor() {
          var colorstep = this.image.colorsteps[this.selectColorStepIndex || 0] || { color: 'rgba(0, 0, 0, 1)' };
          return colorstep.color;
        }
      }, {
        key: '@changeGradientEditor',
        value: function changeGradientEditor(data) {

          var colorsteps = data.colorsteps.map(function (it, index) {
            return new ColorStep({
              color: it.color,
              percent: it.offset.value,
              cut: it.cut,
              index: (index + 1) * 100
            });
          });

          data = _extends({}, data, {
            type: this.selectedTab,
            colorsteps: colorsteps
          });

          this.image.reset(data);

          this.updateGradientPreview();
          this.updateData();
        }
      }, {
        key: "click $tab .picker-tab-item",
        value: function click$tabPickerTabItem(e) {
          var type = e.$delegateTarget.attr("data-selected-value");

          //TODO: picker       .
          this.selectTabContent(type);
        }
      }, {
        key: "selectTabContent",
        value: function selectTabContent(type) {
          this.selectedTab = type;
          this.refs.$tab.attr("data-value", type);

          //   . type  
          //      ?     ?
          // json      .
          //       .
          //   .

          this.image = this.createGradient({ type: type }, this.image);

          this.$store.emit('setGradientEditor', this.getColorString(), this.selectColorStepIndex, this.image.type, this.image.angle, this.image.radialPosition, this.image.radialType);

          var color = this.getCurrentStepColor();

          this['@selectColorStep'](color);

          this.updateGradientPreview();
        }
      }, {
        key: "createGradient",
        value: function createGradient(data, gradient) {
          var colorsteps = data.colorsteps || gradient.colorsteps;

          // linear, conic  angle   .
          var angle = data.angle || gradient.angle;

          // radial   radialType   .
          var radialType = data.radialType || gradient.radialType || 'ellipse';
          var radialPosition = data.radialPosition || gradient.radialPosition || [Length.percent(50), Length.percent(50)];

          var json = gradient.clone().toJSON();
          delete json.itemType;
          delete json.type;

          switch (data.type) {
            case "linear-gradient":
              return new LinearGradient({ colorsteps: colorsteps, angle: angle });
            case "repeating-linear-gradient":
              return new RepeatingLinearGradient({ colorsteps: colorsteps, angle: angle });
            case "radial-gradient":
              return new RadialGradient({
                colorsteps: colorsteps,
                radialType: radialType,
                radialPosition: radialPosition
              });
            case "repeating-radial-gradient":
              return new RepeatingRadialGradient({
                colorsteps: colorsteps,
                radialType: radialType,
                radialPosition: radialPosition
              });
            case "conic-gradient":
              return new ConicGradient({
                colorsteps: colorsteps,
                angle: angle,
                radialPosition: radialPosition
              });
            case "repeating-conic-gradient":
              return new RepeatingConicGradient({
                colorsteps: colorsteps,
                angle: angle,
                radialPosition: radialPosition
              });
          }

          return new Gradient();
        }
      }, {
        key: '@changeEmbedColorPicker',
        value: function changeEmbedColorPicker(color) {
          this.$store.emit('setColorStepColor', color);
        }
      }, {
        key: "@selectColorStep",
        value: function selectColorStep(color) {
          this.EmbedColorPicker.setValue(color);
        }
      }, {
        key: '@changeColorStep',
        value: function changeColorStep() {
          var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};


          this.image.reset(_extends({}, data));

          this.updateGradientPreview();
          // this.updateData();
        }
      }, {
        key: "updateGradientPreview",
        value: function updateGradientPreview() {
          if (this.image) {
            this.refs.$gradientView.css('background-image', this.image.toString());
            this.updateData();
          }
        }
      }, {
        key: "updateData",
        value: function updateData() {
          this.callbackChange();
        }
      }]);
      return GradientPicker;
    }(BaseColorPicker);

    var GradientPicker = {
        createGradientPicker: function createGradientPicker(opts) {
            return new GradientPicker$1(opts);
        }
    };

    var index = _extends({}, Util, ColorPickerUI, GradientPicker);

    return index;

    })));
    }(colorpicker));

    var ColorPickerUI = colorpicker.exports;

    // @ts-ignore
    function useColorPicker(selector, ctx, props) {
        const elementRef = query(selector);
        const { unmountedGroup } = useUnmounted();
        const contextRef = useContext$1(ctx);
        let colorPicker = null;
        let instance = null;
        let toggle = false;
        let container = null;
        const onShow = (id) => {
            if (id && id !== props.id)
                return;
            colorPicker = ColorPickerUI.create({
                type: 'sketch',
                position: 'inline',
                container,
                color: props.color || '',
                onChange: (color) => {
                    props.color = color;
                },
            });
            const tooltip = colorPicker.$root.el;
            instance = createPopper(elementRef.value, tooltip, {
                placement: 'bottom',
                modifiers: [
                    {
                        name: 'offset',
                        options: {
                            offset: [0, 10],
                        },
                    },
                ],
            });
            tooltip.setAttribute('data-show', '');
            toggle = true;
        };
        const onHide = () => {
            instance === null || instance === void 0 ? void 0 : instance.destroy();
            colorPicker === null || colorPicker === void 0 ? void 0 : colorPicker.$root.el.remove();
            instance = null;
            colorPicker = null;
            toggle = false;
        };
        const onClick = () => {
            const { eventBus } = contextRef.value;
            if (toggle) {
                onHide();
            }
            else {
                eventBus.emit(Bus.ColorPicker.close);
                onShow();
            }
        };
        beforeMount(() => {
            const { eventBus } = contextRef.value;
            unmountedGroup.push(eventBus.on(Bus.ColorPicker.close).subscribe(onHide), eventBus.on(Bus.ColorPicker.open).subscribe(onShow));
        });
        mounted(() => {
            container = closestElement('.vuerd-editor', ctx);
            elementRef.value.addEventListener('click', onClick);
        });
        unmounted(() => {
            var _a;
            (_a = elementRef.value) === null || _a === void 0 ? void 0 : _a.removeEventListener('click', onClick);
            onHide();
        });
    }

    function useResizeMemo(props, ctx) {
        const contextRef = useContext$1(ctx);
        let clientX = 0;
        let clientY = 0;
        const resizeWidth = ({ movementX, x }, direction) => {
            const ui = Object.assign({ change: false }, props.memo.ui);
            const mouseDirection = movementX < 0 ? 'left' : 'right';
            const width = direction === 'left' ? ui.width - movementX : ui.width + movementX;
            switch (mouseDirection) {
                case 'left':
                    if (SIZE_MEMO_WIDTH < width && x < clientX) {
                        direction === 'left' && (ui.left += movementX);
                        clientX += movementX;
                        ui.width = width;
                        ui.change = true;
                    }
                    break;
                case 'right':
                    if (SIZE_MEMO_WIDTH < width && x > clientX) {
                        direction === 'left' && (ui.left += movementX);
                        clientX += movementX;
                        ui.width = width;
                        ui.change = true;
                    }
                    break;
            }
            return ui;
        };
        const resizeHeight = ({ movementY, y }, direction) => {
            const ui = Object.assign({ change: false }, props.memo.ui);
            const mouseDirection = movementY < 0 ? 'top' : 'bottom';
            const height = direction === 'top' ? ui.height - movementY : ui.height + movementY;
            switch (mouseDirection) {
                case 'top':
                    if (SIZE_MEMO_HEIGHT < height && y < clientY) {
                        direction === 'top' && (ui.top += movementY);
                        clientY += movementY;
                        ui.height = height;
                        ui.change = true;
                    }
                    break;
                case 'bottom':
                    if (SIZE_MEMO_HEIGHT < height && y > clientY) {
                        direction === 'top' && (ui.top += movementY);
                        clientY += movementY;
                        ui.height = height;
                        ui.change = true;
                    }
                    break;
            }
            return ui;
        };
        const onMousemoveSash = (move, position) => {
            move.event.preventDefault();
            const { store } = contextRef.value;
            let verticalUI = null;
            let horizontalUI = null;
            switch (position) {
                case 'left':
                case 'right':
                    verticalUI = resizeWidth(move, position);
                    break;
                case 'top':
                case 'bottom':
                    horizontalUI = resizeHeight(move, position);
                    break;
                case 'lt':
                    verticalUI = resizeWidth(move, 'left');
                    horizontalUI = resizeHeight(move, 'top');
                    break;
                case 'rt':
                    verticalUI = resizeWidth(move, 'right');
                    horizontalUI = resizeHeight(move, 'top');
                    break;
                case 'lb':
                    verticalUI = resizeWidth(move, 'left');
                    horizontalUI = resizeHeight(move, 'bottom');
                    break;
                case 'rb':
                    verticalUI = resizeWidth(move, 'right');
                    horizontalUI = resizeHeight(move, 'bottom');
                    break;
            }
            if ((verticalUI === null || verticalUI === void 0 ? void 0 : verticalUI.change) && (horizontalUI === null || horizontalUI === void 0 ? void 0 : horizontalUI.change)) {
                store.dispatch(resizeMemo(props.memo.id, horizontalUI.top, verticalUI.left, verticalUI.width, horizontalUI.height));
            }
            else if (verticalUI === null || verticalUI === void 0 ? void 0 : verticalUI.change) {
                store.dispatch(resizeMemo(props.memo.id, verticalUI.top, verticalUI.left, verticalUI.width, verticalUI.height));
            }
            else if (horizontalUI === null || horizontalUI === void 0 ? void 0 : horizontalUI.change) {
                store.dispatch(resizeMemo(props.memo.id, horizontalUI.top, horizontalUI.left, horizontalUI.width, horizontalUI.height));
            }
        };
        const onMousedownSash = (event, position) => {
            const { drag$ } = contextRef.value.globalEvent;
            clientX = event.clientX;
            clientY = event.clientY;
            drag$.subscribe(move => onMousemoveSash(move, position));
        };
        return {
            onMousedownSash,
        };
    }

    const createSash = (top, left) => [
        {
            vertical: true,
            position: 'left',
        },
        {
            vertical: true,
            position: 'right',
            left,
        },
        // {
        //   horizontal: true,
        //   position: 'top',
        // },
        {
            horizontal: true,
            position: 'bottom',
            top,
        },
        {
            edge: true,
            position: 'lt',
            cursor: 'nwse-resize',
        },
        {
            edge: true,
            position: 'rt',
            cursor: 'nesw-resize',
            left,
        },
        {
            edge: true,
            position: 'lb',
            cursor: 'nesw-resize',
            top,
        },
        {
            edge: true,
            position: 'rb',
            cursor: 'nwse-resize',
            top,
            left,
        },
    ];
    const sashTpl = (top, left, onMousedownSash) => createSash(top, left).map(sash => {
        var _a, _b;
        return html `
        <vuerd-sash
          ?vertical=${sash.vertical}
          ?horizontal=${sash.horizontal}
          ?edge=${sash.edge}
          .cursor=${sash.cursor}
          .top=${(_a = sash.top) !== null && _a !== void 0 ? _a : 0}
          .left=${(_b = sash.left) !== null && _b !== void 0 ? _b : 0}
          @mousedown=${(event) => onMousedownSash(event, sash.position)}
        ></vuerd-sash>
      `;
    });

    const MEMO_PADDING$1 = SIZE_MEMO_PADDING * 2;
    const MEMO_HEADER$1 = 6 + MEMO_PADDING$1;
    const ANIMATION_TIME$5 = 300;
    const Memo = (props, ctx) => {
        const contextRef = useContext$1(ctx);
        const { onMousedownSash } = useResizeMemo(props, ctx);
        const { unmountedGroup } = useUnmounted();
        const textareaRef = query('.vuerd-memo-textarea');
        const state = observable$1({ color: '' });
        useColorPicker('.vuerd-memo-header-color', ctx, state);
        useTooltip(['.vuerd-button'], ctx);
        let leftTween = null;
        let topTween = null;
        const onMove = ({ event, movementX, movementY }) => {
            event.type === 'mousemove' && event.preventDefault();
            const { store } = contextRef.value;
            store.dispatch(moveMemo(store, event.ctrlKey || event.metaKey, movementX, movementY, props.memo.id));
        };
        const onMoveStart = (event) => {
            const el = event.target;
            const { store, globalEvent, eventBus } = contextRef.value;
            const { drag$ } = globalEvent;
            if (!el.closest('.vuerd-button') &&
                !el.closest('vuerd-sash') &&
                !el.closest('.vuerd-memo-textarea')) {
                leftTween === null || leftTween === void 0 ? void 0 : leftTween.stop();
                topTween === null || topTween === void 0 ? void 0 : topTween.stop();
                drag$.subscribe({
                    next: onMove,
                    complete: () => eventBus.emit(Bus.BalanceRange.move),
                });
            }
            store.dispatch(selectMemo$(store, event.ctrlKey || event.metaKey, props.memo.id));
        };
        const onRemoveMemo = () => {
            const { store } = contextRef.value;
            store.dispatch(removeMemo(store, props.memo.id));
        };
        const onInput = (event) => {
            const { store } = contextRef.value;
            const textarea = event.target;
            store.dispatch(changeMemoValue(props.memo.id, textarea.value));
        };
        const onBlur = () => ctx.dispatchEvent(new CustomEvent('vuerd-input-blur', {
            composed: true,
            bubbles: true,
        }));
        const moveBalance = () => {
            const { canvasState: { width, height }, } = contextRef.value.store;
            const minWidth = width - (props.memo.ui.width + MEMO_PADDING$1);
            const minHeight = height - (props.memo.ui.height + MEMO_PADDING$1 + MEMO_HEADER$1);
            const x = props.memo.ui.left > minWidth ? minWidth : 0;
            const y = props.memo.ui.top > minHeight ? minHeight : 0;
            if (props.memo.ui.left < 0 || props.memo.ui.left > minWidth) {
                leftTween = new Tween(props.memo.ui)
                    .to({ left: x }, ANIMATION_TIME$5)
                    .easing(Easing.Quadratic.Out)
                    .onComplete(() => (leftTween = null))
                    .start();
            }
            if (props.memo.ui.top < 0 || props.memo.ui.top > minHeight) {
                topTween = new Tween(props.memo.ui)
                    .to({ top: y }, ANIMATION_TIME$5)
                    .easing(Easing.Quadratic.Out)
                    .onComplete(() => (topTween = null))
                    .start();
            }
        };
        beforeMount(() => {
            const { eventBus, store } = contextRef.value;
            state.color = props.memo.ui.color || '';
            unmountedGroup.push(eventBus.on(Bus.BalanceRange.move).subscribe(moveBalance), watch(state, propName => {
                if (propName !== 'color')
                    return;
                store.dispatch(changeColorMemo(store, true, state.color, props.memo.id));
            }));
        });
        mounted(() => {
            const textarea = textareaRef.value;
            if (!textarea || !props.memo.ui.active)
                return;
            textarea.focus();
        });
        return () => {
            var _a;
            const { keymap, store: { editorState: { readonly }, }, } = contextRef.value;
            const { memo } = props;
            const width = memo.ui.width + MEMO_PADDING$1;
            const height = memo.ui.height + MEMO_PADDING$1 + MEMO_HEADER$1;
            return html `
      <div
        class=${classMap({
            'vuerd-memo': true,
            active: memo.ui.active,
        })}
        style=${styleMap({
            top: `${memo.ui.top}px`,
            left: `${memo.ui.left}px`,
            zIndex: `${memo.ui.zIndex}`,
            width: `${width}px`,
            height: `${height}px`,
        })}
        @mousedown=${onMoveStart}
        @touchstart=${onMoveStart}
      >
        <div class="vuerd-memo-header">
          <div
            class="vuerd-memo-header-color"
            style=${styleMap({
            backgroundColor: (_a = memo.ui.color) !== null && _a !== void 0 ? _a : '',
        })}
          ></div>
          <vuerd-icon
            class="vuerd-button"
            name="times"
            size="12"
            data-tippy-content=${keymapOptionsToString(keymap.removeTable)}
            @click=${onRemoveMemo}
          ></vuerd-icon>
        </div>
        <textarea
          class="vuerd-memo-textarea vuerd-scrollbar"
          style=${styleMap({
            width: `${memo.ui.width}px`,
            height: `${memo.ui.height}px`,
        })}
          spellcheck="false"
          ?disabled=${readonly}
          .value=${memo.value}
          @input=${onInput}
          @wheel=${onStopPropagation}
          @blur=${onBlur}
        ></textarea>
        ${sashTpl(height, width, onMousedownSash)}
      </div>
    `;
        };
    };
    defineComponent('vuerd-memo', {
        shadow: false,
        observedProps: ['memo'],
        render: Memo,
    });

    const Input = (props, ctx) => {
        const { unmountedGroup } = useUnmounted();
        const inputRef = query('input');
        const getClassMap = () => ({
            'vuerd-input': true,
            placeholder: props.value.trim() === '' && !props.edit,
            focus: props.focusState && !props.edit,
            edit: props.edit,
            select: props.select,
            active: props.active,
        });
        const getPlaceholderValue = () => props.value.trim() === '' ? props.placeholder : props.value;
        const onBlur = () => ctx.dispatchEvent(new CustomEvent('vuerd-input-blur', {
            composed: true,
            bubbles: true,
        }));
        const onKeyup = (event) => {
            if (event.code === 'Enter') {
                ctx.dispatchEvent(new CustomEvent('keyup-enter'));
            }
        };
        beforeMount(() => unmountedGroup.push(watch(props, propName => {
            const input = inputRef.value;
            if (propName !== 'edit' || !props.edit || !input)
                return;
            lastCursorFocus(input);
        }),
        // firefox
        watch(props, propName => {
            if (propName !== 'edit')
                return;
            props.edit || onBlur();
        })));
        return () => props.edit
            ? html `
          <input
            class=${classMap(getClassMap())}
            style=${styleMap({
            width: `${props.width}px`,
        })}
            type="text"
            spellcheck="false"
            .value=${props.value}
            placeholder=${props.placeholder}
            @keyup=${onKeyup}
            @blur=${onBlur}
          />
        `
            : html `
          <div
            class=${classMap(getClassMap())}
            style=${styleMap({
            width: `${props.width}px`,
        })}
          >
            <span>${getPlaceholderValue()}</span>
          </div>
        `;
    };
    defineComponent('vuerd-input', {
        observedProps: [
            {
                name: 'edit',
                type: Boolean,
                default: false,
            },
            {
                name: 'focusState',
                type: Boolean,
                default: false,
            },
            {
                name: 'select',
                type: Boolean,
                default: false,
            },
            {
                name: 'active',
                type: Boolean,
                default: false,
            },
            {
                name: 'width',
                type: Number,
                default: SIZE_MIN_WIDTH,
            },
            {
                name: 'value',
                default: '',
            },
            {
                name: 'placeholder',
                default: '',
            },
        ],
        shadow: false,
        styleMap: {
            display: 'inline-flex',
        },
        render: Input,
    });

    const ColumnKey = (props, ctx) => {
        return () => html `
    <div
      class=${classMap({
        'vuerd-column-key': true,
        pk: props.ui.pk,
        fk: props.ui.fk,
        pfk: props.ui.pfk,
    })}
    >
      <vuerd-icon size="12" name="key"></vuerd-icon>
    </div>
  `;
    };
    defineComponent('vuerd-column-key', {
        observedProps: ['ui'],
        shadow: false,
        styleMap: {
            display: 'flex',
            height: '100%',
            alignItems: 'center',
        },
        render: ColumnKey,
    });

    const findIndex$3 = findIndex$5(propEq$1('active', true));
    function useDataTypeHint$1(props, ctx) {
        const contextRef = useContext$1(ctx);
        const { unmountedGroup } = useUnmounted();
        const state = observable$1({
            hints: [],
            isFilter: true,
        });
        const getDataTypeHints = () => {
            const { store: { canvasState }, } = contextRef.value;
            const databaseHint = databaseHints.find(databaseHint => databaseHint.database === canvasState.database);
            return databaseHint ? databaseHint.dataTypeHints : [];
        };
        const getActiveIndex = () => findIndex$3(state.hints);
        const setHints = () => {
            if (!state.isFilter)
                return;
            const dataTypeHints = getDataTypeHints();
            state.hints =
                props.value.trim() === ''
                    ? dataTypeHints.map(dataTypeHint => ({
                        name: dataTypeHint.name,
                        html: dataTypeHint.name,
                        active: false,
                    }))
                    : dataTypeHints
                        .filter(dataTypeHint => dataTypeHint.name
                        .toLowerCase()
                        .indexOf(props.value.toLowerCase()) !== -1)
                        .map(dataTypeHint => {
                        return {
                            name: dataTypeHint.name,
                            html: markToHTML('vuerd-data-type-hint-mark', dataTypeHint.name, props.value),
                            active: false,
                        };
                    });
        };
        const activeEnd = () => {
            state.hints.forEach(hint => (hint.active = false));
        };
        const onSelectHint = (hint) => {
            const { store, helper } = contextRef.value;
            activeEnd();
            state.isFilter = false;
            store.dispatch(changeColumnDataType(helper, props.tableId, props.columnId, hint.name));
        };
        const onArrowUp = (event) => {
            state.hints.length !== 0 && event.preventDefault();
            const index = getActiveIndex();
            if (index > 0) {
                state.hints[index].active = false;
                state.hints[index - 1].active = true;
            }
            else if (state.hints.length) {
                index === 0 && (state.hints[index].active = false);
                state.hints[state.hints.length - 1].active = true;
            }
        };
        const onArrowDown = (event) => {
            state.hints.length !== 0 && event.preventDefault();
            const index = getActiveIndex();
            if (index !== -1 && index !== state.hints.length - 1) {
                state.hints[index].active = false;
                state.hints[index + 1].active = true;
            }
            else if (state.hints.length) {
                index === state.hints.length - 1 && (state.hints[index].active = false);
                state.hints[0].active = true;
            }
        };
        const onArrowLeft = () => activeEnd();
        const onArrowRight = (event) => {
            const index = getActiveIndex();
            if (index < 0)
                return;
            event.preventDefault();
            const { store, helper } = contextRef.value;
            state.isFilter = false;
            store.dispatch(changeColumnDataType(helper, props.tableId, props.columnId, state.hints[index].name));
        };
        const arrowMap = {
            ArrowUp: onArrowUp,
            ArrowDown: onArrowDown,
            ArrowLeft: onArrowLeft,
            ArrowRight: onArrowRight,
        };
        const onKeydown = (event) => {
            switch (event.key) {
                case 'ArrowUp':
                case 'ArrowDown':
                case 'ArrowLeft':
                case 'ArrowRight':
                    arrowMap[event.key](event);
                    break;
            }
        };
        const onInput = () => (state.isFilter = true);
        beforeMount(() => {
            const { store: { canvasState }, } = contextRef.value;
            unmountedGroup.push(watch(props, propName => {
                if (propName !== 'value')
                    return;
                setHints();
            }), watch(canvasState, propName => {
                if (propName !== 'database')
                    return;
                state.isFilter = true;
                setHints();
            }));
        });
        return {
            hintState: state,
            onSelectHint,
            onKeydown,
            onInput,
        };
    }

    /**
     * FLIP stands for First, Last, Invert, Play.
     * https://aerotwist.com/blog/flip-your-animations/
     */
    class FlipAnimation {
        constructor(root, selector, animationName) {
            this.flipSnapshots = [];
            this.root = root;
            this.selector = selector;
            this.animationName = animationName;
        }
        snapshot() {
            this.flipSnapshots = [];
            this.root.querySelectorAll(this.selector).forEach(el => {
                // first
                const { top, left } = el.getBoundingClientRect();
                this.flipSnapshots.push({ el, top, left });
            });
        }
        play() {
            if (!this.flipSnapshots.length)
                return;
            this.flipSnapshots.forEach(snapshot => {
                // last
                const el = snapshot.el;
                const { top, left } = el.getBoundingClientRect();
                const dx = snapshot.left - left;
                const dy = snapshot.top - top;
                if (dx || dy) {
                    // invert
                    el.style.transform = `translate(${dx}px,${dy}px)`;
                    el.style.transitionDuration = '0s';
                    // play
                    requestAnimationFrame(() => {
                        el.classList.add(this.animationName);
                        el.style.transform = '';
                        el.style.transitionDuration = '';
                        const onTransitionend = () => {
                            el.classList.remove(this.animationName);
                            el.removeEventListener('transitionend', onTransitionend);
                        };
                        el.addEventListener('transitionend', onTransitionend);
                    });
                }
            });
            this.flipSnapshots = [];
        }
    }

    function useFlipAnimation(ctx, selector, animationName) {
        const flipAnimation = new FlipAnimation(ctx.shadowRoot ? ctx.shadowRoot : ctx, selector, animationName);
        beforeUpdate(() => flipAnimation.snapshot());
        updated(() => flipAnimation.play());
    }

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    // Helper functions for manipulating parts
    // TODO(kschaaf): Refactor into Part API?
    const createAndInsertPart = (containerPart, beforePart) => {
        const container = containerPart.startNode.parentNode;
        const beforeNode = beforePart === undefined ? containerPart.endNode :
            beforePart.startNode;
        const startNode = container.insertBefore(createMarker(), beforeNode);
        container.insertBefore(createMarker(), beforeNode);
        const newPart = new NodePart(containerPart.options);
        newPart.insertAfterNode(startNode);
        return newPart;
    };
    const updatePart = (part, value) => {
        part.setValue(value);
        part.commit();
        return part;
    };
    const insertPartBefore = (containerPart, part, ref) => {
        const container = containerPart.startNode.parentNode;
        const beforeNode = ref ? ref.startNode : containerPart.endNode;
        const endNode = part.endNode.nextSibling;
        if (endNode !== beforeNode) {
            reparentNodes(container, part.startNode, endNode, beforeNode);
        }
    };
    const removePart = (part) => {
        removeNodes(part.startNode.parentNode, part.startNode, part.endNode.nextSibling);
    };
    // Helper for generating a map of array item to its index over a subset
    // of an array (used to lazily generate `newKeyToIndexMap` and
    // `oldKeyToIndexMap`)
    const generateMap = (list, start, end) => {
        const map = new Map();
        for (let i = start; i <= end; i++) {
            map.set(list[i], i);
        }
        return map;
    };
    // Stores previous ordered list of parts and map of key to index
    const partListCache = new WeakMap();
    const keyListCache = new WeakMap();
    /**
     * A directive that repeats a series of values (usually `TemplateResults`)
     * generated from an iterable, and updates those items efficiently when the
     * iterable changes based on user-provided `keys` associated with each item.
     *
     * Note that if a `keyFn` is provided, strict key-to-DOM mapping is maintained,
     * meaning previous DOM for a given key is moved into the new position if
     * needed, and DOM will never be reused with values for different keys (new DOM
     * will always be created for new keys). This is generally the most efficient
     * way to use `repeat` since it performs minimum unnecessary work for insertions
     * and removals.
     *
     * IMPORTANT: If providing a `keyFn`, keys *must* be unique for all items in a
     * given call to `repeat`. The behavior when two or more items have the same key
     * is undefined.
     *
     * If no `keyFn` is provided, this directive will perform similar to mapping
     * items to values, and DOM will be reused against potentially different items.
     */
    const repeat = directive((items, keyFnOrTemplate, template) => {
        let keyFn;
        if (template === undefined) {
            template = keyFnOrTemplate;
        }
        else if (keyFnOrTemplate !== undefined) {
            keyFn = keyFnOrTemplate;
        }
        return (containerPart) => {
            if (!(containerPart instanceof NodePart)) {
                throw new Error('repeat can only be used in text bindings');
            }
            // Old part & key lists are retrieved from the last update
            // (associated with the part for this instance of the directive)
            const oldParts = partListCache.get(containerPart) || [];
            const oldKeys = keyListCache.get(containerPart) || [];
            // New part list will be built up as we go (either reused from
            // old parts or created for new keys in this update). This is
            // saved in the above cache at the end of the update.
            const newParts = [];
            // New value list is eagerly generated from items along with a
            // parallel array indicating its key.
            const newValues = [];
            const newKeys = [];
            let index = 0;
            for (const item of items) {
                newKeys[index] = keyFn ? keyFn(item, index) : index;
                newValues[index] = template(item, index);
                index++;
            }
            // Maps from key to index for current and previous update; these
            // are generated lazily only when needed as a performance
            // optimization, since they are only required for multiple
            // non-contiguous changes in the list, which are less common.
            let newKeyToIndexMap;
            let oldKeyToIndexMap;
            // Head and tail pointers to old parts and new values
            let oldHead = 0;
            let oldTail = oldParts.length - 1;
            let newHead = 0;
            let newTail = newValues.length - 1;
            // Overview of O(n) reconciliation algorithm (general approach
            // based on ideas found in ivi, vue, snabbdom, etc.):
            //
            // * We start with the list of old parts and new values (and
            //   arrays of their respective keys), head/tail pointers into
            //   each, and we build up the new list of parts by updating
            //   (and when needed, moving) old parts or creating new ones.
            //   The initial scenario might look like this (for brevity of
            //   the diagrams, the numbers in the array reflect keys
            //   associated with the old parts or new values, although keys
            //   and parts/values are actually stored in parallel arrays
            //   indexed using the same head/tail pointers):
            //
            //      oldHead v                 v oldTail
            //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]
            //   newParts: [ ,  ,  ,  ,  ,  ,  ]
            //   newKeys:  [0, 2, 1, 4, 3, 7, 6] <- reflects the user's new
            //                                      item order
            //      newHead ^                 ^ newTail
            //
            // * Iterate old & new lists from both sides, updating,
            //   swapping, or removing parts at the head/tail locations
            //   until neither head nor tail can move.
            //
            // * Example below: keys at head pointers match, so update old
            //   part 0 in-place (no need to move it) and record part 0 in
            //   the `newParts` list. The last thing we do is advance the
            //   `oldHead` and `newHead` pointers (will be reflected in the
            //   next diagram).
            //
            //      oldHead v                 v oldTail
            //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]
            //   newParts: [0,  ,  ,  ,  ,  ,  ] <- heads matched: update 0
            //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead
            //                                      & newHead
            //      newHead ^                 ^ newTail
            //
            // * Example below: head pointers don't match, but tail
            //   pointers do, so update part 6 in place (no need to move
            //   it), and record part 6 in the `newParts` list. Last,
            //   advance the `oldTail` and `oldHead` pointers.
            //
            //         oldHead v              v oldTail
            //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]
            //   newParts: [0,  ,  ,  ,  ,  , 6] <- tails matched: update 6
            //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldTail
            //                                      & newTail
            //         newHead ^              ^ newTail
            //
            // * If neither head nor tail match; next check if one of the
            //   old head/tail items was removed. We first need to generate
            //   the reverse map of new keys to index (`newKeyToIndexMap`),
            //   which is done once lazily as a performance optimization,
            //   since we only hit this case if multiple non-contiguous
            //   changes were made. Note that for contiguous removal
            //   anywhere in the list, the head and tails would advance
            //   from either end and pass each other before we get to this
            //   case and removals would be handled in the final while loop
            //   without needing to generate the map.
            //
            // * Example below: The key at `oldTail` was removed (no longer
            //   in the `newKeyToIndexMap`), so remove that part from the
            //   DOM and advance just the `oldTail` pointer.
            //
            //         oldHead v           v oldTail
            //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]
            //   newParts: [0,  ,  ,  ,  ,  , 6] <- 5 not in new map: remove
            //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    5 and advance oldTail
            //         newHead ^           ^ newTail
            //
            // * Once head and tail cannot move, any mismatches are due to
            //   either new or moved items; if a new key is in the previous
            //   "old key to old index" map, move the old part to the new
            //   location, otherwise create and insert a new part. Note
            //   that when moving an old part we null its position in the
            //   oldParts array if it lies between the head and tail so we
            //   know to skip it when the pointers get there.
            //
            // * Example below: neither head nor tail match, and neither
            //   were removed; so find the `newHead` key in the
            //   `oldKeyToIndexMap`, and move that old part's DOM into the
            //   next head position (before `oldParts[oldHead]`). Last,
            //   null the part in the `oldPart` array since it was
            //   somewhere in the remaining oldParts still to be scanned
            //   (between the head and tail pointers) so that we know to
            //   skip that old part on future iterations.
            //
            //         oldHead v        v oldTail
            //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
            //   newParts: [0, 2,  ,  ,  ,  , 6] <- stuck: update & move 2
            //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    into place and advance
            //                                      newHead
            //         newHead ^           ^ newTail
            //
            // * Note that for moves/insertions like the one above, a part
            //   inserted at the head pointer is inserted before the
            //   current `oldParts[oldHead]`, and a part inserted at the
            //   tail pointer is inserted before `newParts[newTail+1]`. The
            //   seeming asymmetry lies in the fact that new parts are
            //   moved into place outside in, so to the right of the head
            //   pointer are old parts, and to the right of the tail
            //   pointer are new parts.
            //
            // * We always restart back from the top of the algorithm,
            //   allowing matching and simple updates in place to
            //   continue...
            //
            // * Example below: the head pointers once again match, so
            //   simply update part 1 and record it in the `newParts`
            //   array.  Last, advance both head pointers.
            //
            //         oldHead v        v oldTail
            //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
            //   newParts: [0, 2, 1,  ,  ,  , 6] <- heads matched: update 1
            //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead
            //                                      & newHead
            //            newHead ^        ^ newTail
            //
            // * As mentioned above, items that were moved as a result of
            //   being stuck (the final else clause in the code below) are
            //   marked with null, so we always advance old pointers over
            //   these so we're comparing the next actual old value on
            //   either end.
            //
            // * Example below: `oldHead` is null (already placed in
            //   newParts), so advance `oldHead`.
            //
            //            oldHead v     v oldTail
            //   oldKeys:  [0, 1, -, 3, 4, 5, 6] <- old head already used:
            //   newParts: [0, 2, 1,  ,  ,  , 6]    advance oldHead
            //   newKeys:  [0, 2, 1, 4, 3, 7, 6]
            //               newHead ^     ^ newTail
            //
            // * Note it's not critical to mark old parts as null when they
            //   are moved from head to tail or tail to head, since they
            //   will be outside the pointer range and never visited again.
            //
            // * Example below: Here the old tail key matches the new head
            //   key, so the part at the `oldTail` position and move its
            //   DOM to the new head position (before `oldParts[oldHead]`).
            //   Last, advance `oldTail` and `newHead` pointers.
            //
            //               oldHead v  v oldTail
            //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
            //   newParts: [0, 2, 1, 4,  ,  , 6] <- old tail matches new
            //   newKeys:  [0, 2, 1, 4, 3, 7, 6]   head: update & move 4,
            //                                     advance oldTail & newHead
            //               newHead ^     ^ newTail
            //
            // * Example below: Old and new head keys match, so update the
            //   old head part in place, and advance the `oldHead` and
            //   `newHead` pointers.
            //
            //               oldHead v oldTail
            //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
            //   newParts: [0, 2, 1, 4, 3,   ,6] <- heads match: update 3
            //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance oldHead &
            //                                      newHead
            //                  newHead ^  ^ newTail
            //
            // * Once the new or old pointers move past each other then all
            //   we have left is additions (if old list exhausted) or
            //   removals (if new list exhausted). Those are handled in the
            //   final while loops at the end.
            //
            // * Example below: `oldHead` exceeded `oldTail`, so we're done
            //   with the main loop.  Create the remaining part and insert
            //   it at the new head position, and the update is complete.
            //
            //                   (oldHead > oldTail)
            //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
            //   newParts: [0, 2, 1, 4, 3, 7 ,6] <- create and insert 7
            //   newKeys:  [0, 2, 1, 4, 3, 7, 6]
            //                     newHead ^ newTail
            //
            // * Note that the order of the if/else clauses is not
            //   important to the algorithm, as long as the null checks
            //   come first (to ensure we're always working on valid old
            //   parts) and that the final else clause comes last (since
            //   that's where the expensive moves occur). The order of
            //   remaining clauses is is just a simple guess at which cases
            //   will be most common.
            //
            // * TODO(kschaaf) Note, we could calculate the longest
            //   increasing subsequence (LIS) of old items in new position,
            //   and only move those not in the LIS set. However that costs
            //   O(nlogn) time and adds a bit more code, and only helps
            //   make rare types of mutations require fewer moves. The
            //   above handles removes, adds, reversal, swaps, and single
            //   moves of contiguous items in linear time, in the minimum
            //   number of moves. As the number of multiple moves where LIS
            //   might help approaches a random shuffle, the LIS
            //   optimization becomes less helpful, so it seems not worth
            //   the code at this point. Could reconsider if a compelling
            //   case arises.
            while (oldHead <= oldTail && newHead <= newTail) {
                if (oldParts[oldHead] === null) {
                    // `null` means old part at head has already been used
                    // below; skip
                    oldHead++;
                }
                else if (oldParts[oldTail] === null) {
                    // `null` means old part at tail has already been used
                    // below; skip
                    oldTail--;
                }
                else if (oldKeys[oldHead] === newKeys[newHead]) {
                    // Old head matches new head; update in place
                    newParts[newHead] =
                        updatePart(oldParts[oldHead], newValues[newHead]);
                    oldHead++;
                    newHead++;
                }
                else if (oldKeys[oldTail] === newKeys[newTail]) {
                    // Old tail matches new tail; update in place
                    newParts[newTail] =
                        updatePart(oldParts[oldTail], newValues[newTail]);
                    oldTail--;
                    newTail--;
                }
                else if (oldKeys[oldHead] === newKeys[newTail]) {
                    // Old head matches new tail; update and move to new tail
                    newParts[newTail] =
                        updatePart(oldParts[oldHead], newValues[newTail]);
                    insertPartBefore(containerPart, oldParts[oldHead], newParts[newTail + 1]);
                    oldHead++;
                    newTail--;
                }
                else if (oldKeys[oldTail] === newKeys[newHead]) {
                    // Old tail matches new head; update and move to new head
                    newParts[newHead] =
                        updatePart(oldParts[oldTail], newValues[newHead]);
                    insertPartBefore(containerPart, oldParts[oldTail], oldParts[oldHead]);
                    oldTail--;
                    newHead++;
                }
                else {
                    if (newKeyToIndexMap === undefined) {
                        // Lazily generate key-to-index maps, used for removals &
                        // moves below
                        newKeyToIndexMap = generateMap(newKeys, newHead, newTail);
                        oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);
                    }
                    if (!newKeyToIndexMap.has(oldKeys[oldHead])) {
                        // Old head is no longer in new list; remove
                        removePart(oldParts[oldHead]);
                        oldHead++;
                    }
                    else if (!newKeyToIndexMap.has(oldKeys[oldTail])) {
                        // Old tail is no longer in new list; remove
                        removePart(oldParts[oldTail]);
                        oldTail--;
                    }
                    else {
                        // Any mismatches at this point are due to additions or
                        // moves; see if we have an old part we can reuse and move
                        // into place
                        const oldIndex = oldKeyToIndexMap.get(newKeys[newHead]);
                        const oldPart = oldIndex !== undefined ? oldParts[oldIndex] : null;
                        if (oldPart === null) {
                            // No old part for this value; create a new one and
                            // insert it
                            const newPart = createAndInsertPart(containerPart, oldParts[oldHead]);
                            updatePart(newPart, newValues[newHead]);
                            newParts[newHead] = newPart;
                        }
                        else {
                            // Reuse old part
                            newParts[newHead] =
                                updatePart(oldPart, newValues[newHead]);
                            insertPartBefore(containerPart, oldPart, oldParts[oldHead]);
                            // This marks the old part as having been used, so that
                            // it will be skipped in the first two checks above
                            oldParts[oldIndex] = null;
                        }
                        newHead++;
                    }
                }
            }
            // Add parts for any remaining new values
            while (newHead <= newTail) {
                // For all remaining additions, we insert before last new
                // tail, since old pointers are no longer valid
                const newPart = createAndInsertPart(containerPart, newParts[newTail + 1]);
                updatePart(newPart, newValues[newHead]);
                newParts[newHead++] = newPart;
            }
            // Remove any remaining unused old parts
            while (oldHead <= oldTail) {
                const oldPart = oldParts[oldHead++];
                if (oldPart !== null) {
                    removePart(oldPart);
                }
            }
            // Save order of new parts for next round
            partListCache.set(containerPart, newParts);
            keyListCache.set(containerPart, newKeys);
        };
    });

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    // For each part, remember the value that was last rendered to the part by the
    // unsafeHTML directive, and the DocumentFragment that was last set as a value.
    // The DocumentFragment is used as a unique key to check if the last value
    // rendered to the part was with unsafeHTML. If not, we'll always re-render the
    // value passed to unsafeHTML.
    const previousValues = new WeakMap();
    /**
     * Renders the result as HTML, rather than text.
     *
     * Note, this is unsafe to use with any user-provided input that hasn't been
     * sanitized or escaped, as it may lead to cross-site-scripting
     * vulnerabilities.
     */
    const unsafeHTML = directive((value) => (part) => {
        if (!(part instanceof NodePart)) {
            throw new Error('unsafeHTML can only be used in text bindings');
        }
        const previousValue = previousValues.get(part);
        if (previousValue !== undefined && isPrimitive(value) &&
            value === previousValue.value && part.value === previousValue.fragment) {
            return;
        }
        const template = document.createElement('template');
        template.innerHTML = value; // innerHTML casts to string internally
        const fragment = document.importNode(template.content, true);
        part.setValue(fragment);
        previousValues.set(part, { value, fragment });
    });

    const dataTypeHintTpl = (props, state) => html `
  <ul class="vuerd-column-data-type-hint">
    ${repeat(state.hints, hint => hint.name, hint => {
    return html `
          <li
            class=${classMap({
        'vuerd-data-type-hint': true,
        active: hint.active,
    })}
            @click=${() => props.onSelectHint(hint)}
          >
            ${unsafeHTML(hint.html)}
          </li>
        `;
})}
  </ul>
`;

    const ColumnDataType = (props, ctx) => {
        const { hintState, onSelectHint, onKeydown, onInput } = useDataTypeHint$1(props, ctx);
        const { unmountedGroup } = useUnmounted();
        let subscription = null;
        useFlipAnimation(ctx, '.vuerd-data-type-hint', 'vuerd-data-type-hint-move');
        const emitBlur = () => ctx.dispatchEvent(new CustomEvent('vuerd-input-blur', {
            composed: true,
            bubbles: true,
        }));
        const onBlur = (event) => {
            event.stopPropagation();
            const input = queryShadowSelector(['vuerd-input', 'input'], ctx);
            input && props.edit ? setTimeout(lastCursorFocus, 0, input) : emitBlur();
        };
        const onMousedown = (event) => {
            const el = event.target;
            if (props.edit && !el.closest('.vuerd-column-data-type')) {
                emitBlur();
            }
        };
        const offERDMousedown = () => {
            subscription === null || subscription === void 0 ? void 0 : subscription.unsubscribe();
            subscription = null;
        };
        const onERDMousedown = () => {
            const erd = closestElement('.vuerd-erd', ctx);
            if (!erd)
                return;
            if (props.edit) {
                offERDMousedown();
                subscription = fromEvent(erd, 'mousedown').subscribe(onMousedown);
            }
        };
        beforeMount(() => {
            unmountedGroup.push(watch(props, propName => {
                if (propName !== 'edit')
                    return;
                props.edit ? onERDMousedown() : offERDMousedown();
            }));
            onERDMousedown();
        });
        unmounted(() => offERDMousedown());
        return () => html `
    <div class="vuerd-column-data-type">
      <vuerd-input
        .width=${props.width}
        .value=${props.value}
        .focusState=${props.focusState}
        .edit=${props.edit}
        .select=${props.select}
        .active=${props.active}
        placeholder="dataType"
        @keydown=${onKeydown}
        @input=${onInput}
        @vuerd-input-blur=${onBlur}
      ></vuerd-input>
      ${props.edit ? dataTypeHintTpl({ onSelectHint }, hintState) : null}
    </div>
  `;
    };
    defineComponent('vuerd-column-data-type', {
        observedProps: [
            'edit',
            'focusState',
            'select',
            'active',
            'width',
            'value',
            'placeholder',
            'tableId',
            'columnId',
        ],
        shadow: false,
        render: ColumnDataType,
    });

    const ColumnNotNull = props => () => html `
    <div
      class=${classMap({
    'vuerd-column-not-null': true,
    focus: props.focusState,
})}
      style=${styleMap({
    width: `${SIZE_COLUMN_OPTION_NN}px`,
})}
    >
      ${props.columnOption.notNull ? 'N-N' : 'NULL'}
    </div>
  `;
    defineComponent('vuerd-column-not-null', {
        observedProps: [
            {
                name: 'focusState',
                default: false,
            },
            'columnOption',
        ],
        shadow: false,
        render: ColumnNotNull,
    });

    const ColumnUnique = (props, ctx) => {
        useTooltip(['.vuerd-column-unique'], ctx);
        return () => html `
    <div
      class=${classMap({
        'vuerd-column-unique': true,
        focus: props.focusState,
        checked: props.columnOption.unique,
    })}
      style=${styleMap({
        width: `${SIZE_COLUMN_OPTION_UQ}px`,
    })}
      data-tippy-content="Unique"
    >
      UQ
    </div>
  `;
    };
    defineComponent('vuerd-column-unique', {
        observedProps: [
            {
                name: 'focusState',
                default: false,
            },
            'columnOption',
        ],
        shadow: false,
        render: ColumnUnique,
    });

    const ColumnAutoIncrement = (props, ctx) => {
        useTooltip(['.vuerd-column-auto-increment'], ctx);
        return () => html `
    <div
      class=${classMap({
        'vuerd-column-auto-increment': true,
        focus: props.focusState,
        checked: props.columnOption.autoIncrement,
    })}
      style=${styleMap({
        width: `${SIZE_COLUMN_OPTION_AI}px`,
    })}
      data-tippy-content="Auto Increment"
    >
      AI
    </div>
  `;
    };
    defineComponent('vuerd-column-auto-increment', {
        observedProps: [
            {
                name: 'focusState',
                default: false,
            },
            'columnOption',
        ],
        shadow: false,
        render: ColumnAutoIncrement,
    });

    function columnTpl$1(props, { store, helper }, { onInput, onFocus, onBlur, onEdit }) {
        const { canvasState: { show, setting }, } = store;
        const { column } = props;
        const { ui } = column;
        const reshapeColumns = setting.columnOrder
            .map(columnType => {
            switch (columnType) {
                case 'columnName':
                    return {
                        columnType,
                        template: html `
              <vuerd-input
                .width=${props.widthName}
                .value=${column.name}
                .active=${ui.active}
                .select=${props.select}
                .focusState=${props.focusName}
                .edit=${props.editName}
                placeholder="column"
                @vuerd-input-blur=${onBlur}
                @input=${(event) => onInput(event, 'columnName')}
                @mousedown=${(event) => onFocus(event, 'columnName')}
                @dblclick=${() => onEdit('columnName')}
              ></vuerd-input>
            `,
                    };
                case 'columnDefault':
                    return show.columnDefault
                        ? {
                            columnType,
                            template: html `
                  <vuerd-input
                    .width=${props.widthDefault}
                    .value=${column.default}
                    .active=${ui.active}
                    .select=${props.select}
                    .focusState=${props.focusDefault}
                    .edit=${props.editDefault}
                    placeholder="default"
                    @vuerd-input-blur=${onBlur}
                    @input=${(event) => onInput(event, 'columnDefault')}
                    @mousedown=${(event) => onFocus(event, 'columnDefault')}
                    @dblclick=${() => onEdit('columnDefault')}
                  ></vuerd-input>
                `,
                        }
                        : null;
                case 'columnComment':
                    return show.columnComment
                        ? {
                            columnType,
                            template: html `
                  <vuerd-input
                    class="vuerd-column-comment"
                    .width=${props.widthComment}
                    .value=${column.comment}
                    .active=${ui.active}
                    .select=${props.select}
                    .edit=${props.editComment}
                    .focusState=${props.focusComment}
                    placeholder="comment"
                    data-tippy-content=${column.comment.trim()
                            ? column.comment
                            : 'comment'}
                    @vuerd-input-blur=${onBlur}
                    @input=${(event) => onInput(event, 'columnComment')}
                    @mousedown=${(event) => onFocus(event, 'columnComment')}
                    @dblclick=${() => onEdit('columnComment')}
                  ></vuerd-input>
                `,
                        }
                        : null;
                case 'columnDataType':
                    return show.columnDataType
                        ? {
                            columnType,
                            template: html `
                  <vuerd-column-data-type
                    .width=${props.widthDataType}
                    .value=${column.dataType}
                    .active=${ui.active}
                    .tableId=${props.tableId}
                    .columnId=${column.id}
                    .select=${props.select}
                    .focusState=${props.focusDataType}
                    .edit=${props.editDataType}
                    @vuerd-input-blur=${onBlur}
                    @input=${(event) => onInput(event, 'columnDataType')}
                    @mousedown=${(event) => onFocus(event, 'columnDataType')}
                    @dblclick=${() => onEdit('columnDataType')}
                  ></vuerd-column-data-type>
                `,
                        }
                        : null;
                case 'columnNotNull':
                    return show.columnNotNull
                        ? {
                            columnType,
                            template: html `
                  <vuerd-column-not-null
                    .columnOption=${column.option}
                    .focusState=${props.focusNotNull}
                    @mousedown=${(event) => onFocus(event, 'columnNotNull')}
                    @dblclick=${() => onEdit('columnNotNull')}
                  ></vuerd-column-not-null>
                `,
                        }
                        : null;
                case 'columnUnique':
                    return show.columnUnique
                        ? {
                            columnType,
                            template: html `
                  <vuerd-column-unique
                    .columnOption=${column.option}
                    .focusState=${props.focusUnique}
                    @mousedown=${(event) => onFocus(event, 'columnUnique')}
                    @dblclick=${() => onEdit('columnUnique')}
                  ></vuerd-column-unique>
                `,
                        }
                        : null;
                case 'columnAutoIncrement':
                    return show.columnAutoIncrement
                        ? {
                            columnType,
                            template: html `
                  <vuerd-column-auto-increment
                    .columnOption=${column.option}
                    .focusState=${props.focusAutoIncrement}
                    @mousedown=${(event) => onFocus(event, 'columnAutoIncrement')}
                    @dblclick=${() => onEdit('columnAutoIncrement')}
                  ></vuerd-column-auto-increment>
                `,
                        }
                        : null;
                default:
                    return null;
            }
        })
            .filter(reshapeColumn => !!reshapeColumn);
        return repeat(reshapeColumns, reshapeColumn => reshapeColumn.columnType, reshapeColumn => reshapeColumn.template);
    }

    const changeColumnMap$1 = {
        columnName: changeColumnName,
        columnComment: changeColumnComment,
        columnDataType: changeColumnDataType,
        columnDefault: changeColumnDefault,
    };
    const changeColumnBooleanMap = {
        columnNotNull: changeColumnNotNull,
        columnUnique: changeColumnUnique,
        columnAutoIncrement: changeColumnAutoIncrement,
    };
    const changeColumnBooleanKeys = [
        'columnNotNull',
        'columnUnique',
        'columnAutoIncrement',
    ];
    const Column$1 = (props, ctx) => {
        const contextRef = useContext$1(ctx);
        useTooltip(['.vuerd-column-button'], ctx, { placement: 'right' });
        const { resetTooltip } = useTooltip(['.vuerd-column-comment'], ctx, {
            placement: 'right',
        });
        const { unmountedGroup } = useUnmounted();
        const dragover$ = new Subject();
        const onRemoveColumn = () => {
            const { store } = contextRef.value;
            store.dispatch(removeColumn$(store, props.tableId, [props.column.id]));
        };
        const onDragstart = (event) => {
            const { store } = contextRef.value;
            store.dispatch(draggableColumn(store, props.tableId, props.column.id, event.ctrlKey || event.metaKey));
        };
        const onDragend = () => {
            const { store } = contextRef.value;
            store.dispatch(draggableColumnEnd());
        };
        const onDragover = () => dragover$.next(null);
        const onDragoverColumn = () => ctx.dispatchEvent(new CustomEvent('dragover-column', {
            detail: {
                tableId: props.tableId,
                columnId: props.column.id,
            },
        }));
        const onInput = (event, columnType) => {
            const { store, helper } = contextRef.value;
            const changeColumn = changeColumnMap$1[columnType];
            if (!changeColumn)
                return;
            const input = event.target;
            store.dispatch(changeColumn(helper, props.tableId, props.column.id, input.value));
        };
        const onFocus = (event, columnType) => {
            const { store } = contextRef.value;
            store.dispatch(focusColumn(props.tableId, props.column.id, columnType, event.ctrlKey || event.metaKey, event.shiftKey));
        };
        const onBlur = () => {
            const { store } = contextRef.value;
            store.dispatch(editTableEnd());
        };
        const onEdit = (columnType) => {
            const { store } = contextRef.value;
            if (changeColumnBooleanKeys.includes(columnType)) {
                const changeColumn = changeColumnBooleanMap[columnType];
                store.dispatch(changeColumn(store, props.tableId, props.column.id));
            }
            else {
                store.dispatch(editTable());
            }
        };
        dragover$.pipe(throttleTime(300)).subscribe(onDragoverColumn);
        beforeMount(() => {
            const { show } = contextRef.value.store.canvasState;
            unmountedGroup.push(watch(props.column, propName => {
                if (propName !== 'comment')
                    return;
                resetTooltip();
            }), watch(show, propName => {
                if (propName !== 'columnComment')
                    return;
                resetTooltip();
            }));
        });
        return () => {
            const { keymap } = contextRef.value;
            const { column } = props;
            const { ui } = column;
            return html `
      <div
        class=${classMap({
            'vuerd-column': true,
            select: props.select,
            draggable: props.draggable,
            active: ui.active,
        })}
        data-id=${column.id}
        draggable="true"
        @dragstart=${onDragstart}
        @dragend=${onDragend}
        @dragover=${onDragover}
      >
        <vuerd-column-key .ui=${ui}></vuerd-column-key>
        ${columnTpl$1(props, contextRef.value, {
            onInput,
            onFocus,
            onBlur,
            onEdit,
        })}
        <vuerd-icon
          class="vuerd-button vuerd-column-button"
          data-tippy-content=${keymapOptionsToString(keymap.removeColumn)}
          name="times"
          size="9"
          @click=${onRemoveColumn}
        ></vuerd-icon>
      </div>
    `;
        };
    };
    defineComponent('vuerd-column', {
        observedProps: [
            'tableId',
            'column',
            'select',
            'draggable',
            'focusName',
            'focusDataType',
            'focusNotNull',
            'focusDefault',
            'focusComment',
            'focusUnique',
            'focusAutoIncrement',
            'editName',
            'editDataType',
            'editDefault',
            'editComment',
            'widthName',
            'widthDataType',
            'widthDefault',
            'widthComment',
        ],
        shadow: false,
        styleMap: {
            display: 'flex',
        },
        render: Column$1,
    });

    function isFocus$1(focusTable, focusType, tableId, columnId = null) {
        if (!focusTable || tableId !== focusTable.table.id)
            return false;
        switch (focusType) {
            case 'tableName':
            case 'tableComment':
                return focusType === focusTable.focusType;
        }
        return columnId === focusTable.columnId && focusType === focusTable.focusType;
    }
    const isSelectColumn = (focusTable, tableId, columnId) => (focusTable === null || focusTable === void 0 ? void 0 : focusTable.table.id) === tableId &&
        focusTable.selectColumnIds.includes(columnId);
    function isEdit$1(focusTable, focusType, tableId, columnId = null) {
        if (!focusTable || tableId !== focusTable.table.id)
            return false;
        switch (focusType) {
            case 'tableName':
            case 'tableComment':
                return focusType === focusTable.focusType && focusTable.edit;
        }
        return (columnId === focusTable.columnId &&
            focusType === focusTable.focusType &&
            focusTable.edit);
    }
    const isDraggableColumn = (draggableColumn, tableId, columnId) => (draggableColumn === null || draggableColumn === void 0 ? void 0 : draggableColumn.tableId) === tableId &&
        draggableColumn.columnIds.includes(columnId);

    function useHasTable(props, ctx) {
        const contextRef = useContext$1(ctx);
        const getFocusTable = () => contextRef.value.store.editorState.focusTable;
        const hasFocusState = (focusType, columnId) => isFocus$1(getFocusTable(), focusType, props.table.id, columnId);
        const hasEdit = (focusType, columnId) => isEdit$1(getFocusTable(), focusType, props.table.id, columnId);
        const hasSelectColumn = (columnId) => isSelectColumn(getFocusTable(), props.table.id, columnId);
        const hasDraggableColumn = (columnId) => {
            const draggableColumn = contextRef.value.store.editorState.draggableColumn;
            return isDraggableColumn(draggableColumn, props.table.id, columnId);
        };
        return {
            hasFocusState,
            hasEdit,
            hasSelectColumn,
            hasDraggableColumn,
        };
    }

    const TABLE_PADDING$2 = (SIZE_TABLE_PADDING + SIZE_TABLE_BORDER) * 2;
    const ANIMATION_TIME$4 = 300;
    const Table$1 = (props, ctx) => {
        var _a;
        const contextRef = useContext$1(ctx);
        const { hasFocusState, hasEdit, hasSelectColumn, hasDraggableColumn } = useHasTable(props, ctx);
        useTooltip(['.vuerd-table-button'], ctx);
        const { resetTooltip } = useTooltip(['.vuerd-table-comment'], ctx);
        const flipAnimation = new FlipAnimation(ctx.shadowRoot ? ctx.shadowRoot : ctx, 'vuerd-column', 'vuerd-column-move');
        const draggable$ = new Subject();
        const { unmountedGroup } = useUnmounted();
        const state = observable$1({ color: '', id: (_a = props.table) === null || _a === void 0 ? void 0 : _a.id });
        useColorPicker('.vuerd-table-header-color', ctx, state);
        let leftTween = null;
        let topTween = null;
        const onInput = (event, focusType) => {
            const { store, helper } = contextRef.value;
            const input = event.target;
            switch (focusType) {
                case 'tableName':
                    store.dispatch(changeTableName(helper, props.table.id, input.value));
                    break;
                case 'tableComment':
                    store.dispatch(changeTableComment(helper, props.table.id, input.value));
                    break;
            }
        };
        const onMove = ({ event, movementX, movementY }) => {
            event.type === 'mousemove' && event.preventDefault();
            const { store } = contextRef.value;
            store.dispatch(moveTable(store, event.ctrlKey || event.metaKey, movementX, movementY, props.table.id));
        };
        const onMoveStart = (event) => {
            const el = event.target;
            const { store, globalEvent, eventBus } = contextRef.value;
            const { drag$ } = globalEvent;
            if (!el.closest('.vuerd-button') && !el.closest('vuerd-input')) {
                leftTween === null || leftTween === void 0 ? void 0 : leftTween.stop();
                topTween === null || topTween === void 0 ? void 0 : topTween.stop();
                drag$.subscribe({
                    next: onMove,
                    complete: () => eventBus.emit(Bus.BalanceRange.move),
                });
            }
            store.dispatch(selectTable$(store, event.ctrlKey || event.metaKey, props.table.id));
        };
        const onRemoveTable = () => {
            const { store } = contextRef.value;
            store.dispatch(removeTable(store, props.table.id));
        };
        const onAddColumn = () => {
            const { store } = contextRef.value;
            store.dispatch(addColumn$(store, props.table.id));
        };
        const onFocus = (focusType) => {
            const { store } = contextRef.value;
            store.dispatch(focusTable(props.table.id, focusType));
        };
        const onBlur = () => {
            const { store } = contextRef.value;
            store.dispatch(editTableEnd());
        };
        const onEdit = () => {
            const { store } = contextRef.value;
            store.dispatch(editTable());
        };
        const onDragoverGroupColumn = (event) => draggable$.next(event);
        const onDraggableColumn = (event) => {
            const { store } = contextRef.value;
            const { editorState: { draggableColumn }, } = store;
            const { tableId, columnId } = event.detail;
            if (!draggableColumn || draggableColumn.columnIds.includes(columnId))
                return;
            flipAnimation.snapshot();
            store.dispatch(moveColumn$(store, draggableColumn.tableId, draggableColumn.columnIds, tableId, columnId));
        };
        const moveBalance = () => {
            const { canvasState: { width, height }, tableState: { tables }, relationshipState: { relationships }, } = contextRef.value.store;
            const minWidth = width - (props.table.width() + TABLE_PADDING$2);
            const minHeight = height - (props.table.height() + TABLE_PADDING$2);
            const x = props.table.ui.left > minWidth ? minWidth : 0;
            const y = props.table.ui.top > minHeight ? minHeight : 0;
            if (props.table.ui.left < 0 || props.table.ui.left > minWidth) {
                leftTween = new Tween(props.table.ui)
                    .to({ left: x }, ANIMATION_TIME$4)
                    .easing(Easing.Quadratic.Out)
                    .onUpdate(() => relationshipSort(tables, relationships))
                    .onComplete(() => (leftTween = null))
                    .start();
            }
            if (props.table.ui.top < 0 || props.table.ui.top > minHeight) {
                topTween = new Tween(props.table.ui)
                    .to({ top: y }, ANIMATION_TIME$4)
                    .easing(Easing.Quadratic.Out)
                    .onUpdate(() => relationshipSort(tables, relationships))
                    .onComplete(() => (topTween = null))
                    .start();
            }
        };
        updated(() => flipAnimation.play());
        beforeMount(() => {
            const { eventBus, store } = contextRef.value;
            const { canvasState: { show }, } = store;
            state.color = props.table.ui.color || '';
            unmountedGroup.push(draggable$.pipe(debounceTime(50)).subscribe(onDraggableColumn), eventBus.on(Bus.BalanceRange.move).subscribe(moveBalance), watch(props.table, propName => {
                if (propName !== 'comment')
                    return;
                resetTooltip();
            }), watch(show, propName => {
                if (propName !== 'tableComment')
                    return;
                resetTooltip();
            }), watch(state, propName => {
                if (propName !== 'color')
                    return;
                store.dispatch(changeColorTable(store, true, state.color, props.table.id));
            }));
        });
        return () => {
            var _a;
            const { keymap, store: { canvasState: { show }, }, } = contextRef.value;
            const { table } = props;
            const { ui, columns } = table;
            const widthColumn = table.maxWidthColumn();
            state.id = table.id;
            return html `
      <div
        class=${classMap({
            'vuerd-table': true,
            active: ui.active,
        })}
        style=${styleMap({
            top: `${ui.top}px`,
            left: `${ui.left}px`,
            zIndex: `${ui.zIndex}`,
            width: `${table.width()}px`,
            height: `${table.height()}px`,
        })}
        data-id=${table.id}
        @mousedown=${onMoveStart}
        @touchstart=${onMoveStart}
      >
        <div class="vuerd-table-header">
          <div
            class="vuerd-table-header-color"
            style=${styleMap({
            width: `${table.width() + SIZE_TABLE_PADDING * 2}px`,
            backgroundColor: (_a = ui.color) !== null && _a !== void 0 ? _a : '',
        })}
          ></div>
          <div class="vuerd-table-header-top">
            <vuerd-icon
              class="vuerd-button vuerd-table-button"
              data-tippy-content=${keymapOptionsToString(keymap.removeTable)}
              name="times"
              size="12"
              @click=${onRemoveTable}
            ></vuerd-icon>
            <vuerd-icon
              class="vuerd-button vuerd-table-button"
              data-tippy-content=${keymapOptionsToString(keymap.addColumn)}
              name="plus"
              size="12"
              @click=${onAddColumn}
            ></vuerd-icon>
          </div>
          <div class="vuerd-table-header-body">
            <vuerd-input
              class="vuerd-table-name"
              .width=${table.ui.widthName}
              .value=${table.name}
              .focusState=${hasFocusState('tableName')}
              .edit=${hasEdit('tableName')}
              placeholder="table"
              @input=${(event) => onInput(event, 'tableName')}
              @mousedown=${() => onFocus('tableName')}
              @dblclick=${onEdit}
              @vuerd-input-blur=${onBlur}
            ></vuerd-input>
            ${show.tableComment
            ? html `
                  <vuerd-input
                    class="vuerd-table-comment"
                    .width=${table.ui.widthComment}
                    .value=${table.comment}
                    .focusState=${hasFocusState('tableComment')}
                    .edit=${hasEdit('tableComment')}
                    placeholder="comment"
                    data-tippy-content=${table.comment.trim()
                ? table.comment
                : 'comment'}
                    @input=${(event) => onInput(event, 'tableComment')}
                    @mousedown=${() => onFocus('tableComment')}
                    @dblclick=${onEdit}
                    @vuerd-input-blur=${onBlur}
                  ></vuerd-input>
                `
            : null}
          </div>
        </div>
        <div
          class="vuerd-table-body"
          @dragenter=${onPreventDefault}
          @dragover=${onPreventDefault}
        >
          ${repeat(columns, column => column.id, column => html `
                <vuerd-column
                  .tableId=${table.id}
                  .column=${column}
                  .select=${hasSelectColumn(column.id)}
                  .draggable=${hasDraggableColumn(column.id)}
                  .focusName=${hasFocusState('columnName', column.id)}
                  .focusDataType=${hasFocusState('columnDataType', column.id)}
                  .focusNotNull=${hasFocusState('columnNotNull', column.id)}
                  .focusDefault=${hasFocusState('columnDefault', column.id)}
                  .focusComment=${hasFocusState('columnComment', column.id)}
                  .focusUnique=${hasFocusState('columnUnique', column.id)}
                  .focusAutoIncrement=${hasFocusState('columnAutoIncrement', column.id)}
                  .editName=${hasEdit('columnName', column.id)}
                  .editComment=${hasEdit('columnComment', column.id)}
                  .editDataType=${hasEdit('columnDataType', column.id)}
                  .editDefault=${hasEdit('columnDefault', column.id)}
                  .widthName=${widthColumn.name}
                  .widthComment=${widthColumn.comment}
                  .widthDataType=${widthColumn.dataType}
                  .widthDefault=${widthColumn.default}
                  @dragover-column=${onDragoverGroupColumn}
                ></vuerd-column>
              `)}
        </div>
      </div>
    `;
        };
    };
    defineComponent('vuerd-table', {
        observedProps: ['table'],
        shadow: false,
        render: Table$1,
    });

    const TABLE_PADDING$1 = (SIZE_TABLE_PADDING + SIZE_TABLE_BORDER) * 2;
    const ANIMATION_TIME$3 = 300;
    const HighLevelTable = (props, ctx) => {
        const contextRef = useContext$1(ctx);
        const { unmountedGroup } = useUnmounted();
        const state = observable$1({ color: '' });
        useColorPicker('.vuerd-table-header-color', ctx, state);
        let leftTween = null;
        let topTween = null;
        const getFontSize = () => {
            const { zoomLevel } = contextRef.value.store.canvasState;
            let fontSize = 25;
            if (zoomLevel > 0.6) {
                fontSize = 25;
            }
            else if (zoomLevel > 0.5) {
                fontSize = 30;
            }
            else if (zoomLevel > 0.4) {
                fontSize = 35;
            }
            else if (zoomLevel > 0.3) {
                fontSize = 40;
            }
            else {
                fontSize = 45;
            }
            return fontSize;
        };
        const onMove = ({ event, movementX, movementY }) => {
            event.type === 'mousemove' && event.preventDefault();
            const { store } = contextRef.value;
            store.dispatch(moveTable(store, event.ctrlKey || event.metaKey, movementX, movementY, props.table.id));
        };
        const onMoveStart = (event) => {
            const el = event.target;
            const { store, globalEvent, eventBus } = contextRef.value;
            const { drag$ } = globalEvent;
            if (!el.closest('.vuerd-button') && !el.closest('vuerd-input')) {
                leftTween === null || leftTween === void 0 ? void 0 : leftTween.stop();
                topTween === null || topTween === void 0 ? void 0 : topTween.stop();
                drag$.subscribe({
                    next: onMove,
                    complete: () => eventBus.emit(Bus.BalanceRange.move),
                });
            }
            store.dispatch(selectTable$(store, event.ctrlKey || event.metaKey, props.table.id));
        };
        const moveBalance = () => {
            const { canvasState: { width, height }, tableState: { tables }, relationshipState: { relationships }, } = contextRef.value.store;
            const minWidth = width - (props.table.width() + TABLE_PADDING$1);
            const minHeight = height - (props.table.height() + TABLE_PADDING$1);
            const x = props.table.ui.left > minWidth ? minWidth : 0;
            const y = props.table.ui.top > minHeight ? minHeight : 0;
            if (props.table.ui.left < 0 || props.table.ui.left > minWidth) {
                leftTween = new Tween(props.table.ui)
                    .to({ left: x }, ANIMATION_TIME$3)
                    .easing(Easing.Quadratic.Out)
                    .onUpdate(() => relationshipSort(tables, relationships))
                    .onComplete(() => (leftTween = null))
                    .start();
            }
            if (props.table.ui.top < 0 || props.table.ui.top > minHeight) {
                topTween = new Tween(props.table.ui)
                    .to({ top: y }, ANIMATION_TIME$3)
                    .easing(Easing.Quadratic.Out)
                    .onUpdate(() => relationshipSort(tables, relationships))
                    .onComplete(() => (topTween = null))
                    .start();
            }
        };
        beforeMount(() => {
            const { eventBus, store } = contextRef.value;
            state.color = props.table.ui.color || '';
            unmountedGroup.push(eventBus.on(Bus.BalanceRange.move).subscribe(moveBalance), watch(state, propName => {
                if (propName !== 'color')
                    return;
                store.dispatch(changeColorTable(store, true, state.color, props.table.id));
            }));
        });
        return () => {
            var _a;
            const { table } = props;
            const { ui } = table;
            table.maxWidthColumn();
            return html `
      <div
        class=${classMap({
            'vuerd-table': true,
            active: ui.active,
        })}
        style=${styleMap({
            top: `${ui.top}px`,
            left: `${ui.left}px`,
            zIndex: `${ui.zIndex}`,
            width: `${table.width()}px`,
            height: `${table.height()}px`,
        })}
        data-id=${table.id}
        @mousedown=${onMoveStart}
        @touchstart=${onMoveStart}
      >
        <div class="vuerd-table-header">
          <div
            class="vuerd-table-header-color"
            style=${styleMap({
            width: `${table.width() + SIZE_TABLE_PADDING * 2}px`,
            backgroundColor: (_a = ui.color) !== null && _a !== void 0 ? _a : '',
        })}
          ></div>
        </div>
        <div
          class="vuerd-high-level-table vuerd-scrollbar"
          style=${styleMap({
            fontSize: `${getFontSize()}px`,
        })}
        >
          ${table.name}
        </div>
      </div>
    `;
        };
    };
    defineComponent('vuerd-high-level-table', {
        observedProps: ['table'],
        shadow: false,
        render: HighLevelTable,
    });

    const DrawRelationship = (props, ctx) => {
        const contextRef = useContext$1(ctx);
        const { unmountedGroup } = useUnmounted();
        beforeMount(() => {
            const { store } = contextRef.value;
            const erd = closestElement('.vuerd-erd', ctx);
            if (!erd)
                return;
            unmountedGroup.push(fromEvent(erd, 'mousemove').subscribe(event => {
                event.preventDefault();
                const { x, y } = erd.getBoundingClientRect();
                store.dispatch(drawRelationship(event.clientX - x, event.clientY - y));
            }));
        });
        return () => {
            const { store: { canvasState }, } = contextRef.value;
            const { path, line } = getDraw(props.draw);
            return svg `
       <svg
        class="vuerd-draw-relationship"
        style=${styleMap({
            width: `${canvasState.width}px`,
            height: `${canvasState.height}px`,
        })}
      >
        <g>
          <path
            d=${path.path.d()}
            stroke-dasharray="10"
            stroke-width="3"
            fill="transparent"
          ></path>
          <line
            x1=${path.line.start.x1} y1=${path.line.start.y1}
            x2=${path.line.start.x2} y2=${path.line.start.y2}
            stroke-width="3"
          ></line>
          <line
            x1=${line.start.base.x1} y1=${line.start.base.y1}
            x2=${line.start.base.x2} y2=${line.start.base.y2}
            stroke-width="3"
          ></line>
          <line
            x1=${line.start.base2.x1} y1=${line.start.base2.y1}
            x2=${line.start.base2.x2} y2=${line.start.base2.y2}
            stroke-width="3"
          ></line>
          <line
            x1=${line.start.center2.x1} y1=${line.start.center2.y1}
            x2=${line.start.center2.x2} y2=${line.start.center2.y2}
            stroke-width="3"
          ></line>
        </g>
      </svg>
  `;
        };
    };
    defineComponent('vuerd-draw-relationship', {
        observedProps: ['draw'],
        shadow: false,
        render: DrawRelationship,
    });

    var heap$1 = {exports: {}};

    (function (module) {
    // Generated by CoffeeScript 1.8.0
    (function() {
      var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;

      floor = Math.floor, min = Math.min;


      /*
      Default comparison function to be used
       */

      defaultCmp = function(x, y) {
        if (x < y) {
          return -1;
        }
        if (x > y) {
          return 1;
        }
        return 0;
      };


      /*
      Insert item x in list a, and keep it sorted assuming a is sorted.

      If x is already in a, insert it to the right of the rightmost x.

      Optional args lo (default 0) and hi (default a.length) bound the slice
      of a to be searched.
       */

      insort = function(a, x, lo, hi, cmp) {
        var mid;
        if (lo == null) {
          lo = 0;
        }
        if (cmp == null) {
          cmp = defaultCmp;
        }
        if (lo < 0) {
          throw new Error('lo must be non-negative');
        }
        if (hi == null) {
          hi = a.length;
        }
        while (lo < hi) {
          mid = floor((lo + hi) / 2);
          if (cmp(x, a[mid]) < 0) {
            hi = mid;
          } else {
            lo = mid + 1;
          }
        }
        return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);
      };


      /*
      Push item onto heap, maintaining the heap invariant.
       */

      heappush = function(array, item, cmp) {
        if (cmp == null) {
          cmp = defaultCmp;
        }
        array.push(item);
        return _siftdown(array, 0, array.length - 1, cmp);
      };


      /*
      Pop the smallest item off the heap, maintaining the heap invariant.
       */

      heappop = function(array, cmp) {
        var lastelt, returnitem;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        lastelt = array.pop();
        if (array.length) {
          returnitem = array[0];
          array[0] = lastelt;
          _siftup(array, 0, cmp);
        } else {
          returnitem = lastelt;
        }
        return returnitem;
      };


      /*
      Pop and return the current smallest value, and add the new item.

      This is more efficient than heappop() followed by heappush(), and can be
      more appropriate when using a fixed size heap. Note that the value
      returned may be larger than item! That constrains reasonable use of
      this routine unless written as part of a conditional replacement:
          if item > array[0]
            item = heapreplace(array, item)
       */

      heapreplace = function(array, item, cmp) {
        var returnitem;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        returnitem = array[0];
        array[0] = item;
        _siftup(array, 0, cmp);
        return returnitem;
      };


      /*
      Fast version of a heappush followed by a heappop.
       */

      heappushpop = function(array, item, cmp) {
        var _ref;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        if (array.length && cmp(array[0], item) < 0) {
          _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
          _siftup(array, 0, cmp);
        }
        return item;
      };


      /*
      Transform list into a heap, in-place, in O(array.length) time.
       */

      heapify = function(array, cmp) {
        var i, _i, _len, _ref1, _results, _results1;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        _ref1 = (function() {
          _results1 = [];
          for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }
          return _results1;
        }).apply(this).reverse();
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          i = _ref1[_i];
          _results.push(_siftup(array, i, cmp));
        }
        return _results;
      };


      /*
      Update the position of the given item in the heap.
      This function should be called every time the item is being modified.
       */

      updateItem = function(array, item, cmp) {
        var pos;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        pos = array.indexOf(item);
        if (pos === -1) {
          return;
        }
        _siftdown(array, 0, pos, cmp);
        return _siftup(array, pos, cmp);
      };


      /*
      Find the n largest elements in a dataset.
       */

      nlargest = function(array, n, cmp) {
        var elem, result, _i, _len, _ref;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        result = array.slice(0, n);
        if (!result.length) {
          return result;
        }
        heapify(result, cmp);
        _ref = array.slice(n);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          elem = _ref[_i];
          heappushpop(result, elem, cmp);
        }
        return result.sort(cmp).reverse();
      };


      /*
      Find the n smallest elements in a dataset.
       */

      nsmallest = function(array, n, cmp) {
        var elem, los, result, _i, _j, _len, _ref, _ref1, _results;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        if (n * 10 <= array.length) {
          result = array.slice(0, n).sort(cmp);
          if (!result.length) {
            return result;
          }
          los = result[result.length - 1];
          _ref = array.slice(n);
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            elem = _ref[_i];
            if (cmp(elem, los) < 0) {
              insort(result, elem, 0, null, cmp);
              result.pop();
              los = result[result.length - 1];
            }
          }
          return result;
        }
        heapify(array, cmp);
        _results = [];
        for (_j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; 0 <= _ref1 ? ++_j : --_j) {
          _results.push(heappop(array, cmp));
        }
        return _results;
      };

      _siftdown = function(array, startpos, pos, cmp) {
        var newitem, parent, parentpos;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        newitem = array[pos];
        while (pos > startpos) {
          parentpos = (pos - 1) >> 1;
          parent = array[parentpos];
          if (cmp(newitem, parent) < 0) {
            array[pos] = parent;
            pos = parentpos;
            continue;
          }
          break;
        }
        return array[pos] = newitem;
      };

      _siftup = function(array, pos, cmp) {
        var childpos, endpos, newitem, rightpos, startpos;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        endpos = array.length;
        startpos = pos;
        newitem = array[pos];
        childpos = 2 * pos + 1;
        while (childpos < endpos) {
          rightpos = childpos + 1;
          if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
            childpos = rightpos;
          }
          array[pos] = array[childpos];
          pos = childpos;
          childpos = 2 * pos + 1;
        }
        array[pos] = newitem;
        return _siftdown(array, startpos, pos, cmp);
      };

      Heap = (function() {
        Heap.push = heappush;

        Heap.pop = heappop;

        Heap.replace = heapreplace;

        Heap.pushpop = heappushpop;

        Heap.heapify = heapify;

        Heap.updateItem = updateItem;

        Heap.nlargest = nlargest;

        Heap.nsmallest = nsmallest;

        function Heap(cmp) {
          this.cmp = cmp != null ? cmp : defaultCmp;
          this.nodes = [];
        }

        Heap.prototype.push = function(x) {
          return heappush(this.nodes, x, this.cmp);
        };

        Heap.prototype.pop = function() {
          return heappop(this.nodes, this.cmp);
        };

        Heap.prototype.peek = function() {
          return this.nodes[0];
        };

        Heap.prototype.contains = function(x) {
          return this.nodes.indexOf(x) !== -1;
        };

        Heap.prototype.replace = function(x) {
          return heapreplace(this.nodes, x, this.cmp);
        };

        Heap.prototype.pushpop = function(x) {
          return heappushpop(this.nodes, x, this.cmp);
        };

        Heap.prototype.heapify = function() {
          return heapify(this.nodes, this.cmp);
        };

        Heap.prototype.updateItem = function(x) {
          return updateItem(this.nodes, x, this.cmp);
        };

        Heap.prototype.clear = function() {
          return this.nodes = [];
        };

        Heap.prototype.empty = function() {
          return this.nodes.length === 0;
        };

        Heap.prototype.size = function() {
          return this.nodes.length;
        };

        Heap.prototype.clone = function() {
          var heap;
          heap = new Heap();
          heap.nodes = this.nodes.slice(0);
          return heap;
        };

        Heap.prototype.toArray = function() {
          return this.nodes.slice(0);
        };

        Heap.prototype.insert = Heap.prototype.push;

        Heap.prototype.top = Heap.prototype.peek;

        Heap.prototype.front = Heap.prototype.peek;

        Heap.prototype.has = Heap.prototype.contains;

        Heap.prototype.copy = Heap.prototype.clone;

        return Heap;

      })();

      if (module !== null ? module.exports : void 0) {
        module.exports = Heap;
      } else {
        window.Heap = Heap;
      }

    }).call(commonjsGlobal$1);
    }(heap$1));

    var heap = heap$1.exports;

    /**
     * A node in grid.
     * This class holds some basic information about a node and custom
     * attributes may be added, depending on the algorithms' needs.
     * @constructor
     * @param {number} x - The x coordinate of the node on the grid.
     * @param {number} y - The y coordinate of the node on the grid.
     * @param {boolean} [walkable] - Whether this node is walkable.
     */

    function Node$3(x, y, walkable) {
        /**
         * The x coordinate of the node on the grid.
         * @type number
         */
        this.x = x;
        /**
         * The y coordinate of the node on the grid.
         * @type number
         */
        this.y = y;
        /**
         * Whether this node can be walked through.
         * @type boolean
         */
        this.walkable = (walkable === undefined ? true : walkable);
    }

    var Node_1 = Node$3;

    var DiagonalMovement$b = {
        Always: 1,
        Never: 2,
        IfAtMostOneObstacle: 3,
        OnlyWhenNoObstacles: 4
    };

    var DiagonalMovement_1 = DiagonalMovement$b;

    var Node$2 = Node_1;
    var DiagonalMovement$a = DiagonalMovement_1;

    /**
     * The Grid class, which serves as the encapsulation of the layout of the nodes.
     * @constructor
     * @param {number|Array<Array<(number|boolean)>>} width_or_matrix Number of columns of the grid, or matrix
     * @param {number} height Number of rows of the grid.
     * @param {Array<Array<(number|boolean)>>} [matrix] - A 0-1 matrix
     *     representing the walkable status of the nodes(0 or false for walkable).
     *     If the matrix is not supplied, all the nodes will be walkable.  */
    function Grid$1(width_or_matrix, height, matrix) {
        var width;

        if (typeof width_or_matrix !== 'object') {
            width = width_or_matrix;
        } else {
            height = width_or_matrix.length;
            width = width_or_matrix[0].length;
            matrix = width_or_matrix;
        }

        /**
         * The number of columns of the grid.
         * @type number
         */
        this.width = width;
        /**
         * The number of rows of the grid.
         * @type number
         */
        this.height = height;

        /**
         * A 2D array of nodes.
         */
        this.nodes = this._buildNodes(width, height, matrix);
    }

    /**
     * Build and return the nodes.
     * @private
     * @param {number} width
     * @param {number} height
     * @param {Array<Array<number|boolean>>} [matrix] - A 0-1 matrix representing
     *     the walkable status of the nodes.
     * @see Grid
     */
    Grid$1.prototype._buildNodes = function(width, height, matrix) {
        var i, j,
            nodes = new Array(height);

        for (i = 0; i < height; ++i) {
            nodes[i] = new Array(width);
            for (j = 0; j < width; ++j) {
                nodes[i][j] = new Node$2(j, i);
            }
        }


        if (matrix === undefined) {
            return nodes;
        }

        if (matrix.length !== height || matrix[0].length !== width) {
            throw new Error('Matrix size does not fit');
        }

        for (i = 0; i < height; ++i) {
            for (j = 0; j < width; ++j) {
                if (matrix[i][j]) {
                    // 0, false, null will be walkable
                    // while others will be un-walkable
                    nodes[i][j].walkable = false;
                }
            }
        }

        return nodes;
    };


    Grid$1.prototype.getNodeAt = function(x, y) {
        return this.nodes[y][x];
    };


    /**
     * Determine whether the node at the given position is walkable.
     * (Also returns false if the position is outside the grid.)
     * @param {number} x - The x coordinate of the node.
     * @param {number} y - The y coordinate of the node.
     * @return {boolean} - The walkability of the node.
     */
    Grid$1.prototype.isWalkableAt = function(x, y) {
        return this.isInside(x, y) && this.nodes[y][x].walkable;
    };


    /**
     * Determine whether the position is inside the grid.
     * XXX: `grid.isInside(x, y)` is wierd to read.
     * It should be `(x, y) is inside grid`, but I failed to find a better
     * name for this method.
     * @param {number} x
     * @param {number} y
     * @return {boolean}
     */
    Grid$1.prototype.isInside = function(x, y) {
        return (x >= 0 && x < this.width) && (y >= 0 && y < this.height);
    };


    /**
     * Set whether the node on the given position is walkable.
     * NOTE: throws exception if the coordinate is not inside the grid.
     * @param {number} x - The x coordinate of the node.
     * @param {number} y - The y coordinate of the node.
     * @param {boolean} walkable - Whether the position is walkable.
     */
    Grid$1.prototype.setWalkableAt = function(x, y, walkable) {
        this.nodes[y][x].walkable = walkable;
    };


    /**
     * Get the neighbors of the given node.
     *
     *     offsets      diagonalOffsets:
     *  +---+---+---+    +---+---+---+
     *  |   | 0 |   |    | 0 |   | 1 |
     *  +---+---+---+    +---+---+---+
     *  | 3 |   | 1 |    |   |   |   |
     *  +---+---+---+    +---+---+---+
     *  |   | 2 |   |    | 3 |   | 2 |
     *  +---+---+---+    +---+---+---+
     *
     *  When allowDiagonal is true, if offsets[i] is valid, then
     *  diagonalOffsets[i] and
     *  diagonalOffsets[(i + 1) % 4] is valid.
     * @param {Node} node
     * @param {DiagonalMovement} diagonalMovement
     */
    Grid$1.prototype.getNeighbors = function(node, diagonalMovement) {
        var x = node.x,
            y = node.y,
            neighbors = [],
            s0 = false, d0 = false,
            s1 = false, d1 = false,
            s2 = false, d2 = false,
            s3 = false, d3 = false,
            nodes = this.nodes;

        // 
        if (this.isWalkableAt(x, y - 1)) {
            neighbors.push(nodes[y - 1][x]);
            s0 = true;
        }
        // 
        if (this.isWalkableAt(x + 1, y)) {
            neighbors.push(nodes[y][x + 1]);
            s1 = true;
        }
        // 
        if (this.isWalkableAt(x, y + 1)) {
            neighbors.push(nodes[y + 1][x]);
            s2 = true;
        }
        // 
        if (this.isWalkableAt(x - 1, y)) {
            neighbors.push(nodes[y][x - 1]);
            s3 = true;
        }

        if (diagonalMovement === DiagonalMovement$a.Never) {
            return neighbors;
        }

        if (diagonalMovement === DiagonalMovement$a.OnlyWhenNoObstacles) {
            d0 = s3 && s0;
            d1 = s0 && s1;
            d2 = s1 && s2;
            d3 = s2 && s3;
        } else if (diagonalMovement === DiagonalMovement$a.IfAtMostOneObstacle) {
            d0 = s3 || s0;
            d1 = s0 || s1;
            d2 = s1 || s2;
            d3 = s2 || s3;
        } else if (diagonalMovement === DiagonalMovement$a.Always) {
            d0 = true;
            d1 = true;
            d2 = true;
            d3 = true;
        } else {
            throw new Error('Incorrect value of diagonalMovement');
        }

        // 
        if (d0 && this.isWalkableAt(x - 1, y - 1)) {
            neighbors.push(nodes[y - 1][x - 1]);
        }
        // 
        if (d1 && this.isWalkableAt(x + 1, y - 1)) {
            neighbors.push(nodes[y - 1][x + 1]);
        }
        // 
        if (d2 && this.isWalkableAt(x + 1, y + 1)) {
            neighbors.push(nodes[y + 1][x + 1]);
        }
        // 
        if (d3 && this.isWalkableAt(x - 1, y + 1)) {
            neighbors.push(nodes[y + 1][x - 1]);
        }

        return neighbors;
    };


    /**
     * Get a clone of this grid.
     * @return {Grid} Cloned grid.
     */
    Grid$1.prototype.clone = function() {
        var i, j,

            width = this.width,
            height = this.height,
            thisNodes = this.nodes,

            newGrid = new Grid$1(width, height),
            newNodes = new Array(height);

        for (i = 0; i < height; ++i) {
            newNodes[i] = new Array(width);
            for (j = 0; j < width; ++j) {
                newNodes[i][j] = new Node$2(j, i, thisNodes[i][j].walkable);
            }
        }

        newGrid.nodes = newNodes;

        return newGrid;
    };

    var Grid_1 = Grid$1;

    var Util$5 = {};

    /**
     * Backtrace according to the parent records and return the path.
     * (including both start and end nodes)
     * @param {Node} node End node
     * @return {Array<Array<number>>} the path
     */

    function backtrace(node) {
        var path = [[node.x, node.y]];
        while (node.parent) {
            node = node.parent;
            path.push([node.x, node.y]);
        }
        return path.reverse();
    }
    Util$5.backtrace = backtrace;

    /**
     * Backtrace from start and end node, and return the path.
     * (including both start and end nodes)
     * @param {Node}
     * @param {Node}
     */
    function biBacktrace(nodeA, nodeB) {
        var pathA = backtrace(nodeA),
            pathB = backtrace(nodeB);
        return pathA.concat(pathB.reverse());
    }
    Util$5.biBacktrace = biBacktrace;

    /**
     * Compute the length of the path.
     * @param {Array<Array<number>>} path The path
     * @return {number} The length of the path
     */
    function pathLength(path) {
        var i, sum = 0, a, b, dx, dy;
        for (i = 1; i < path.length; ++i) {
            a = path[i - 1];
            b = path[i];
            dx = a[0] - b[0];
            dy = a[1] - b[1];
            sum += Math.sqrt(dx * dx + dy * dy);
        }
        return sum;
    }
    Util$5.pathLength = pathLength;


    /**
     * Given the start and end coordinates, return all the coordinates lying
     * on the line formed by these coordinates, based on Bresenham's algorithm.
     * http://en.wikipedia.org/wiki/Bresenham's_line_algorithm#Simplification
     * @param {number} x0 Start x coordinate
     * @param {number} y0 Start y coordinate
     * @param {number} x1 End x coordinate
     * @param {number} y1 End y coordinate
     * @return {Array<Array<number>>} The coordinates on the line
     */
    function interpolate$1(x0, y0, x1, y1) {
        var abs = Math.abs,
            line = [],
            sx, sy, dx, dy, err, e2;

        dx = abs(x1 - x0);
        dy = abs(y1 - y0);

        sx = (x0 < x1) ? 1 : -1;
        sy = (y0 < y1) ? 1 : -1;

        err = dx - dy;

        while (true) {
            line.push([x0, y0]);

            if (x0 === x1 && y0 === y1) {
                break;
            }

            e2 = 2 * err;
            if (e2 > -dy) {
                err = err - dy;
                x0 = x0 + sx;
            }
            if (e2 < dx) {
                err = err + dx;
                y0 = y0 + sy;
            }
        }

        return line;
    }
    Util$5.interpolate = interpolate$1;


    /**
     * Given a compressed path, return a new path that has all the segments
     * in it interpolated.
     * @param {Array<Array<number>>} path The path
     * @return {Array<Array<number>>} expanded path
     */
    function expandPath(path) {
        var expanded = [],
            len = path.length,
            coord0, coord1,
            interpolated,
            interpolatedLen,
            i, j;

        if (len < 2) {
            return expanded;
        }

        for (i = 0; i < len - 1; ++i) {
            coord0 = path[i];
            coord1 = path[i + 1];

            interpolated = interpolate$1(coord0[0], coord0[1], coord1[0], coord1[1]);
            interpolatedLen = interpolated.length;
            for (j = 0; j < interpolatedLen - 1; ++j) {
                expanded.push(interpolated[j]);
            }
        }
        expanded.push(path[len - 1]);

        return expanded;
    }
    Util$5.expandPath = expandPath;


    /**
     * Smoothen the give path.
     * The original path will not be modified; a new path will be returned.
     * @param {PF.Grid} grid
     * @param {Array<Array<number>>} path The path
     */
    function smoothenPath(grid, path) {
        var len = path.length,
            x0 = path[0][0],        // path start x
            y0 = path[0][1],        // path start y
            x1 = path[len - 1][0],  // path end x
            y1 = path[len - 1][1],  // path end y
            sx, sy,                 // current start coordinate
            ex, ey,                 // current end coordinate
            newPath,
            i, j, coord, line, testCoord, blocked;

        sx = x0;
        sy = y0;
        newPath = [[sx, sy]];

        for (i = 2; i < len; ++i) {
            coord = path[i];
            ex = coord[0];
            ey = coord[1];
            line = interpolate$1(sx, sy, ex, ey);

            blocked = false;
            for (j = 1; j < line.length; ++j) {
                testCoord = line[j];

                if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {
                    blocked = true;
                    break;
                }
            }
            if (blocked) {
                lastValidCoord = path[i - 1];
                newPath.push(lastValidCoord);
                sx = lastValidCoord[0];
                sy = lastValidCoord[1];
            }
        }
        newPath.push([x1, y1]);

        return newPath;
    }
    Util$5.smoothenPath = smoothenPath;


    /**
     * Compress a path, remove redundant nodes without altering the shape
     * The original path is not modified
     * @param {Array<Array<number>>} path The path
     * @return {Array<Array<number>>} The compressed path
     */
    function compressPath(path) {

        // nothing to compress
        if(path.length < 3) {
            return path;
        }

        var compressed = [],
            sx = path[0][0], // start x
            sy = path[0][1], // start y
            px = path[1][0], // second point x
            py = path[1][1], // second point y
            dx = px - sx, // direction between the two points
            dy = py - sy, // direction between the two points
            lx, ly,
            ldx, ldy,
            sq, i;

        // normalize the direction
        sq = Math.sqrt(dx*dx + dy*dy);
        dx /= sq;
        dy /= sq;

        // start the new path
        compressed.push([sx,sy]);

        for(i = 2; i < path.length; i++) {

            // store the last point
            lx = px;
            ly = py;

            // store the last direction
            ldx = dx;
            ldy = dy;

            // next point
            px = path[i][0];
            py = path[i][1];

            // next direction
            dx = px - lx;
            dy = py - ly;

            // normalize
            sq = Math.sqrt(dx*dx + dy*dy);
            dx /= sq;
            dy /= sq;

            // if the direction has changed, store the point
            if ( dx !== ldx || dy !== ldy ) {
                compressed.push([lx,ly]);
            }
        }

        // store the last point
        compressed.push([px,py]);

        return compressed;
    }
    Util$5.compressPath = compressPath;

    /**
     * @namespace PF.Heuristic
     * @description A collection of heuristic functions.
     */

    var Heuristic$4 = {

      /**
       * Manhattan distance.
       * @param {number} dx - Difference in x.
       * @param {number} dy - Difference in y.
       * @return {number} dx + dy
       */
      manhattan: function(dx, dy) {
          return dx + dy;
      },

      /**
       * Euclidean distance.
       * @param {number} dx - Difference in x.
       * @param {number} dy - Difference in y.
       * @return {number} sqrt(dx * dx + dy * dy)
       */
      euclidean: function(dx, dy) {
          return Math.sqrt(dx * dx + dy * dy);
      },

      /**
       * Octile distance.
       * @param {number} dx - Difference in x.
       * @param {number} dy - Difference in y.
       * @return {number} sqrt(dx * dx + dy * dy) for grids
       */
      octile: function(dx, dy) {
          var F = Math.SQRT2 - 1;
          return (dx < dy) ? F * dx + dy : F * dy + dx;
      },

      /**
       * Chebyshev distance.
       * @param {number} dx - Difference in x.
       * @param {number} dy - Difference in y.
       * @return {number} max(dx, dy)
       */
      chebyshev: function(dx, dy) {
          return Math.max(dx, dy);
      }

    };

    var Heap$2       = heap;
    var Util$4       = Util$5;
    var Heuristic$3  = Heuristic$4;
    var DiagonalMovement$9 = DiagonalMovement_1;

    /**
     * A* path-finder. Based upon https://github.com/bgrins/javascript-astar
     * @constructor
     * @param {Object} opt
     * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
     *     Deprecated, use diagonalMovement instead.
     * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
     *     block corners. Deprecated, use diagonalMovement instead.
     * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
     * @param {function} opt.heuristic Heuristic function to estimate the distance
     *     (defaults to manhattan).
     * @param {number} opt.weight Weight to apply to the heuristic to allow for
     *     suboptimal paths, in order to speed up the search.
     */
    function AStarFinder$2(opt) {
        opt = opt || {};
        this.allowDiagonal = opt.allowDiagonal;
        this.dontCrossCorners = opt.dontCrossCorners;
        this.heuristic = opt.heuristic || Heuristic$3.manhattan;
        this.weight = opt.weight || 1;
        this.diagonalMovement = opt.diagonalMovement;

        if (!this.diagonalMovement) {
            if (!this.allowDiagonal) {
                this.diagonalMovement = DiagonalMovement$9.Never;
            } else {
                if (this.dontCrossCorners) {
                    this.diagonalMovement = DiagonalMovement$9.OnlyWhenNoObstacles;
                } else {
                    this.diagonalMovement = DiagonalMovement$9.IfAtMostOneObstacle;
                }
            }
        }

        // When diagonal movement is allowed the manhattan heuristic is not
        //admissible. It should be octile instead
        if (this.diagonalMovement === DiagonalMovement$9.Never) {
            this.heuristic = opt.heuristic || Heuristic$3.manhattan;
        } else {
            this.heuristic = opt.heuristic || Heuristic$3.octile;
        }
    }

    /**
     * Find and return the the path.
     * @return {Array<Array<number>>} The path, including both start and
     *     end positions.
     */
    AStarFinder$2.prototype.findPath = function(startX, startY, endX, endY, grid) {
        var openList = new Heap$2(function(nodeA, nodeB) {
                return nodeA.f - nodeB.f;
            }),
            startNode = grid.getNodeAt(startX, startY),
            endNode = grid.getNodeAt(endX, endY),
            heuristic = this.heuristic,
            diagonalMovement = this.diagonalMovement,
            weight = this.weight,
            abs = Math.abs, SQRT2 = Math.SQRT2,
            node, neighbors, neighbor, i, l, x, y, ng;

        // set the `g` and `f` value of the start node to be 0
        startNode.g = 0;
        startNode.f = 0;

        // push the start node into the open list
        openList.push(startNode);
        startNode.opened = true;

        // while the open list is not empty
        while (!openList.empty()) {
            // pop the position of node which has the minimum `f` value.
            node = openList.pop();
            node.closed = true;

            // if reached the end position, construct the path and return it
            if (node === endNode) {
                return Util$4.backtrace(endNode);
            }

            // get neigbours of the current node
            neighbors = grid.getNeighbors(node, diagonalMovement);
            for (i = 0, l = neighbors.length; i < l; ++i) {
                neighbor = neighbors[i];

                if (neighbor.closed) {
                    continue;
                }

                x = neighbor.x;
                y = neighbor.y;

                // get the distance between current node and the neighbor
                // and calculate the next g score
                ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);

                // check if the neighbor has not been inspected yet, or
                // can be reached with smaller cost from the current node
                if (!neighbor.opened || ng < neighbor.g) {
                    neighbor.g = ng;
                    neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));
                    neighbor.f = neighbor.g + neighbor.h;
                    neighbor.parent = node;

                    if (!neighbor.opened) {
                        openList.push(neighbor);
                        neighbor.opened = true;
                    } else {
                        // the neighbor can be reached with smaller cost.
                        // Since its f value has been updated, we have to
                        // update its position in the open list
                        openList.updateItem(neighbor);
                    }
                }
            } // end for each neighbor
        } // end while not open list empty

        // fail to find the path
        return [];
    };

    var AStarFinder_1 = AStarFinder$2;

    var AStarFinder$1 = AStarFinder_1;

    /**
     * Best-First-Search path-finder.
     * @constructor
     * @extends AStarFinder
     * @param {Object} opt
     * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
     *     Deprecated, use diagonalMovement instead.
     * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
     *     block corners. Deprecated, use diagonalMovement instead.
     * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
     * @param {function} opt.heuristic Heuristic function to estimate the distance
     *     (defaults to manhattan).
     */
    function BestFirstFinder(opt) {
        AStarFinder$1.call(this, opt);

        var orig = this.heuristic;
        this.heuristic = function(dx, dy) {
            return orig(dx, dy) * 1000000;
        };
    }

    BestFirstFinder.prototype = new AStarFinder$1();
    BestFirstFinder.prototype.constructor = BestFirstFinder;

    var BestFirstFinder_1 = BestFirstFinder;

    var Util$3 = Util$5;
    var DiagonalMovement$8 = DiagonalMovement_1;

    /**
     * Breadth-First-Search path finder.
     * @constructor
     * @param {Object} opt
     * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
     *     Deprecated, use diagonalMovement instead.
     * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
     *     block corners. Deprecated, use diagonalMovement instead.
     * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
     */
    function BreadthFirstFinder(opt) {
        opt = opt || {};
        this.allowDiagonal = opt.allowDiagonal;
        this.dontCrossCorners = opt.dontCrossCorners;
        this.diagonalMovement = opt.diagonalMovement;

        if (!this.diagonalMovement) {
            if (!this.allowDiagonal) {
                this.diagonalMovement = DiagonalMovement$8.Never;
            } else {
                if (this.dontCrossCorners) {
                    this.diagonalMovement = DiagonalMovement$8.OnlyWhenNoObstacles;
                } else {
                    this.diagonalMovement = DiagonalMovement$8.IfAtMostOneObstacle;
                }
            }
        }
    }

    /**
     * Find and return the the path.
     * @return {Array<Array<number>>} The path, including both start and
     *     end positions.
     */
    BreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
        var openList = [],
            diagonalMovement = this.diagonalMovement,
            startNode = grid.getNodeAt(startX, startY),
            endNode = grid.getNodeAt(endX, endY),
            neighbors, neighbor, node, i, l;

        // push the start pos into the queue
        openList.push(startNode);
        startNode.opened = true;

        // while the queue is not empty
        while (openList.length) {
            // take the front node from the queue
            node = openList.shift();
            node.closed = true;

            // reached the end position
            if (node === endNode) {
                return Util$3.backtrace(endNode);
            }

            neighbors = grid.getNeighbors(node, diagonalMovement);
            for (i = 0, l = neighbors.length; i < l; ++i) {
                neighbor = neighbors[i];

                // skip this neighbor if it has been inspected before
                if (neighbor.closed || neighbor.opened) {
                    continue;
                }

                openList.push(neighbor);
                neighbor.opened = true;
                neighbor.parent = node;
            }
        }

        // fail to find the path
        return [];
    };

    var BreadthFirstFinder_1 = BreadthFirstFinder;

    var AStarFinder = AStarFinder_1;

    /**
     * Dijkstra path-finder.
     * @constructor
     * @extends AStarFinder
     * @param {Object} opt
     * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
     *     Deprecated, use diagonalMovement instead.
     * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
     *     block corners. Deprecated, use diagonalMovement instead.
     * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
     */
    function DijkstraFinder(opt) {
        AStarFinder.call(this, opt);
        this.heuristic = function(dx, dy) {
            return 0;
        };
    }

    DijkstraFinder.prototype = new AStarFinder();
    DijkstraFinder.prototype.constructor = DijkstraFinder;

    var DijkstraFinder_1 = DijkstraFinder;

    var Heap$1       = heap;
    var Util$2       = Util$5;
    var Heuristic$2  = Heuristic$4;
    var DiagonalMovement$7 = DiagonalMovement_1;

    /**
     * A* path-finder.
     * based upon https://github.com/bgrins/javascript-astar
     * @constructor
     * @param {Object} opt
     * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
     *     Deprecated, use diagonalMovement instead.
     * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
     *     block corners. Deprecated, use diagonalMovement instead.
     * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
     * @param {function} opt.heuristic Heuristic function to estimate the distance
     *     (defaults to manhattan).
     * @param {number} opt.weight Weight to apply to the heuristic to allow for
     *     suboptimal paths, in order to speed up the search.
     */
    function BiAStarFinder$2(opt) {
        opt = opt || {};
        this.allowDiagonal = opt.allowDiagonal;
        this.dontCrossCorners = opt.dontCrossCorners;
        this.diagonalMovement = opt.diagonalMovement;
        this.heuristic = opt.heuristic || Heuristic$2.manhattan;
        this.weight = opt.weight || 1;

        if (!this.diagonalMovement) {
            if (!this.allowDiagonal) {
                this.diagonalMovement = DiagonalMovement$7.Never;
            } else {
                if (this.dontCrossCorners) {
                    this.diagonalMovement = DiagonalMovement$7.OnlyWhenNoObstacles;
                } else {
                    this.diagonalMovement = DiagonalMovement$7.IfAtMostOneObstacle;
                }
            }
        }

        //When diagonal movement is allowed the manhattan heuristic is not admissible
        //It should be octile instead
        if (this.diagonalMovement === DiagonalMovement$7.Never) {
            this.heuristic = opt.heuristic || Heuristic$2.manhattan;
        } else {
            this.heuristic = opt.heuristic || Heuristic$2.octile;
        }
    }

    /**
     * Find and return the the path.
     * @return {Array<Array<number>>} The path, including both start and
     *     end positions.
     */
    BiAStarFinder$2.prototype.findPath = function(startX, startY, endX, endY, grid) {
        var cmp = function(nodeA, nodeB) {
                return nodeA.f - nodeB.f;
            },
            startOpenList = new Heap$1(cmp),
            endOpenList = new Heap$1(cmp),
            startNode = grid.getNodeAt(startX, startY),
            endNode = grid.getNodeAt(endX, endY),
            heuristic = this.heuristic,
            diagonalMovement = this.diagonalMovement,
            weight = this.weight,
            abs = Math.abs, SQRT2 = Math.SQRT2,
            node, neighbors, neighbor, i, l, x, y, ng,
            BY_START = 1, BY_END = 2;

        // set the `g` and `f` value of the start node to be 0
        // and push it into the start open list
        startNode.g = 0;
        startNode.f = 0;
        startOpenList.push(startNode);
        startNode.opened = BY_START;

        // set the `g` and `f` value of the end node to be 0
        // and push it into the open open list
        endNode.g = 0;
        endNode.f = 0;
        endOpenList.push(endNode);
        endNode.opened = BY_END;

        // while both the open lists are not empty
        while (!startOpenList.empty() && !endOpenList.empty()) {

            // pop the position of start node which has the minimum `f` value.
            node = startOpenList.pop();
            node.closed = true;

            // get neigbours of the current node
            neighbors = grid.getNeighbors(node, diagonalMovement);
            for (i = 0, l = neighbors.length; i < l; ++i) {
                neighbor = neighbors[i];

                if (neighbor.closed) {
                    continue;
                }
                if (neighbor.opened === BY_END) {
                    return Util$2.biBacktrace(node, neighbor);
                }

                x = neighbor.x;
                y = neighbor.y;

                // get the distance between current node and the neighbor
                // and calculate the next g score
                ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);

                // check if the neighbor has not been inspected yet, or
                // can be reached with smaller cost from the current node
                if (!neighbor.opened || ng < neighbor.g) {
                    neighbor.g = ng;
                    neighbor.h = neighbor.h ||
                        weight * heuristic(abs(x - endX), abs(y - endY));
                    neighbor.f = neighbor.g + neighbor.h;
                    neighbor.parent = node;

                    if (!neighbor.opened) {
                        startOpenList.push(neighbor);
                        neighbor.opened = BY_START;
                    } else {
                        // the neighbor can be reached with smaller cost.
                        // Since its f value has been updated, we have to
                        // update its position in the open list
                        startOpenList.updateItem(neighbor);
                    }
                }
            } // end for each neighbor


            // pop the position of end node which has the minimum `f` value.
            node = endOpenList.pop();
            node.closed = true;

            // get neigbours of the current node
            neighbors = grid.getNeighbors(node, diagonalMovement);
            for (i = 0, l = neighbors.length; i < l; ++i) {
                neighbor = neighbors[i];

                if (neighbor.closed) {
                    continue;
                }
                if (neighbor.opened === BY_START) {
                    return Util$2.biBacktrace(neighbor, node);
                }

                x = neighbor.x;
                y = neighbor.y;

                // get the distance between current node and the neighbor
                // and calculate the next g score
                ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);

                // check if the neighbor has not been inspected yet, or
                // can be reached with smaller cost from the current node
                if (!neighbor.opened || ng < neighbor.g) {
                    neighbor.g = ng;
                    neighbor.h = neighbor.h ||
                        weight * heuristic(abs(x - startX), abs(y - startY));
                    neighbor.f = neighbor.g + neighbor.h;
                    neighbor.parent = node;

                    if (!neighbor.opened) {
                        endOpenList.push(neighbor);
                        neighbor.opened = BY_END;
                    } else {
                        // the neighbor can be reached with smaller cost.
                        // Since its f value has been updated, we have to
                        // update its position in the open list
                        endOpenList.updateItem(neighbor);
                    }
                }
            } // end for each neighbor
        } // end while not open list empty

        // fail to find the path
        return [];
    };

    var BiAStarFinder_1 = BiAStarFinder$2;

    var BiAStarFinder$1 = BiAStarFinder_1;

    /**
     * Bi-direcitional Best-First-Search path-finder.
     * @constructor
     * @extends BiAStarFinder
     * @param {Object} opt
     * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
     *     Deprecated, use diagonalMovement instead.
     * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
     *     block corners. Deprecated, use diagonalMovement instead.
     * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
     * @param {function} opt.heuristic Heuristic function to estimate the distance
     *     (defaults to manhattan).
     */
    function BiBestFirstFinder(opt) {
        BiAStarFinder$1.call(this, opt);

        var orig = this.heuristic;
        this.heuristic = function(dx, dy) {
            return orig(dx, dy) * 1000000;
        };
    }

    BiBestFirstFinder.prototype = new BiAStarFinder$1();
    BiBestFirstFinder.prototype.constructor = BiBestFirstFinder;

    var BiBestFirstFinder_1 = BiBestFirstFinder;

    var Util$1 = Util$5;
    var DiagonalMovement$6 = DiagonalMovement_1;

    /**
     * Bi-directional Breadth-First-Search path finder.
     * @constructor
     * @param {object} opt
     * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
     *     Deprecated, use diagonalMovement instead.
     * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
     *     block corners. Deprecated, use diagonalMovement instead.
     * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
     */
    function BiBreadthFirstFinder(opt) {
        opt = opt || {};
        this.allowDiagonal = opt.allowDiagonal;
        this.dontCrossCorners = opt.dontCrossCorners;
        this.diagonalMovement = opt.diagonalMovement;

        if (!this.diagonalMovement) {
            if (!this.allowDiagonal) {
                this.diagonalMovement = DiagonalMovement$6.Never;
            } else {
                if (this.dontCrossCorners) {
                    this.diagonalMovement = DiagonalMovement$6.OnlyWhenNoObstacles;
                } else {
                    this.diagonalMovement = DiagonalMovement$6.IfAtMostOneObstacle;
                }
            }
        }
    }


    /**
     * Find and return the the path.
     * @return {Array<Array<number>>} The path, including both start and
     *     end positions.
     */
    BiBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
        var startNode = grid.getNodeAt(startX, startY),
            endNode = grid.getNodeAt(endX, endY),
            startOpenList = [], endOpenList = [],
            neighbors, neighbor, node,
            diagonalMovement = this.diagonalMovement,
            BY_START = 0, BY_END = 1,
            i, l;

        // push the start and end nodes into the queues
        startOpenList.push(startNode);
        startNode.opened = true;
        startNode.by = BY_START;

        endOpenList.push(endNode);
        endNode.opened = true;
        endNode.by = BY_END;

        // while both the queues are not empty
        while (startOpenList.length && endOpenList.length) {

            // expand start open list

            node = startOpenList.shift();
            node.closed = true;

            neighbors = grid.getNeighbors(node, diagonalMovement);
            for (i = 0, l = neighbors.length; i < l; ++i) {
                neighbor = neighbors[i];

                if (neighbor.closed) {
                    continue;
                }
                if (neighbor.opened) {
                    // if this node has been inspected by the reversed search,
                    // then a path is found.
                    if (neighbor.by === BY_END) {
                        return Util$1.biBacktrace(node, neighbor);
                    }
                    continue;
                }
                startOpenList.push(neighbor);
                neighbor.parent = node;
                neighbor.opened = true;
                neighbor.by = BY_START;
            }

            // expand end open list

            node = endOpenList.shift();
            node.closed = true;

            neighbors = grid.getNeighbors(node, diagonalMovement);
            for (i = 0, l = neighbors.length; i < l; ++i) {
                neighbor = neighbors[i];

                if (neighbor.closed) {
                    continue;
                }
                if (neighbor.opened) {
                    if (neighbor.by === BY_START) {
                        return Util$1.biBacktrace(neighbor, node);
                    }
                    continue;
                }
                endOpenList.push(neighbor);
                neighbor.parent = node;
                neighbor.opened = true;
                neighbor.by = BY_END;
            }
        }

        // fail to find the path
        return [];
    };

    var BiBreadthFirstFinder_1 = BiBreadthFirstFinder;

    var BiAStarFinder = BiAStarFinder_1;

    /**
     * Bi-directional Dijkstra path-finder.
     * @constructor
     * @extends BiAStarFinder
     * @param {Object} opt
     * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
     *     Deprecated, use diagonalMovement instead.
     * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
     *     block corners. Deprecated, use diagonalMovement instead.
     * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
     */
    function BiDijkstraFinder(opt) {
        BiAStarFinder.call(this, opt);
        this.heuristic = function(dx, dy) {
            return 0;
        };
    }

    BiDijkstraFinder.prototype = new BiAStarFinder();
    BiDijkstraFinder.prototype.constructor = BiDijkstraFinder;

    var BiDijkstraFinder_1 = BiDijkstraFinder;

    var Heuristic$1  = Heuristic$4;
    var Node$1       = Node_1;
    var DiagonalMovement$5 = DiagonalMovement_1;

    /**
     * Iterative Deeping A Star (IDA*) path-finder.
     *
     * Recursion based on:
     *   http://www.apl.jhu.edu/~hall/AI-Programming/IDA-Star.html
     *
     * Path retracing based on:
     *  V. Nageshwara Rao, Vipin Kumar and K. Ramesh
     *  "A Parallel Implementation of Iterative-Deeping-A*", January 1987.
     *  ftp://ftp.cs.utexas.edu/.snapshot/hourly.1/pub/AI-Lab/tech-reports/UT-AI-TR-87-46.pdf
     *
     * @author Gerard Meier (www.gerardmeier.com)
     *
     * @constructor
     * @param {Object} opt
     * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
     *     Deprecated, use diagonalMovement instead.
     * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
     *     block corners. Deprecated, use diagonalMovement instead.
     * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
     * @param {function} opt.heuristic Heuristic function to estimate the distance
     *     (defaults to manhattan).
     * @param {number} opt.weight Weight to apply to the heuristic to allow for
     *     suboptimal paths, in order to speed up the search.
     * @param {boolean} opt.trackRecursion Whether to track recursion for
     *     statistical purposes.
     * @param {number} opt.timeLimit Maximum execution time. Use <= 0 for infinite.
     */
    function IDAStarFinder(opt) {
        opt = opt || {};
        this.allowDiagonal = opt.allowDiagonal;
        this.dontCrossCorners = opt.dontCrossCorners;
        this.diagonalMovement = opt.diagonalMovement;
        this.heuristic = opt.heuristic || Heuristic$1.manhattan;
        this.weight = opt.weight || 1;
        this.trackRecursion = opt.trackRecursion || false;
        this.timeLimit = opt.timeLimit || Infinity; // Default: no time limit.

        if (!this.diagonalMovement) {
            if (!this.allowDiagonal) {
                this.diagonalMovement = DiagonalMovement$5.Never;
            } else {
                if (this.dontCrossCorners) {
                    this.diagonalMovement = DiagonalMovement$5.OnlyWhenNoObstacles;
                } else {
                    this.diagonalMovement = DiagonalMovement$5.IfAtMostOneObstacle;
                }
            }
        }

        // When diagonal movement is allowed the manhattan heuristic is not
        // admissible, it should be octile instead
        if (this.diagonalMovement === DiagonalMovement$5.Never) {
            this.heuristic = opt.heuristic || Heuristic$1.manhattan;
        } else {
            this.heuristic = opt.heuristic || Heuristic$1.octile;
        }
    }

    /**
     * Find and return the the path. When an empty array is returned, either
     * no path is possible, or the maximum execution time is reached.
     *
     * @return {Array<Array<number>>} The path, including both start and
     *     end positions.
     */
    IDAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {

        // Execution time limitation:
        var startTime = new Date().getTime();

        // Heuristic helper:
        var h = function(a, b) {
            return this.heuristic(Math.abs(b.x - a.x), Math.abs(b.y - a.y));
        }.bind(this);

        // Step cost from a to b:
        var cost = function(a, b) {
            return (a.x === b.x || a.y === b.y) ? 1 : Math.SQRT2;
        };

        /**
         * IDA* search implementation.
         *
         * @param {Node} The node currently expanding from.
         * @param {number} Cost to reach the given node.
         * @param {number} Maximum search depth (cut-off value).
         * @param {Array<Array<number>>} The found route.
         * @param {number} Recursion depth.
         *
         * @return {Object} either a number with the new optimal cut-off depth,
         * or a valid node instance, in which case a path was found.
         */
        var search = function(node, g, cutoff, route, depth) {

            // Enforce timelimit:
            if (this.timeLimit > 0 &&
                new Date().getTime() - startTime > this.timeLimit * 1000) {
                // Enforced as "path-not-found".
                return Infinity;
            }

            var f = g + h(node, end) * this.weight;

            // We've searched too deep for this iteration.
            if (f > cutoff) {
                return f;
            }

            if (node == end) {
                route[depth] = [node.x, node.y];
                return node;
            }

            var min, t, k, neighbour;

            var neighbours = grid.getNeighbors(node, this.diagonalMovement);

            // Sort the neighbours, gives nicer paths. But, this deviates
            // from the original algorithm - so I left it out.
            //neighbours.sort(function(a, b){
            //    return h(a, end) - h(b, end);
            //});


            /*jshint -W084 *///Disable warning: Expected a conditional expression and instead saw an assignment
            for (k = 0, min = Infinity; neighbour = neighbours[k]; ++k) {
            /*jshint +W084 *///Enable warning: Expected a conditional expression and instead saw an assignment
                if (this.trackRecursion) {
                    // Retain a copy for visualisation. Due to recursion, this
                    // node may be part of other paths too.
                    neighbour.retainCount = neighbour.retainCount + 1 || 1;

                    if(neighbour.tested !== true) {
                        neighbour.tested = true;
                    }
                }

                t = search(neighbour, g + cost(node, neighbour), cutoff, route, depth + 1);

                if (t instanceof Node$1) {
                    route[depth] = [node.x, node.y];

                    // For a typical A* linked list, this would work:
                    // neighbour.parent = node;
                    return t;
                }

                // Decrement count, then determine whether it's actually closed.
                if (this.trackRecursion && (--neighbour.retainCount) === 0) {
                    neighbour.tested = false;
                }

                if (t < min) {
                    min = t;
                }
            }

            return min;

        }.bind(this);

        // Node instance lookups:
        var start = grid.getNodeAt(startX, startY);
        var end   = grid.getNodeAt(endX, endY);

        // Initial search depth, given the typical heuristic contraints,
        // there should be no cheaper route possible.
        var cutOff = h(start, end);

        var j, route, t;

        // With an overflow protection.
        for (j = 0; true; ++j) {

            route = [];

            // Search till cut-off depth:
            t = search(start, 0, cutOff, route, 0);

            // Route not possible, or not found in time limit.
            if (t === Infinity) {
                return [];
            }

            // If t is a node, it's also the end node. Route is now
            // populated with a valid path to the end node.
            if (t instanceof Node$1) {
                return route;
            }

            // Try again, this time with a deeper cut-off. The t score
            // is the closest we got to the end node.
            cutOff = t;
        }

        // This _should_ never to be reached.
        return [];
    };

    var IDAStarFinder_1 = IDAStarFinder;

    /**
     * @author imor / https://github.com/imor
     */

    var Heap       = heap;
    var Util       = Util$5;
    var Heuristic  = Heuristic$4;

    /**
     * Base class for the Jump Point Search algorithm
     * @param {object} opt
     * @param {function} opt.heuristic Heuristic function to estimate the distance
     *     (defaults to manhattan).
     */
    function JumpPointFinderBase$4(opt) {
        opt = opt || {};
        this.heuristic = opt.heuristic || Heuristic.manhattan;
        this.trackJumpRecursion = opt.trackJumpRecursion || false;
    }

    /**
     * Find and return the path.
     * @return {Array<Array<number>>} The path, including both start and
     *     end positions.
     */
    JumpPointFinderBase$4.prototype.findPath = function(startX, startY, endX, endY, grid) {
        var openList = this.openList = new Heap(function(nodeA, nodeB) {
                return nodeA.f - nodeB.f;
            }),
            startNode = this.startNode = grid.getNodeAt(startX, startY),
            endNode = this.endNode = grid.getNodeAt(endX, endY), node;

        this.grid = grid;


        // set the `g` and `f` value of the start node to be 0
        startNode.g = 0;
        startNode.f = 0;

        // push the start node into the open list
        openList.push(startNode);
        startNode.opened = true;

        // while the open list is not empty
        while (!openList.empty()) {
            // pop the position of node which has the minimum `f` value.
            node = openList.pop();
            node.closed = true;

            if (node === endNode) {
                return Util.expandPath(Util.backtrace(endNode));
            }

            this._identifySuccessors(node);
        }

        // fail to find the path
        return [];
    };

    /**
     * Identify successors for the given node. Runs a jump point search in the
     * direction of each available neighbor, adding any points found to the open
     * list.
     * @protected
     */
    JumpPointFinderBase$4.prototype._identifySuccessors = function(node) {
        var grid = this.grid,
            heuristic = this.heuristic,
            openList = this.openList,
            endX = this.endNode.x,
            endY = this.endNode.y,
            neighbors, neighbor,
            jumpPoint, i, l,
            x = node.x, y = node.y,
            jx, jy, d, ng, jumpNode,
            abs = Math.abs;

        neighbors = this._findNeighbors(node);
        for(i = 0, l = neighbors.length; i < l; ++i) {
            neighbor = neighbors[i];
            jumpPoint = this._jump(neighbor[0], neighbor[1], x, y);
            if (jumpPoint) {

                jx = jumpPoint[0];
                jy = jumpPoint[1];
                jumpNode = grid.getNodeAt(jx, jy);

                if (jumpNode.closed) {
                    continue;
                }

                // include distance, as parent may not be immediately adjacent:
                d = Heuristic.octile(abs(jx - x), abs(jy - y));
                ng = node.g + d; // next `g` value

                if (!jumpNode.opened || ng < jumpNode.g) {
                    jumpNode.g = ng;
                    jumpNode.h = jumpNode.h || heuristic(abs(jx - endX), abs(jy - endY));
                    jumpNode.f = jumpNode.g + jumpNode.h;
                    jumpNode.parent = node;

                    if (!jumpNode.opened) {
                        openList.push(jumpNode);
                        jumpNode.opened = true;
                    } else {
                        openList.updateItem(jumpNode);
                    }
                }
            }
        }
    };

    var JumpPointFinderBase_1 = JumpPointFinderBase$4;

    /**
     * @author imor / https://github.com/imor
     */

    var JumpPointFinderBase$3 = JumpPointFinderBase_1;
    var DiagonalMovement$4 = DiagonalMovement_1;

    /**
     * Path finder using the Jump Point Search algorithm allowing only horizontal
     * or vertical movements.
     */
    function JPFNeverMoveDiagonally$1(opt) {
        JumpPointFinderBase$3.call(this, opt);
    }

    JPFNeverMoveDiagonally$1.prototype = new JumpPointFinderBase$3();
    JPFNeverMoveDiagonally$1.prototype.constructor = JPFNeverMoveDiagonally$1;

    /**
     * Search recursively in the direction (parent -> child), stopping only when a
     * jump point is found.
     * @protected
     * @return {Array<Array<number>>} The x, y coordinate of the jump point
     *     found, or null if not found
     */
    JPFNeverMoveDiagonally$1.prototype._jump = function(x, y, px, py) {
        var grid = this.grid,
            dx = x - px, dy = y - py;

        if (!grid.isWalkableAt(x, y)) {
            return null;
        }

        if(this.trackJumpRecursion === true) {
            grid.getNodeAt(x, y).tested = true;
        }

        if (grid.getNodeAt(x, y) === this.endNode) {
            return [x, y];
        }

        if (dx !== 0) {
            if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||
                (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {
                return [x, y];
            }
        }
        else if (dy !== 0) {
            if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||
                (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {
                return [x, y];
            }
            //When moving vertically, must check for horizontal jump points
            if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {
                return [x, y];
            }
        }
        else {
            throw new Error("Only horizontal and vertical movements are allowed");
        }

        return this._jump(x + dx, y + dy, x, y);
    };

    /**
     * Find the neighbors for the given node. If the node has a parent,
     * prune the neighbors based on the jump point search algorithm, otherwise
     * return all available neighbors.
     * @return {Array<Array<number>>} The neighbors found.
     */
    JPFNeverMoveDiagonally$1.prototype._findNeighbors = function(node) {
        var parent = node.parent,
            x = node.x, y = node.y,
            grid = this.grid,
            px, py, dx, dy,
            neighbors = [], neighborNodes, neighborNode, i, l;

        // directed pruning: can ignore most neighbors, unless forced.
        if (parent) {
            px = parent.x;
            py = parent.y;
            // get the normalized direction of travel
            dx = (x - px) / Math.max(Math.abs(x - px), 1);
            dy = (y - py) / Math.max(Math.abs(y - py), 1);

            if (dx !== 0) {
                if (grid.isWalkableAt(x, y - 1)) {
                    neighbors.push([x, y - 1]);
                }
                if (grid.isWalkableAt(x, y + 1)) {
                    neighbors.push([x, y + 1]);
                }
                if (grid.isWalkableAt(x + dx, y)) {
                    neighbors.push([x + dx, y]);
                }
            }
            else if (dy !== 0) {
                if (grid.isWalkableAt(x - 1, y)) {
                    neighbors.push([x - 1, y]);
                }
                if (grid.isWalkableAt(x + 1, y)) {
                    neighbors.push([x + 1, y]);
                }
                if (grid.isWalkableAt(x, y + dy)) {
                    neighbors.push([x, y + dy]);
                }
            }
        }
        // return all neighbors
        else {
            neighborNodes = grid.getNeighbors(node, DiagonalMovement$4.Never);
            for (i = 0, l = neighborNodes.length; i < l; ++i) {
                neighborNode = neighborNodes[i];
                neighbors.push([neighborNode.x, neighborNode.y]);
            }
        }

        return neighbors;
    };

    var JPFNeverMoveDiagonally_1 = JPFNeverMoveDiagonally$1;

    /**
     * @author imor / https://github.com/imor
     */

    var JumpPointFinderBase$2 = JumpPointFinderBase_1;
    var DiagonalMovement$3 = DiagonalMovement_1;

    /**
     * Path finder using the Jump Point Search algorithm which always moves
     * diagonally irrespective of the number of obstacles.
     */
    function JPFAlwaysMoveDiagonally$1(opt) {
        JumpPointFinderBase$2.call(this, opt);
    }

    JPFAlwaysMoveDiagonally$1.prototype = new JumpPointFinderBase$2();
    JPFAlwaysMoveDiagonally$1.prototype.constructor = JPFAlwaysMoveDiagonally$1;

    /**
     * Search recursively in the direction (parent -> child), stopping only when a
     * jump point is found.
     * @protected
     * @return {Array<Array<number>>} The x, y coordinate of the jump point
     *     found, or null if not found
     */
    JPFAlwaysMoveDiagonally$1.prototype._jump = function(x, y, px, py) {
        var grid = this.grid,
            dx = x - px, dy = y - py;

        if (!grid.isWalkableAt(x, y)) {
            return null;
        }

        if(this.trackJumpRecursion === true) {
            grid.getNodeAt(x, y).tested = true;
        }

        if (grid.getNodeAt(x, y) === this.endNode) {
            return [x, y];
        }

        // check for forced neighbors
        // along the diagonal
        if (dx !== 0 && dy !== 0) {
            if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||
                (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {
                return [x, y];
            }
            // when moving diagonally, must check for vertical/horizontal jump points
            if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
                return [x, y];
            }
        }
        // horizontally/vertically
        else {
            if( dx !== 0 ) { // moving along x
                if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||
                   (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {
                    return [x, y];
                }
            }
            else {
                if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||
                   (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {
                    return [x, y];
                }
            }
        }

        return this._jump(x + dx, y + dy, x, y);
    };

    /**
     * Find the neighbors for the given node. If the node has a parent,
     * prune the neighbors based on the jump point search algorithm, otherwise
     * return all available neighbors.
     * @return {Array<Array<number>>} The neighbors found.
     */
    JPFAlwaysMoveDiagonally$1.prototype._findNeighbors = function(node) {
        var parent = node.parent,
            x = node.x, y = node.y,
            grid = this.grid,
            px, py, dx, dy,
            neighbors = [], neighborNodes, neighborNode, i, l;

        // directed pruning: can ignore most neighbors, unless forced.
        if (parent) {
            px = parent.x;
            py = parent.y;
            // get the normalized direction of travel
            dx = (x - px) / Math.max(Math.abs(x - px), 1);
            dy = (y - py) / Math.max(Math.abs(y - py), 1);

            // search diagonally
            if (dx !== 0 && dy !== 0) {
                if (grid.isWalkableAt(x, y + dy)) {
                    neighbors.push([x, y + dy]);
                }
                if (grid.isWalkableAt(x + dx, y)) {
                    neighbors.push([x + dx, y]);
                }
                if (grid.isWalkableAt(x + dx, y + dy)) {
                    neighbors.push([x + dx, y + dy]);
                }
                if (!grid.isWalkableAt(x - dx, y)) {
                    neighbors.push([x - dx, y + dy]);
                }
                if (!grid.isWalkableAt(x, y - dy)) {
                    neighbors.push([x + dx, y - dy]);
                }
            }
            // search horizontally/vertically
            else {
                if(dx === 0) {
                    if (grid.isWalkableAt(x, y + dy)) {
                        neighbors.push([x, y + dy]);
                    }
                    if (!grid.isWalkableAt(x + 1, y)) {
                        neighbors.push([x + 1, y + dy]);
                    }
                    if (!grid.isWalkableAt(x - 1, y)) {
                        neighbors.push([x - 1, y + dy]);
                    }
                }
                else {
                    if (grid.isWalkableAt(x + dx, y)) {
                        neighbors.push([x + dx, y]);
                    }
                    if (!grid.isWalkableAt(x, y + 1)) {
                        neighbors.push([x + dx, y + 1]);
                    }
                    if (!grid.isWalkableAt(x, y - 1)) {
                        neighbors.push([x + dx, y - 1]);
                    }
                }
            }
        }
        // return all neighbors
        else {
            neighborNodes = grid.getNeighbors(node, DiagonalMovement$3.Always);
            for (i = 0, l = neighborNodes.length; i < l; ++i) {
                neighborNode = neighborNodes[i];
                neighbors.push([neighborNode.x, neighborNode.y]);
            }
        }

        return neighbors;
    };

    var JPFAlwaysMoveDiagonally_1 = JPFAlwaysMoveDiagonally$1;

    /**
     * @author imor / https://github.com/imor
     */

    var JumpPointFinderBase$1 = JumpPointFinderBase_1;
    var DiagonalMovement$2 = DiagonalMovement_1;

    /**
     * Path finder using the Jump Point Search algorithm which moves
     * diagonally only when there are no obstacles.
     */
    function JPFMoveDiagonallyIfNoObstacles$1(opt) {
        JumpPointFinderBase$1.call(this, opt);
    }

    JPFMoveDiagonallyIfNoObstacles$1.prototype = new JumpPointFinderBase$1();
    JPFMoveDiagonallyIfNoObstacles$1.prototype.constructor = JPFMoveDiagonallyIfNoObstacles$1;

    /**
     * Search recursively in the direction (parent -> child), stopping only when a
     * jump point is found.
     * @protected
     * @return {Array<Array<number>>} The x, y coordinate of the jump point
     *     found, or null if not found
     */
    JPFMoveDiagonallyIfNoObstacles$1.prototype._jump = function(x, y, px, py) {
        var grid = this.grid,
            dx = x - px, dy = y - py;

        if (!grid.isWalkableAt(x, y)) {
            return null;
        }

        if(this.trackJumpRecursion === true) {
            grid.getNodeAt(x, y).tested = true;
        }

        if (grid.getNodeAt(x, y) === this.endNode) {
            return [x, y];
        }

        // check for forced neighbors
        // along the diagonal
        if (dx !== 0 && dy !== 0) {
            // if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||
                // (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {
                // return [x, y];
            // }
            // when moving diagonally, must check for vertical/horizontal jump points
            if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
                return [x, y];
            }
        }
        // horizontally/vertically
        else {
            if (dx !== 0) {
                if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||
                    (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {
                    return [x, y];
                }
            }
            else if (dy !== 0) {
                if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||
                    (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {
                    return [x, y];
                }
                // When moving vertically, must check for horizontal jump points
                // if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {
                    // return [x, y];
                // }
            }
        }

        // moving diagonally, must make sure one of the vertical/horizontal
        // neighbors is open to allow the path
        if (grid.isWalkableAt(x + dx, y) && grid.isWalkableAt(x, y + dy)) {
            return this._jump(x + dx, y + dy, x, y);
        } else {
            return null;
        }
    };

    /**
     * Find the neighbors for the given node. If the node has a parent,
     * prune the neighbors based on the jump point search algorithm, otherwise
     * return all available neighbors.
     * @return {Array<Array<number>>} The neighbors found.
     */
    JPFMoveDiagonallyIfNoObstacles$1.prototype._findNeighbors = function(node) {
        var parent = node.parent,
            x = node.x, y = node.y,
            grid = this.grid,
            px, py, dx, dy,
            neighbors = [], neighborNodes, neighborNode, i, l;

        // directed pruning: can ignore most neighbors, unless forced.
        if (parent) {
            px = parent.x;
            py = parent.y;
            // get the normalized direction of travel
            dx = (x - px) / Math.max(Math.abs(x - px), 1);
            dy = (y - py) / Math.max(Math.abs(y - py), 1);

            // search diagonally
            if (dx !== 0 && dy !== 0) {
                if (grid.isWalkableAt(x, y + dy)) {
                    neighbors.push([x, y + dy]);
                }
                if (grid.isWalkableAt(x + dx, y)) {
                    neighbors.push([x + dx, y]);
                }
                if (grid.isWalkableAt(x, y + dy) && grid.isWalkableAt(x + dx, y)) {
                    neighbors.push([x + dx, y + dy]);
                }
            }
            // search horizontally/vertically
            else {
                var isNextWalkable;
                if (dx !== 0) {
                    isNextWalkable = grid.isWalkableAt(x + dx, y);
                    var isTopWalkable = grid.isWalkableAt(x, y + 1);
                    var isBottomWalkable = grid.isWalkableAt(x, y - 1);

                    if (isNextWalkable) {
                        neighbors.push([x + dx, y]);
                        if (isTopWalkable) {
                            neighbors.push([x + dx, y + 1]);
                        }
                        if (isBottomWalkable) {
                            neighbors.push([x + dx, y - 1]);
                        }
                    }
                    if (isTopWalkable) {
                        neighbors.push([x, y + 1]);
                    }
                    if (isBottomWalkable) {
                        neighbors.push([x, y - 1]);
                    }
                }
                else if (dy !== 0) {
                    isNextWalkable = grid.isWalkableAt(x, y + dy);
                    var isRightWalkable = grid.isWalkableAt(x + 1, y);
                    var isLeftWalkable = grid.isWalkableAt(x - 1, y);

                    if (isNextWalkable) {
                        neighbors.push([x, y + dy]);
                        if (isRightWalkable) {
                            neighbors.push([x + 1, y + dy]);
                        }
                        if (isLeftWalkable) {
                            neighbors.push([x - 1, y + dy]);
                        }
                    }
                    if (isRightWalkable) {
                        neighbors.push([x + 1, y]);
                    }
                    if (isLeftWalkable) {
                        neighbors.push([x - 1, y]);
                    }
                }
            }
        }
        // return all neighbors
        else {
            neighborNodes = grid.getNeighbors(node, DiagonalMovement$2.OnlyWhenNoObstacles);
            for (i = 0, l = neighborNodes.length; i < l; ++i) {
                neighborNode = neighborNodes[i];
                neighbors.push([neighborNode.x, neighborNode.y]);
            }
        }

        return neighbors;
    };

    var JPFMoveDiagonallyIfNoObstacles_1 = JPFMoveDiagonallyIfNoObstacles$1;

    /**
     * @author imor / https://github.com/imor
     */

    var JumpPointFinderBase = JumpPointFinderBase_1;
    var DiagonalMovement$1 = DiagonalMovement_1;

    /**
     * Path finder using the Jump Point Search algorithm which moves
     * diagonally only when there is at most one obstacle.
     */
    function JPFMoveDiagonallyIfAtMostOneObstacle$1(opt) {
        JumpPointFinderBase.call(this, opt);
    }

    JPFMoveDiagonallyIfAtMostOneObstacle$1.prototype = new JumpPointFinderBase();
    JPFMoveDiagonallyIfAtMostOneObstacle$1.prototype.constructor = JPFMoveDiagonallyIfAtMostOneObstacle$1;

    /**
     * Search recursively in the direction (parent -> child), stopping only when a
     * jump point is found.
     * @protected
     * @return {Array<Array<number>>} The x, y coordinate of the jump point
     *     found, or null if not found
     */
    JPFMoveDiagonallyIfAtMostOneObstacle$1.prototype._jump = function(x, y, px, py) {
        var grid = this.grid,
            dx = x - px, dy = y - py;

        if (!grid.isWalkableAt(x, y)) {
            return null;
        }

        if(this.trackJumpRecursion === true) {
            grid.getNodeAt(x, y).tested = true;
        }

        if (grid.getNodeAt(x, y) === this.endNode) {
            return [x, y];
        }

        // check for forced neighbors
        // along the diagonal
        if (dx !== 0 && dy !== 0) {
            if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||
                (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {
                return [x, y];
            }
            // when moving diagonally, must check for vertical/horizontal jump points
            if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
                return [x, y];
            }
        }
        // horizontally/vertically
        else {
            if( dx !== 0 ) { // moving along x
                if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||
                   (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {
                    return [x, y];
                }
            }
            else {
                if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||
                   (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {
                    return [x, y];
                }
            }
        }

        // moving diagonally, must make sure one of the vertical/horizontal
        // neighbors is open to allow the path
        if (grid.isWalkableAt(x + dx, y) || grid.isWalkableAt(x, y + dy)) {
            return this._jump(x + dx, y + dy, x, y);
        } else {
            return null;
        }
    };

    /**
     * Find the neighbors for the given node. If the node has a parent,
     * prune the neighbors based on the jump point search algorithm, otherwise
     * return all available neighbors.
     * @return {Array<Array<number>>} The neighbors found.
     */
    JPFMoveDiagonallyIfAtMostOneObstacle$1.prototype._findNeighbors = function(node) {
        var parent = node.parent,
            x = node.x, y = node.y,
            grid = this.grid,
            px, py, dx, dy,
            neighbors = [], neighborNodes, neighborNode, i, l;

        // directed pruning: can ignore most neighbors, unless forced.
        if (parent) {
            px = parent.x;
            py = parent.y;
            // get the normalized direction of travel
            dx = (x - px) / Math.max(Math.abs(x - px), 1);
            dy = (y - py) / Math.max(Math.abs(y - py), 1);

            // search diagonally
            if (dx !== 0 && dy !== 0) {
                if (grid.isWalkableAt(x, y + dy)) {
                    neighbors.push([x, y + dy]);
                }
                if (grid.isWalkableAt(x + dx, y)) {
                    neighbors.push([x + dx, y]);
                }
                if (grid.isWalkableAt(x, y + dy) || grid.isWalkableAt(x + dx, y)) {
                    neighbors.push([x + dx, y + dy]);
                }
                if (!grid.isWalkableAt(x - dx, y) && grid.isWalkableAt(x, y + dy)) {
                    neighbors.push([x - dx, y + dy]);
                }
                if (!grid.isWalkableAt(x, y - dy) && grid.isWalkableAt(x + dx, y)) {
                    neighbors.push([x + dx, y - dy]);
                }
            }
            // search horizontally/vertically
            else {
                if(dx === 0) {
                    if (grid.isWalkableAt(x, y + dy)) {
                        neighbors.push([x, y + dy]);
                        if (!grid.isWalkableAt(x + 1, y)) {
                            neighbors.push([x + 1, y + dy]);
                        }
                        if (!grid.isWalkableAt(x - 1, y)) {
                            neighbors.push([x - 1, y + dy]);
                        }
                    }
                }
                else {
                    if (grid.isWalkableAt(x + dx, y)) {
                        neighbors.push([x + dx, y]);
                        if (!grid.isWalkableAt(x, y + 1)) {
                            neighbors.push([x + dx, y + 1]);
                        }
                        if (!grid.isWalkableAt(x, y - 1)) {
                            neighbors.push([x + dx, y - 1]);
                        }
                    }
                }
            }
        }
        // return all neighbors
        else {
            neighborNodes = grid.getNeighbors(node, DiagonalMovement$1.IfAtMostOneObstacle);
            for (i = 0, l = neighborNodes.length; i < l; ++i) {
                neighborNode = neighborNodes[i];
                neighbors.push([neighborNode.x, neighborNode.y]);
            }
        }

        return neighbors;
    };

    var JPFMoveDiagonallyIfAtMostOneObstacle_1 = JPFMoveDiagonallyIfAtMostOneObstacle$1;

    /**
     * @author aniero / https://github.com/aniero
     */

    var DiagonalMovement = DiagonalMovement_1;
    var JPFNeverMoveDiagonally = JPFNeverMoveDiagonally_1;
    var JPFAlwaysMoveDiagonally = JPFAlwaysMoveDiagonally_1;
    var JPFMoveDiagonallyIfNoObstacles = JPFMoveDiagonallyIfNoObstacles_1;
    var JPFMoveDiagonallyIfAtMostOneObstacle = JPFMoveDiagonallyIfAtMostOneObstacle_1;

    /**
     * Path finder using the Jump Point Search algorithm
     * @param {Object} opt
     * @param {function} opt.heuristic Heuristic function to estimate the distance
     *     (defaults to manhattan).
     * @param {DiagonalMovement} opt.diagonalMovement Condition under which diagonal
     *      movement will be allowed.
     */
    function JumpPointFinder(opt) {
        opt = opt || {};
        if (opt.diagonalMovement === DiagonalMovement.Never) {
            return new JPFNeverMoveDiagonally(opt);
        } else if (opt.diagonalMovement === DiagonalMovement.Always) {
            return new JPFAlwaysMoveDiagonally(opt);
        } else if (opt.diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {
            return new JPFMoveDiagonallyIfNoObstacles(opt);
        } else {
            return new JPFMoveDiagonallyIfAtMostOneObstacle(opt);
        }
    }

    var JumpPointFinder_1 = JumpPointFinder;

    var PathFinding = {
        'Heap'                      : heap,
        'Node'                      : Node_1,
        'Grid'                      : Grid_1,
        'Util'                      : Util$5,
        'DiagonalMovement'          : DiagonalMovement_1,
        'Heuristic'                 : Heuristic$4,
        'AStarFinder'               : AStarFinder_1,
        'BestFirstFinder'           : BestFirstFinder_1,
        'BreadthFirstFinder'        : BreadthFirstFinder_1,
        'DijkstraFinder'            : DijkstraFinder_1,
        'BiAStarFinder'             : BiAStarFinder_1,
        'BiBestFirstFinder'         : BiBestFirstFinder_1,
        'BiBreadthFirstFinder'      : BiBreadthFirstFinder_1,
        'BiDijkstraFinder'          : BiDijkstraFinder_1,
        'IDAStarFinder'             : IDAStarFinder_1,
        'JumpPointFinder'           : JumpPointFinder_1,
    };

    var pathfinding = PathFinding;

    const finder = new pathfinding.BestFirstFinder({
        heuristic: pathfinding.Heuristic.chebyshev,
        allowDiagonal: true,
    });
    const relationshipZeroOneN = ({ path, line }) => svg `
    <line
      x1=${path.line.end.x1} y1=${path.line.end.y1}
      x2=${path.line.end.x2} y2=${path.line.end.y2}
      stroke-width="3"
    ></line>
    <circle
      cx=${line.circle.cx} cy=${line.circle.cy} r="8"
      fill-opacity="0.0"
      stroke-width="3"
    ></circle>
    <line
      x1=${line.line.end.base.x1} y1=${line.line.end.base.y1}
      x2=${line.line.end.base.x2} y2=${line.line.end.base.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.left.x1} y1=${line.line.end.left.y1}
      x2=${line.line.end.left.x2} y2=${line.line.end.left.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.center.x1} y1=${line.line.end.center.y1}
      x2=${line.line.end.center.x2} y2=${line.line.end.center.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.right.x1} y1=${line.line.end.right.y1}
      x2=${line.line.end.right.x2} y2=${line.line.end.right.y2}
      stroke-width="3"
    ></line>
  `;
    const relationshipZeroOne = ({ path, line }) => svg `
    <line
      x1=${path.line.end.x1} y1=${path.line.end.y1}
      x2=${path.line.end.x2} y2=${path.line.end.y2}
      stroke-width="3"
    ></line>
    <circle
      cx=${line.circle.cx} cy=${line.circle.cy} r="8"
      fill-opacity="0.0"
      stroke-width="3"
    ></circle>
    <line
      x1=${line.line.end.base.x1} y1=${line.line.end.base.y1}
      x2=${line.line.end.base.x2} y2=${line.line.end.base.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.center.x1} y1=${line.line.end.center.y1}
      x2=${line.line.end.center.x2} y2=${line.line.end.center.y2}
      stroke-width="3"
    ></line>
  `;
    const relationshipZeroN = ({ path, line }) => svg `
    <line
      x1=${path.line.end.x1} y1=${path.line.end.y1}
      x2=${path.line.end.x2} y2=${path.line.end.y2}
      stroke-width="3"
    ></line>
    <circle
      cx=${line.circle.cx} cy=${line.circle.cy} r="8"
      fill-opacity="0.0"
      stroke-width="3"
    ></circle>
    <line
      x1=${line.line.end.left.x1} y1=${line.line.end.left.y1}
      x2=${line.line.end.left.x2} y2=${line.line.end.left.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.center.x1} y1=${line.line.end.center.y1}
      x2=${line.line.end.center.x2} y2=${line.line.end.center.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.right.x1} y1=${line.line.end.right.y1}
      x2=${line.line.end.right.x2} y2=${line.line.end.right.y2}
      stroke-width="3"
    ></line>
  `;
    const relationshipOneOnly = ({ path, line }) => svg `
    <line
      x1=${path.line.end.x1} y1=${path.line.end.y1}
      x2=${path.line.end.x2} y2=${path.line.end.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.base.x1} y1=${line.line.end.base.y1}
      x2=${line.line.end.base.x2} y2=${line.line.end.base.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.base2.x1} y1=${line.line.end.base2.y1}
      x2=${line.line.end.base2.x2} y2=${line.line.end.base2.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.center2.x1} y1=${line.line.end.center2.y1}
      x2=${line.line.end.center2.x2} y2=${line.line.end.center2.y2}
      stroke-width="3"
    ></line>
  `;
    const relationshipOneN = ({ path, line }) => svg `
    <line
      x1=${path.line.end.x1} y1=${path.line.end.y1}
      x2=${path.line.end.x2} y2=${path.line.end.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.base.x1} y1=${line.line.end.base.y1}
      x2=${line.line.end.base.x2} y2=${line.line.end.base.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.left.x1} y1=${line.line.end.left.y1}
      x2=${line.line.end.left.x2} y2=${line.line.end.left.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.center2.x1} y1=${line.line.end.center2.y1}
      x2=${line.line.end.center2.x2} y2=${line.line.end.center2.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.right.x1} y1=${line.line.end.right.y1}
      x2=${line.line.end.right.x2} y2=${line.line.end.right.y2}
      stroke-width="3"
    ></line>
  `;
    const relationshipOne = ({ path, line }) => svg `
    <line
      x1=${path.line.end.x1} y1=${path.line.end.y1}
      x2=${path.line.end.x2} y2=${path.line.end.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.base.x1} y1=${line.line.end.base.y1}
      x2=${line.line.end.base.x2} y2=${line.line.end.base.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.center2.x1} y1=${line.line.end.center2.y1}
      x2=${line.line.end.center2.x2} y2=${line.line.end.center2.y2}
      stroke-width="3"
    ></line>
  `;
    const relationshipN = ({ path, line }) => svg `
    <line
      x1=${path.line.end.x1} y1=${path.line.end.y1}
      x2=${path.line.end.x2} y2=${path.line.end.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.left.x1} y1=${line.line.end.left.y1}
      x2=${line.line.end.left.x2} y2=${line.line.end.left.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.center2.x1} y1=${line.line.end.center2.y1}
      x2=${line.line.end.center2.x2} y2=${line.line.end.center2.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.right.x1} y1=${line.line.end.right.y1}
      x2=${line.line.end.right.x2} y2=${line.line.end.right.y2}
      stroke-width="3"
    ></line>
  `;
    const relationshipShapeMap = {
        ZeroOneN: relationshipZeroOneN,
        ZeroOne: relationshipZeroOne,
        ZeroN: relationshipZeroN,
        OneOnly: relationshipOneOnly,
        OneN: relationshipOneN,
        One: relationshipOne,
        N: relationshipN,
    };
    function relationshipTpl(relationship, strokeWidth = 3, grid, ratio = 1, width = 2000, height = 2000) {
        const relationshipPath = getRelationshipPath(relationship);
        const { path, line } = relationshipPath;
        const relationshipShapeTpl = relationshipShapeMap[relationship.relationshipType];
        const shape = relationshipShapeTpl
            ? relationshipShapeTpl(relationshipPath)
            : null;
        let d = path.path.d();
        if (grid &&
            0 < path.path.M.x &&
            path.path.M.x < width &&
            0 < path.path.M.y &&
            path.path.M.y < height &&
            0 < path.path.L.x &&
            path.path.L.x < width &&
            0 < path.path.L.y &&
            path.path.L.y < height) {
            try {
                const fullPaths = finder.findPath(Math.round(path.path.M.x * ratio), Math.round(path.path.M.y * ratio), Math.round(path.path.L.x * ratio), Math.round(path.path.L.y * ratio), grid.clone());
                const paths = pathfinding.Util.compressPath(fullPaths);
                const len = paths.length;
                const svgPaths = [];
                paths.forEach((p, i) => {
                    if (i < len - 1) {
                        let x1 = Math.round(p[0] / ratio);
                        let y1 = Math.round(p[1] / ratio);
                        let x2 = Math.round(paths[i + 1][0] / ratio);
                        let y2 = Math.round(paths[i + 1][1] / ratio);
                        if (i === 0) {
                            x1 = path.path.M.x;
                            y1 = path.path.M.y;
                        }
                        else if (i === len - 2) {
                            x2 = path.path.L.x;
                            y2 = path.path.L.y;
                        }
                        svgPaths.push(`M ${x1} ${y1} L ${x2} ${y2}`);
                    }
                });
                if (svgPaths.length > 1) {
                    d = svgPaths.join(' ');
                }
            }
            catch (e) { }
        }
        return relationship.startRelationshipType === 'Ring'
            ? svg `
        <path
          d=${d}
          stroke-dasharray=${relationship.identification ? 0 : 10}
          stroke-width=${strokeWidth}
          fill="transparent"
        ></path>
        <line
          x1=${path.line.start.x1} y1=${path.line.start.y1}
          x2=${path.line.start.x2} y2=${path.line.start.y2}
          stroke-width="3"
        ></line>
        <circle
          cx=${line.startCircle.cx} cy=${line.startCircle.cy} r="8"
          fill-opacity="0.0"
          stroke-width="3"
        ></circle>
        <line
          x1=${line.line.start.base.x1} y1=${line.line.start.base.y1}
          x2=${line.line.start.base.x2} y2=${line.line.start.base.y2}
          stroke-width="3"
        ></line>
        <line
          x1=${line.line.start.center.x1} y1=${line.line.start.center.y1}
          x2=${line.line.start.center.x2} y2=${line.line.start.center.y2}
          stroke-width="3"
        ></line>
        ${shape}
    `
            : svg `
        <path
          d=${d}
          stroke-dasharray=${relationship.identification ? 0 : 10}
          stroke-width=${strokeWidth}
          fill="transparent"
        ></path>
        <line
          x1=${path.line.start.x1} y1=${path.line.start.y1}
          x2=${path.line.start.x2} y2=${path.line.start.y2}
          stroke-width="3"
        ></line>
        <line
          x1=${line.line.start.base.x1} y1=${line.line.start.base.y1}
          x2=${line.line.start.base.x2} y2=${line.line.start.base.y2}
          stroke-width="3"
        ></line>
        <line
          x1=${line.line.start.base2.x1} y1=${line.line.start.base2.y1}
          x2=${line.line.start.base2.x2} y2=${line.line.start.base2.y2}
          stroke-width="3"
        ></line>
        <line
          x1=${line.line.start.center2.x1} y1=${line.line.start.center2.y1}
          x2=${line.line.start.center2.x2} y2=${line.line.start.center2.y2}
          stroke-width="3"
        ></line>
        ${shape}
    `;
    }

    const SIZE_GRID = 100;
    const MARGIN$1 = 5;
    const TABLE_PADDING = (SIZE_TABLE_PADDING + SIZE_TABLE_BORDER) * 2;
    const TABLE_MARGIN = MARGIN$1 * 2 + TABLE_PADDING;
    const CanvasSVG = (props, ctx) => {
        const contextRef = useContext$1(ctx);
        const state = observable$1({ activeId: '' });
        const gridCache = new Map();
        const onMouseover = (relationship) => {
            const { store } = contextRef.value;
            store.dispatch(activeColumn(relationship));
            state.activeId = relationship.id;
        };
        const onMouseleave = (relationship) => {
            const { store } = contextRef.value;
            store.dispatch(activeEndColumn(relationship));
            state.activeId = '';
        };
        const range = createBalanceRange(0, SIZE_GRID);
        const getRatio = () => {
            const { store: { canvasState: { width }, }, } = contextRef.value;
            return SIZE_GRID / width;
        };
        const getGrid = () => {
            const { store: { canvasState: { width, height }, }, } = contextRef.value;
            const key = `${width}:${height}`;
            return gridCache.has(key)
                ? gridCache.get(key)
                : gridCache
                    .set(key, new pathfinding.Grid(SIZE_GRID, SIZE_GRID))
                    .get(key);
        };
        const createGrid = () => {
            const { store: { tableState: { tables }, }, } = contextRef.value;
            const ratio = getRatio();
            const grid = getGrid().clone();
            tables.forEach(table => {
                const x = Math.round((table.ui.left - MARGIN$1) * ratio);
                const y = Math.round((table.ui.top - MARGIN$1) * ratio);
                const maxWidth = range(x + Math.round((table.width() + TABLE_MARGIN) * ratio));
                const maxHeight = range(y + Math.round((table.height() + TABLE_MARGIN) * ratio));
                try {
                    for (let i = range(x); i < maxWidth; i++) {
                        for (let j = range(y); j < maxHeight; j++) {
                            grid.setWalkableAt(i, j, false);
                        }
                    }
                }
                catch (e) { }
            });
            return grid;
        };
        return () => {
            const { store: { canvasState: { width, height, setting: { relationshipOptimization }, }, relationshipState: { relationships }, }, } = contextRef.value;
            const ratio = getRatio();
            const grid = relationshipOptimization ? createGrid() : null;
            return svg `
      <svg
        class="vuerd-canvas-svg"
        style=${styleMap({
            width: `${width}px`,
            height: `${height}px`,
        })}
      >
      ${repeat(relationships, relationship => relationship.id, relationship => relationship.visible
            ? svg `
            <g class=${classMap({
                'vuerd-relationship': true,
                identification: relationship.identification &&
                    state.activeId !== relationship.id,
                active: state.activeId === relationship.id,
            })}
              data-id=${relationship.id}
              @mouseover=${() => onMouseover(relationship)}
              @mouseleave=${() => onMouseleave(relationship)}
            >
              ${relationshipTpl(relationship, 3, grid, ratio, width, height)}
            </g>
          `
            : null)}
    </svg>
`;
        };
    };
    defineComponent('vuerd-canvas-svg', {
        shadow: false,
        render: CanvasSVG,
    });

    /**
     * @license
     * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    const templateCaches = new WeakMap();
    /**
     * Enables fast switching between multiple templates by caching the DOM nodes
     * and TemplateInstances produced by the templates.
     *
     * Example:
     *
     * ```
     * let checked = false;
     *
     * html`
     *   ${cache(checked ? html`input is checked` : html`input is not checked`)}
     * `
     * ```
     */
    const cache = directive((value) => (part) => {
        if (!(part instanceof NodePart)) {
            throw new Error('cache can only be used in text bindings');
        }
        let templateCache = templateCaches.get(part);
        if (templateCache === undefined) {
            templateCache = new WeakMap();
            templateCaches.set(part, templateCache);
        }
        const previousValue = part.value;
        // First, can we update the current TemplateInstance, or do we need to move
        // the current nodes into the cache?
        if (previousValue instanceof TemplateInstance) {
            if (value instanceof TemplateResult &&
                previousValue.template === part.options.templateFactory(value)) {
                // Same Template, just trigger an update of the TemplateInstance
                part.setValue(value);
                return;
            }
            else {
                // Not the same Template, move the nodes from the DOM into the cache.
                let cachedTemplate = templateCache.get(previousValue.template);
                if (cachedTemplate === undefined) {
                    cachedTemplate = {
                        instance: previousValue,
                        nodes: document.createDocumentFragment(),
                    };
                    templateCache.set(previousValue.template, cachedTemplate);
                }
                reparentNodes(cachedTemplate.nodes, part.startNode.nextSibling, part.endNode);
            }
        }
        // Next, can we reuse nodes from the cache?
        if (value instanceof TemplateResult) {
            const template = part.options.templateFactory(value);
            const cachedTemplate = templateCache.get(template);
            if (cachedTemplate !== undefined) {
                // Move nodes out of cache
                part.setValue(cachedTemplate.nodes);
                part.commit();
                // Set the Part value to the TemplateInstance so it'll update it.
                part.value = cachedTemplate.instance;
            }
        }
        part.setValue(value);
    });

    function useRenderTrigger() {
        const state = observable$1({ count: 0 });
        const renderTrigger = () => state.count++;
        beforeFirstUpdate(() => state.count);
        beforeUpdate(() => state.count);
        return {
            renderTrigger,
        };
    }

    const Canvas = (props, ctx) => {
        const contextRef = useContext$1(ctx);
        const { unmountedGroup } = useUnmounted();
        const { renderTrigger } = useRenderTrigger();
        beforeMount(() => {
            const { memoState: { memos }, tableState: { tables }, } = contextRef.value.store;
            unmountedGroup.push(watch(tables, renderTrigger), watch(memos, renderTrigger));
        });
        return () => {
            const { canvasState: { width, height, scrollTop, scrollLeft, zoomLevel, show }, memoState: { memos }, tableState: { tables }, editorState: { drawRelationship }, } = contextRef.value.store;
            return html `
      <div
        class="vuerd-canvas"
        style=${styleMap({
            width: `${width}px`,
            height: `${height}px`,
            top: `${scrollTop}px`,
            left: `${scrollLeft}px`,
            transform: `scale(${zoomLevel})`,
        })}
      >
        ${cache(zoomLevel > 0.7
            ? repeat(tables, table => table.id, table => table.visible
                ? html `<vuerd-table .table=${table}></vuerd-table>`
                : null)
            : repeat(tables, table => table.id, table => table.visible
                ? html `
                        <vuerd-high-level-table
                          .table=${table}
                        ></vuerd-high-level-table>
                      `
                : null))}
        ${repeat(memos, memo => memo.id, memo => html `<vuerd-memo .memo=${memo}></vuerd-memo>`)}
        ${show.relationship
            ? html `<vuerd-canvas-svg></vuerd-canvas-svg>`
            : null}
        ${(drawRelationship === null || drawRelationship === void 0 ? void 0 : drawRelationship.start)
            ? html `
              <vuerd-draw-relationship
                .draw=${drawRelationship}
              ></vuerd-draw-relationship>
            `
            : null}
      </div>
    `;
        };
    };
    defineComponent('vuerd-canvas', {
        shadow: false,
        render: Canvas,
    });

    function getOverlapPosition(dragRect, rect) {
        if (dragRect.x > rect.x + rect.w ||
            dragRect.x + dragRect.w < rect.x ||
            dragRect.y > rect.y + rect.h ||
            dragRect.y + dragRect.h < rect.y)
            return null;
        const target = { x1: 0, y1: 0, x2: 0, y2: 0 };
        target.x1 = Math.max(dragRect.x, rect.x);
        target.y1 = Math.max(dragRect.y, rect.y);
        target.x2 = Math.min(dragRect.x + dragRect.w, rect.x + rect.w) - rect.x;
        target.y2 = Math.min(dragRect.y + dragRect.h, rect.y + rect.h) - rect.y;
        return target;
    }
    function getZoomViewport(width, height, zoomLevel) {
        const viewport = { x: 0, y: 0, w: 0, h: 0 };
        viewport.w = width * zoomLevel;
        viewport.h = height * zoomLevel;
        viewport.x = (width - viewport.w) / 2;
        viewport.y = (height - viewport.h) / 2;
        return viewport;
    }
    const getAbsolutePosition = (overlapPosition, zoomViewport, zoomLevel) => ({
        x1: (overlapPosition.x1 - zoomViewport.x) / zoomLevel,
        y1: (overlapPosition.y1 - zoomViewport.y) / zoomLevel,
        x2: overlapPosition.x2 / zoomLevel,
        y2: overlapPosition.y2 / zoomLevel,
    });

    const DragSelect = (props, ctx) => {
        const contextRef = useContext$1(ctx);
        const state = observable$1({ width: 0, height: 0, top: 0, left: 0 });
        const { unmountedGroup } = useUnmounted();
        const onGlobalMouseup = () => {
            ctx.dispatchEvent(new CustomEvent('drag-select-end'));
        };
        beforeMount(() => {
            const { store, globalEvent: { mouseup$ }, } = contextRef.value;
            const { canvasState } = store;
            const erd = closestElement('.vuerd-erd', ctx);
            if (!erd)
                return;
            unmountedGroup.push(mouseup$.subscribe(onGlobalMouseup), fromEvent(erd, 'mousemove').subscribe(event => {
                event.preventDefault();
                const rect = erd.getBoundingClientRect();
                const currentX = event.clientX - rect.x;
                const currentY = event.clientY - rect.y;
                const min = {
                    x: props.x < currentX ? props.x : currentX,
                    y: props.y < currentY ? props.y : currentY,
                };
                const max = {
                    x: props.x > currentX ? props.x : currentX,
                    y: props.y > currentY ? props.y : currentY,
                };
                state.left = min.x;
                state.width = max.x - min.x;
                if (state.width < 0) {
                    state.width = 0;
                }
                state.top = min.y;
                state.height = max.y - min.y;
                if (state.height < 0) {
                    state.height = 0;
                }
                const ghostMin = Object.assign({}, min);
                const ghostMax = Object.assign({}, max);
                ghostMin.x -= canvasState.scrollLeft;
                ghostMin.y -= canvasState.scrollTop;
                ghostMax.x -= canvasState.scrollLeft;
                ghostMax.y -= canvasState.scrollTop;
                const zoomViewportRect = getZoomViewport(canvasState.width, canvasState.height, canvasState.zoomLevel);
                const overlapPosition = getOverlapPosition(Object.assign(Object.assign({}, ghostMin), { w: ghostMax.x - ghostMin.x, h: ghostMax.y - ghostMin.y }), zoomViewportRect);
                if (!overlapPosition)
                    return;
                const absolutePosition = getAbsolutePosition(overlapPosition, zoomViewportRect, canvasState.zoomLevel);
                ghostMin.x = absolutePosition.x1;
                ghostMin.y = absolutePosition.y1;
                ghostMax.x = absolutePosition.x2;
                ghostMax.y = absolutePosition.y2;
                store.dispatch(dragSelectTable(ghostMin, ghostMax), dragSelectMemo(ghostMin, ghostMax));
            }));
        });
        return () => {
            return svg `
      <svg 
        class="vuerd-drag-select" 
        style=${styleMap({
            top: `${state.top}px`,
            left: `${state.left}px`,
            width: `${state.width}px`,
            height: `${state.height}px`,
        })}
      >
        <rect
          width=${state.width}
          height=${state.height}
          stroke-width="1"
          stroke-opacity="0.9"
          stroke-dasharray="3"
          fill-opacity="0.3"
        >
        </rect>
      </svg>    
    `;
        };
    };
    defineComponent('vuerd-drag-select', {
        observedProps: ['x', 'y'],
        shadow: false,
        render: DragSelect,
    });

    const MinimapTable = (props, ctx) => () => {
        const { table } = props;
        const { ui } = table;
        table.maxWidthColumn();
        return html `
    <div
      class="vuerd-table"
      style=${styleMap({
        top: `${ui.top}px`,
        left: `${ui.left}px`,
        zIndex: `${ui.zIndex}`,
        width: `${table.width()}px`,
        height: `${table.height()}px`,
    })}
    ></div>
  `;
    };
    defineComponent('vuerd-minimap-table', {
        observedProps: ['table'],
        shadow: false,
        render: MinimapTable,
    });

    const MEMO_PADDING = SIZE_MEMO_PADDING * 2;
    const MEMO_HEADER = 6 + MEMO_PADDING;
    const MinimapMemo = (props, ctx) => () => {
        const { memo } = props;
        const width = memo.ui.width + MEMO_PADDING;
        const height = memo.ui.height + MEMO_PADDING + MEMO_HEADER;
        return html `
      <div
        class="vuerd-memo"
        style=${styleMap({
        top: `${memo.ui.top}px`,
        left: `${memo.ui.left}px`,
        zIndex: `${memo.ui.zIndex}`,
        width: `${width}px`,
        height: `${height}px`,
    })}
      ></div>
    `;
    };
    defineComponent('vuerd-minimap-memo', {
        observedProps: ['memo'],
        shadow: false,
        render: MinimapMemo,
    });

    const MinimapHandle = (props, ctx) => {
        const contextRef = useContext$1(ctx);
        const getRatio = () => {
            const { width } = contextRef.value.store.canvasState;
            return SIZE_MINIMAP_WIDTH / width;
        };
        const getStyleMap = () => {
            const { scrollLeft, scrollTop } = contextRef.value.store.canvasState;
            const ratio = getRatio();
            const x = scrollLeft * ratio;
            const y = scrollTop * ratio;
            const left = props.width - SIZE_MINIMAP_WIDTH - SIZE_MINIMAP_MARGIN - x;
            const top = SIZE_MINIMAP_MARGIN - y;
            return {
                width: `${props.width * ratio}px`,
                height: `${props.height * ratio}px`,
                left: `${left}px`,
                top: `${top}px`,
            };
        };
        const onMove = ({ event, movementX, movementY }) => {
            event.type === 'mousemove' && event.preventDefault();
            const { store } = contextRef.value;
            const ratio = getRatio();
            store.dispatch(movementCanvas((movementX / ratio) * -1, (movementY / ratio) * -1));
        };
        const onMoveStart = () => {
            const { globalEvent: { drag$ }, } = contextRef.value;
            drag$.subscribe(onMove);
        };
        return () => html `
    <div
      class="vuerd-minimap-handle"
      style=${styleMap(getStyleMap())}
      @mousedown=${onMoveStart}
      @touchstart=${onMoveStart}
    ></div>
  `;
    };
    defineComponent('vuerd-minimap-handle', {
        observedProps: ['width', 'height'],
        shadow: false,
        render: MinimapHandle,
    });

    const Minimap = (props, ctx) => {
        const contextRef = useContext$1(ctx);
        const { unmountedGroup } = useUnmounted();
        const { renderTrigger } = useRenderTrigger();
        const getStyleMap = () => {
            const { width, height } = contextRef.value.store.canvasState;
            const ratio = SIZE_MINIMAP_WIDTH / width;
            const x = (-1 * width) / 2 + SIZE_MINIMAP_WIDTH / 2;
            const y = (-1 * height) / 2 + (height * ratio) / 2;
            const left = x - SIZE_MINIMAP_WIDTH - SIZE_MINIMAP_MARGIN + props.width;
            const top = y + SIZE_MINIMAP_MARGIN;
            return {
                transform: `scale(${ratio}, ${ratio})`,
                width: `${width}px`,
                height: `${height}px`,
                left: `${left}px`,
                top: `${top}px`,
            };
        };
        const getShadowStyle = () => {
            const left = props.width - SIZE_MINIMAP_WIDTH - SIZE_MINIMAP_MARGIN;
            const top = SIZE_MINIMAP_MARGIN;
            return {
                width: `${SIZE_MINIMAP_WIDTH}px`,
                height: `${SIZE_MINIMAP_WIDTH}px`,
                left: `${left}px`,
                top: `${top}px`,
            };
        };
        const onClickMove = (ev) => {
            const { store } = contextRef.value;
            // minimap position
            const mapPosLeft = props.width - SIZE_MINIMAP_WIDTH - SIZE_MINIMAP_MARGIN;
            const mapPosTop = SIZE_MINIMAP_MARGIN + SIZE_MENUBAR_HEIGHT;
            // mouse on minimap
            const leftMap = ev.x - mapPosLeft;
            const topMap = ev.y - mapPosTop;
            // ratio size of minimap
            const { width } = contextRef.value.store.canvasState;
            const ratio = SIZE_MINIMAP_WIDTH / width;
            // the orange square showing what user sees position
            const mapDetailTop = (props.height * ratio) / 2;
            const mapDetailLeft = (props.width * ratio) / 2;
            // real movement
            const { scrollLeft, scrollTop } = contextRef.value.store.canvasState;
            const movementX = scrollLeft + (leftMap - mapDetailLeft) / ratio;
            const movementY = scrollTop + (topMap - mapDetailTop) / ratio;
            store.dispatch(movementCanvas(-movementX, -movementY));
        };
        beforeMount(() => {
            const { memoState: { memos }, tableState: { tables }, relationshipState: { relationships }, } = contextRef.value.store;
            unmountedGroup.push(watch(tables, renderTrigger), watch(memos, renderTrigger), watch(relationships, renderTrigger));
        });
        return () => {
            const { canvasState: { width, height, zoomLevel, show }, tableState: { tables }, memoState: { memos }, relationshipState: { relationships }, } = contextRef.value.store;
            return html `
      <div
        class="vuerd-minimap-shadow"
        style=${styleMap(getShadowStyle())}
      ></div>
      <div
        class="vuerd-minimap"
        style=${styleMap(getStyleMap())}
        @click=${onClickMove}
      >
        <div class="vuerd-erd-background"></div>
        <div
          class="vuerd-canvas"
          style=${styleMap({
            width: `${width}px`,
            height: `${height}px`,
            transform: `scale(${zoomLevel})`,
        })}
        >
          ${repeat(tables, table => table.id, table => table.visible
            ? html `
                    <vuerd-minimap-table .table=${table}></vuerd-minimap-table>
                  `
            : null)}
          ${repeat(memos, memo => memo.id, memo => html `<vuerd-minimap-memo .memo=${memo}></vuerd-minimap-memo>`)}
          ${show.relationship
            ? svg `
              <svg
                class="vuerd-canvas-svg"
                style=${styleMap({
                width: `${width}px`,
                height: `${height}px`,
            })}
              >
              ${repeat(relationships, relationship => relationship.id, relationship => relationship.visible
                ? svg `
                    <g
                      class=${classMap({
                    'vuerd-relationship': true,
                    identification: relationship.identification,
                })}
                    >
                      ${relationshipTpl(relationship, 12)}
                    </g>
                `
                : null)}
              </svg>
          `
            : null}
        </div>
      </div>
      <vuerd-minimap-handle
        .width=${props.width}
        .height=${props.height}
      ></vuerd-minimap-handle>
    `;
        };
    };
    defineComponent('vuerd-minimap', {
        observedProps: ['width', 'height'],
        shadow: false,
        render: Minimap,
    });

    const findIndex$2 = findIndex$5(propEq$1('active', true));
    function useTableHint(ctx) {
        const contextRef = useContext$1(ctx);
        const { unmountedGroup } = useUnmounted();
        const state = observable$1({
            value: '',
            hints: [],
            isFilter: true,
            focus: false,
        });
        const inputRef = query('input');
        const getActiveIndex = () => findIndex$2(state.hints);
        const setHints = () => {
            if (!state.isFilter)
                return;
            const { store: { tableState: { tables }, }, } = contextRef.value;
            state.hints =
                state.value.trim().length < 1
                    ? []
                    : tables
                        .filter(table => table.name.toLowerCase().indexOf(state.value.toLowerCase()) !==
                        -1)
                        .map(column => {
                        return {
                            id: column.id,
                            name: column.name,
                            html: markToHTML('vuerd-find-table-hint-mark', column.name, state.value),
                            active: false,
                        };
                    });
        };
        const activeEnd = () => {
            state.hints.forEach(hint => (hint.active = false));
        };
        const moveCanvasFindTable = (table) => {
            const { store } = contextRef.value;
            store.dispatch(moveCanvas((table.ui.top - SIZE_START_Y) * -1, (table.ui.left - SIZE_START_X) * -1), selectTable(store, false, table.id));
        };
        const onSelectHint = (hint) => {
            activeEnd();
            state.isFilter = false;
            lastCursorFocus(inputRef.value);
            const { tables } = contextRef.value.store.tableState;
            const table = getData(tables, hint.id);
            if (table) {
                moveCanvasFindTable(table);
            }
        };
        const onArrowUp = (event) => {
            state.hints.length !== 0 && event.preventDefault();
            const index = getActiveIndex();
            if (index > 0) {
                state.hints[index].active = false;
                state.hints[index - 1].active = true;
            }
            else if (state.hints.length) {
                index === 0 && (state.hints[index].active = false);
                state.hints[state.hints.length - 1].active = true;
            }
        };
        const onArrowDown = (event) => {
            state.hints.length !== 0 && event.preventDefault();
            const index = getActiveIndex();
            if (index !== -1 && index !== state.hints.length - 1) {
                state.hints[index].active = false;
                state.hints[index + 1].active = true;
            }
            else if (state.hints.length) {
                index === state.hints.length - 1 && (state.hints[index].active = false);
                state.hints[0].active = true;
            }
        };
        const onArrowLeft = () => activeEnd();
        const onArrowRight = (event) => {
            const index = getActiveIndex();
            if (index < 0)
                return;
            event.preventDefault();
            state.isFilter = false;
            const { tables } = contextRef.value.store.tableState;
            const table = getData(tables, state.hints[index].id);
            if (table) {
                moveCanvasFindTable(table);
            }
        };
        const arrowMap = {
            ArrowUp: onArrowUp,
            ArrowDown: onArrowDown,
            ArrowLeft: onArrowLeft,
            ArrowRight: onArrowRight,
        };
        const onKeydown = (event) => {
            switch (event.key) {
                case 'ArrowUp':
                case 'ArrowDown':
                case 'ArrowLeft':
                case 'ArrowRight':
                    arrowMap[event.key](event);
                    break;
                case 'Enter':
                    arrowMap.ArrowRight(event);
                    break;
            }
        };
        const onInput = (event) => {
            const input = event.target;
            state.value = input.value;
            state.isFilter = true;
        };
        const initHints = () => {
            state.isFilter = true;
            setHints();
        };
        beforeMount(() => unmountedGroup.push(watch(state, propName => {
            if (propName !== 'value')
                return;
            setHints();
        })));
        return {
            hintState: state,
            onSelectHint,
            onKeydown,
            onInput,
            initHints,
        };
    }

    const hintTpl$1 = (props, state) => html `
  <ul class="vuerd-find-table-list">
    ${repeat(state.hints, hint => hint.id, hint => {
    return html `
          <li
            class=${classMap({
        'vuerd-find-table-hint': true,
        active: hint.active,
    })}
            @click=${() => props.onSelectHint(hint)}
          >
            ${unsafeHTML(hint.html)}
          </li>
        `;
})}
  </ul>
`;

    const ANIMATION_TIME$2 = 200;
    const HEIGHT$2 = 33;
    const Find = (props, ctx) => {
        const contextRef = useContext$1(ctx);
        const { unmountedGroup } = useUnmounted();
        const { resetTooltip } = useTooltip(['.vuerd-button'], ctx);
        const { hintState, onSelectHint, onKeydown, onInput, initHints } = useTableHint(ctx);
        const inputRef = query('input');
        const state = observable$1({ top: 0, visible: false });
        let openTween = null;
        let closeTween = null;
        useFlipAnimation(ctx, '.vuerd-find-table-hint', 'vuerd-find-table-hint-move');
        const emitBlur = () => ctx.dispatchEvent(new CustomEvent('vuerd-input-blur', {
            composed: true,
            bubbles: true,
        }));
        const onOpen = () => {
            if (openTween)
                return;
            closeTween === null || closeTween === void 0 ? void 0 : closeTween.stop();
            closeTween = null;
            state.visible = true;
            state.top = state.top === 0 ? -1 * HEIGHT$2 : state.top;
            openTween = new Tween(state)
                .to({ top: 0 }, ANIMATION_TIME$2)
                .easing(Easing.Quadratic.Out)
                .onComplete(() => (openTween = null))
                .start();
        };
        const onClose = () => {
            if (closeTween)
                return;
            openTween === null || openTween === void 0 ? void 0 : openTween.stop();
            openTween = null;
            closeTween = new Tween(state)
                .to({ top: -1 * HEIGHT$2 }, ANIMATION_TIME$2)
                .easing(Easing.Quadratic.In)
                .onComplete(() => {
                closeTween = null;
                state.visible = false;
                ctx.dispatchEvent(new CustomEvent('close'));
                emitBlur();
            })
                .start();
        };
        const focus = () => {
            const input = inputRef.value;
            input === null || input === void 0 ? void 0 : input.focus();
        };
        const onFocus = () => {
            hintState.focus = true;
        };
        const onBlur = () => {
            hintState.focus = false;
            setTimeout(() => {
                if (hintState.focus)
                    return;
                hintState.hints = [];
            }, 200);
        };
        beforeMount(() => unmountedGroup.push(watch(props, propName => {
            if (propName !== 'visible')
                return;
            props.visible ? onOpen() : onClose();
            props.visible &&
                setTimeout(() => {
                    resetTooltip();
                    focus();
                    initHints();
                }, 0);
        })));
        return () => {
            const { keymap } = contextRef.value;
            const keymapStop = keymapOptionsToString(keymap.stop);
            return state.visible
                ? html `
          <div
            class="vuerd-find"
            style=${styleMap({
                top: `${state.top}px`,
                height: `${HEIGHT$2}px`,
            })}
          >
            <div class="vuerd-find-table">
              <input
                type="text"
                spellcheck="false"
                placeholder="table"
                .value=${hintState.value}
                @keydown=${onKeydown}
                @input=${onInput}
                @focus=${onFocus}
                @blur=${onBlur}
              />
              ${hintTpl$1({ onSelectHint }, hintState)}
            </div>
            <vuerd-icon
              class="vuerd-button"
              data-tippy-content=${keymapStop}
              name="times"
              size="12"
              @click=${onClose}
            ></vuerd-icon>
          </div>
        `
                : null;
        };
    };
    defineComponent('vuerd-find', {
        observedProps: [
            {
                name: 'visible',
                type: Boolean,
                default: false,
            },
        ],
        shadow: false,
        render: Find,
    });

    const defaultOptions$e = {
        nameWidth: 80,
        keymapWidth: 0,
        close: false,
    };
    const createDatabaseMenus = ({ store }) => databaseList.map(databaseType => ({
        icon: store.canvasState.database === databaseType
            ? {
                prefix: 'fas',
                name: 'check',
            }
            : undefined,
        name: databaseType,
        execute: () => store.dispatch(changeDatabase(databaseType)),
        options: Object.assign({}, defaultOptions$e),
    }));

    class InternMap extends Map {
      constructor(entries, key = keyof) {
        super();
        Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});
        if (entries != null) for (const [key, value] of entries) this.set(key, value);
      }
      get(key) {
        return super.get(intern_get(this, key));
      }
      has(key) {
        return super.has(intern_get(this, key));
      }
      set(key, value) {
        return super.set(intern_set(this, key), value);
      }
      delete(key) {
        return super.delete(intern_delete(this, key));
      }
    }

    function intern_get({_intern, _key}, value) {
      const key = _key(value);
      return _intern.has(key) ? _intern.get(key) : value;
    }

    function intern_set({_intern, _key}, value) {
      const key = _key(value);
      if (_intern.has(key)) return _intern.get(key);
      _intern.set(key, value);
      return value;
    }

    function intern_delete({_intern, _key}, value) {
      const key = _key(value);
      if (_intern.has(key)) {
        value = _intern.get(value);
        _intern.delete(key);
      }
      return value;
    }

    function keyof(value) {
      return value !== null && typeof value === "object" ? value.valueOf() : value;
    }

    var noop = {value: () => {}};

    function dispatch() {
      for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
        if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
        _[t] = [];
      }
      return new Dispatch(_);
    }

    function Dispatch(_) {
      this._ = _;
    }

    function parseTypenames$1(typenames, types) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
        return {type: t, name: name};
      });
    }

    Dispatch.prototype = dispatch.prototype = {
      constructor: Dispatch,
      on: function(typename, callback) {
        var _ = this._,
            T = parseTypenames$1(typename + "", _),
            t,
            i = -1,
            n = T.length;

        // If no callback was specified, return the callback of the given type and name.
        if (arguments.length < 2) {
          while (++i < n) if ((t = (typename = T[i]).type) && (t = get$1(_[t], typename.name))) return t;
          return;
        }

        // If a type was specified, set the callback for the given type and name.
        // Otherwise, if a null callback was specified, remove callbacks of the given name.
        if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
        while (++i < n) {
          if (t = (typename = T[i]).type) _[t] = set$1(_[t], typename.name, callback);
          else if (callback == null) for (t in _) _[t] = set$1(_[t], typename.name, null);
        }

        return this;
      },
      copy: function() {
        var copy = {}, _ = this._;
        for (var t in _) copy[t] = _[t].slice();
        return new Dispatch(copy);
      },
      call: function(type, that) {
        if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      },
      apply: function(type, that, args) {
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      }
    };

    function get$1(type, name) {
      for (var i = 0, n = type.length, c; i < n; ++i) {
        if ((c = type[i]).name === name) {
          return c.value;
        }
      }
    }

    function set$1(type, name, callback) {
      for (var i = 0, n = type.length; i < n; ++i) {
        if (type[i].name === name) {
          type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
          break;
        }
      }
      if (callback != null) type.push({name: name, value: callback});
      return type;
    }

    var xhtml = "http://www.w3.org/1999/xhtml";

    var namespaces = {
      svg: "http://www.w3.org/2000/svg",
      xhtml: xhtml,
      xlink: "http://www.w3.org/1999/xlink",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/"
    };

    function namespace(name) {
      var prefix = name += "", i = prefix.indexOf(":");
      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
      return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name; // eslint-disable-line no-prototype-builtins
    }

    function creatorInherit(name) {
      return function() {
        var document = this.ownerDocument,
            uri = this.namespaceURI;
        return uri === xhtml && document.documentElement.namespaceURI === xhtml
            ? document.createElement(name)
            : document.createElementNS(uri, name);
      };
    }

    function creatorFixed(fullname) {
      return function() {
        return this.ownerDocument.createElementNS(fullname.space, fullname.local);
      };
    }

    function creator(name) {
      var fullname = namespace(name);
      return (fullname.local
          ? creatorFixed
          : creatorInherit)(fullname);
    }

    function none() {}

    function selector(selector) {
      return selector == null ? none : function() {
        return this.querySelector(selector);
      };
    }

    function selection_select(select) {
      if (typeof select !== "function") select = selector(select);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
          }
        }
      }

      return new Selection$1(subgroups, this._parents);
    }

    // Given something array like (or null), returns something that is strictly an
    // array. This is used to ensure that array-like objects passed to d3.selectAll
    // or selection.selectAll are converted into proper arrays when creating a
    // selection; we dont ever want to create a selection backed by a live
    // HTMLCollection or NodeList. However, note that selection.selectAll will use a
    // static NodeList as a group, since it safely derived from querySelectorAll.
    function array(x) {
      return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
    }

    function empty() {
      return [];
    }

    function selectorAll(selector) {
      return selector == null ? empty : function() {
        return this.querySelectorAll(selector);
      };
    }

    function arrayAll(select) {
      return function() {
        return array(select.apply(this, arguments));
      };
    }

    function selection_selectAll(select) {
      if (typeof select === "function") select = arrayAll(select);
      else select = selectorAll(select);

      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            subgroups.push(select.call(node, node.__data__, i, group));
            parents.push(node);
          }
        }
      }

      return new Selection$1(subgroups, parents);
    }

    function matcher(selector) {
      return function() {
        return this.matches(selector);
      };
    }

    function childMatcher(selector) {
      return function(node) {
        return node.matches(selector);
      };
    }

    var find$1 = Array.prototype.find;

    function childFind(match) {
      return function() {
        return find$1.call(this.children, match);
      };
    }

    function childFirst() {
      return this.firstElementChild;
    }

    function selection_selectChild(match) {
      return this.select(match == null ? childFirst
          : childFind(typeof match === "function" ? match : childMatcher(match)));
    }

    var filter = Array.prototype.filter;

    function children() {
      return Array.from(this.children);
    }

    function childrenFilter(match) {
      return function() {
        return filter.call(this.children, match);
      };
    }

    function selection_selectChildren(match) {
      return this.selectAll(match == null ? children
          : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
    }

    function selection_filter(match) {
      if (typeof match !== "function") match = matcher(match);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
            subgroup.push(node);
          }
        }
      }

      return new Selection$1(subgroups, this._parents);
    }

    function sparse(update) {
      return new Array(update.length);
    }

    function selection_enter() {
      return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
    }

    function EnterNode(parent, datum) {
      this.ownerDocument = parent.ownerDocument;
      this.namespaceURI = parent.namespaceURI;
      this._next = null;
      this._parent = parent;
      this.__data__ = datum;
    }

    EnterNode.prototype = {
      constructor: EnterNode,
      appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
      insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
      querySelector: function(selector) { return this._parent.querySelector(selector); },
      querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
    };

    function constant$3(x) {
      return function() {
        return x;
      };
    }

    function bindIndex(parent, group, enter, update, exit, data) {
      var i = 0,
          node,
          groupLength = group.length,
          dataLength = data.length;

      // Put any non-null nodes that fit into update.
      // Put any null nodes into enter.
      // Put any remaining data into enter.
      for (; i < dataLength; ++i) {
        if (node = group[i]) {
          node.__data__ = data[i];
          update[i] = node;
        } else {
          enter[i] = new EnterNode(parent, data[i]);
        }
      }

      // Put any non-null nodes that dont fit into exit.
      for (; i < groupLength; ++i) {
        if (node = group[i]) {
          exit[i] = node;
        }
      }
    }

    function bindKey(parent, group, enter, update, exit, data, key) {
      var i,
          node,
          nodeByKeyValue = new Map,
          groupLength = group.length,
          dataLength = data.length,
          keyValues = new Array(groupLength),
          keyValue;

      // Compute the key for each node.
      // If multiple nodes have the same key, the duplicates are added to exit.
      for (i = 0; i < groupLength; ++i) {
        if (node = group[i]) {
          keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
          if (nodeByKeyValue.has(keyValue)) {
            exit[i] = node;
          } else {
            nodeByKeyValue.set(keyValue, node);
          }
        }
      }

      // Compute the key for each datum.
      // If there a node associated with this key, join and add it to update.
      // If there is not (or the key is a duplicate), add it to enter.
      for (i = 0; i < dataLength; ++i) {
        keyValue = key.call(parent, data[i], i, data) + "";
        if (node = nodeByKeyValue.get(keyValue)) {
          update[i] = node;
          node.__data__ = data[i];
          nodeByKeyValue.delete(keyValue);
        } else {
          enter[i] = new EnterNode(parent, data[i]);
        }
      }

      // Add any remaining nodes that were not bound to data to exit.
      for (i = 0; i < groupLength; ++i) {
        if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {
          exit[i] = node;
        }
      }
    }

    function datum(node) {
      return node.__data__;
    }

    function selection_data(value, key) {
      if (!arguments.length) return Array.from(this, datum);

      var bind = key ? bindKey : bindIndex,
          parents = this._parents,
          groups = this._groups;

      if (typeof value !== "function") value = constant$3(value);

      for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
        var parent = parents[j],
            group = groups[j],
            groupLength = group.length,
            data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
            dataLength = data.length,
            enterGroup = enter[j] = new Array(dataLength),
            updateGroup = update[j] = new Array(dataLength),
            exitGroup = exit[j] = new Array(groupLength);

        bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

        // Now connect the enter nodes to their following update node, such that
        // appendChild can insert the materialized enter node before this node,
        // rather than at the end of the parent node.
        for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
          if (previous = enterGroup[i0]) {
            if (i0 >= i1) i1 = i0 + 1;
            while (!(next = updateGroup[i1]) && ++i1 < dataLength);
            previous._next = next || null;
          }
        }
      }

      update = new Selection$1(update, parents);
      update._enter = enter;
      update._exit = exit;
      return update;
    }

    // Given some data, this returns an array-like view of it: an object that
    // exposes a length property and allows numeric indexing. Note that unlike
    // selectAll, this isnt worried about live collections because the resulting
    // array will only be used briefly while data is being bound. (It is possible to
    // cause the data to change while iterating by using a key function, but please
    // dont; wed rather avoid a gratuitous copy.)
    function arraylike(data) {
      return typeof data === "object" && "length" in data
        ? data // Array, TypedArray, NodeList, array-like
        : Array.from(data); // Map, Set, iterable, string, or anything else
    }

    function selection_exit() {
      return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
    }

    function selection_join(onenter, onupdate, onexit) {
      var enter = this.enter(), update = this, exit = this.exit();
      if (typeof onenter === "function") {
        enter = onenter(enter);
        if (enter) enter = enter.selection();
      } else {
        enter = enter.append(onenter + "");
      }
      if (onupdate != null) {
        update = onupdate(update);
        if (update) update = update.selection();
      }
      if (onexit == null) exit.remove(); else onexit(exit);
      return enter && update ? enter.merge(update).order() : update;
    }

    function selection_merge(context) {
      var selection = context.selection ? context.selection() : context;

      for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge[i] = node;
          }
        }
      }

      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }

      return new Selection$1(merges, this._parents);
    }

    function selection_order() {

      for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
        for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
          if (node = group[i]) {
            if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
            next = node;
          }
        }
      }

      return this;
    }

    function selection_sort(compare) {
      if (!compare) compare = ascending;

      function compareNode(a, b) {
        return a && b ? compare(a.__data__, b.__data__) : !a - !b;
      }

      for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            sortgroup[i] = node;
          }
        }
        sortgroup.sort(compareNode);
      }

      return new Selection$1(sortgroups, this._parents).order();
    }

    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function selection_call() {
      var callback = arguments[0];
      arguments[0] = this;
      callback.apply(null, arguments);
      return this;
    }

    function selection_nodes() {
      return Array.from(this);
    }

    function selection_node() {

      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
          var node = group[i];
          if (node) return node;
        }
      }

      return null;
    }

    function selection_size() {
      let size = 0;
      for (const node of this) ++size; // eslint-disable-line no-unused-vars
      return size;
    }

    function selection_empty() {
      return !this.node();
    }

    function selection_each(callback) {

      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
          if (node = group[i]) callback.call(node, node.__data__, i, group);
        }
      }

      return this;
    }

    function attrRemove$1(name) {
      return function() {
        this.removeAttribute(name);
      };
    }

    function attrRemoveNS$1(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }

    function attrConstant$1(name, value) {
      return function() {
        this.setAttribute(name, value);
      };
    }

    function attrConstantNS$1(fullname, value) {
      return function() {
        this.setAttributeNS(fullname.space, fullname.local, value);
      };
    }

    function attrFunction$1(name, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttribute(name);
        else this.setAttribute(name, v);
      };
    }

    function attrFunctionNS$1(fullname, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
        else this.setAttributeNS(fullname.space, fullname.local, v);
      };
    }

    function selection_attr(name, value) {
      var fullname = namespace(name);

      if (arguments.length < 2) {
        var node = this.node();
        return fullname.local
            ? node.getAttributeNS(fullname.space, fullname.local)
            : node.getAttribute(fullname);
      }

      return this.each((value == null
          ? (fullname.local ? attrRemoveNS$1 : attrRemove$1) : (typeof value === "function"
          ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)
          : (fullname.local ? attrConstantNS$1 : attrConstant$1)))(fullname, value));
    }

    function defaultView(node) {
      return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
          || (node.document && node) // node is a Window
          || node.defaultView; // node is a Document
    }

    function styleRemove$1(name) {
      return function() {
        this.style.removeProperty(name);
      };
    }

    function styleConstant$1(name, value, priority) {
      return function() {
        this.style.setProperty(name, value, priority);
      };
    }

    function styleFunction$1(name, value, priority) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.style.removeProperty(name);
        else this.style.setProperty(name, v, priority);
      };
    }

    function selection_style(name, value, priority) {
      return arguments.length > 1
          ? this.each((value == null
                ? styleRemove$1 : typeof value === "function"
                ? styleFunction$1
                : styleConstant$1)(name, value, priority == null ? "" : priority))
          : styleValue(this.node(), name);
    }

    function styleValue(node, name) {
      return node.style.getPropertyValue(name)
          || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
    }

    function propertyRemove(name) {
      return function() {
        delete this[name];
      };
    }

    function propertyConstant(name, value) {
      return function() {
        this[name] = value;
      };
    }

    function propertyFunction(name, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) delete this[name];
        else this[name] = v;
      };
    }

    function selection_property(name, value) {
      return arguments.length > 1
          ? this.each((value == null
              ? propertyRemove : typeof value === "function"
              ? propertyFunction
              : propertyConstant)(name, value))
          : this.node()[name];
    }

    function classArray(string) {
      return string.trim().split(/^|\s+/);
    }

    function classList(node) {
      return node.classList || new ClassList(node);
    }

    function ClassList(node) {
      this._node = node;
      this._names = classArray(node.getAttribute("class") || "");
    }

    ClassList.prototype = {
      add: function(name) {
        var i = this._names.indexOf(name);
        if (i < 0) {
          this._names.push(name);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      remove: function(name) {
        var i = this._names.indexOf(name);
        if (i >= 0) {
          this._names.splice(i, 1);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      contains: function(name) {
        return this._names.indexOf(name) >= 0;
      }
    };

    function classedAdd(node, names) {
      var list = classList(node), i = -1, n = names.length;
      while (++i < n) list.add(names[i]);
    }

    function classedRemove(node, names) {
      var list = classList(node), i = -1, n = names.length;
      while (++i < n) list.remove(names[i]);
    }

    function classedTrue(names) {
      return function() {
        classedAdd(this, names);
      };
    }

    function classedFalse(names) {
      return function() {
        classedRemove(this, names);
      };
    }

    function classedFunction(names, value) {
      return function() {
        (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
      };
    }

    function selection_classed(name, value) {
      var names = classArray(name + "");

      if (arguments.length < 2) {
        var list = classList(this.node()), i = -1, n = names.length;
        while (++i < n) if (!list.contains(names[i])) return false;
        return true;
      }

      return this.each((typeof value === "function"
          ? classedFunction : value
          ? classedTrue
          : classedFalse)(names, value));
    }

    function textRemove() {
      this.textContent = "";
    }

    function textConstant$1(value) {
      return function() {
        this.textContent = value;
      };
    }

    function textFunction$1(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.textContent = v == null ? "" : v;
      };
    }

    function selection_text(value) {
      return arguments.length
          ? this.each(value == null
              ? textRemove : (typeof value === "function"
              ? textFunction$1
              : textConstant$1)(value))
          : this.node().textContent;
    }

    function htmlRemove() {
      this.innerHTML = "";
    }

    function htmlConstant(value) {
      return function() {
        this.innerHTML = value;
      };
    }

    function htmlFunction(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.innerHTML = v == null ? "" : v;
      };
    }

    function selection_html(value) {
      return arguments.length
          ? this.each(value == null
              ? htmlRemove : (typeof value === "function"
              ? htmlFunction
              : htmlConstant)(value))
          : this.node().innerHTML;
    }

    function raise() {
      if (this.nextSibling) this.parentNode.appendChild(this);
    }

    function selection_raise() {
      return this.each(raise);
    }

    function lower() {
      if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
    }

    function selection_lower() {
      return this.each(lower);
    }

    function selection_append(name) {
      var create = typeof name === "function" ? name : creator(name);
      return this.select(function() {
        return this.appendChild(create.apply(this, arguments));
      });
    }

    function constantNull() {
      return null;
    }

    function selection_insert(name, before) {
      var create = typeof name === "function" ? name : creator(name),
          select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
      return this.select(function() {
        return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
      });
    }

    function remove() {
      var parent = this.parentNode;
      if (parent) parent.removeChild(this);
    }

    function selection_remove() {
      return this.each(remove);
    }

    function selection_cloneShallow() {
      var clone = this.cloneNode(false), parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }

    function selection_cloneDeep() {
      var clone = this.cloneNode(true), parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }

    function selection_clone(deep) {
      return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
    }

    function selection_datum(value) {
      return arguments.length
          ? this.property("__data__", value)
          : this.node().__data__;
    }

    function contextListener(listener) {
      return function(event) {
        listener.call(this, event, this.__data__);
      };
    }

    function parseTypenames(typenames) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        return {type: t, name: name};
      });
    }

    function onRemove(typename) {
      return function() {
        var on = this.__on;
        if (!on) return;
        for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
          if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
          } else {
            on[++i] = o;
          }
        }
        if (++i) on.length = i;
        else delete this.__on;
      };
    }

    function onAdd(typename, value, options) {
      return function() {
        var on = this.__on, o, listener = contextListener(value);
        if (on) for (var j = 0, m = on.length; j < m; ++j) {
          if ((o = on[j]).type === typename.type && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
            this.addEventListener(o.type, o.listener = listener, o.options = options);
            o.value = value;
            return;
          }
        }
        this.addEventListener(typename.type, listener, options);
        o = {type: typename.type, name: typename.name, value: value, listener: listener, options: options};
        if (!on) this.__on = [o];
        else on.push(o);
      };
    }

    function selection_on(typename, value, options) {
      var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

      if (arguments.length < 2) {
        var on = this.node().__on;
        if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
          for (i = 0, o = on[j]; i < n; ++i) {
            if ((t = typenames[i]).type === o.type && t.name === o.name) {
              return o.value;
            }
          }
        }
        return;
      }

      on = value ? onAdd : onRemove;
      for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
      return this;
    }

    function dispatchEvent(node, type, params) {
      var window = defaultView(node),
          event = window.CustomEvent;

      if (typeof event === "function") {
        event = new event(type, params);
      } else {
        event = window.document.createEvent("Event");
        if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
        else event.initEvent(type, false, false);
      }

      node.dispatchEvent(event);
    }

    function dispatchConstant(type, params) {
      return function() {
        return dispatchEvent(this, type, params);
      };
    }

    function dispatchFunction(type, params) {
      return function() {
        return dispatchEvent(this, type, params.apply(this, arguments));
      };
    }

    function selection_dispatch(type, params) {
      return this.each((typeof params === "function"
          ? dispatchFunction
          : dispatchConstant)(type, params));
    }

    function* selection_iterator() {
      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
          if (node = group[i]) yield node;
        }
      }
    }

    var root = [null];

    function Selection$1(groups, parents) {
      this._groups = groups;
      this._parents = parents;
    }

    function selection() {
      return new Selection$1([[document.documentElement]], root);
    }

    function selection_selection() {
      return this;
    }

    Selection$1.prototype = selection.prototype = {
      constructor: Selection$1,
      select: selection_select,
      selectAll: selection_selectAll,
      selectChild: selection_selectChild,
      selectChildren: selection_selectChildren,
      filter: selection_filter,
      data: selection_data,
      enter: selection_enter,
      exit: selection_exit,
      join: selection_join,
      merge: selection_merge,
      selection: selection_selection,
      order: selection_order,
      sort: selection_sort,
      call: selection_call,
      nodes: selection_nodes,
      node: selection_node,
      size: selection_size,
      empty: selection_empty,
      each: selection_each,
      attr: selection_attr,
      style: selection_style,
      property: selection_property,
      classed: selection_classed,
      text: selection_text,
      html: selection_html,
      raise: selection_raise,
      lower: selection_lower,
      append: selection_append,
      insert: selection_insert,
      remove: selection_remove,
      clone: selection_clone,
      datum: selection_datum,
      on: selection_on,
      dispatch: selection_dispatch,
      [Symbol.iterator]: selection_iterator
    };

    function select(selector) {
      return typeof selector === "string"
          ? new Selection$1([[document.querySelector(selector)]], [document.documentElement])
          : new Selection$1([[selector]], root);
    }

    function create$1(name) {
      return select(creator(name).call(document.documentElement));
    }

    function sourceEvent(event) {
      let sourceEvent;
      while (sourceEvent = event.sourceEvent) event = sourceEvent;
      return event;
    }

    function pointer(event, node) {
      event = sourceEvent(event);
      if (node === undefined) node = event.currentTarget;
      if (node) {
        var svg = node.ownerSVGElement || node;
        if (svg.createSVGPoint) {
          var point = svg.createSVGPoint();
          point.x = event.clientX, point.y = event.clientY;
          point = point.matrixTransform(node.getScreenCTM().inverse());
          return [point.x, point.y];
        }
        if (node.getBoundingClientRect) {
          var rect = node.getBoundingClientRect();
          return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
        }
      }
      return [event.pageX, event.pageY];
    }

    // These are typically used in conjunction with noevent to ensure that we can
    // preventDefault on the event.
    const nonpassive = {passive: false};
    const nonpassivecapture = {capture: true, passive: false};

    function nopropagation(event) {
      event.stopImmediatePropagation();
    }

    function noevent(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    function dragDisable(view) {
      var root = view.document.documentElement,
          selection = select(view).on("dragstart.drag", noevent, nonpassivecapture);
      if ("onselectstart" in root) {
        selection.on("selectstart.drag", noevent, nonpassivecapture);
      } else {
        root.__noselect = root.style.MozUserSelect;
        root.style.MozUserSelect = "none";
      }
    }

    function yesdrag(view, noclick) {
      var root = view.document.documentElement,
          selection = select(view).on("dragstart.drag", null);
      if (noclick) {
        selection.on("click.drag", noevent, nonpassivecapture);
        setTimeout(function() { selection.on("click.drag", null); }, 0);
      }
      if ("onselectstart" in root) {
        selection.on("selectstart.drag", null);
      } else {
        root.style.MozUserSelect = root.__noselect;
        delete root.__noselect;
      }
    }

    var constant$2 = x => () => x;

    function DragEvent(type, {
      sourceEvent,
      subject,
      target,
      identifier,
      active,
      x, y, dx, dy,
      dispatch
    }) {
      Object.defineProperties(this, {
        type: {value: type, enumerable: true, configurable: true},
        sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
        subject: {value: subject, enumerable: true, configurable: true},
        target: {value: target, enumerable: true, configurable: true},
        identifier: {value: identifier, enumerable: true, configurable: true},
        active: {value: active, enumerable: true, configurable: true},
        x: {value: x, enumerable: true, configurable: true},
        y: {value: y, enumerable: true, configurable: true},
        dx: {value: dx, enumerable: true, configurable: true},
        dy: {value: dy, enumerable: true, configurable: true},
        _: {value: dispatch}
      });
    }

    DragEvent.prototype.on = function() {
      var value = this._.on.apply(this._, arguments);
      return value === this._ ? this : value;
    };

    // Ignore right-click, since that should open the context menu.
    function defaultFilter(event) {
      return !event.ctrlKey && !event.button;
    }

    function defaultContainer() {
      return this.parentNode;
    }

    function defaultSubject(event, d) {
      return d == null ? {x: event.x, y: event.y} : d;
    }

    function defaultTouchable() {
      return navigator.maxTouchPoints || ("ontouchstart" in this);
    }

    function drag() {
      var filter = defaultFilter,
          container = defaultContainer,
          subject = defaultSubject,
          touchable = defaultTouchable,
          gestures = {},
          listeners = dispatch("start", "drag", "end"),
          active = 0,
          mousedownx,
          mousedowny,
          mousemoving,
          touchending,
          clickDistance2 = 0;

      function drag(selection) {
        selection
            .on("mousedown.drag", mousedowned)
          .filter(touchable)
            .on("touchstart.drag", touchstarted)
            .on("touchmove.drag", touchmoved, nonpassive)
            .on("touchend.drag touchcancel.drag", touchended)
            .style("touch-action", "none")
            .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }

      function mousedowned(event, d) {
        if (touchending || !filter.call(this, event, d)) return;
        var gesture = beforestart(this, container.call(this, event, d), event, d, "mouse");
        if (!gesture) return;
        select(event.view)
          .on("mousemove.drag", mousemoved, nonpassivecapture)
          .on("mouseup.drag", mouseupped, nonpassivecapture);
        dragDisable(event.view);
        nopropagation(event);
        mousemoving = false;
        mousedownx = event.clientX;
        mousedowny = event.clientY;
        gesture("start", event);
      }

      function mousemoved(event) {
        noevent(event);
        if (!mousemoving) {
          var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
          mousemoving = dx * dx + dy * dy > clickDistance2;
        }
        gestures.mouse("drag", event);
      }

      function mouseupped(event) {
        select(event.view).on("mousemove.drag mouseup.drag", null);
        yesdrag(event.view, mousemoving);
        noevent(event);
        gestures.mouse("end", event);
      }

      function touchstarted(event, d) {
        if (!filter.call(this, event, d)) return;
        var touches = event.changedTouches,
            c = container.call(this, event, d),
            n = touches.length, i, gesture;

        for (i = 0; i < n; ++i) {
          if (gesture = beforestart(this, c, event, d, touches[i].identifier, touches[i])) {
            nopropagation(event);
            gesture("start", event, touches[i]);
          }
        }
      }

      function touchmoved(event) {
        var touches = event.changedTouches,
            n = touches.length, i, gesture;

        for (i = 0; i < n; ++i) {
          if (gesture = gestures[touches[i].identifier]) {
            noevent(event);
            gesture("drag", event, touches[i]);
          }
        }
      }

      function touchended(event) {
        var touches = event.changedTouches,
            n = touches.length, i, gesture;

        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
        for (i = 0; i < n; ++i) {
          if (gesture = gestures[touches[i].identifier]) {
            nopropagation(event);
            gesture("end", event, touches[i]);
          }
        }
      }

      function beforestart(that, container, event, d, identifier, touch) {
        var dispatch = listeners.copy(),
            p = pointer(touch || event, container), dx, dy,
            s;

        if ((s = subject.call(that, new DragEvent("beforestart", {
            sourceEvent: event,
            target: drag,
            identifier,
            active,
            x: p[0],
            y: p[1],
            dx: 0,
            dy: 0,
            dispatch
          }), d)) == null) return;

        dx = s.x - p[0] || 0;
        dy = s.y - p[1] || 0;

        return function gesture(type, event, touch) {
          var p0 = p, n;
          switch (type) {
            case "start": gestures[identifier] = gesture, n = active++; break;
            case "end": delete gestures[identifier], --active; // falls through
            case "drag": p = pointer(touch || event, container), n = active; break;
          }
          dispatch.call(
            type,
            that,
            new DragEvent(type, {
              sourceEvent: event,
              subject: s,
              target: drag,
              identifier,
              active: n,
              x: p[0] + dx,
              y: p[1] + dy,
              dx: p[0] - p0[0],
              dy: p[1] - p0[1],
              dispatch
            }),
            d
          );
        };
      }

      drag.filter = function(_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : constant$2(!!_), drag) : filter;
      };

      drag.container = function(_) {
        return arguments.length ? (container = typeof _ === "function" ? _ : constant$2(_), drag) : container;
      };

      drag.subject = function(_) {
        return arguments.length ? (subject = typeof _ === "function" ? _ : constant$2(_), drag) : subject;
      };

      drag.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$2(!!_), drag) : touchable;
      };

      drag.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? drag : value;
      };

      drag.clickDistance = function(_) {
        return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
      };

      return drag;
    }

    function define(constructor, factory, prototype) {
      constructor.prototype = factory.prototype = prototype;
      prototype.constructor = constructor;
    }

    function extend(parent, definition) {
      var prototype = Object.create(parent.prototype);
      for (var key in definition) prototype[key] = definition[key];
      return prototype;
    }

    function Color$1() {}

    var darker = 0.7;
    var brighter = 1 / darker;

    var reI = "\\s*([+-]?\\d+)\\s*",
        reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
        reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
        reHex = /^#([0-9a-f]{3,8})$/,
        reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
        reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
        reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
        reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
        reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
        reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

    var named = {
      aliceblue: 0xf0f8ff,
      antiquewhite: 0xfaebd7,
      aqua: 0x00ffff,
      aquamarine: 0x7fffd4,
      azure: 0xf0ffff,
      beige: 0xf5f5dc,
      bisque: 0xffe4c4,
      black: 0x000000,
      blanchedalmond: 0xffebcd,
      blue: 0x0000ff,
      blueviolet: 0x8a2be2,
      brown: 0xa52a2a,
      burlywood: 0xdeb887,
      cadetblue: 0x5f9ea0,
      chartreuse: 0x7fff00,
      chocolate: 0xd2691e,
      coral: 0xff7f50,
      cornflowerblue: 0x6495ed,
      cornsilk: 0xfff8dc,
      crimson: 0xdc143c,
      cyan: 0x00ffff,
      darkblue: 0x00008b,
      darkcyan: 0x008b8b,
      darkgoldenrod: 0xb8860b,
      darkgray: 0xa9a9a9,
      darkgreen: 0x006400,
      darkgrey: 0xa9a9a9,
      darkkhaki: 0xbdb76b,
      darkmagenta: 0x8b008b,
      darkolivegreen: 0x556b2f,
      darkorange: 0xff8c00,
      darkorchid: 0x9932cc,
      darkred: 0x8b0000,
      darksalmon: 0xe9967a,
      darkseagreen: 0x8fbc8f,
      darkslateblue: 0x483d8b,
      darkslategray: 0x2f4f4f,
      darkslategrey: 0x2f4f4f,
      darkturquoise: 0x00ced1,
      darkviolet: 0x9400d3,
      deeppink: 0xff1493,
      deepskyblue: 0x00bfff,
      dimgray: 0x696969,
      dimgrey: 0x696969,
      dodgerblue: 0x1e90ff,
      firebrick: 0xb22222,
      floralwhite: 0xfffaf0,
      forestgreen: 0x228b22,
      fuchsia: 0xff00ff,
      gainsboro: 0xdcdcdc,
      ghostwhite: 0xf8f8ff,
      gold: 0xffd700,
      goldenrod: 0xdaa520,
      gray: 0x808080,
      green: 0x008000,
      greenyellow: 0xadff2f,
      grey: 0x808080,
      honeydew: 0xf0fff0,
      hotpink: 0xff69b4,
      indianred: 0xcd5c5c,
      indigo: 0x4b0082,
      ivory: 0xfffff0,
      khaki: 0xf0e68c,
      lavender: 0xe6e6fa,
      lavenderblush: 0xfff0f5,
      lawngreen: 0x7cfc00,
      lemonchiffon: 0xfffacd,
      lightblue: 0xadd8e6,
      lightcoral: 0xf08080,
      lightcyan: 0xe0ffff,
      lightgoldenrodyellow: 0xfafad2,
      lightgray: 0xd3d3d3,
      lightgreen: 0x90ee90,
      lightgrey: 0xd3d3d3,
      lightpink: 0xffb6c1,
      lightsalmon: 0xffa07a,
      lightseagreen: 0x20b2aa,
      lightskyblue: 0x87cefa,
      lightslategray: 0x778899,
      lightslategrey: 0x778899,
      lightsteelblue: 0xb0c4de,
      lightyellow: 0xffffe0,
      lime: 0x00ff00,
      limegreen: 0x32cd32,
      linen: 0xfaf0e6,
      magenta: 0xff00ff,
      maroon: 0x800000,
      mediumaquamarine: 0x66cdaa,
      mediumblue: 0x0000cd,
      mediumorchid: 0xba55d3,
      mediumpurple: 0x9370db,
      mediumseagreen: 0x3cb371,
      mediumslateblue: 0x7b68ee,
      mediumspringgreen: 0x00fa9a,
      mediumturquoise: 0x48d1cc,
      mediumvioletred: 0xc71585,
      midnightblue: 0x191970,
      mintcream: 0xf5fffa,
      mistyrose: 0xffe4e1,
      moccasin: 0xffe4b5,
      navajowhite: 0xffdead,
      navy: 0x000080,
      oldlace: 0xfdf5e6,
      olive: 0x808000,
      olivedrab: 0x6b8e23,
      orange: 0xffa500,
      orangered: 0xff4500,
      orchid: 0xda70d6,
      palegoldenrod: 0xeee8aa,
      palegreen: 0x98fb98,
      paleturquoise: 0xafeeee,
      palevioletred: 0xdb7093,
      papayawhip: 0xffefd5,
      peachpuff: 0xffdab9,
      peru: 0xcd853f,
      pink: 0xffc0cb,
      plum: 0xdda0dd,
      powderblue: 0xb0e0e6,
      purple: 0x800080,
      rebeccapurple: 0x663399,
      red: 0xff0000,
      rosybrown: 0xbc8f8f,
      royalblue: 0x4169e1,
      saddlebrown: 0x8b4513,
      salmon: 0xfa8072,
      sandybrown: 0xf4a460,
      seagreen: 0x2e8b57,
      seashell: 0xfff5ee,
      sienna: 0xa0522d,
      silver: 0xc0c0c0,
      skyblue: 0x87ceeb,
      slateblue: 0x6a5acd,
      slategray: 0x708090,
      slategrey: 0x708090,
      snow: 0xfffafa,
      springgreen: 0x00ff7f,
      steelblue: 0x4682b4,
      tan: 0xd2b48c,
      teal: 0x008080,
      thistle: 0xd8bfd8,
      tomato: 0xff6347,
      turquoise: 0x40e0d0,
      violet: 0xee82ee,
      wheat: 0xf5deb3,
      white: 0xffffff,
      whitesmoke: 0xf5f5f5,
      yellow: 0xffff00,
      yellowgreen: 0x9acd32
    };

    define(Color$1, color, {
      copy: function(channels) {
        return Object.assign(new this.constructor, this, channels);
      },
      displayable: function() {
        return this.rgb().displayable();
      },
      hex: color_formatHex, // Deprecated! Use color.formatHex.
      formatHex: color_formatHex,
      formatHsl: color_formatHsl,
      formatRgb: color_formatRgb,
      toString: color_formatRgb
    });

    function color_formatHex() {
      return this.rgb().formatHex();
    }

    function color_formatHsl() {
      return hslConvert(this).formatHsl();
    }

    function color_formatRgb() {
      return this.rgb().formatRgb();
    }

    function color(format) {
      var m, l;
      format = (format + "").trim().toLowerCase();
      return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
          : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
          : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
          : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
          : null) // invalid hex
          : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
          : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
          : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
          : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
          : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
          : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
          : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
          : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
          : null;
    }

    function rgbn(n) {
      return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
    }

    function rgba(r, g, b, a) {
      if (a <= 0) r = g = b = NaN;
      return new Rgb(r, g, b, a);
    }

    function rgbConvert(o) {
      if (!(o instanceof Color$1)) o = color(o);
      if (!o) return new Rgb;
      o = o.rgb();
      return new Rgb(o.r, o.g, o.b, o.opacity);
    }

    function rgb(r, g, b, opacity) {
      return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
    }

    function Rgb(r, g, b, opacity) {
      this.r = +r;
      this.g = +g;
      this.b = +b;
      this.opacity = +opacity;
    }

    define(Rgb, rgb, extend(Color$1, {
      brighter: function(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      darker: function(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      rgb: function() {
        return this;
      },
      displayable: function() {
        return (-0.5 <= this.r && this.r < 255.5)
            && (-0.5 <= this.g && this.g < 255.5)
            && (-0.5 <= this.b && this.b < 255.5)
            && (0 <= this.opacity && this.opacity <= 1);
      },
      hex: rgb_formatHex, // Deprecated! Use color.formatHex.
      formatHex: rgb_formatHex,
      formatRgb: rgb_formatRgb,
      toString: rgb_formatRgb
    }));

    function rgb_formatHex() {
      return "#" + hex(this.r) + hex(this.g) + hex(this.b);
    }

    function rgb_formatRgb() {
      var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
      return (a === 1 ? "rgb(" : "rgba(")
          + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
          + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
          + Math.max(0, Math.min(255, Math.round(this.b) || 0))
          + (a === 1 ? ")" : ", " + a + ")");
    }

    function hex(value) {
      value = Math.max(0, Math.min(255, Math.round(value) || 0));
      return (value < 16 ? "0" : "") + value.toString(16);
    }

    function hsla(h, s, l, a) {
      if (a <= 0) h = s = l = NaN;
      else if (l <= 0 || l >= 1) h = s = NaN;
      else if (s <= 0) h = NaN;
      return new Hsl(h, s, l, a);
    }

    function hslConvert(o) {
      if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Color$1)) o = color(o);
      if (!o) return new Hsl;
      if (o instanceof Hsl) return o;
      o = o.rgb();
      var r = o.r / 255,
          g = o.g / 255,
          b = o.b / 255,
          min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          h = NaN,
          s = max - min,
          l = (max + min) / 2;
      if (s) {
        if (r === max) h = (g - b) / s + (g < b) * 6;
        else if (g === max) h = (b - r) / s + 2;
        else h = (r - g) / s + 4;
        s /= l < 0.5 ? max + min : 2 - max - min;
        h *= 60;
      } else {
        s = l > 0 && l < 1 ? 0 : h;
      }
      return new Hsl(h, s, l, o.opacity);
    }

    function hsl(h, s, l, opacity) {
      return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
    }

    function Hsl(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }

    define(Hsl, hsl, extend(Color$1, {
      brighter: function(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      darker: function(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      rgb: function() {
        var h = this.h % 360 + (this.h < 0) * 360,
            s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
            l = this.l,
            m2 = l + (l < 0.5 ? l : 1 - l) * s,
            m1 = 2 * l - m2;
        return new Rgb(
          hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
          hsl2rgb(h, m1, m2),
          hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
          this.opacity
        );
      },
      displayable: function() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s))
            && (0 <= this.l && this.l <= 1)
            && (0 <= this.opacity && this.opacity <= 1);
      },
      formatHsl: function() {
        var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
        return (a === 1 ? "hsl(" : "hsla(")
            + (this.h || 0) + ", "
            + (this.s || 0) * 100 + "%, "
            + (this.l || 0) * 100 + "%"
            + (a === 1 ? ")" : ", " + a + ")");
      }
    }));

    /* From FvD 13.37, CSS Color Module Level 3 */
    function hsl2rgb(h, m1, m2) {
      return (h < 60 ? m1 + (m2 - m1) * h / 60
          : h < 180 ? m2
          : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
          : m1) * 255;
    }

    var constant$1 = x => () => x;

    function linear(a, d) {
      return function(t) {
        return a + t * d;
      };
    }

    function exponential(a, b, y) {
      return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
        return Math.pow(a + t * b, y);
      };
    }

    function gamma(y) {
      return (y = +y) === 1 ? nogamma : function(a, b) {
        return b - a ? exponential(a, b, y) : constant$1(isNaN(a) ? b : a);
      };
    }

    function nogamma(a, b) {
      var d = b - a;
      return d ? linear(a, d) : constant$1(isNaN(a) ? b : a);
    }

    var interpolateRgb = (function rgbGamma(y) {
      var color = gamma(y);

      function rgb$1(start, end) {
        var r = color((start = rgb(start)).r, (end = rgb(end)).r),
            g = color(start.g, end.g),
            b = color(start.b, end.b),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.r = r(t);
          start.g = g(t);
          start.b = b(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }

      rgb$1.gamma = rgbGamma;

      return rgb$1;
    })(1);

    function interpolateNumber(a, b) {
      return a = +a, b = +b, function(t) {
        return a * (1 - t) + b * t;
      };
    }

    var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
        reB = new RegExp(reA.source, "g");

    function zero(b) {
      return function() {
        return b;
      };
    }

    function one(b) {
      return function(t) {
        return b(t) + "";
      };
    }

    function interpolateString(a, b) {
      var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
          am, // current match in a
          bm, // current match in b
          bs, // string preceding current number in b, if any
          i = -1, // index in s
          s = [], // string constants and placeholders
          q = []; // number interpolators

      // Coerce inputs to strings.
      a = a + "", b = b + "";

      // Interpolate pairs of numbers in a & b.
      while ((am = reA.exec(a))
          && (bm = reB.exec(b))) {
        if ((bs = bm.index) > bi) { // a string precedes the next number in b
          bs = b.slice(bi, bs);
          if (s[i]) s[i] += bs; // coalesce with previous string
          else s[++i] = bs;
        }
        if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
          if (s[i]) s[i] += bm; // coalesce with previous string
          else s[++i] = bm;
        } else { // interpolate non-matching numbers
          s[++i] = null;
          q.push({i: i, x: interpolateNumber(am, bm)});
        }
        bi = reB.lastIndex;
      }

      // Add remains of b.
      if (bi < b.length) {
        bs = b.slice(bi);
        if (s[i]) s[i] += bs; // coalesce with previous string
        else s[++i] = bs;
      }

      // Special optimization for only a single match.
      // Otherwise, interpolate each of the numbers and rejoin the string.
      return s.length < 2 ? (q[0]
          ? one(q[0].x)
          : zero(b))
          : (b = q.length, function(t) {
              for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
              return s.join("");
            });
    }

    var degrees = 180 / Math.PI;

    var identity = {
      translateX: 0,
      translateY: 0,
      rotate: 0,
      skewX: 0,
      scaleX: 1,
      scaleY: 1
    };

    function decompose(a, b, c, d, e, f) {
      var scaleX, scaleY, skewX;
      if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
      if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
      if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
      if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
      return {
        translateX: e,
        translateY: f,
        rotate: Math.atan2(b, a) * degrees,
        skewX: Math.atan(skewX) * degrees,
        scaleX: scaleX,
        scaleY: scaleY
      };
    }

    var svgNode;

    /* eslint-disable no-undef */
    function parseCss(value) {
      const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
      return m.isIdentity ? identity : decompose(m.a, m.b, m.c, m.d, m.e, m.f);
    }

    function parseSvg(value) {
      if (value == null) return identity;
      if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
      svgNode.setAttribute("transform", value);
      if (!(value = svgNode.transform.baseVal.consolidate())) return identity;
      value = value.matrix;
      return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
    }

    function interpolateTransform(parse, pxComma, pxParen, degParen) {

      function pop(s) {
        return s.length ? s.pop() + " " : "";
      }

      function translate(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push("translate(", null, pxComma, null, pxParen);
          q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
        } else if (xb || yb) {
          s.push("translate(" + xb + pxComma + yb + pxParen);
        }
      }

      function rotate(a, b, s, q) {
        if (a !== b) {
          if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
          q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b)});
        } else if (b) {
          s.push(pop(s) + "rotate(" + b + degParen);
        }
      }

      function skewX(a, b, s, q) {
        if (a !== b) {
          q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b)});
        } else if (b) {
          s.push(pop(s) + "skewX(" + b + degParen);
        }
      }

      function scale(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push(pop(s) + "scale(", null, ",", null, ")");
          q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
        } else if (xb !== 1 || yb !== 1) {
          s.push(pop(s) + "scale(" + xb + "," + yb + ")");
        }
      }

      return function(a, b) {
        var s = [], // string constants and placeholders
            q = []; // number interpolators
        a = parse(a), b = parse(b);
        translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
        rotate(a.rotate, b.rotate, s, q);
        skewX(a.skewX, b.skewX, s, q);
        scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
        a = b = null; // gc
        return function(t) {
          var i = -1, n = q.length, o;
          while (++i < n) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        };
      };
    }

    var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
    var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

    var frame = 0, // is an animation frame pending?
        timeout$1 = 0, // is a timeout pending?
        interval = 0, // are any timers active?
        pokeDelay = 1000, // how frequently we check for clock skew
        taskHead,
        taskTail,
        clockLast = 0,
        clockNow = 0,
        clockSkew = 0,
        clock = typeof performance === "object" && performance.now ? performance : Date,
        setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

    function now() {
      return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
    }

    function clearNow() {
      clockNow = 0;
    }

    function Timer() {
      this._call =
      this._time =
      this._next = null;
    }

    Timer.prototype = timer.prototype = {
      constructor: Timer,
      restart: function(callback, delay, time) {
        if (typeof callback !== "function") throw new TypeError("callback is not a function");
        time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
        if (!this._next && taskTail !== this) {
          if (taskTail) taskTail._next = this;
          else taskHead = this;
          taskTail = this;
        }
        this._call = callback;
        this._time = time;
        sleep();
      },
      stop: function() {
        if (this._call) {
          this._call = null;
          this._time = Infinity;
          sleep();
        }
      }
    };

    function timer(callback, delay, time) {
      var t = new Timer;
      t.restart(callback, delay, time);
      return t;
    }

    function timerFlush() {
      now(); // Get the current time, if not already set.
      ++frame; // Pretend weve set an alarm, if we havent already.
      var t = taskHead, e;
      while (t) {
        if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
        t = t._next;
      }
      --frame;
    }

    function wake() {
      clockNow = (clockLast = clock.now()) + clockSkew;
      frame = timeout$1 = 0;
      try {
        timerFlush();
      } finally {
        frame = 0;
        nap();
        clockNow = 0;
      }
    }

    function poke() {
      var now = clock.now(), delay = now - clockLast;
      if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
    }

    function nap() {
      var t0, t1 = taskHead, t2, time = Infinity;
      while (t1) {
        if (t1._call) {
          if (time > t1._time) time = t1._time;
          t0 = t1, t1 = t1._next;
        } else {
          t2 = t1._next, t1._next = null;
          t1 = t0 ? t0._next = t2 : taskHead = t2;
        }
      }
      taskTail = t0;
      sleep(time);
    }

    function sleep(time) {
      if (frame) return; // Soonest alarm already set, or will be.
      if (timeout$1) timeout$1 = clearTimeout(timeout$1);
      var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
      if (delay > 24) {
        if (time < Infinity) timeout$1 = setTimeout(wake, time - clock.now() - clockSkew);
        if (interval) interval = clearInterval(interval);
      } else {
        if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
        frame = 1, setFrame(wake);
      }
    }

    function timeout(callback, delay, time) {
      var t = new Timer;
      delay = delay == null ? 0 : +delay;
      t.restart(elapsed => {
        t.stop();
        callback(elapsed + delay);
      }, delay, time);
      return t;
    }

    var emptyOn = dispatch("start", "end", "cancel", "interrupt");
    var emptyTween = [];

    var CREATED = 0;
    var SCHEDULED = 1;
    var STARTING = 2;
    var STARTED = 3;
    var RUNNING = 4;
    var ENDING = 5;
    var ENDED = 6;

    function schedule(node, name, id, index, group, timing) {
      var schedules = node.__transition;
      if (!schedules) node.__transition = {};
      else if (id in schedules) return;
      create(node, id, {
        name: name,
        index: index, // For context during callback.
        group: group, // For context during callback.
        on: emptyOn,
        tween: emptyTween,
        time: timing.time,
        delay: timing.delay,
        duration: timing.duration,
        ease: timing.ease,
        timer: null,
        state: CREATED
      });
    }

    function init(node, id) {
      var schedule = get(node, id);
      if (schedule.state > CREATED) throw new Error("too late; already scheduled");
      return schedule;
    }

    function set(node, id) {
      var schedule = get(node, id);
      if (schedule.state > STARTED) throw new Error("too late; already running");
      return schedule;
    }

    function get(node, id) {
      var schedule = node.__transition;
      if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
      return schedule;
    }

    function create(node, id, self) {
      var schedules = node.__transition,
          tween;

      // Initialize the self timer when the transition is created.
      // Note the actual delay is not known until the first callback!
      schedules[id] = self;
      self.timer = timer(schedule, 0, self.time);

      function schedule(elapsed) {
        self.state = SCHEDULED;
        self.timer.restart(start, self.delay, self.time);

        // If the elapsed delay is less than our first sleep, start immediately.
        if (self.delay <= elapsed) start(elapsed - self.delay);
      }

      function start(elapsed) {
        var i, j, n, o;

        // If the state is not SCHEDULED, then we previously errored on start.
        if (self.state !== SCHEDULED) return stop();

        for (i in schedules) {
          o = schedules[i];
          if (o.name !== self.name) continue;

          // While this element already has a starting transition during this frame,
          // defer starting an interrupting transition until that transition has a
          // chance to tick (and possibly end); see d3/d3-transition#54!
          if (o.state === STARTED) return timeout(start);

          // Interrupt the active transition, if any.
          if (o.state === RUNNING) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("interrupt", node, node.__data__, o.index, o.group);
            delete schedules[i];
          }

          // Cancel any pre-empted transitions.
          else if (+i < id) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("cancel", node, node.__data__, o.index, o.group);
            delete schedules[i];
          }
        }

        // Defer the first tick to end of the current frame; see d3/d3#1576.
        // Note the transition may be canceled after start and before the first tick!
        // Note this must be scheduled before the start event; see d3/d3-transition#16!
        // Assuming this is successful, subsequent callbacks go straight to tick.
        timeout(function() {
          if (self.state === STARTED) {
            self.state = RUNNING;
            self.timer.restart(tick, self.delay, self.time);
            tick(elapsed);
          }
        });

        // Dispatch the start event.
        // Note this must be done before the tween are initialized.
        self.state = STARTING;
        self.on.call("start", node, node.__data__, self.index, self.group);
        if (self.state !== STARTING) return; // interrupted
        self.state = STARTED;

        // Initialize the tween, deleting null tween.
        tween = new Array(n = self.tween.length);
        for (i = 0, j = -1; i < n; ++i) {
          if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
            tween[++j] = o;
          }
        }
        tween.length = j + 1;
      }

      function tick(elapsed) {
        var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
            i = -1,
            n = tween.length;

        while (++i < n) {
          tween[i].call(node, t);
        }

        // Dispatch the end event.
        if (self.state === ENDING) {
          self.on.call("end", node, node.__data__, self.index, self.group);
          stop();
        }
      }

      function stop() {
        self.state = ENDED;
        self.timer.stop();
        delete schedules[id];
        for (var i in schedules) return; // eslint-disable-line no-unused-vars
        delete node.__transition;
      }
    }

    function interrupt(node, name) {
      var schedules = node.__transition,
          schedule,
          active,
          empty = true,
          i;

      if (!schedules) return;

      name = name == null ? null : name + "";

      for (i in schedules) {
        if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
        active = schedule.state > STARTING && schedule.state < ENDING;
        schedule.state = ENDED;
        schedule.timer.stop();
        schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
        delete schedules[i];
      }

      if (empty) delete node.__transition;
    }

    function selection_interrupt(name) {
      return this.each(function() {
        interrupt(this, name);
      });
    }

    function tweenRemove(id, name) {
      var tween0, tween1;
      return function() {
        var schedule = set(this, id),
            tween = schedule.tween;

        // If this node shared tween with the previous node,
        // just assign the updated shared tween and were done!
        // Otherwise, copy-on-write.
        if (tween !== tween0) {
          tween1 = tween0 = tween;
          for (var i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name) {
              tween1 = tween1.slice();
              tween1.splice(i, 1);
              break;
            }
          }
        }

        schedule.tween = tween1;
      };
    }

    function tweenFunction(id, name, value) {
      var tween0, tween1;
      if (typeof value !== "function") throw new Error;
      return function() {
        var schedule = set(this, id),
            tween = schedule.tween;

        // If this node shared tween with the previous node,
        // just assign the updated shared tween and were done!
        // Otherwise, copy-on-write.
        if (tween !== tween0) {
          tween1 = (tween0 = tween).slice();
          for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name) {
              tween1[i] = t;
              break;
            }
          }
          if (i === n) tween1.push(t);
        }

        schedule.tween = tween1;
      };
    }

    function transition_tween(name, value) {
      var id = this._id;

      name += "";

      if (arguments.length < 2) {
        var tween = get(this.node(), id).tween;
        for (var i = 0, n = tween.length, t; i < n; ++i) {
          if ((t = tween[i]).name === name) {
            return t.value;
          }
        }
        return null;
      }

      return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
    }

    function tweenValue(transition, name, value) {
      var id = transition._id;

      transition.each(function() {
        var schedule = set(this, id);
        (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
      });

      return function(node) {
        return get(node, id).value[name];
      };
    }

    function interpolate(a, b) {
      var c;
      return (typeof b === "number" ? interpolateNumber
          : b instanceof color ? interpolateRgb
          : (c = color(b)) ? (b = c, interpolateRgb)
          : interpolateString)(a, b);
    }

    function attrRemove(name) {
      return function() {
        this.removeAttribute(name);
      };
    }

    function attrRemoveNS(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }

    function attrConstant(name, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = this.getAttribute(name);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function attrConstantNS(fullname, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = this.getAttributeNS(fullname.space, fullname.local);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function attrFunction(name, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0, value1 = value(this), string1;
        if (value1 == null) return void this.removeAttribute(name);
        string0 = this.getAttribute(name);
        string1 = value1 + "";
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function attrFunctionNS(fullname, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0, value1 = value(this), string1;
        if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
        string0 = this.getAttributeNS(fullname.space, fullname.local);
        string1 = value1 + "";
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function transition_attr(name, value) {
      var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate;
      return this.attrTween(name, typeof value === "function"
          ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value))
          : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
          : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
    }

    function attrInterpolate(name, i) {
      return function(t) {
        this.setAttribute(name, i.call(this, t));
      };
    }

    function attrInterpolateNS(fullname, i) {
      return function(t) {
        this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
      };
    }

    function attrTweenNS(fullname, value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function attrTween(name, value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function transition_attrTween(name, value) {
      var key = "attr." + name;
      if (arguments.length < 2) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      var fullname = namespace(name);
      return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
    }

    function delayFunction(id, value) {
      return function() {
        init(this, id).delay = +value.apply(this, arguments);
      };
    }

    function delayConstant(id, value) {
      return value = +value, function() {
        init(this, id).delay = value;
      };
    }

    function transition_delay(value) {
      var id = this._id;

      return arguments.length
          ? this.each((typeof value === "function"
              ? delayFunction
              : delayConstant)(id, value))
          : get(this.node(), id).delay;
    }

    function durationFunction(id, value) {
      return function() {
        set(this, id).duration = +value.apply(this, arguments);
      };
    }

    function durationConstant(id, value) {
      return value = +value, function() {
        set(this, id).duration = value;
      };
    }

    function transition_duration(value) {
      var id = this._id;

      return arguments.length
          ? this.each((typeof value === "function"
              ? durationFunction
              : durationConstant)(id, value))
          : get(this.node(), id).duration;
    }

    function easeConstant(id, value) {
      if (typeof value !== "function") throw new Error;
      return function() {
        set(this, id).ease = value;
      };
    }

    function transition_ease(value) {
      var id = this._id;

      return arguments.length
          ? this.each(easeConstant(id, value))
          : get(this.node(), id).ease;
    }

    function easeVarying(id, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (typeof v !== "function") throw new Error;
        set(this, id).ease = v;
      };
    }

    function transition_easeVarying(value) {
      if (typeof value !== "function") throw new Error;
      return this.each(easeVarying(this._id, value));
    }

    function transition_filter(match) {
      if (typeof match !== "function") match = matcher(match);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
            subgroup.push(node);
          }
        }
      }

      return new Transition(subgroups, this._parents, this._name, this._id);
    }

    function transition_merge(transition) {
      if (transition._id !== this._id) throw new Error;

      for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge[i] = node;
          }
        }
      }

      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }

      return new Transition(merges, this._parents, this._name, this._id);
    }

    function start(name) {
      return (name + "").trim().split(/^|\s+/).every(function(t) {
        var i = t.indexOf(".");
        if (i >= 0) t = t.slice(0, i);
        return !t || t === "start";
      });
    }

    function onFunction(id, name, listener) {
      var on0, on1, sit = start(name) ? init : set;
      return function() {
        var schedule = sit(this, id),
            on = schedule.on;

        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and were done!
        // Otherwise, copy-on-write.
        if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

        schedule.on = on1;
      };
    }

    function transition_on(name, listener) {
      var id = this._id;

      return arguments.length < 2
          ? get(this.node(), id).on.on(name)
          : this.each(onFunction(id, name, listener));
    }

    function removeFunction(id) {
      return function() {
        var parent = this.parentNode;
        for (var i in this.__transition) if (+i !== id) return;
        if (parent) parent.removeChild(this);
      };
    }

    function transition_remove() {
      return this.on("end.remove", removeFunction(this._id));
    }

    function transition_select(select) {
      var name = this._name,
          id = this._id;

      if (typeof select !== "function") select = selector(select);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
            schedule(subgroup[i], name, id, i, subgroup, get(node, id));
          }
        }
      }

      return new Transition(subgroups, this._parents, name, id);
    }

    function transition_selectAll(select) {
      var name = this._name,
          id = this._id;

      if (typeof select !== "function") select = selectorAll(select);

      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            for (var children = select.call(node, node.__data__, i, group), child, inherit = get(node, id), k = 0, l = children.length; k < l; ++k) {
              if (child = children[k]) {
                schedule(child, name, id, k, children, inherit);
              }
            }
            subgroups.push(children);
            parents.push(node);
          }
        }
      }

      return new Transition(subgroups, parents, name, id);
    }

    var Selection = selection.prototype.constructor;

    function transition_selection() {
      return new Selection(this._groups, this._parents);
    }

    function styleNull(name, interpolate) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0 = styleValue(this, name),
            string1 = (this.style.removeProperty(name), styleValue(this, name));
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, string10 = string1);
      };
    }

    function styleRemove(name) {
      return function() {
        this.style.removeProperty(name);
      };
    }

    function styleConstant(name, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = styleValue(this, name);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function styleFunction(name, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0 = styleValue(this, name),
            value1 = value(this),
            string1 = value1 + "";
        if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function styleMaybeRemove(id, name) {
      var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
      return function() {
        var schedule = set(this, id),
            on = schedule.on,
            listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and were done!
        // Otherwise, copy-on-write.
        if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

        schedule.on = on1;
      };
    }

    function transition_style(name, value, priority) {
      var i = (name += "") === "transform" ? interpolateTransformCss : interpolate;
      return value == null ? this
          .styleTween(name, styleNull(name, i))
          .on("end.style." + name, styleRemove(name))
        : typeof value === "function" ? this
          .styleTween(name, styleFunction(name, i, tweenValue(this, "style." + name, value)))
          .each(styleMaybeRemove(this._id, name))
        : this
          .styleTween(name, styleConstant(name, i, value), priority)
          .on("end.style." + name, null);
    }

    function styleInterpolate(name, i, priority) {
      return function(t) {
        this.style.setProperty(name, i.call(this, t), priority);
      };
    }

    function styleTween(name, value, priority) {
      var t, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
        return t;
      }
      tween._value = value;
      return tween;
    }

    function transition_styleTween(name, value, priority) {
      var key = "style." + (name += "");
      if (arguments.length < 2) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
    }

    function textConstant(value) {
      return function() {
        this.textContent = value;
      };
    }

    function textFunction(value) {
      return function() {
        var value1 = value(this);
        this.textContent = value1 == null ? "" : value1;
      };
    }

    function transition_text(value) {
      return this.tween("text", typeof value === "function"
          ? textFunction(tweenValue(this, "text", value))
          : textConstant(value == null ? "" : value + ""));
    }

    function textInterpolate(i) {
      return function(t) {
        this.textContent = i.call(this, t);
      };
    }

    function textTween(value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function transition_textTween(value) {
      var key = "text";
      if (arguments.length < 1) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      return this.tween(key, textTween(value));
    }

    function transition_transition() {
      var name = this._name,
          id0 = this._id,
          id1 = newId();

      for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            var inherit = get(node, id0);
            schedule(node, name, id1, i, group, {
              time: inherit.time + inherit.delay + inherit.duration,
              delay: 0,
              duration: inherit.duration,
              ease: inherit.ease
            });
          }
        }
      }

      return new Transition(groups, this._parents, name, id1);
    }

    function transition_end() {
      var on0, on1, that = this, id = that._id, size = that.size();
      return new Promise(function(resolve, reject) {
        var cancel = {value: reject},
            end = {value: function() { if (--size === 0) resolve(); }};

        that.each(function() {
          var schedule = set(this, id),
              on = schedule.on;

          // If this node shared a dispatch with the previous node,
          // just assign the updated shared dispatch and were done!
          // Otherwise, copy-on-write.
          if (on !== on0) {
            on1 = (on0 = on).copy();
            on1._.cancel.push(cancel);
            on1._.interrupt.push(cancel);
            on1._.end.push(end);
          }

          schedule.on = on1;
        });

        // The selection was empty, resolve end immediately
        if (size === 0) resolve();
      });
    }

    var id = 0;

    function Transition(groups, parents, name, id) {
      this._groups = groups;
      this._parents = parents;
      this._name = name;
      this._id = id;
    }

    function newId() {
      return ++id;
    }

    var selection_prototype = selection.prototype;

    Transition.prototype = {
      constructor: Transition,
      select: transition_select,
      selectAll: transition_selectAll,
      selectChild: selection_prototype.selectChild,
      selectChildren: selection_prototype.selectChildren,
      filter: transition_filter,
      merge: transition_merge,
      selection: transition_selection,
      transition: transition_transition,
      call: selection_prototype.call,
      nodes: selection_prototype.nodes,
      node: selection_prototype.node,
      size: selection_prototype.size,
      empty: selection_prototype.empty,
      each: selection_prototype.each,
      on: transition_on,
      attr: transition_attr,
      attrTween: transition_attrTween,
      style: transition_style,
      styleTween: transition_styleTween,
      text: transition_text,
      textTween: transition_textTween,
      remove: transition_remove,
      tween: transition_tween,
      delay: transition_delay,
      duration: transition_duration,
      ease: transition_ease,
      easeVarying: transition_easeVarying,
      end: transition_end,
      [Symbol.iterator]: selection_prototype[Symbol.iterator]
    };

    function cubicInOut(t) {
      return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
    }

    var defaultTiming = {
      time: null, // Set on use.
      delay: 0,
      duration: 250,
      ease: cubicInOut
    };

    function inherit(node, id) {
      var timing;
      while (!(timing = node.__transition) || !(timing = timing[id])) {
        if (!(node = node.parentNode)) {
          throw new Error(`transition ${id} not found`);
        }
      }
      return timing;
    }

    function selection_transition(name) {
      var id,
          timing;

      if (name instanceof Transition) {
        id = name._id, name = name._name;
      } else {
        id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
      }

      for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            schedule(node, name, id, i, group, timing || inherit(node, id));
          }
        }
      }

      return new Transition(groups, this._parents, name, id);
    }

    selection.prototype.interrupt = selection_interrupt;
    selection.prototype.transition = selection_transition;

    function tree_add(d) {
      const x = +this._x.call(null, d),
          y = +this._y.call(null, d);
      return add(this.cover(x, y), x, y, d);
    }

    function add(tree, x, y, d) {
      if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

      var parent,
          node = tree._root,
          leaf = {data: d},
          x0 = tree._x0,
          y0 = tree._y0,
          x1 = tree._x1,
          y1 = tree._y1,
          xm,
          ym,
          xp,
          yp,
          right,
          bottom,
          i,
          j;

      // If the tree is empty, initialize the root as a leaf.
      if (!node) return tree._root = leaf, tree;

      // Find the existing leaf for the new point, or add it.
      while (node.length) {
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
        if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
      }

      // Is the new point is exactly coincident with the existing point?
      xp = +tree._x.call(null, node.data);
      yp = +tree._y.call(null, node.data);
      if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

      // Otherwise, split the leaf node until the old and new point are separated.
      do {
        parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
      } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
      return parent[j] = node, parent[i] = leaf, tree;
    }

    function addAll(data) {
      var d, i, n = data.length,
          x,
          y,
          xz = new Array(n),
          yz = new Array(n),
          x0 = Infinity,
          y0 = Infinity,
          x1 = -Infinity,
          y1 = -Infinity;

      // Compute the points and their extent.
      for (i = 0; i < n; ++i) {
        if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
        xz[i] = x;
        yz[i] = y;
        if (x < x0) x0 = x;
        if (x > x1) x1 = x;
        if (y < y0) y0 = y;
        if (y > y1) y1 = y;
      }

      // If there were no (valid) points, abort.
      if (x0 > x1 || y0 > y1) return this;

      // Expand the tree to cover the new points.
      this.cover(x0, y0).cover(x1, y1);

      // Add the new points.
      for (i = 0; i < n; ++i) {
        add(this, xz[i], yz[i], data[i]);
      }

      return this;
    }

    function tree_cover(x, y) {
      if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

      var x0 = this._x0,
          y0 = this._y0,
          x1 = this._x1,
          y1 = this._y1;

      // If the quadtree has no extent, initialize them.
      // Integer extent are necessary so that if we later double the extent,
      // the existing quadrant boundaries dont change due to floating point error!
      if (isNaN(x0)) {
        x1 = (x0 = Math.floor(x)) + 1;
        y1 = (y0 = Math.floor(y)) + 1;
      }

      // Otherwise, double repeatedly to cover.
      else {
        var z = x1 - x0 || 1,
            node = this._root,
            parent,
            i;

        while (x0 > x || x >= x1 || y0 > y || y >= y1) {
          i = (y < y0) << 1 | (x < x0);
          parent = new Array(4), parent[i] = node, node = parent, z *= 2;
          switch (i) {
            case 0: x1 = x0 + z, y1 = y0 + z; break;
            case 1: x0 = x1 - z, y1 = y0 + z; break;
            case 2: x1 = x0 + z, y0 = y1 - z; break;
            case 3: x0 = x1 - z, y0 = y1 - z; break;
          }
        }

        if (this._root && this._root.length) this._root = node;
      }

      this._x0 = x0;
      this._y0 = y0;
      this._x1 = x1;
      this._y1 = y1;
      return this;
    }

    function tree_data() {
      var data = [];
      this.visit(function(node) {
        if (!node.length) do data.push(node.data); while (node = node.next)
      });
      return data;
    }

    function tree_extent(_) {
      return arguments.length
          ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
          : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
    }

    function Quad(node, x0, y0, x1, y1) {
      this.node = node;
      this.x0 = x0;
      this.y0 = y0;
      this.x1 = x1;
      this.y1 = y1;
    }

    function tree_find(x, y, radius) {
      var data,
          x0 = this._x0,
          y0 = this._y0,
          x1,
          y1,
          x2,
          y2,
          x3 = this._x1,
          y3 = this._y1,
          quads = [],
          node = this._root,
          q,
          i;

      if (node) quads.push(new Quad(node, x0, y0, x3, y3));
      if (radius == null) radius = Infinity;
      else {
        x0 = x - radius, y0 = y - radius;
        x3 = x + radius, y3 = y + radius;
        radius *= radius;
      }

      while (q = quads.pop()) {

        // Stop searching if this quadrant cant contain a closer node.
        if (!(node = q.node)
            || (x1 = q.x0) > x3
            || (y1 = q.y0) > y3
            || (x2 = q.x1) < x0
            || (y2 = q.y1) < y0) continue;

        // Bisect the current quadrant.
        if (node.length) {
          var xm = (x1 + x2) / 2,
              ym = (y1 + y2) / 2;

          quads.push(
            new Quad(node[3], xm, ym, x2, y2),
            new Quad(node[2], x1, ym, xm, y2),
            new Quad(node[1], xm, y1, x2, ym),
            new Quad(node[0], x1, y1, xm, ym)
          );

          // Visit the closest quadrant first.
          if (i = (y >= ym) << 1 | (x >= xm)) {
            q = quads[quads.length - 1];
            quads[quads.length - 1] = quads[quads.length - 1 - i];
            quads[quads.length - 1 - i] = q;
          }
        }

        // Visit this point. (Visiting coincident points isnt necessary!)
        else {
          var dx = x - +this._x.call(null, node.data),
              dy = y - +this._y.call(null, node.data),
              d2 = dx * dx + dy * dy;
          if (d2 < radius) {
            var d = Math.sqrt(radius = d2);
            x0 = x - d, y0 = y - d;
            x3 = x + d, y3 = y + d;
            data = node.data;
          }
        }
      }

      return data;
    }

    function tree_remove(d) {
      if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

      var parent,
          node = this._root,
          retainer,
          previous,
          next,
          x0 = this._x0,
          y0 = this._y0,
          x1 = this._x1,
          y1 = this._y1,
          x,
          y,
          xm,
          ym,
          right,
          bottom,
          i,
          j;

      // If the tree is empty, initialize the root as a leaf.
      if (!node) return this;

      // Find the leaf node for the point.
      // While descending, also retain the deepest parent with a non-removed sibling.
      if (node.length) while (true) {
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
        if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
        if (!node.length) break;
        if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
      }

      // Find the point to remove.
      while (node.data !== d) if (!(previous = node, node = node.next)) return this;
      if (next = node.next) delete node.next;

      // If there are multiple coincident points, remove just the point.
      if (previous) return (next ? previous.next = next : delete previous.next), this;

      // If this is the root point, remove it.
      if (!parent) return this._root = next, this;

      // Remove this leaf.
      next ? parent[i] = next : delete parent[i];

      // If the parent now contains exactly one leaf, collapse superfluous parents.
      if ((node = parent[0] || parent[1] || parent[2] || parent[3])
          && node === (parent[3] || parent[2] || parent[1] || parent[0])
          && !node.length) {
        if (retainer) retainer[j] = node;
        else this._root = node;
      }

      return this;
    }

    function removeAll(data) {
      for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
      return this;
    }

    function tree_root() {
      return this._root;
    }

    function tree_size() {
      var size = 0;
      this.visit(function(node) {
        if (!node.length) do ++size; while (node = node.next)
      });
      return size;
    }

    function tree_visit(callback) {
      var quads = [], q, node = this._root, child, x0, y0, x1, y1;
      if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
      while (q = quads.pop()) {
        if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
          var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
          if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
          if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
          if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
          if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
        }
      }
      return this;
    }

    function tree_visitAfter(callback) {
      var quads = [], next = [], q;
      if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
      while (q = quads.pop()) {
        var node = q.node;
        if (node.length) {
          var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
          if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
          if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
          if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
          if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
        }
        next.push(q);
      }
      while (q = next.pop()) {
        callback(q.node, q.x0, q.y0, q.x1, q.y1);
      }
      return this;
    }

    function defaultX(d) {
      return d[0];
    }

    function tree_x(_) {
      return arguments.length ? (this._x = _, this) : this._x;
    }

    function defaultY(d) {
      return d[1];
    }

    function tree_y(_) {
      return arguments.length ? (this._y = _, this) : this._y;
    }

    function quadtree(nodes, x, y) {
      var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
      return nodes == null ? tree : tree.addAll(nodes);
    }

    function Quadtree(x, y, x0, y0, x1, y1) {
      this._x = x;
      this._y = y;
      this._x0 = x0;
      this._y0 = y0;
      this._x1 = x1;
      this._y1 = y1;
      this._root = undefined;
    }

    function leaf_copy(leaf) {
      var copy = {data: leaf.data}, next = copy;
      while (leaf = leaf.next) next = next.next = {data: leaf.data};
      return copy;
    }

    var treeProto = quadtree.prototype = Quadtree.prototype;

    treeProto.copy = function() {
      var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
          node = this._root,
          nodes,
          child;

      if (!node) return copy;

      if (!node.length) return copy._root = leaf_copy(node), copy;

      nodes = [{source: node, target: copy._root = new Array(4)}];
      while (node = nodes.pop()) {
        for (var i = 0; i < 4; ++i) {
          if (child = node.source[i]) {
            if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
            else node.target[i] = leaf_copy(child);
          }
        }
      }

      return copy;
    };

    treeProto.add = tree_add;
    treeProto.addAll = addAll;
    treeProto.cover = tree_cover;
    treeProto.data = tree_data;
    treeProto.extent = tree_extent;
    treeProto.find = tree_find;
    treeProto.remove = tree_remove;
    treeProto.removeAll = removeAll;
    treeProto.root = tree_root;
    treeProto.size = tree_size;
    treeProto.visit = tree_visit;
    treeProto.visitAfter = tree_visitAfter;
    treeProto.x = tree_x;
    treeProto.y = tree_y;

    function constant(x) {
      return function() {
        return x;
      };
    }

    function jiggle(random) {
      return (random() - 0.5) * 1e-6;
    }

    function x$1(d) {
      return d.x + d.vx;
    }

    function y$1(d) {
      return d.y + d.vy;
    }

    function forceCollide(radius) {
      var nodes,
          radii,
          random,
          strength = 1,
          iterations = 1;

      if (typeof radius !== "function") radius = constant(radius == null ? 1 : +radius);

      function force() {
        var i, n = nodes.length,
            tree,
            node,
            xi,
            yi,
            ri,
            ri2;

        for (var k = 0; k < iterations; ++k) {
          tree = quadtree(nodes, x$1, y$1).visitAfter(prepare);
          for (i = 0; i < n; ++i) {
            node = nodes[i];
            ri = radii[node.index], ri2 = ri * ri;
            xi = node.x + node.vx;
            yi = node.y + node.vy;
            tree.visit(apply);
          }
        }

        function apply(quad, x0, y0, x1, y1) {
          var data = quad.data, rj = quad.r, r = ri + rj;
          if (data) {
            if (data.index > node.index) {
              var x = xi - data.x - data.vx,
                  y = yi - data.y - data.vy,
                  l = x * x + y * y;
              if (l < r * r) {
                if (x === 0) x = jiggle(random), l += x * x;
                if (y === 0) y = jiggle(random), l += y * y;
                l = (r - (l = Math.sqrt(l))) / l * strength;
                node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
                node.vy += (y *= l) * r;
                data.vx -= x * (r = 1 - r);
                data.vy -= y * r;
              }
            }
            return;
          }
          return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
        }
      }

      function prepare(quad) {
        if (quad.data) return quad.r = radii[quad.data.index];
        for (var i = quad.r = 0; i < 4; ++i) {
          if (quad[i] && quad[i].r > quad.r) {
            quad.r = quad[i].r;
          }
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length, node;
        radii = new Array(n);
        for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
      }

      force.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random = _random;
        initialize();
      };

      force.iterations = function(_) {
        return arguments.length ? (iterations = +_, force) : iterations;
      };

      force.strength = function(_) {
        return arguments.length ? (strength = +_, force) : strength;
      };

      force.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), initialize(), force) : radius;
      };

      return force;
    }

    function index(d) {
      return d.index;
    }

    function find(nodeById, nodeId) {
      var node = nodeById.get(nodeId);
      if (!node) throw new Error("node not found: " + nodeId);
      return node;
    }

    function forceLink(links) {
      var id = index,
          strength = defaultStrength,
          strengths,
          distance = constant(30),
          distances,
          nodes,
          count,
          bias,
          random,
          iterations = 1;

      if (links == null) links = [];

      function defaultStrength(link) {
        return 1 / Math.min(count[link.source.index], count[link.target.index]);
      }

      function force(alpha) {
        for (var k = 0, n = links.length; k < iterations; ++k) {
          for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
            link = links[i], source = link.source, target = link.target;
            x = target.x + target.vx - source.x - source.vx || jiggle(random);
            y = target.y + target.vy - source.y - source.vy || jiggle(random);
            l = Math.sqrt(x * x + y * y);
            l = (l - distances[i]) / l * alpha * strengths[i];
            x *= l, y *= l;
            target.vx -= x * (b = bias[i]);
            target.vy -= y * b;
            source.vx += x * (b = 1 - b);
            source.vy += y * b;
          }
        }
      }

      function initialize() {
        if (!nodes) return;

        var i,
            n = nodes.length,
            m = links.length,
            nodeById = new Map(nodes.map((d, i) => [id(d, i, nodes), d])),
            link;

        for (i = 0, count = new Array(n); i < m; ++i) {
          link = links[i], link.index = i;
          if (typeof link.source !== "object") link.source = find(nodeById, link.source);
          if (typeof link.target !== "object") link.target = find(nodeById, link.target);
          count[link.source.index] = (count[link.source.index] || 0) + 1;
          count[link.target.index] = (count[link.target.index] || 0) + 1;
        }

        for (i = 0, bias = new Array(m); i < m; ++i) {
          link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
        }

        strengths = new Array(m), initializeStrength();
        distances = new Array(m), initializeDistance();
      }

      function initializeStrength() {
        if (!nodes) return;

        for (var i = 0, n = links.length; i < n; ++i) {
          strengths[i] = +strength(links[i], i, links);
        }
      }

      function initializeDistance() {
        if (!nodes) return;

        for (var i = 0, n = links.length; i < n; ++i) {
          distances[i] = +distance(links[i], i, links);
        }
      }

      force.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random = _random;
        initialize();
      };

      force.links = function(_) {
        return arguments.length ? (links = _, initialize(), force) : links;
      };

      force.id = function(_) {
        return arguments.length ? (id = _, force) : id;
      };

      force.iterations = function(_) {
        return arguments.length ? (iterations = +_, force) : iterations;
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initializeStrength(), force) : strength;
      };

      force.distance = function(_) {
        return arguments.length ? (distance = typeof _ === "function" ? _ : constant(+_), initializeDistance(), force) : distance;
      };

      return force;
    }

    // https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
    const a = 1664525;
    const c = 1013904223;
    const m = 4294967296; // 2^32

    function lcg() {
      let s = 1;
      return () => (s = (a * s + c) % m) / m;
    }

    function x(d) {
      return d.x;
    }

    function y(d) {
      return d.y;
    }

    var initialRadius = 10,
        initialAngle = Math.PI * (3 - Math.sqrt(5));

    function forceSimulation(nodes) {
      var simulation,
          alpha = 1,
          alphaMin = 0.001,
          alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
          alphaTarget = 0,
          velocityDecay = 0.6,
          forces = new Map(),
          stepper = timer(step),
          event = dispatch("tick", "end"),
          random = lcg();

      if (nodes == null) nodes = [];

      function step() {
        tick();
        event.call("tick", simulation);
        if (alpha < alphaMin) {
          stepper.stop();
          event.call("end", simulation);
        }
      }

      function tick(iterations) {
        var i, n = nodes.length, node;

        if (iterations === undefined) iterations = 1;

        for (var k = 0; k < iterations; ++k) {
          alpha += (alphaTarget - alpha) * alphaDecay;

          forces.forEach(function(force) {
            force(alpha);
          });

          for (i = 0; i < n; ++i) {
            node = nodes[i];
            if (node.fx == null) node.x += node.vx *= velocityDecay;
            else node.x = node.fx, node.vx = 0;
            if (node.fy == null) node.y += node.vy *= velocityDecay;
            else node.y = node.fy, node.vy = 0;
          }
        }

        return simulation;
      }

      function initializeNodes() {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.index = i;
          if (node.fx != null) node.x = node.fx;
          if (node.fy != null) node.y = node.fy;
          if (isNaN(node.x) || isNaN(node.y)) {
            var radius = initialRadius * Math.sqrt(0.5 + i), angle = i * initialAngle;
            node.x = radius * Math.cos(angle);
            node.y = radius * Math.sin(angle);
          }
          if (isNaN(node.vx) || isNaN(node.vy)) {
            node.vx = node.vy = 0;
          }
        }
      }

      function initializeForce(force) {
        if (force.initialize) force.initialize(nodes, random);
        return force;
      }

      initializeNodes();

      return simulation = {
        tick: tick,

        restart: function() {
          return stepper.restart(step), simulation;
        },

        stop: function() {
          return stepper.stop(), simulation;
        },

        nodes: function(_) {
          return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
        },

        alpha: function(_) {
          return arguments.length ? (alpha = +_, simulation) : alpha;
        },

        alphaMin: function(_) {
          return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
        },

        alphaDecay: function(_) {
          return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
        },

        alphaTarget: function(_) {
          return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
        },

        velocityDecay: function(_) {
          return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
        },

        randomSource: function(_) {
          return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;
        },

        force: function(name, _) {
          return arguments.length > 1 ? ((_ == null ? forces.delete(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
        },

        find: function(x, y, radius) {
          var i = 0,
              n = nodes.length,
              dx,
              dy,
              d2,
              node,
              closest;

          if (radius == null) radius = Infinity;
          else radius *= radius;

          for (i = 0; i < n; ++i) {
            node = nodes[i];
            dx = x - node.x;
            dy = y - node.y;
            d2 = dx * dx + dy * dy;
            if (d2 < radius) closest = node, radius = d2;
          }

          return closest;
        },

        on: function(name, _) {
          return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
        }
      };
    }

    function forceManyBody() {
      var nodes,
          node,
          random,
          alpha,
          strength = constant(-30),
          strengths,
          distanceMin2 = 1,
          distanceMax2 = Infinity,
          theta2 = 0.81;

      function force(_) {
        var i, n = nodes.length, tree = quadtree(nodes, x, y).visitAfter(accumulate);
        for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length, node;
        strengths = new Array(n);
        for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
      }

      function accumulate(quad) {
        var strength = 0, q, c, weight = 0, x, y, i;

        // For internal nodes, accumulate forces from child quadrants.
        if (quad.length) {
          for (x = y = i = 0; i < 4; ++i) {
            if ((q = quad[i]) && (c = Math.abs(q.value))) {
              strength += q.value, weight += c, x += c * q.x, y += c * q.y;
            }
          }
          quad.x = x / weight;
          quad.y = y / weight;
        }

        // For leaf nodes, accumulate forces from coincident quadrants.
        else {
          q = quad;
          q.x = q.data.x;
          q.y = q.data.y;
          do strength += strengths[q.data.index];
          while (q = q.next);
        }

        quad.value = strength;
      }

      function apply(quad, x1, _, x2) {
        if (!quad.value) return true;

        var x = quad.x - node.x,
            y = quad.y - node.y,
            w = x2 - x1,
            l = x * x + y * y;

        // Apply the Barnes-Hut approximation if possible.
        // Limit forces for very close nodes; randomize direction if coincident.
        if (w * w / theta2 < l) {
          if (l < distanceMax2) {
            if (x === 0) x = jiggle(random), l += x * x;
            if (y === 0) y = jiggle(random), l += y * y;
            if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
            node.vx += x * quad.value * alpha / l;
            node.vy += y * quad.value * alpha / l;
          }
          return true;
        }

        // Otherwise, process points directly.
        else if (quad.length || l >= distanceMax2) return;

        // Limit forces for very close nodes; randomize direction if coincident.
        if (quad.data !== node || quad.next) {
          if (x === 0) x = jiggle(random), l += x * x;
          if (y === 0) y = jiggle(random), l += y * y;
          if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        }

        do if (quad.data !== node) {
          w = strengths[quad.data.index] * alpha / l;
          node.vx += x * w;
          node.vy += y * w;
        } while (quad = quad.next);
      }

      force.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random = _random;
        initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
      };

      force.distanceMin = function(_) {
        return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
      };

      force.distanceMax = function(_) {
        return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
      };

      force.theta = function(_) {
        return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
      };

      return force;
    }

    function forceX(x) {
      var strength = constant(0.1),
          nodes,
          strengths,
          xz;

      if (typeof x !== "function") x = constant(x == null ? 0 : +x);

      function force(alpha) {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        xz = new Array(n);
        for (i = 0; i < n; ++i) {
          strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
        }
      }

      force.initialize = function(_) {
        nodes = _;
        initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
      };

      force.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : constant(+_), initialize(), force) : x;
      };

      return force;
    }

    function forceY(y) {
      var strength = constant(0.1),
          nodes,
          strengths,
          yz;

      if (typeof y !== "function") y = constant(y == null ? 0 : +y);

      function force(alpha) {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        yz = new Array(n);
        for (i = 0; i < n; ++i) {
          strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
        }
      }

      force.initialize = function(_) {
        nodes = _;
        initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
      };

      force.y = function(_) {
        return arguments.length ? (y = typeof _ === "function" ? _ : constant(+_), initialize(), force) : y;
      };

      return force;
    }

    function initRange(domain, range) {
      switch (arguments.length) {
        case 0: break;
        case 1: this.range(domain); break;
        default: this.range(range).domain(domain); break;
      }
      return this;
    }

    const implicit = Symbol("implicit");

    function ordinal() {
      var index = new InternMap(),
          domain = [],
          range = [],
          unknown = implicit;

      function scale(d) {
        let i = index.get(d);
        if (i === undefined) {
          if (unknown !== implicit) return unknown;
          index.set(d, i = domain.push(d) - 1);
        }
        return range[i % range.length];
      }

      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [], index = new InternMap();
        for (const value of _) {
          if (index.has(value)) continue;
          index.set(value, domain.push(value) - 1);
        }
        return scale;
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), scale) : range.slice();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return ordinal(domain, range).unknown(unknown);
      };

      initRange.apply(scale, arguments);

      return scale;
    }

    function colors(specifier) {
      var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
      while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
      return colors;
    }

    var schemeCategory10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

    const zoomBalanceRange = createBalanceRange(SIZE_CANVAS_ZOOM_MIN, 0.7);
    function isLink$1(links, startTableId, endTableId) {
        let result = true;
        for (const link of links) {
            if (link.source === startTableId && link.target === endTableId) {
                result = false;
                break;
            }
        }
        return result;
    }
    function createNodes(tables, relationships, x, y) {
        const nodes = [];
        const links = [];
        tables.forEach(table => {
            nodes.push({
                id: table.id,
                r: (table.width() + table.height()) / 4,
                x,
                y,
                ref: table,
            });
        });
        relationships.forEach(relationship => {
            const { start, end } = relationship;
            if (start.tableId !== end.tableId &&
                isLink$1(links, start.tableId, end.tableId)) {
                links.push({
                    source: start.tableId,
                    target: end.tableId,
                });
            }
        });
        return [nodes, links];
    }
    function holdEditor(store) {
        const { canvasState, editorState } = store;
        const prevState = {
            zoomLevel: canvasState.zoomLevel,
            scrollLeft: canvasState.scrollLeft,
            scrollTop: canvasState.scrollTop,
        };
        canvasState.zoomLevel = zoomBalanceRange(editorState.viewport.width / canvasState.width);
        canvasState.scrollLeft =
            (canvasState.width / 2 - editorState.viewport.width / 2) * -1;
        canvasState.scrollTop =
            (canvasState.height / 2 - editorState.viewport.height / 2) * -1;
        // TODO: command
        editorState.erdUiEventNone = true;
        store.dispatchSync(readonlyEditor$(true));
        return prevState;
    }
    function releaseEditor({ eventBus, store }, prevState) {
        const { editorState, canvasState } = store;
        eventBus.emit(Bus.BalanceRange.move);
        store.dispatchSync(readonlyEditor$(false));
        editorState.erdUiEventNone = false;
        canvasState.zoomLevel = prevState.zoomLevel;
        // canvasState.scrollLeft = prevState.scrollLeft;
        // canvasState.scrollTop = prevState.scrollTop;
        eventBus.emit(Bus.Editor.change);
    }
    function runAutomaticTablePlacement(context) {
        const { eventBus, store } = context;
        const { tableState: { tables }, relationshipState: { relationships }, canvasState, } = store;
        const centerX = canvasState.width / 2;
        const centerY = canvasState.height / 2;
        if (!tables.length) {
            eventBus.emit(Bus.ToastBar.add, {
                bodyTpl: html `Not found tables`,
            });
            return;
        }
        let resolveToastBar = noop$2;
        let rejectToastBar = noop$2;
        const close = new Promise((resolve, reject) => {
            resolveToastBar = resolve;
            rejectToastBar = reject;
        });
        try {
            const [nodes, links] = createNodes(tables, relationships, centerX, centerY);
            const prevState = holdEditor(store);
            const simulation = forceSimulation(nodes)
                .force('link', forceLink(links).id((d) => d.id))
                .force('collide', forceCollide().radius((d) => 100 + d.r))
                .force('charge', forceManyBody())
                .force('x', forceX(centerX))
                .force('y', forceY(centerY))
                .on('tick', () => {
                nodes.forEach(({ r, x, y, ref }) => {
                    ref.ui.top = y - r;
                    ref.ui.left = x - r;
                });
                relationshipSort(tables, relationships);
            });
            const onStop = () => {
                simulation.stop();
                releaseEditor(context, prevState);
                resolveToastBar();
            };
            eventBus.emit(Bus.ToastBar.add, {
                bodyTpl: html `
        <span>Automatic Table Placement...</span>
        <div class="vuerd-btn" @click=${onStop}>Stop</div>
      `,
                close,
            });
            simulation.on('end', onStop);
        }
        catch (e) {
            rejectToastBar();
        }
    }

    const relationshipMenus = [
        {
            name: 'Zero One',
            relationshipType: 'ZeroOne',
            keymapName: 'relationshipZeroOne',
        },
        {
            name: 'Zero N',
            relationshipType: 'ZeroN',
            keymapName: 'relationshipZeroN',
        },
        {
            name: 'One Only',
            relationshipType: 'OneOnly',
            keymapName: 'relationshipOneOnly',
        },
        {
            name: 'One N',
            relationshipType: 'OneN',
            keymapName: 'relationshipOneN',
        },
    ];
    const defaultOptions$d = {
        nameWidth: 75,
        keymapWidth: 85,
    };
    const createDrawRelationshipMenus = ({ keymap, store, }) => relationshipMenus.map(relationshipMenu => ({
        iconBase64: getBase64Icon(relationshipMenu.relationshipType),
        name: relationshipMenu.name,
        keymap: keymapOptionToString(keymap[relationshipMenu.keymapName][0]),
        keymapTooltip: keymapOptionsToString(keymap[relationshipMenu.keymapName]),
        execute: () => store.dispatch(drawStartRelationship$(store, relationshipMenu.relationshipType)),
        options: Object.assign({}, defaultOptions$d),
    }));

    const defaultOptions$c = {
        nameWidth: 60,
        keymapWidth: 0,
    };
    const liquibaseOptions = {
        nameWidth: 75,
        keymapWidth: 0,
    };
    const createImportMenus = (context) => [
        {
            icon: {
                prefix: 'mdi',
                name: 'code-json',
                size: 18,
            },
            name: 'json',
            execute: () => importJSON(context),
        },
        {
            icon: {
                prefix: 'mdi',
                name: 'database-import',
                size: 18,
            },
            name: 'SQL DDL',
            execute: () => importSQLDDL(context),
        },
        {
            icon: {
                prefix: 'mdi',
                name: 'xml',
                size: 18,
            },
            name: 'Liquibase',
            children: [
                {
                    icon: {
                        prefix: 'mdi',
                        name: 'xml',
                        size: 18,
                    },
                    name: 'PostgreSQL',
                    execute: () => importLiquibase(context, 'postgresql'),
                },
                {
                    icon: {
                        prefix: 'mdi',
                        name: 'xml',
                        size: 18,
                    },
                    name: 'Oracle',
                    execute: () => importLiquibase(context, 'oracle'),
                },
                {
                    icon: {
                        prefix: 'mdi',
                        name: 'xml',
                        size: 18,
                    },
                    name: 'MSSQL',
                    execute: () => importLiquibase(context, 'mssql'),
                },
            ].map(menu => (Object.assign(Object.assign({}, menu), { options: Object.assign({}, liquibaseOptions) }))),
        },
    ].map(menu => (Object.assign(Object.assign({}, menu), { options: Object.assign({}, defaultOptions$c) })));

    const showMenus = [
        {
            name: 'Table Comment',
            showKey: 'tableComment',
        },
        {
            name: 'Column Comment',
            showKey: 'columnComment',
        },
        {
            name: 'DataType',
            showKey: 'columnDataType',
        },
        {
            name: 'Default',
            showKey: 'columnDefault',
        },
        {
            name: 'Not Null',
            showKey: 'columnNotNull',
        },
        {
            name: 'Unique',
            showKey: 'columnUnique',
        },
        {
            name: 'Auto Increment',
            showKey: 'columnAutoIncrement',
        },
        {
            name: 'Relationship',
            showKey: 'relationship',
        },
    ];
    const defaultOptions$b = {
        nameWidth: 115,
        keymapWidth: 0,
        close: false,
    };
    const createShowMenus = ({ store }) => showMenus.map(showMenu => ({
        icon: store.canvasState.show[showMenu.showKey]
            ? {
                prefix: 'fas',
                name: 'check',
            }
            : undefined,
        name: showMenu.name,
        execute: () => store.dispatch(changeCanvasShow(store, showMenu.showKey)),
        options: Object.assign({}, defaultOptions$b),
    }));

    const defaultOptions$a = {
        nameWidth: 165,
        keymapWidth: 50,
    };
    function createERDMenus(context, canvas) {
        const { store, keymap, eventBus } = context;
        return [
            {
                icon: {
                    prefix: 'fas',
                    name: 'eye',
                },
                name: 'View Option',
                children: createShowMenus(context),
            },
            {
                icon: {
                    prefix: 'mdi',
                    name: 'atom',
                    size: 18,
                },
                name: 'Automatic Table Placement',
                execute: () => runAutomaticTablePlacement(context),
            },
        ].map(menu => (Object.assign(Object.assign({}, menu), { options: Object.assign({}, defaultOptions$a) })));
    }

    const defaultOptions$9 = {
        nameWidth: 75,
        keymapWidth: 0,
        close: false,
    };
    const createSingleRelationship = ({ store }, relationship) => relationshipMenus.map(relationshipMenu => ({
        icon: relationship.relationshipType === relationshipMenu.relationshipType
            ? {
                prefix: 'fas',
                name: 'check',
            }
            : undefined,
        name: relationshipMenu.name,
        execute: () => store.dispatch(changeRelationshipType(relationship.id, relationshipMenu.relationshipType)),
        options: Object.assign({}, defaultOptions$9),
    }));

    const defaultOptions$8 = {
        nameWidth: 110,
        keymapWidth: 0,
    };
    function createRelationshipMenus(context, relationship) {
        const { store } = context;
        return [

        ].map(menu => (Object.assign(Object.assign({}, menu), { options: Object.assign({}, defaultOptions$8) })));
    }

    const defaultOptions$7 = {
        nameWidth: 105,
        keymapWidth: 100,
    };
    const createTableMenus = ({ keymap, eventBus, store, helper }, tableId) => [
        {
            icon: {
                prefix: 'mdi',
                name: 'table-cog',
                size: 18,
            },
            name: 'Table Properties',
            keymap: keymapOptionToString(keymap.tableProperties[0]),
            keymapTooltip: keymapOptionsToString(keymap.tableProperties),
            execute: () => eventBus.emit(Bus.Drawer.openTableProperties, {
                tableId,
            }),
        },
        {
            icon: {
                prefix: 'fas',
                name: 'palette',
            },
            name: 'Color',
            execute: () => eventBus.emit(Bus.ColorPicker.open, tableId),
        },
    ].map(menu => (Object.assign(Object.assign({}, menu), { options: Object.assign({}, defaultOptions$7) })));

    const changeColumnMap = {
        columnNotNull: changeColumnNotNull,
        columnUnique: changeColumnUnique,
        columnAutoIncrement: changeColumnAutoIncrement,
    };
    const changeColumnKeys = [
        'columnNotNull',
        'columnUnique',
        'columnAutoIncrement',
    ];
    function useERDKeymap(ctx) {
        const contextRef = useContext$1(ctx);
        const { unmountedGroup } = useUnmounted();
        const onKeydown = (event) => {
            const { keymap, store, eventBus } = contextRef.value;
            const { tableState, memoState, editorState } = store;
            if (!editorState.focusTable || !editorState.focusTable.edit) {
                keymapMatchAndStop(event, keymap.addTable) &&
                    store.dispatch(addTable$(store));
                keymapMatchAndStop(event, keymap.addColumn) &&
                    tableState.tables.some(table => table.ui.active) &&
                    store.dispatch(addColumn$(store));
                keymapMatchAndStop(event, keymap.addMemo) &&
                    store.dispatch(addMemo$(store));
                keymapMatchAndStop(event, keymap.selectAllTable) &&
                    store.dispatch(selectAllTable(), selectAllMemo());
                relationshipMenus.forEach(relationshipMenu => keymapMatchAndStop(event, keymap[relationshipMenu.keymapName]) &&
                    store.dispatch(drawStartRelationship$(store, relationshipMenu.relationshipType)));
                if (keymapMatchAndStop(event, keymap.removeTable) &&
                    (store.tableState.tables.some(table => table.ui.active) ||
                        store.memoState.memos.some(memo => memo.ui.active))) {
                    const commands = [];
                    tableState.tables.some(table => table.ui.active) &&
                        commands.push(removeTable(store));
                    memoState.memos.some(memo => memo.ui.active) &&
                        commands.push(removeMemo(store));
                    store.dispatch(...commands);
                }
                if (keymapMatchAndStop(event, keymap.hideTable) &&
                    (store.tableState.tables.some(table => table.ui.active) ||
                        store.memoState.memos.some(memo => memo.ui.active))) {
                    const table = store.tableState.tables.find(table => table.ui.active);
                    if (table)
                        store.dispatch(hideTable(table.id));
                }
                if (keymapMatchAndStop(event, keymap.tableProperties) &&
                    store.tableState.tables.some(table => table.ui.active)) {
                    const table = store.tableState.tables.find(table => table.ui.active);
                    if (!table)
                        return;
                    eventBus.emit(Bus.Drawer.openTableProperties, {
                        tableId: editorState.focusTable
                            ? editorState.focusTable.table.id
                            : table.id,
                    });
                }
                if (keymapMatchAndStop(event, keymap.find)) {
                    if (editorState.findActive) {
                        store.dispatch(findActiveEnd());
                    }
                    else {
                        store.dispatch(findActive$());
                    }
                    eventBus.emit(Bus.Drawer.close);
                }
                keymapMatchAndStop(event, keymap.zoomIn) &&
                    store.dispatch(movementZoomCanvas(0.1));
                keymapMatchAndStop(event, keymap.zoomOut) &&
                    store.dispatch(movementZoomCanvas(-0.1));
            }
            if (editorState.focusTable && !editorState.focusTable.edit) {
                keymapMatchAndStop(event, keymap.selectAllColumn) &&
                    store.dispatch(selectAllColumn());
                editorState.focusTable.selectColumnIds.length &&
                    keymapMatchAndStop(event, keymap.removeColumn) &&
                    store.dispatch(removeColumn$(store, editorState.focusTable.table.id, editorState.focusTable.selectColumnIds));
                editorState.focusTable.selectColumnIds.length &&
                    keymapMatchAndStop(event, keymap.copyColumn) &&
                    store.dispatch(copyColumn(editorState.focusTable.table.id, editorState.focusTable.selectColumnIds));
                keymapMatchAndStop(event, keymap.pasteColumn) &&
                    store.dispatch(pasteColumn$(store));
                editorState.focusTable.columnId &&
                    keymapMatchAndStop(event, keymap.primaryKey) &&
                    store.dispatch(changeColumnPrimaryKey$(store, editorState.focusTable.table.id, editorState.focusTable.columnId));
                event.key !== 'Tab' &&
                    moveKeys.includes(event.key) &&
                    store.dispatch(focusMoveTable(event.key, event.shiftKey));
            }
            if (editorState.focusTable && event.key === 'Tab') {
                event.preventDefault();
                store.dispatch(focusMoveTable$(store, event.key, event.shiftKey));
                setTimeout(() => {
                    if (!editorState.focusTable ||
                        changeColumnKeys.includes(editorState.focusTable.focusType))
                        return;
                    store.dispatch(editTable());
                }, 0);
            }
            if (editorState.focusTable && keymapMatchAndStop(event, keymap.edit)) {
                const focusTable = editorState.focusTable;
                if (focusTable.edit) {
                    store.dispatch(editTableEnd());
                }
                else if (focusTable.columnId &&
                    changeColumnKeys.includes(focusTable.focusType)) {
                    const changeColumn = changeColumnMap[focusTable.focusType];
                    store.dispatch(changeColumn(store, focusTable.table.id, focusTable.columnId));
                }
                else {
                    store.dispatch(editTable());
                }
            }
            if (keymapMatchAndStop(event, keymap.stop)) {
                const commands = [drawEndRelationship(), findActiveEnd()];
                if (editorState.findActive) {
                    const table = store.tableState.tables.find(table => table.ui.active);
                    if (table) {
                        commands.push(selectTable$(store, false, table.id));
                    }
                }
                else {
                    commands.push(selectEndMemo(), selectEndTable$());
                }
                store.dispatch(...commands);
            }
            keymapMatchAndStop(event, keymap.undo) && store.undo();
            keymapMatchAndStop(event, keymap.redo) && store.redo();
        };
        beforeMount(() => {
            const { helper } = contextRef.value;
            unmountedGroup.push(helper.keydown$.subscribe(onKeydown));
        });
    }

    function useMousePosition(selector) {
        const elementRef = query(selector);
        const getPosition = (event) => {
            const { x, y } = elementRef.value.getBoundingClientRect();
            return {
                x: event.clientX - x,
                y: event.clientY - y,
            };
        };
        return {
            getPosition,
        };
    }

    const ScrollbarStyle = css `
  ::-webkit-scrollbar {
    width: 12px;
    height: 12px;
  }
  ::-webkit-scrollbar-track {
    background: #fff0;
  }
  ::-webkit-scrollbar-corner {
    background: #fff0;
  }
  ::-webkit-scrollbar-thumb {
    background: var(--vuerd-color-scrollbar-thumb);
  }
  ::-webkit-scrollbar-thumb:hover {
    background: var(--vuerd-color-scrollbar-thumb-active);
  }

  /* firefox */
  .vuerd-scrollbar {
    scrollbar-color: var(--vuerd-color-scrollbar-thumb) #fff0;
    scrollbar-width: auto;
  }
`;

    const DefaultStyle = css `
  .vuerd-button {
    cursor: pointer;
  }
  .vuerd-button:hover {
    fill: var(--vuerd-color-font-active);
  }

  ${ScrollbarStyle}
`;

    const IconStyle = css `
  .vuerd-icon {
    transition: fill 0.15s;
  }
`;

    const CanvasStyle = css `
  .vuerd-canvas {
    position: relative;
    background-color: var(--vuerd-color-canvas);
  }
`;

    const CanvasSVGStyle = css `
  .vuerd-canvas-svg {
    position: absolute;
    top: 0;
    left: 0;
    overflow: visible;
  }

  .vuerd-relationship {
    stroke: var(--vuerd-color-key-fk);
  }

  .vuerd-relationship.identification {
    stroke: var(--vuerd-color-key-pfk);
  }

  .vuerd-relationship.active {
    stroke: var(--vuerd-color-edit);
  }
`;

    const DragSelectStyle = css `
  .vuerd-drag-select {
    position: absolute;
    stroke: var(--vuerd-color-focus);
    pointer-events: none;
  }
`;

    const DrawRelationshipStyle = css `
  .vuerd-draw-relationship {
    position: absolute;
    top: 0;
    left: 0;
    stroke: var(--vuerd-color-key-fk);
    pointer-events: none;
  }
`;

    const ERDStyle = css `
  .vuerd-erd {
    overflow: hidden;
    position: relative;
  }

  .vuerd-erd-background {
    width: 100%;
    height: 100%;
    pointer-events: none;
    float: left;
    background-color: var(--vuerd-color-contextmenu);
  }
`;

    const FindStyle = css `
  .vuerd-find {
    width: 225px;
    display: flex;
    align-items: center;
    padding: 0 10px;
    box-sizing: border-box;
    position: absolute;
    right: 190px;
    color: var(--vuerd-color-font);
    background-color: var(--vuerd-color-menubar);
    opacity: 0.9;
    fill: #fff0;
  }

  .vuerd-find:hover {
    fill: var(--vuerd-color-font);
  }

  .vuerd-find-table {
    position: relative;
  }

  .vuerd-find-table input {
    display: flex;
    width: 193px;
    vertical-align: middle;
    align-items: center;
    margin-right: ${SIZE_COLUMN_MARGIN_RIGHT}px;
    color: var(--vuerd-color-font-active);
    background-color: var(--vuerd-color-menubar);
    outline: none;
    border: none;
    opacity: 0.9;
    padding: 1px 0 1px 0;
    height: 17px;
    font-size: ${SIZE_FONT}px;
    font-family: var(--vuerd-font-family);
    border-bottom: solid #fff0 1.5px;
  }

  .vuerd-find-table input:focus {
    border-bottom: solid var(--vuerd-color-edit) 1.5px;
  }

  .vuerd-find-table-list {
    position: absolute;
    top: 27px;
    left: 0;
    z-index: 100;
    color: var(--vuerd-color-font);
    background-color: var(--vuerd-color-contextmenu);
    opacity: 0.9;
    list-style: none;
    padding: 0;
    margin: 0;
  }
  .vuerd-find-table-list > li {
    padding: 5px;
    cursor: pointer;
    font-size: ${SIZE_FONT}px;
  }
  .vuerd-find-table-list > li:hover,
  .vuerd-find-table-hint.active {
    color: var(--vuerd-color-font-active);
    background-color: var(--vuerd-color-contextmenu-active);
  }
  .vuerd-find-table-list > li:hover .vuerd-find-table-hint-mark,
  .vuerd-find-table-hint.active .vuerd-find-table-hint-mark {
    color: var(--vuerd-color-font-active);
  }
  /* animation flip */
  .vuerd-find-table-hint-move {
    transition: transform 0.2s;
  }

  .vuerd-find-table-hint-mark {
    color: var(--vuerd-color-edit);
  }
`;

    const InputStyle = css `
  .vuerd-input {
    display: inline-flex;
    vertical-align: middle;
    align-items: center;
    margin-right: ${SIZE_COLUMN_MARGIN_RIGHT}px;
    color: var(--vuerd-color-font-active);
    background-color: var(--vuerd-color-table);
  }

  input.vuerd-input {
    outline: none;
    border: none;
    opacity: 0.9;
    padding: 1px 0 1px 0;
    height: 17px;
    font-size: ${SIZE_FONT}px;
    font-family: var(--vuerd-font-family);
  }

  div.vuerd-input {
    border-bottom: solid #fff0 1.5px;
    height: ${SIZE_INPUT_EDIT_HEIGHT}px;
    cursor: default;
  }

  .vuerd-input > span {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .vuerd-input.select {
    background-color: var(--vuerd-color-column-select);
  }

  .vuerd-input.active {
    background-color: var(--vuerd-color-column-active);
  }

  .vuerd-input.focus {
    border-bottom: solid var(--vuerd-color-focus) 1.5px;
  }

  .vuerd-input.edit {
    border-bottom: solid var(--vuerd-color-edit) 1.5px;
  }

  .vuerd-input.placeholder {
    color: var(--vuerd-color-font-placeholder);
  }
`;

    const MemoStyle = css `
  .vuerd-memo {
    position: absolute;
    opacity: 0.9;
    fill: #fff0;
    background-color: var(--vuerd-color-table);
    border-radius: 5px;
  }

  .vuerd-memo:hover {
    fill: var(--vuerd-color-font);
  }

  .vuerd-memo.active {
    border: solid var(--vuerd-color-table-active) 1px;
    box-shadow: 0 1px 6px var(--vuerd-color-table-active);
  }

  .vuerd-memo-header {
    padding: ${SIZE_MEMO_PADDING}px;
    cursor: move;
    position: relative;
  }

  .vuerd-memo-header-color {
    position: absolute;
    width: 100%;
    height: 4px;
    top: 0;
    left: 0;
    border-radius: 5px 5px 0 0;
    opacity: 0.9;
    cursor: pointer;
  }

  .vuerd-memo-header .vuerd-button {
    float: right;
  }

  .vuerd-memo-textarea {
    padding: ${SIZE_MEMO_PADDING}px;
    opacity: 0.9;
    border: none;
    resize: none;
    outline: none;
    font-size: ${SIZE_FONT}px;
    font-family: var(--vuerd-font-family);
    color: var(--vuerd-color-font-active);
    background-color: var(--vuerd-color-table);
  }
`;

    const MinimapStyle = css `
  .vuerd-minimap {
    position: absolute;
    overflow: hidden;
  }

  .vuerd-minimap-shadow {
    position: absolute;
    box-shadow: 0 1px 6px var(--vuerd-color-minimap-shadow);
    pointer-events: none;
  }
`;

    const MinimapHandleStyle = css `
  .vuerd-minimap-handle {
    position: absolute;
    border: solid var(--vuerd-color-edit) 1px;
    cursor: pointer;
    opacity: 0.7;
  }

  .vuerd-minimap-handle:hover {
    opacity: 1;
  }
`;

    const ColumnStyle = css `
  .vuerd-column {
    height: ${SIZE_COLUMN_HEIGHT}px;
    fill: #fff0;
  }

  .vuerd-column:hover {
    fill: var(--vuerd-color-font);
  }

  .vuerd-column.select {
    background-color: var(--vuerd-color-column-select);
  }

  .vuerd-column.active {
    background-color: var(--vuerd-color-column-active);
  }

  .vuerd-column.draggable {
    opacity: 0.5;
  }

  .vuerd-column > vuerd-icon,
  .vuerd-column > vuerd-input,
  vuerd-column-key,
  vuerd-column-not-null,
  vuerd-column-data-type,
  vuerd-column-auto-increment,
  vuerd-column-unique {
    float: left;
  }
`;

    const ColumnAutoIncrementStyle = css `
  .vuerd-column-auto-increment {
    display: flex;
    vertical-align: middle;
    align-items: center;
    border-bottom: solid #fff0 1.5px;
    cursor: default;
    height: ${SIZE_INPUT_EDIT_HEIGHT}px;
    margin-right: ${SIZE_COLUMN_MARGIN_RIGHT}px;
    color: var(--vuerd-color-font-placeholder);
  }

  .vuerd-column-auto-increment.focus {
    border-bottom: solid var(--vuerd-color-focus) 1.5px;
  }

  .vuerd-column-auto-increment.checked {
    color: var(--vuerd-color-font-active);
  }
`;

    const ColumnDataTypeStyle = css `
  .vuerd-column-data-type {
    display: flex;
    vertical-align: middle;
    align-items: center;
    position: relative;
  }

  .vuerd-column-data-type-hint {
    position: absolute;
    z-index: 1;
    opacity: 0.9;
    top: ${SIZE_COLUMN_HEIGHT}px;
    left: 0;
    color: var(--vuerd-color-font);
    background-color: var(--vuerd-color-contextmenu);
    list-style: none;
    padding: 0;
    margin: 0;
    white-space: nowrap;
  }

  .vuerd-column-data-type-hint > li {
    padding: 5px;
    cursor: pointer;
    font-size: ${SIZE_FONT}px;
  }

  .vuerd-column-data-type-hint > li:hover,
  .vuerd-data-type-hint.active {
    color: var(--vuerd-color-font-active);
    background-color: var(--vuerd-color-contextmenu-active);
  }

  .vuerd-column-data-type-hint > li:hover .vuerd-data-type-hint-mark,
  .vuerd-data-type-hint.active .vuerd-data-type-hint-mark {
    color: var(--vuerd-color-font-active);
  }

  /* animation flip */
  .vuerd-data-type-hint-move {
    transition: transform 0.2s;
  }

  .vuerd-data-type-hint-mark {
    color: var(--vuerd-color-edit);
  }
`;

    const ColumnKeyStyle = css `
  .vuerd-column-key {
    display: flex;
    vertical-align: middle;
    align-items: center;
    fill: #fff0;
    margin-right: ${SIZE_COLUMN_MARGIN_RIGHT}px;
  }

  .vuerd-column-key.pk {
    fill: var(--vuerd-color-key-pk);
  }

  .vuerd-column-key.fk {
    fill: var(--vuerd-color-key-fk);
  }

  .vuerd-column-key.pfk {
    fill: var(--vuerd-color-key-pfk);
  }
`;

    const ColumnNotNullStyle = css `
  .vuerd-column-not-null {
    display: flex;
    vertical-align: middle;
    align-items: center;
    border-bottom: solid #fff0 1.5px;
    cursor: default;
    height: ${SIZE_INPUT_EDIT_HEIGHT}px;
    margin-right: ${SIZE_COLUMN_MARGIN_RIGHT}px;
    color: var(--vuerd-color-font-active);
  }

  .vuerd-column-not-null.focus {
    border-bottom: solid var(--vuerd-color-focus) 1.5px;
  }
`;

    const ColumnUniqueStyle = css `
  .vuerd-column-unique {
    display: flex;
    vertical-align: middle;
    align-items: center;
    border-bottom: solid #fff0 1.5px;
    cursor: default;
    height: ${SIZE_INPUT_EDIT_HEIGHT}px;
    margin-right: ${SIZE_COLUMN_MARGIN_RIGHT}px;
    color: var(--vuerd-color-font-placeholder);
  }

  .vuerd-column-unique.focus {
    border-bottom: solid var(--vuerd-color-focus) 1.5px;
  }

  .vuerd-column-unique.checked {
    color: var(--vuerd-color-font-active);
  }
`;

    const HighLevelTableStyle = css `
  .vuerd-high-level-table {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: auto;
    color: var(--vuerd-color-font-active);
    font-weight: bold;
    font-size: 20px;
    word-break: break-all;
  }
`;

    const TableStyle = css `
  .vuerd-table {
    position: absolute;
    opacity: 0.9;
    padding: ${SIZE_TABLE_PADDING}px;
    font-size: ${SIZE_FONT}px;
    fill: #fff0;
    color: #fff0;
    background-color: var(--vuerd-color-table);
    border: solid #fff0 ${SIZE_TABLE_BORDER}px;
    border-radius: 5px;
  }

  .vuerd-table:hover {
    fill: var(--vuerd-color-font);
    color: var(--vuerd-color-font);
  }

  .vuerd-table.active {
    border: solid var(--vuerd-color-table-active) ${SIZE_TABLE_BORDER}px;
    box-shadow: 0 1px 6px var(--vuerd-color-table-active);
  }

  .vuerd-table .vuerd-table-header {
    position: relative;
  }

  .vuerd-table .vuerd-table-header-color {
    position: absolute;
    height: 4px;
    top: -11px;
    left: -10px;
    border-radius: 5px 5px 0 0;
    opacity: 0.9;
    cursor: pointer;
  }

  .vuerd-table .vuerd-table-header-top {
    overflow: hidden;
    cursor: move;
  }

  .vuerd-table .vuerd-table-header-top .vuerd-button {
    margin-left: 5px;
    float: right;
  }

  .vuerd-table .vuerd-table-header-body {
    height: ${SIZE_TABLE_HEADER_BODY_HEIGHT}px;
  }

  .vuerd-table .vuerd-table-header-body > vuerd-input {
    float: left;
  }

  /* animation flip */
  .vuerd-column-move {
    transition: transform 0.3s;
  }

  .vuerd-table-default:hover {
    color: var(--vuerd-color-font-active);
  }
`;

    const IndexStyle$4 = [
        DefaultStyle,
        ERDStyle,
        CanvasStyle,
        MemoStyle,
        TableStyle,
        HighLevelTableStyle,
        InputStyle,
        ColumnStyle,
        ColumnKeyStyle,
        ColumnDataTypeStyle,
        ColumnNotNullStyle,
        ColumnUniqueStyle,
        ColumnAutoIncrementStyle,
        DrawRelationshipStyle,
        CanvasSVGStyle,
        DragSelectStyle,
        MinimapStyle,
        MinimapHandleStyle,
        FindStyle,
        IconStyle,
    ].join('');

    const ERD = (props, ctx) => {
        const state = observable$1({
            contextmenuX: 0,
            contextmenuY: 0,
            menus: null,
            dragSelect: false,
            dragSelectX: 0,
            dragSelectY: 0,
        });
        const contextRef = useContext$1(ctx);
        const { unmountedGroup } = useUnmounted();
        const { getPosition } = useMousePosition('.vuerd-erd');
        const canvasRef = query('.vuerd-canvas');
        const erdRef = query('.vuerd-erd');
        useERDKeymap(ctx);
        let relationshipUnsubscribe = null;
        const resetScroll = () => {
            if (erdRef.value.scrollTop === 0 && erdRef.value.scrollLeft === 0)
                return;
            erdRef.value.scrollTop = 0;
            erdRef.value.scrollLeft = 0;
        };
        const onContextmenu = (event) => {
            event.preventDefault();
            const el = event.target;
            const context = contextRef.value;
            const { relationships } = context.store.relationshipState;
            state.contextmenuX = event.clientX;
            state.contextmenuY = event.clientY;
            const $table = el.closest('.vuerd-table');
            const $relationship = el.closest('.vuerd-relationship');
            if ($table) {
                const tableId = $table.dataset.id;
                state.menus = createTableMenus(context, tableId);
            }
            else if ($relationship) {
                const relationshipId = $relationship.dataset.id;
                const relationship = getData(relationships, relationshipId);
                if (!relationship)
                    return;
                state.menus = createRelationshipMenus(context, relationship);
                relationshipUnsubscribe = watch(relationship, propName => {
                    var _a;
                    if (propName !== 'relationshipType')
                        return;
                    const menue = (_a = state.menus) === null || _a === void 0 ? void 0 : _a.find(menu => menu.name === 'Relationship Type');
                    if (!menue)
                        return;
                    menue.children = createSingleRelationship(context, relationship);
                });
            }
            else {
                state.menus = createERDMenus(context, canvasRef.value);
            }
        };
        const onCloseContextmenu = () => {
            state.menus = null;
            relationshipUnsubscribe && relationshipUnsubscribe();
            relationshipUnsubscribe = null;
        };
        const onCloseFind = () => {
            const { store } = contextRef.value;
            store.dispatch(findActiveEnd());
        };
        const onMove = ({ event, movementX, movementY }) => {
            const { store } = contextRef.value;
            event.type === 'mousemove' && event.preventDefault();
            store.dispatch(movementCanvas(movementX, movementY));
            resetScroll();
        };
        const onDragSelect = (event) => {
            const el = event.target;
            const { store, globalEvent: { drag$ }, eventBus, } = contextRef.value;
            onCloseContextmenu();
            if (!el.closest('.vuerd-table-header-color')) {
                eventBus.emit(Bus.ColorPicker.close);
            }
            if (!el.closest('.vuerd-find')) {
                onCloseFind();
            }
            if (!el.closest('.vuerd-table') &&
                !el.closest('.vuerd-memo') &&
                !el.closest('.vuerd-input')) {
                store.dispatch(selectEndTable$(), selectEndMemo());
                if (event.type === 'mousedown' && (event.ctrlKey || event.metaKey)) {
                    const position = getPosition(event);
                    state.dragSelect = true;
                    state.dragSelectX = position.x;
                    state.dragSelectY = position.y;
                }
                else {
                    drag$.subscribe(onMove);
                }
            }
        };
        const onWheel = (event) => {
            const { store } = contextRef.value;
            store.dispatch(movementZoomCanvas(event.deltaY < 0 ? 0.1 : -0.1));
        };
        const onDragSelectEnd = () => (state.dragSelect = false);
        beforeMount(() => {
            const { store: { canvasState }, eventBus, } = contextRef.value;
            unmountedGroup.push(watch(canvasState.show, () => {
                var _a;
                const menue = (_a = state.menus) === null || _a === void 0 ? void 0 : _a.find(menu => menu.name === 'View Option');
                if (!menue)
                    return;
                menue.children = createShowMenus(contextRef.value);
            }), watch(canvasState, propName => {
                var _a;
                if (propName !== 'database')
                    return;
                const menue = (_a = state.menus) === null || _a === void 0 ? void 0 : _a.find(menu => menu.name === 'Database');
                if (!menue)
                    return;
                menue.children = createDatabaseMenus(contextRef.value);
            }), eventBus.on(Bus.Contextmenu.close).subscribe(onCloseContextmenu));
        });
        unmounted(() => onCloseContextmenu());
        return () => {
            const { store: { editorState: { drawRelationship, findActive, erdUiEventNone }, }, } = contextRef.value;
            return html `
      <div
        class="vuerd-erd"
        style=${styleMap({
            width: `${props.width}px`,
            height: `${props.height}px`,
            cursor: drawRelationship
                ? `url("${getBase64Icon(drawRelationship.relationshipType)}") 16 16, auto`
                : '',
            pointerEvents: erdUiEventNone ? 'none' : '',
            touchAction: erdUiEventNone ? 'none' : '',
        })}
        @mousedown=${onDragSelect}
        @touchstart=${onDragSelect}
        @contextmenu=${onContextmenu}
        @wheel=${onWheel}
      >
        <div class="vuerd-erd-background"></div>
        <vuerd-canvas></vuerd-canvas>
        <vuerd-minimap
          .width=${props.width}
          .height=${props.height}
        ></vuerd-minimap>
        ${state.dragSelect
            ? html `
              <vuerd-drag-select
                .x=${state.dragSelectX}
                .y=${state.dragSelectY}
                @drag-select-end=${onDragSelectEnd}
              ></vuerd-drag-select>
            `
            : null}
        ${state.menus
            ? html `
              <vuerd-contextmenu
                .menus=${state.menus}
                .x=${state.contextmenuX}
                .y=${state.contextmenuY}
                @close=${onCloseContextmenu}
              ></vuerd-contextmenu>
            `
            : null}
        <vuerd-find .visible=${findActive} @close=${onCloseFind}></vuerd-find>
      </div>
    `;
        };
    };
    defineComponent('vuerd-erd', {
        observedProps: [
            {
                name: 'width',
                default: 0,
            },
            {
                name: 'height',
                default: 0,
            },
        ],
        styleMap: {
            height: '100%',
        },
        style: IndexStyle$4,
        render: ERD,
    });

    const MAX_WIDTH = 800;
    const ANIMATION_TIME$1 = 300;
    function useDrawerAnimation(props, ctx) {
        const state = observable$1({ right: 0, visible: false });
        let openTween = null;
        let closeTween = null;
        const getWidth = () => {
            let width = props.width / 2;
            if (width > MAX_WIDTH) {
                width = MAX_WIDTH;
            }
            return width;
        };
        const onOpen = () => {
            if (openTween)
                return;
            closeTween === null || closeTween === void 0 ? void 0 : closeTween.stop();
            closeTween = null;
            state.visible = true;
            state.right = state.right === 0 ? -1 * getWidth() : state.right;
            openTween = new Tween(state)
                .to({ right: 0 }, ANIMATION_TIME$1)
                .easing(Easing.Quadratic.Out)
                .onComplete(() => (openTween = null))
                .start();
        };
        const onClose = () => {
            if (closeTween)
                return;
            openTween === null || openTween === void 0 ? void 0 : openTween.stop();
            openTween = null;
            closeTween = new Tween(state)
                .to({ right: -1 * getWidth() }, ANIMATION_TIME$1)
                .easing(Easing.Quadratic.In)
                .onComplete(() => {
                closeTween = null;
                state.visible = false;
                ctx.dispatchEvent(new CustomEvent('close'));
            })
                .start();
        };
        return {
            drawerState: state,
            getWidth,
            onOpen,
            onClose,
        };
    }

    const DrawerStyle = css `
  .vuerd-drawer {
    position: absolute;
    top: ${SIZE_MENUBAR_HEIGHT}px;
    height: calc(100% - ${SIZE_MENUBAR_HEIGHT}px);
    color: var(--vuerd-color-font);
    opacity: 0.9;
    background-color: var(--vuerd-color-contextmenu);
    fill: #fff0;
    padding: 20px;
    box-sizing: border-box;
    z-index: 100;
  }

  .vuerd-drawer:hover {
    fill: var(--vuerd-color-font);
  }

  .vuerd-drawer-header {
    height: 30px;
    margin-bottom: 10px;
    overflow: hidden;
  }

  .vuerd-drawer-header > h3 {
    display: inline-block;
    margin: 0;
  }

  .vuerd-drawer-header > .vuerd-button {
    float: right;
  }

  .vuerd-drawer-body {
    height: calc(100% - 40px);
    overflow: auto;
    box-sizing: border-box;
  }

  ${DefaultStyle}
`;

    const Drawer = (props, ctx) => {
        const contextRef = useContext$1(ctx);
        const { drawerState, getWidth, onOpen, onClose } = useDrawerAnimation(props, ctx);
        const { unmountedGroup } = useUnmounted();
        const { resetTooltip } = useTooltip(['.vuerd-button'], ctx);
        beforeMount(() => unmountedGroup.push(watch(props, propName => {
            if (propName !== 'visible')
                return;
            props.visible ? onOpen() : onClose();
            props.visible && setTimeout(resetTooltip, 0);
        })));
        return () => {
            const { keymap } = contextRef.value;
            const keymapStop = keymapOptionsToString(keymap.stop);
            return drawerState.visible
                ? html `
          <div
            class="vuerd-drawer"
            style=${styleMap({
                width: `${getWidth()}px`,
                right: `${drawerState.right}px`,
            })}
          >
            <div class="vuerd-drawer-header">
              <h3>${props.name}</h3>
              <vuerd-icon
                class="vuerd-button"
                name="times"
                size="16"
                data-tippy-content=${keymapStop}
                @click=${onClose}
              ></vuerd-icon>
            </div>
            <div class="vuerd-drawer-body vuerd-scrollbar">
              <slot></slot>
            </div>
          </div>
        `
                : null;
        };
    };
    defineComponent('vuerd-drawer', {
        observedProps: [
            {
                name: 'name',
                default: '',
            },
            {
                name: 'width',
                type: Number,
                default: DEFAULT_WIDTH,
            },
            {
                name: 'visible',
                type: Boolean,
                default: false,
            },
        ],
        style: [DrawerStyle, IconStyle].join(''),
        render: Drawer,
    });

    const HelpDrawer = (props, ctx) => {
        const contextRef = useContext$1(ctx);
        const getHelpDescribe = () => {
            const { keymap } = contextRef.value;
            return [
                {
                    name: 'Editing - ERD',
                    keymap: `dblclick, ${keymapOptionsToString(keymap.edit)}`,
                },
                {
                    name: 'Editing - Grid',
                    keymap: 'dblclick, Enter',
                },
                {
                    name: 'All Stop',
                    keymap: keymapOptionsToString(keymap.stop),
                },
                {
                    name: 'Search - find, filter',
                    keymap: keymapOptionsToString(keymap.find),
                },
                {
                    name: 'Undo - ERD',
                    keymap: keymapOptionsToString(keymap.undo),
                },
                {
                    name: 'Redo - ERD',
                    keymap: keymapOptionsToString(keymap.redo),
                },
                {
                    name: 'Selection - table, memo',
                    keymap: `Ctrl + Drag, Click, Ctrl + Click, Cmd + Drag, Cmd + Click, ${keymapOptionsToString(keymap.selectAllTable)}`,
                },
                {
                    name: 'Selection - column, filter',
                    keymap: `Click, Ctrl + Click, Cmd + Click, Shift + Click, Shift + Arrow key(up, down), ${keymapOptionsToString(keymap.selectAllColumn)}`,
                },
                {
                    name: 'Movement - table, memo, column, filter',
                    keymap: 'Drag, Ctrl + Drag, Cmd + Drag',
                },
                {
                    name: 'Copy - column',
                    keymap: keymapOptionsToString(keymap.copyColumn),
                },
                {
                    name: 'Paste - column',
                    keymap: keymapOptionsToString(keymap.pasteColumn),
                },
                {
                    name: 'Contextmenu - ERD, Table, Relationship, SQL DDL, Generator Code',
                    keymap: 'Right-click',
                },
                {
                    name: 'Table Properties',
                    keymap: keymapOptionsToString(keymap.tableProperties),
                },
                {
                    name: 'New Table',
                    keymap: keymapOptionsToString(keymap.addTable),
                },
                {
                    name: 'New Memo',
                    keymap: keymapOptionsToString(keymap.addMemo),
                },
                {
                    name: 'New - column, filter',
                    keymap: keymapOptionsToString(keymap.addColumn),
                },
                {
                    name: 'Delete - table, memo',
                    keymap: keymapOptionsToString(keymap.removeTable),
                },
                {
                    name: 'Hide table',
                    keymap: keymapOptionsToString(keymap.hideTable),
                },
                {
                    name: 'Delete - column, filter',
                    keymap: keymapOptionsToString(keymap.removeColumn),
                },
                {
                    name: 'Select Hint - dataType, find',
                    keymap: 'Arrow key(right), Click',
                },
                {
                    name: 'Move Hint - dataType, find',
                    keymap: 'Arrow key(up, down)',
                },
                {
                    name: 'Primary Key',
                    keymap: keymapOptionsToString(keymap.primaryKey),
                },
                {
                    name: 'checkbox - Grid, filter',
                    keymap: 'Space, Click',
                },
                {
                    name: 'Move checkbox - Grid, filter',
                    keymap: 'Arrow key(up, down, left, right)',
                },
                {
                    name: 'Relationship - Zero One',
                    keymap: keymapOptionsToString(keymap.relationshipZeroOne),
                },
                {
                    name: 'Relationship - Zero N',
                    keymap: keymapOptionsToString(keymap.relationshipZeroN),
                },
                {
                    name: 'Relationship - One Only',
                    keymap: keymapOptionsToString(keymap.relationshipOneOnly),
                },
                {
                    name: 'Relationship - One N',
                    keymap: keymapOptionsToString(keymap.relationshipOneN),
                },
                {
                    name: 'Zoom In - ERD',
                    keymap: keymapOptionsToString(keymap.zoomIn),
                },
                {
                    name: 'Zoom Out - ERD',
                    keymap: keymapOptionsToString(keymap.zoomOut),
                },
            ];
        };
        const onClose = () => ctx.dispatchEvent(new CustomEvent('close'));
        return () => html `
    <vuerd-drawer
      name="Help"
      .width=${props.width}
      .visible=${props.visible}
      @close=${onClose}
    >
      <table>
        <thead>
          <th>Name</th>
          <th>Keymap</th>
        </thead>
        <tbody>
          ${getHelpDescribe().map(describe => html `
              <tr>
                <td>${describe.name}</td>
                <td>${describe.keymap}</td>
              </tr>
            `)}
        </tbody>
      </table>
    </vuerd-drawer>
  `;
    };
    defineComponent('vuerd-help-drawer', {
        observedProps: ['width', 'visible'],
        shadow: false,
        render: HelpDrawer,
    });

    const fromShadowDraggable = (elements) => merge(...elements.map(el => fromEvent(el, 'dragover').pipe(throttleTime(300), map(() => el.dataset.id)))).pipe(debounceTime(50), takeUntil(merge(...elements.map(el => fromEvent(el, 'dragend')))));

    const SettingDrawer = (props, ctx) => {
        const contextRef = useContext$1(ctx);
        const state = observable$1({
            currentColumnType: null,
        });
        const columnsOrderRef = queryAll('.vuerd-column-order');
        const flipAnimation = new FlipAnimation(ctx.shadowRoot ? ctx.shadowRoot : ctx, '.vuerd-column-order', 'vuerd-column-order-move');
        const onClose = () => ctx.dispatchEvent(new CustomEvent('close'));
        const onChangeRelationshipDataTypeSync = (event) => {
            const checkbox = event.target;
            const { store } = contextRef.value;
            store.dispatch(changeRelationshipDataTypeSync(checkbox.checked));
        };
        const onChangeRelationshipOptimization = (event) => {
            const checkbox = event.target;
            const { store } = contextRef.value;
            store.dispatch(changeRelationshipOptimization(checkbox.checked));
        };
        const onMoveColumnOrder = (currentColumnType, targetColumnType) => {
            const { store } = contextRef.value;
            if (currentColumnType && currentColumnType !== targetColumnType) {
                flipAnimation.snapshot();
                store.dispatch(moveColumnOrder(currentColumnType, targetColumnType));
            }
        };
        const onDragstartColumnOrder = (currentColumnType) => {
            state.currentColumnType = currentColumnType;
            columnsOrderRef.value.forEach(el => el.classList.add('none-hover'));
            fromShadowDraggable(columnsOrderRef.value).subscribe({
                next: id => onMoveColumnOrder(currentColumnType, id),
                complete: () => {
                    state.currentColumnType = null;
                    columnsOrderRef.value.forEach(el => el.classList.remove('none-hover'));
                },
            });
        };
        const onSyncTableWidth = () => {
            const { store: { tableState: { tables }, relationshipState: { relationships }, }, helper, } = contextRef.value;
            recalculatingTableWidth(tables, helper);
            relationshipSort(tables, relationships);
        };
        updated(() => flipAnimation.play());
        return () => {
            const { canvasState: { setting }, editorState: { readonly }, } = contextRef.value.store;
            return html `
      <vuerd-drawer
        name="Setting"
        .width=${props.width}
        .visible=${props.visible}
        @close=${onClose}
      >
        <table class="vuerd-setting-drawer">
          <colgroup>
            <col width="190px" />
          </colgroup>
          <tbody>
            <tr>
              <td>Relationship DataType Sync</td>
              <td>
                <input
                  type="checkbox"
                  ?checked=${setting.relationshipDataTypeSync}
                  ?disabled=${readonly}
                  @change=${onChangeRelationshipDataTypeSync}
                />
              </td>
            </tr>
            <tr>
              <td>Relationship Optimization</td>
              <td>
                <input
                  type="checkbox"
                  ?checked=${setting.relationshipOptimization}
                  ?disabled=${readonly}
                  @change=${onChangeRelationshipOptimization}
                />
              </td>
            </tr>
            <tr>
              <td>ColumnType Order</td>
              <td @dragenter=${onPreventDefault} @dragover=${onPreventDefault}>
                ${repeat(setting.columnOrder, columnType => columnType, columnType => html `
                      <div
                        class=${classMap({
            'vuerd-column-order': true,
            draggable: state.currentColumnType === columnType,
        })}
                        data-id=${columnType}
                        draggable="true"
                        @dragstart=${() => onDragstartColumnOrder(columnType)}
                      >
                        ${columnType}
                      </div>
                    `)}
              </td>
            </tr>
            <tr>
              <td>Recalculating table width</td>
              <td>
                <div
                  class="vuerd-recalculating-table-width-button"
                  @click=${onSyncTableWidth}
                >
                  <span>Sync</span>
                  <vuerd-icon name="sync-alt" size="12"></vuerd-icon>
                </div>
              </td>
            </tr>
          </tbody>
        </table>
      </vuerd-drawer>
    `;
        };
    };
    defineComponent('vuerd-setting-drawer', {
        observedProps: ['width', 'visible'],
        shadow: false,
        render: SettingDrawer,
    });

    const Column = (props, ctx) => {
        const contextRef = useContext$1(ctx);
        const state = observable$1({
            hover: false,
            iconHover: false,
        });
        /**
         * Toggle select/unselect state of a single column
         */
        const toggleSelectColumn = () => {
            // todo
        };
        return () => html `
    <div
      class=${classMap({
        'vuerd-tree-column-name': true,
        'diff-modify': props.changes === 'modify',
        'diff-add': props.changes === 'add',
        'diff-remove': props.changes === 'remove',
    })}
      @mouseover=${() => {
        state.hover = true;
        contextRef.value.store.dispatch(focusTable(props.tableId, 'tableName'), focusColumn(props.tableId, props.column.id, 'columnName'));
    }}
      @mouseleave=${() => {
        state.hover = false;
        contextRef.value.store.dispatch(focusTableEnd());
    }}
    >
      ${props.column.option.primaryKey
        ? html ` <vuerd-icon id="pk" name="key" size="12"> </vuerd-icon> `
        : null}
      ${props.column.ui.fk
        ? html ` <vuerd-icon id="fk" name="key" size="12"> </vuerd-icon> `
        : null}

      <span> ${props.column.name} </span>

      ${state.hover
        ? html `
            <vuerd-icon
              name="eye${state.iconHover ? '-slash' : ''}"
              size="15"
              @click=${toggleSelectColumn}
              @mouseover=${() => (state.iconHover = true)}
              @mouseleave=${() => (state.iconHover = false)}
            >
            </vuerd-icon>
          `
        : null}
    </div>
  `;
    };
    const style$3 = css `
  .vuerd-tree-column-name {
    height: 18px;
    width: max-content;

    margin: 1px 0;

    cursor: pointer;
    display: flex;
    align-items: center;

    font-size: 15px;
  }
  .vuerd-tree-column-name > span:hover {
    color: var(--vuerd-color-font-active);
  }

  .vuerd-tree-column-name > span {
    padding: 0 3px;
  }

  .vuerd-tree-column-name .vuerd-icon {
    margin: 0 3px;
  }

  .vuerd-tree-column-name #eye {
    fill: var(--vuerd-color-font);
  }

  .vuerd-tree-column-name #eye:hover {
    fill: var(--vuerd-color-font-active);
  }

  .vuerd-tree-column-name #pk {
    fill: var(--vuerd-color-key-pk);
  }

  .vuerd-tree-column-name #fk {
    fill: var(--vuerd-color-key-fk);
  }
`;
    defineComponent('vuerd-tree-column-name', {
        observedProps: ['changes', 'column', 'update', 'tableId'],
        style: style$3,
        render: Column,
    });

    const TreeLine = (props, ctx) => {
        /**
         * Create svg based on type
         * @returns Svg coordinates
         */
        const getLine = () => {
            switch (props.shape) {
                case 'L':
                    return 'M5,0 L5,10 L15,10';
                case 'X':
                    return 'M5,0 L5,20 M5,10 L15,10';
                case 'I':
                    return 'M5,0 L5,20';
                case 'NULL':
                    return '';
            }
        };
        return () => html `
    <div class="vuerd-tree-line">
      <svg class="vuerd-tree-line-svg">
        <path d="${getLine()}" />
      </svg>
    </div>
  `;
    };
    const style$2 = css `
  .vuerd-tree-line {
    width: 20px;
    height: 20px;
  }
  .vuerd-tree-line-svg {
    width: 20px;
    height: 20px;
  }

  .vuerd-tree-line-svg > path {
    stroke: var(--vuerd-color-font);
    fill: transparent;
  }
`;
    defineComponent('vuerd-tree-line', {
        observedProps: [
            {
                name: 'shape',
                default: 'NULL',
            },
        ],
        style: style$2,
        render: TreeLine,
    });

    const Table = (props, ctx) => {
        const contextRef = useContext$1(ctx);
        const state = observable$1({
            hover: false,
            iconHover: false,
        });
        /**
         * Toggle open/close and select/unselect state of a single node
         */
        const toggleNode = () => {
            if (!props.node.open && props.node.table.visible) {
                if (props.node.toggleOpen())
                    props.update();
            }
            else if (props.node.open && !props.node.table.visible) {
                if (props.node.toggleVisible())
                    props.update();
            }
            else {
                if (props.node.toggleVisible() && props.node.toggleOpen())
                    props.update();
            }
        };
        /**
         * Toggle select/unselect state of a single node
         */
        const toggleSelectNode = () => {
            if (props.node.toggleVisible())
                props.update();
        };
        /**
         * When drag ends, recalculate position of table inside canvas and load it
         * @param ev MouseEvent
         */
        const onDragEnd = (ev) => {
            if (!props.node.table)
                return;
            if (props.node.table.visible || props.node.disabled)
                return;
            const { store } = contextRef.value;
            const { height, width, scrollTop, scrollLeft, zoomLevel } = store.canvasState;
            var diffX = (width - width * zoomLevel + scrollLeft * 2) / 2;
            var diffY = (height - height * zoomLevel + scrollTop * 2) / 2;
            props.node.table.ui.left = (ev.clientX - diffX) / zoomLevel;
            props.node.table.ui.top = (ev.clientY - 30 - diffY) / zoomLevel;
            toggleSelectNode();
            store.dispatch(moveTable(store, false, 0, 0, props.node.table.id));
        };
        return () => html `<div
    class=${classMap({
        'vuerd-tree-table-name': true,
        'diff-modify': props.node.changes === 'modify',
        'diff-add': props.node.changes === 'add',
        'diff-remove': props.node.changes === 'remove',
    })}
    @dragenter=${onPreventDefault}
    @dragover=${onPreventDefault}
    @mouseover=${() => {
        state.hover = true;
        contextRef.value.store.dispatch(selectTable(contextRef.value.store, false, props.node.id));
    }}
    @mouseleave=${() => {
        state.hover = false;
        contextRef.value.store.dispatch(selectEndTable());
    }}
    style=${styleMap({
        cursor: props.node.disabled ? 'default' : '',
    })}
  >
    <vuerd-icon
      id="table"
      name="table"
      size="12"
      @click=${toggleNode}
      style=${styleMap({
        fill: props.node.disabled ? 'var(--vuerd-color-font-placeholder)' : '',
    })}
    >
    </vuerd-icon>

    <span
      draggable="${props.node.disabled ||
        !props.node.table ||
        props.node.table.visible
        ? 'false'
        : 'true'}"
      @dragend=${onDragEnd}
      @click=${toggleNode}
      style=${styleMap({
        backgroundColor: props.node.table.visible && !props.node.disabled
            ? 'var(--vuerd-color-contextmenu-active)'
            : '',
        color: props.node.disabled ? 'var(--vuerd-color-font-placeholder)' : '',
        cursor: props.node.disabled || props.node.table.visible ? 'pointer' : 'grab',
    })}
    >
      ${props.node.table.name}
    </span>

    ${props.node.nestedChanges !== 'none'
        ? html `
          <svg
            class=${classMap({
            'vuerd-tree-table-nested-change': true,
            'diff-modify': props.node.nestedChanges === 'modify',
            'diff-add': props.node.nestedChanges === 'add',
            'diff-remove': props.node.nestedChanges === 'remove',
        })}
          >
            <circle cx="5" cy="5" r="5" />
          </svg>
        `
        : null}
    ${state.hover
        ? html `
          <vuerd-icon
            id="eye"
            name="eye${props.node.table.visible === state.iconHover
            ? '-slash'
            : ''}"
            size="15"
            @click=${toggleSelectNode}
            @mouseover=${() => (state.iconHover = true)}
            @mouseleave=${() => (state.iconHover = false)}
          >
          </vuerd-icon>
        `
        : null}
  </div> `;
    };
    const style$1 = css `
  .vuerd-tree-table-name {
    height: 18px;
    width: max-content;

    margin: 1px 0;

    cursor: pointer;
    display: flex;
    align-items: center;

    font-size: 15px;
  }

  .vuerd-tree-table-name > span:hover {
    color: var(--vuerd-color-font-active);
  }

  .vuerd-tree-table-name > span {
    padding: 0 3px;
  }

  .vuerd-tree-table-name #eye,
  .vuerd-tree-table-name #table {
    margin: 0 3px;
    fill: var(--vuerd-color-font);
  }

  .vuerd-tree-table-name #eye:hover {
    fill: var(--vuerd-color-font-active);
  }

  .vuerd-tree-table-nested-change {
    width: 10px;
    height: 10px;
    margin-left: 5px;
  }

  .vuerd-tree-table-nested-change.diff-remove {
    fill: var(--vuerd-color-diff-remove);
  }
  .vuerd-tree-table-nested-change.diff-add {
    fill: var(--vuerd-color-diff-add);
  }
  .vuerd-tree-table-nested-change.diff-modify {
    fill: var(--vuerd-color-diff-modify);
  }
`;
    defineComponent('vuerd-tree-table-name', {
        observedProps: ['node', 'update'],
        style: style$1,
        render: Table,
    });

    /**
     * Single node of entire graph - represents one table with children as relationships
     */
    class TreeNode {
        constructor(context, id, table, parent, root, children = []) {
            this.context = context;
            this.id = id;
            this.table = table;
            this.open = false;
            this.disabled = this.verifyParent(parent);
            this.parent = parent;
            this.root = root;
            this.children = children;
            // this.selected = this.verifySelected();
            this.changes = 'none';
            this.nestedChanges = 'none';
            this.diffs = [];
        }
        /**
         * Recursively searches through all predecessors of provided node to check if provided node was a distant predecessor of itself
         * @param node Node to be checked againts this
         * @returns True if found duplicate along the way
         */
        verifyParent(node) {
            if (node && node.id === this.id) {
                return true;
            }
            else if (node === null || node === void 0 ? void 0 : node.parent) {
                return this.verifyParent(node.parent);
            }
            else {
                return false;
            }
        }
        /**
         * Toggles between open/closed state
         * @returns True if toggle was succesfull
         */
        toggleOpen() {
            if (this.disabled)
                return false;
            this.open = !this.open;
            if (this.open) {
                findChildren(this.context, this);
            }
            return true;
        }
        /**
         * Toggles between visible/hidden state
         * @returns True if toggle was succesfull
         */
        toggleVisible() {
            if (this.disabled)
                return false;
            this.setVisible(!this.table.visible);
            return true;
        }
        /**
         * Setter for visible
         */
        setVisible(visible) {
            if (visible) {
                this.context.store.dispatch(showTable(this.table.id));
            }
            else {
                this.context.store.dispatch(hideTable(this.table.id));
            }
        }
        /**
         * Gets all relationships inside editor of this node
         * @returns Relationships inside editor
         */
        getRelationships() {
            // @ts-ignore
            var relationships = this.context.store.relationshipState.relationships
                .map(relationship => {
                if (relationship.start.tableId === this.id ||
                    relationship.end.tableId === this.id) {
                    return relationship;
                }
                else {
                    return null;
                }
            })
                .filter(value => value !== null);
            return relationships || [];
        }
    }
    /**
     * Generates entire graph with root having all tables as children
     * @param context Context of entire app
     * @returns Root node if found
     */
    const generateRoot = (context, oldRoot) => {
        const { store } = context;
        const { tables } = store.tableState;
        //@ts-ignore
        var root = new TreeNode(context, '', null, null, null);
        root.children.push(...tables.map(table => {
            var node = new TreeNode(context, table.id, table, root, root);
            return node;
        }));
        root.children.sort((a, b) => {
            if (!a.table || !b.table)
                return 0;
            if (a.table.name < b.table.name)
                return -1;
            if (a.table.name > b.table.name)
                return 1;
            return 0;
        });
        oldRoot === null || oldRoot === void 0 ? void 0 : oldRoot.children.forEach(oldChild => {
            var _a;
            const newChild = getData(root.children, oldChild.id);
            if (newChild === null || newChild === void 0 ? void 0 : newChild.table) {
                newChild.table.visible = (_a = oldChild.table) === null || _a === void 0 ? void 0 : _a.visible;
            }
        });
        return root;
    };
    /**
     * Searches through relationships to find all related children
     * @param context Context of entire app
     * @param node Single
     */
    const findChildren = (context, node) => {
        if (node.disabled || !node.root)
            return;
        // @ts-ignore
        var childrenIDs = [
            ...new Set(context.store.relationshipState.relationships
                .map(relation => {
                if (relation.end.tableId === node.id)
                    return relation.start.tableId;
                else if (relation.start.tableId === node.id)
                    return relation.end.tableId;
                else
                    return null;
            })
                .filter(relation => relation !== null)),
        ];
        // @ts-ignore
        node.children =
            childrenIDs
                .map(id => {
                if (node.root)
                    var child = getData(node.root.children, id);
                if (child)
                    return new TreeNode(context, id, child.table, node, node.root);
                else
                    return null;
            })
                .filter(child => child !== null) || [];
    };

    const TreeDrawer = (props, ctx) => {
        const contextRef = useContext$1(ctx);
        const state = observable$1({
            tree: [],
            root: null,
            forbidUpdate: false,
        });
        /**
         * Draws entire tree of tables
         */
        const refresh = () => {
            state.root = generateRoot(contextRef.value, state.root || undefined);
            refreshDiff();
        };
        const updateTree = () => {
            var _a;
            state.tree = [];
            if ((_a = state.root) === null || _a === void 0 ? void 0 : _a.children.length) {
                state.tree.push(...showChildren(state.root));
            }
            else {
                state.tree[0] = html `No table found`;
            }
        };
        const refreshDiff = () => {
            var _a;
            const diffs = calculateLatestDiff(contextRef.value);
            // @ts-ignore
            const tableDiffs = diffs.filter(diff => diff.type === 'table');
            // @ts-ignore
            const columnDiffs = diffs.filter(diff => diff.type === 'column');
            (_a = state.root) === null || _a === void 0 ? void 0 : _a.children.forEach(child => {
                child.changes = 'none';
                child.nestedChanges = 'none';
                child.diffs = [];
                tableDiffs.forEach(diff => {
                    if (diff.changes === 'modify' && child.id === diff.newTable.id) {
                        child.changes = 'modify';
                        child.diffs.push(diff);
                    }
                    else if (diff.changes === 'add' && child.id === diff.newTable.id) {
                        child.changes = 'add';
                        child.diffs.push(diff);
                    }
                    else if (diff.changes === 'remove' && child.id === diff.oldTable.id) {
                        child.changes = 'remove';
                        child.diffs.push(diff);
                    }
                });
                columnDiffs.forEach(diff => {
                    if (child.id === diff.table.id) {
                        child.nestedChanges = diff.changes;
                        child.diffs.push(diff);
                    }
                });
            });
            tableDiffs.forEach(diff => {
                var _a, _b;
                if (diff.changes === 'remove') {
                    var node = new TreeNode(contextRef.value, diff.oldTable.id, diff.oldTable, state.root, state.root, []);
                    node.changes = 'remove';
                    node.diffs = [diff];
                    const duplicate = (_a = state.root) === null || _a === void 0 ? void 0 : _a.children.some(node => {
                        if (node.id === diff.oldTable.id)
                            return true;
                    });
                    if (!duplicate)
                        (_b = state.root) === null || _b === void 0 ? void 0 : _b.children.push(node);
                }
            });
            updateTree();
        };
        /**
         * Returns array of html children of one node
         * @param node Node of which children will be returned
         * @param lines Lines before this node
         * @returns Array of html containing rows with tables/columns
         */
        const showChildren = (node, lines = []) => {
            if (node.children.length) {
                const lastChild = node.children[node.children.length - 1];
                function tableRow(changes, node) {
                    return html `<div
          class=${classMap({
                    'vuerd-tree-row': true,
                    'diff-modify': changes === 'modify',
                    'diff-add': changes === 'add',
                    'diff-remove': changes === 'remove',
                })}
        >
          ${makeTreeLines(lines)}
          <vuerd-tree-table-name
            .node=${node}
            .update=${updateTree}
          ></vuerd-tree-table-name>
        </div>`;
                }
                var rows = node.children.map(child => {
                    var _a;
                    if (child === lastChild)
                        lines[lines.length - 1] = 'L';
                    const primaryNode = getData(((_a = child.root) === null || _a === void 0 ? void 0 : _a.children) || [], child.id);
                    if (primaryNode && !child.disabled) {
                        child.changes = primaryNode.changes;
                        child.nestedChanges = primaryNode.nestedChanges;
                    }
                    var childRows = [];
                    childRows.push(tableRow(child.changes, child));
                    if (child.open) {
                        if (lastChild.id === child.id) {
                            lines[lines.length - 1] = 'NULL';
                        }
                        else {
                            lines[lines.length - 1] = 'I';
                        }
                        childRows.push(...showColumns(child, [...lines, 'I']));
                        childRows.push(...showChildren(child, [...lines, 'X']));
                    }
                    return childRows;
                });
                // const removedTables: TemplateResult[] = node.diffs;
                return rows.reduce((acc, val) => acc.concat(val), []); // flatten array [][] --> []
            }
            else
                return [];
        };
        /**
         * Returns array of html columns belonging to one table inside node
         * @param node Node of which columns will be returned
         * @param lines Lines to draw
         * @returns Array of html containing rows of columns
         */
        const showColumns = (node, lines) => {
            var _a, _b;
            var columns = [];
            function columnRow(changes, column) {
                return html `
        <div
          class=${classMap({
                'vuerd-tree-row': true,
                'diff-modify': changes === 'modify',
                'diff-add': changes === 'add',
                'diff-remove': changes === 'remove',
            })}
        >
          ${makeTreeLines(lines)}
          <vuerd-tree-column-name
            .tableId=${node.id}
            .changes=${changes}
            .column=${column}
            .update=${updateTree}
          ></vuerd-tree-column-name>
        </div>
      `;
            }
            const primaryNode = getData(((_a = node.root) === null || _a === void 0 ? void 0 : _a.children) || [], node.id);
            if (primaryNode === null || primaryNode === void 0 ? void 0 : primaryNode.table) {
                columns = (_b = primaryNode.table) === null || _b === void 0 ? void 0 : _b.columns.map(col => {
                    for (let diff of primaryNode.diffs) {
                        if (diff.type === 'table' &&
                            (diff.changes === 'add' || diff.changes === 'remove')) {
                            return columnRow(diff.changes, col);
                        }
                        else if (diff.type === 'column') {
                            if (diff.changes === 'add' && diff.newColumn.id === col.id) {
                                return columnRow('add', col);
                            }
                            else if (diff.changes === 'modify' &&
                                diff.newColumn.id === col.id) {
                                return columnRow('modify', col);
                            }
                            else if (diff.changes === 'remove' &&
                                diff.oldColumn.id === col.id) {
                                return columnRow('remove', col);
                            }
                        }
                    }
                    return columnRow('none', col);
                });
                //@ts-ignore
                const removedColumns = primaryNode.diffs
                    .map(diff => {
                    if (diff.changes === 'remove' &&
                        diff.type === 'column' &&
                        diff.oldColumn)
                        return columnRow('remove', diff.oldColumn);
                })
                    .filter(row => row);
                columns.push(...removedColumns);
            }
            return columns;
        };
        /**
         * Creates lines
         * @param lines Array of lines to draw
         * @returns Array of lines
         */
        const makeTreeLines = (lines) => {
            return lines.map(line => html `<vuerd-tree-line .shape=${line}></vuerd-tree-line>`);
        };
        const showAll = () => {
            var _a;
            refresh();
            (_a = state.root) === null || _a === void 0 ? void 0 : _a.children.forEach(child => {
                if (!child.table.visible) {
                    child.toggleVisible();
                }
            });
            updateTree();
        };
        /**
         * Hides all tables
         */
        const hideAll = () => {
            var _a;
            refresh();
            (_a = state.root) === null || _a === void 0 ? void 0 : _a.children.forEach(child => {
                if (child.table.visible) {
                    child.toggleVisible();
                }
            });
            updateTree();
        };
        const onClose = () => ctx.dispatchEvent(new CustomEvent('close'));
        updated(() => {
            var _a;
            // S-R latch so we dont create infinite loop of updates
            if (props.visible === true && state.forbidUpdate === false) {
                state.forbidUpdate = true;
                if (!((_a = state.root) === null || _a === void 0 ? void 0 : _a.children.length)) {
                    refresh();
                }
                refreshDiff();
            }
            else if (props.visible === false && state.forbidUpdate === true) {
                state.forbidUpdate = false;
            }
        });
        return () => {
            return html `
      <vuerd-drawer
        name="Table Tree"
        .width=${props.width}
        .visible=${props.visible}
        @close=${onClose}
      >
        <div class="vuerd-tree-refresh" @click=${refresh}>
          <span>Refresh</span>
          <vuerd-icon name="sync-alt" size="12"></vuerd-icon>
        </div>

        <div class="vuerd-tree-hideall" @click=${showAll}>
          <span>Show all</span>
          <vuerd-icon name="eye" size="14"></vuerd-icon>
        </div>

        <div class="vuerd-tree-hideall" @click=${hideAll}>
          <span>Hide all</span>
          <vuerd-icon name="eye-slash" size="14"></vuerd-icon>
        </div>

        <div class="vuerd-tree-diff" @click=${refreshDiff}>
          <span>Get diff</span>
          <vuerd-icon name="sync-alt" size="12"></vuerd-icon>
        </div>

        ${state.tree}
      </vuerd-drawer>
    `;
        };
    };
    const style = css `
  .vuerd-tree-row {
    display: flex;
    flex-direction: row;
  }

  .vuerd-tree-refresh,
  .vuerd-tree-hideall,
  .vuerd-tree-diff {
    box-sizing: border-box;
    padding: 5px;
    display: inline-block;
    cursor: pointer;
    fill: var(--vuerd-color-font);
    font-size: 15px;
  }
  .vuerd-tree-refresh:hover,
  .vuerd-tree-hideall:hover,
  .vuerd-tree-diff:hover {
    color: var(--vuerd-color-font-active);
    background-color: var(--vuerd-color-contextmenu-active);
    fill: var(--vuerd-color-font-active);
  }

  .vuerd-tree-row.diff-add {
    background-color: var(--vuerd-color-diff-add);
  }
  .vuerd-tree-row.diff-modify {
    background-color: var(--vuerd-color-diff-modify);
  }
  .vuerd-tree-row.diff-remove {
    background-color: var(--vuerd-color-diff-remove);
  }
`;
    defineComponent('vuerd-tree-drawer', {
        observedProps: ['width', 'visible'],
        shadow: false,
        style,
        render: TreeDrawer,
    });

    const defaultOptions$6 = {
        nameWidth: 85,
        keymapWidth: 0,
        close: false,
    };
    const bracketTypeMenus = [
        {
            name: 'SingleQuote',
            bracketType: 'singleQuote',
        },
        {
            name: 'DoubleQuote',
            bracketType: 'doubleQuote',
        },
        {
            name: 'Backtick',
            bracketType: 'backtick',
        },
        {
            name: 'None',
            bracketType: 'none',
        },
    ];
    const createBracketTypeMenus = ({ store }) => bracketTypeMenus.map(menu => ({
        icon: store.canvasState.bracketType === menu.bracketType
            ? {
                prefix: 'fas',
                name: 'check',
            }
            : undefined,
        name: menu.name,
        execute: () => store.dispatch(changeBracketType(menu.bracketType)),
        options: Object.assign({}, defaultOptions$6),
    }));

    const defaultOptions$5 = {
        nameWidth: 105,
        keymapWidth: 0,
        close: false,
    };
    const createHighlightThemeMenus = ({ store, }) => highlightThemes.map(highlightTheme => ({
        icon: store.canvasState.highlightTheme === highlightTheme
            ? {
                prefix: 'fas',
                name: 'check',
            }
            : undefined,
        name: highlightTheme,
        execute: () => store.dispatch(changeHighlightTheme(highlightTheme)),
        options: Object.assign({}, defaultOptions$5),
    }));

    const defaultOptions$4 = {
        nameWidth: 100,
        keymapWidth: 0,
    };
    const createSQLDDLMenus = (context) => [
        {
            icon: {
                prefix: 'mdi',
                name: 'database',
                size: 18,
            },
            name: 'Database',
            children: createDatabaseMenus(context),
        },
        {
            icon: {
                prefix: 'mdi',
                name: 'code-brackets',
                size: 18,
            },
            name: 'Bracket',
            children: createBracketTypeMenus(context),
        },
        {
            icon: {
                prefix: 'mdi',
                name: 'palette',
                size: 18,
            },
            name: 'Highlight Theme',
            children: createHighlightThemeMenus(context),
        },
    ].map(menu => (Object.assign(Object.assign({}, menu), { options: Object.assign({}, defaultOptions$4) })));

    const AtomOneDarkStyle = css `
  /*
  Atom One Dark by Daniel Gamage
  Original One Dark Syntax theme from https://github.com/atom/one-dark-syntax

  base:    #282c34
  mono-1:  #abb2bf
  mono-2:  #818896
  mono-3:  #5c6370
  hue-1:   #56b6c2
  hue-2:   #61aeee
  hue-3:   #c678dd
  hue-4:   #98c379
  hue-5:   #e06c75
  hue-5-2: #be5046
  hue-6:   #d19a66
  hue-6-2: #e6c07b
  */

  .hljs {
    display: block;
    overflow-x: auto;
    padding: 0.5em;
    color: #abb2bf;
    background: #282c34;
  }

  .hljs-comment,
  .hljs-quote {
    color: #5c6370;
    font-style: italic;
  }

  .hljs-doctag,
  .hljs-keyword,
  .hljs-formula {
    color: #c678dd;
  }

  .hljs-section,
  .hljs-name,
  .hljs-selector-tag,
  .hljs-deletion,
  .hljs-subst {
    color: #e06c75;
  }

  .hljs-literal {
    color: #56b6c2;
  }

  .hljs-string,
  .hljs-regexp,
  .hljs-addition,
  .hljs-attribute,
  .hljs-meta-string {
    color: #98c379;
  }

  .hljs-built_in,
  .hljs-class .hljs-title {
    color: #e6c07b;
  }

  .hljs-attr,
  .hljs-variable,
  .hljs-template-variable,
  .hljs-type,
  .hljs-selector-class,
  .hljs-selector-attr,
  .hljs-selector-pseudo,
  .hljs-number {
    color: #d19a66;
  }

  .hljs-symbol,
  .hljs-bullet,
  .hljs-link,
  .hljs-meta,
  .hljs-selector-id,
  .hljs-title {
    color: #61aeee;
  }

  .hljs-emphasis {
    font-style: italic;
  }

  .hljs-strong {
    font-weight: bold;
  }

  .hljs-link {
    text-decoration: underline;
  }
`;

    const AtomOneLightStyle = css `
  /*
  Atom One Light by Daniel Gamage
  Original One Light Syntax theme from https://github.com/atom/one-light-syntax

  base:    #fafafa
  mono-1:  #383a42
  mono-2:  #686b77
  mono-3:  #a0a1a7
  hue-1:   #0184bb
  hue-2:   #4078f2
  hue-3:   #a626a4
  hue-4:   #50a14f
  hue-5:   #e45649
  hue-5-2: #c91243
  hue-6:   #986801
  hue-6-2: #c18401
  */

  .hljs {
    display: block;
    overflow-x: auto;
    padding: 0.5em;
    color: #383a42;
    background: #fafafa;
  }

  .hljs-comment,
  .hljs-quote {
    color: #a0a1a7;
    font-style: italic;
  }

  .hljs-doctag,
  .hljs-keyword,
  .hljs-formula {
    color: #a626a4;
  }

  .hljs-section,
  .hljs-name,
  .hljs-selector-tag,
  .hljs-deletion,
  .hljs-subst {
    color: #e45649;
  }

  .hljs-literal {
    color: #0184bb;
  }

  .hljs-string,
  .hljs-regexp,
  .hljs-addition,
  .hljs-attribute,
  .hljs-meta-string {
    color: #50a14f;
  }

  .hljs-built_in,
  .hljs-class .hljs-title {
    color: #c18401;
  }

  .hljs-attr,
  .hljs-variable,
  .hljs-template-variable,
  .hljs-type,
  .hljs-selector-class,
  .hljs-selector-attr,
  .hljs-selector-pseudo,
  .hljs-number {
    color: #986801;
  }

  .hljs-symbol,
  .hljs-bullet,
  .hljs-link,
  .hljs-meta,
  .hljs-selector-id,
  .hljs-title {
    color: #4078f2;
  }

  .hljs-emphasis {
    font-style: italic;
  }

  .hljs-strong {
    font-weight: bold;
  }

  .hljs-link {
    text-decoration: underline;
  }
`;

    const GithubGistStyle = css `
  /**
   * GitHub Gist Theme
   * Author : Anthony Attard - https://github.com/AnthonyAttard
   * Author : Louis Barranqueiro - https://github.com/LouisBarranqueiro
   */

  .hljs {
    display: block;
    background: white;
    padding: 0.5em;
    color: #333333;
    overflow-x: auto;
  }

  .hljs-comment,
  .hljs-meta {
    color: #969896;
  }

  .hljs-variable,
  .hljs-template-variable,
  .hljs-strong,
  .hljs-emphasis,
  .hljs-quote {
    color: #df5000;
  }

  .hljs-keyword,
  .hljs-selector-tag,
  .hljs-type {
    color: #d73a49;
  }

  .hljs-literal,
  .hljs-symbol,
  .hljs-bullet,
  .hljs-attribute {
    color: #0086b3;
  }

  .hljs-section,
  .hljs-name {
    color: #63a35c;
  }

  .hljs-tag {
    color: #333333;
  }

  .hljs-title,
  .hljs-attr,
  .hljs-selector-id,
  .hljs-selector-class,
  .hljs-selector-attr,
  .hljs-selector-pseudo {
    color: #6f42c1;
  }

  .hljs-addition {
    color: #55a532;
    background-color: #eaffea;
  }

  .hljs-deletion {
    color: #bd2c00;
    background-color: #ffecec;
  }

  .hljs-link {
    text-decoration: underline;
  }

  .hljs-number {
    color: #005cc5;
  }

  .hljs-string {
    color: #032f62;
  }
`;

    const MonokaiSublimeStyle = css `
  /*
    Monokai Sublime style. Derived from Monokai by noformnocontent http://nn.mit-license.org/
  */
  .hljs {
    display: block;
    overflow-x: auto;
    padding: 0.5em;
    background: #23241f;
  }

  .hljs,
  .hljs-tag,
  .hljs-subst {
    color: #f8f8f2;
  }

  .hljs-strong,
  .hljs-emphasis {
    color: #a8a8a2;
  }

  .hljs-bullet,
  .hljs-quote,
  .hljs-number,
  .hljs-regexp,
  .hljs-literal,
  .hljs-link {
    color: #ae81ff;
  }

  .hljs-code,
  .hljs-title,
  .hljs-section,
  .hljs-selector-class {
    color: #a6e22e;
  }

  .hljs-strong {
    font-weight: bold;
  }

  .hljs-emphasis {
    font-style: italic;
  }

  .hljs-keyword,
  .hljs-selector-tag,
  .hljs-name,
  .hljs-attr {
    color: #f92672;
  }

  .hljs-symbol,
  .hljs-attribute {
    color: #66d9ef;
  }

  .hljs-params,
  .hljs-class .hljs-title {
    color: #f8f8f2;
  }

  .hljs-string,
  .hljs-type,
  .hljs-built_in,
  .hljs-builtin-name,
  .hljs-selector-id,
  .hljs-selector-attr,
  .hljs-selector-pseudo,
  .hljs-addition,
  .hljs-variable,
  .hljs-template-variable {
    color: #e6db74;
  }

  .hljs-comment,
  .hljs-deletion,
  .hljs-meta {
    color: #75715e;
  }
`;

    const VS2015Style = css `
  /*
  * Visual Studio 2015 dark style
  * Author: Nicolas LLOBERA <nllobera@gmail.com>
  */

  .hljs {
    display: block;
    overflow-x: auto;
    padding: 0.5em;
    background: #1e1e1e;
    color: #dcdcdc;
  }

  .hljs-keyword,
  .hljs-literal,
  .hljs-symbol,
  .hljs-name {
    color: #569cd6;
  }
  .hljs-link {
    color: #569cd6;
    text-decoration: underline;
  }

  .hljs-built_in,
  .hljs-type {
    color: #4ec9b0;
  }

  .hljs-number,
  .hljs-class {
    color: #b8d7a3;
  }

  .hljs-string,
  .hljs-meta-string {
    color: #d69d85;
  }

  .hljs-regexp,
  .hljs-template-tag {
    color: #9a5334;
  }

  .hljs-subst,
  .hljs-function,
  .hljs-title,
  .hljs-params,
  .hljs-formula {
    color: #dcdcdc;
  }

  .hljs-comment,
  .hljs-quote {
    color: #57a64a;
    font-style: italic;
  }

  .hljs-doctag {
    color: #608b4e;
  }

  .hljs-meta,
  .hljs-meta-keyword,
  .hljs-tag {
    color: #9b9b9b;
  }

  .hljs-variable,
  .hljs-template-variable {
    color: #bd63c5;
  }

  .hljs-attr,
  .hljs-attribute,
  .hljs-builtin-name {
    color: #9cdcfe;
  }

  .hljs-section {
    color: gold;
  }

  .hljs-emphasis {
    font-style: italic;
  }

  .hljs-strong {
    font-weight: bold;
  }

  /*.hljs-code {
  font-family:'Monospace';
}*/

  .hljs-bullet,
  .hljs-selector-tag,
  .hljs-selector-id,
  .hljs-selector-class,
  .hljs-selector-attr,
  .hljs-selector-pseudo {
    color: #d7ba7d;
  }

  .hljs-addition {
    background-color: #144212;
    display: inline-block;
    width: 100%;
  }

  .hljs-deletion {
    background-color: #600;
    display: inline-block;
    width: 100%;
  }
`;

    const languageMap = {
        GraphQL: 'graphql',
        'C#': 'csharp',
        Java: 'java',
        Kotlin: 'kotlin',
        TypeScript: 'typescript',
        JPA: 'java',
        Scala: 'scala',
    };
    const highlightThemeMap = {
        AtomOneDark: AtomOneDarkStyle,
        AtomOneLight: AtomOneLightStyle,
        MonokaiSublime: MonokaiSublimeStyle,
        GithubGist: GithubGistStyle,
        VS2015: VS2015Style,
    };

    const SQLDDLStyle = css `
  .vuerd-sql-ddl {
    height: 100%;
    white-space: pre;
    box-sizing: border-box;
    overflow: auto;
    font-family: monospace !important;
    outline: none;
  }
`;

    const SQLDDL = (props, ctx) => {
        const contextRef = useContext$1(ctx);
        const state = observable$1({
            menus: null,
            contextmenuX: 0,
            contextmenuY: 0,
        });
        const { unmountedGroup } = useUnmounted();
        const onContextmenu = (event) => {
            event.preventDefault();
            state.contextmenuX = event.clientX;
            state.contextmenuY = event.clientY;
            state.menus = createSQLDDLMenus(contextRef.value);
        };
        const onCloseContextmenu = () => (state.menus = null);
        const onMousedown = () => onCloseContextmenu();
        beforeMount(() => {
            const context = contextRef.value;
            const { store: { canvasState }, eventBus, } = context;
            unmountedGroup.push(watch(canvasState, propName => {
                var _a;
                if (propName !== 'database')
                    return;
                const menue = (_a = state.menus) === null || _a === void 0 ? void 0 : _a.find(menu => menu.name === 'Database');
                if (!menue)
                    return;
                menue.children = createDatabaseMenus(context);
            }), watch(canvasState, propName => {
                var _a;
                if (propName !== 'highlightTheme')
                    return;
                const menue = (_a = state.menus) === null || _a === void 0 ? void 0 : _a.find(menu => menu.name === 'Highlight Theme');
                if (!menue)
                    return;
                menue.children = createHighlightThemeMenus(context);
            }), watch(canvasState, propName => {
                var _a;
                if (propName !== 'bracketType')
                    return;
                const menue = (_a = state.menus) === null || _a === void 0 ? void 0 : _a.find(menu => menu.name === 'Bracket');
                if (!menue)
                    return;
                menue.children = createBracketTypeMenus(context);
            }), eventBus.on(Bus.Contextmenu.close).subscribe(onCloseContextmenu));
        });
        return () => {
            const { store } = contextRef.value;
            const { canvasState: { highlightTheme }, } = store;
            const sql = props.mode === 'all' || !props.table
                ? createDDL(store)
                : createDDLTable(store, props.table);
            const sqlHTML = core.highlight(sql, {
                language: 'sql',
            }).value;
            return html `
      <style type="text/css">
        ${highlightThemeMap[highlightTheme]}
      </style>
      <div
        class="vuerd-sql-ddl vuerd-scrollbar hljs"
        contenteditable="true"
        spellcheck="false"
        @mousedown=${onMousedown}
        @contextmenu=${onContextmenu}
      >
        ${unsafeHTML(sqlHTML)}
        ${state.menus
            ? html `
              <vuerd-contextmenu
                .menus=${state.menus}
                .x=${state.contextmenuX}
                .y=${state.contextmenuY}
                @close=${onCloseContextmenu}
              >
              </vuerd-contextmenu>
            `
            : null}
      </div>
    `;
        };
    };
    defineComponent('vuerd-sql-ddl', {
        observedProps: [
            {
                name: 'table',
                default: null,
            },
            {
                name: 'mode',
                default: 'all',
            },
        ],
        styleMap: {
            width: '100%',
            height: '100%',
        },
        style: [SQLDDLStyle, ScrollbarStyle].join(''),
        render: SQLDDL,
    });

    const defaultOptions$3 = {
        nameWidth: 50,
        keymapWidth: 0,
        close: false,
    };
    const nameCaseMenus$1 = [
        {
            name: 'Pascal',
            nameCase: 'pascalCase',
        },
        {
            name: 'Camel',
            nameCase: 'camelCase',
        },
        {
            name: 'Snake',
            nameCase: 'snakeCase',
        },
        {
            name: 'None',
            nameCase: 'none',
        },
    ];
    const createColumnNameCaseMenus = ({ store, }) => nameCaseMenus$1.map(menu => ({
        icon: store.canvasState.columnCase === menu.nameCase
            ? {
                prefix: 'fas',
                name: 'check',
            }
            : undefined,
        name: menu.name,
        execute: () => store.dispatch(changeColumnCase(menu.nameCase)),
        options: Object.assign({}, defaultOptions$3),
    }));

    const defaultOptions$2 = {
        nameWidth: 70,
        keymapWidth: 0,
        close: false,
    };
    const createLanguageMenus = ({ store }) => languageList.map(language => ({
        icon: store.canvasState.language === language
            ? {
                prefix: 'fas',
                name: 'check',
            }
            : undefined,
        name: language,
        execute: () => store.dispatch(changeLanguage(language)),
        options: Object.assign({}, defaultOptions$2),
    }));

    const defaultOptions$1 = {
        nameWidth: 50,
        keymapWidth: 0,
        close: false,
    };
    const nameCaseMenus = [
        {
            name: 'Pascal',
            nameCase: 'pascalCase',
        },
        {
            name: 'Camel',
            nameCase: 'camelCase',
        },
        {
            name: 'Snake',
            nameCase: 'snakeCase',
        },
        {
            name: 'None',
            nameCase: 'none',
        },
    ];
    const createTableNameCaseMenus = ({ store }) => nameCaseMenus.map(menu => ({
        icon: store.canvasState.tableCase === menu.nameCase
            ? {
                prefix: 'fas',
                name: 'check',
            }
            : undefined,
        name: menu.name,
        execute: () => store.dispatch(changeTableCase(menu.nameCase)),
        options: Object.assign({}, defaultOptions$1),
    }));

    const defaultOptions = {
        nameWidth: 120,
        keymapWidth: 0,
    };
    const createGeneratorCodeMenus = (context) => [
        {
            icon: {
                prefix: 'fas',
                name: 'code',
            },
            name: 'Language',
            children: createLanguageMenus(context),
        },
        {
            icon: {
                prefix: 'mdi',
                name: 'format-letter-case',
                size: 18,
            },
            name: 'Table Name Case',
            children: createTableNameCaseMenus(context),
        },
        {
            icon: {
                prefix: 'mdi',
                name: 'format-letter-case',
                size: 18,
            },
            name: 'Column Name Case',
            children: createColumnNameCaseMenus(context),
        },
        {
            icon: {
                prefix: 'mdi',
                name: 'palette',
                size: 18,
            },
            name: 'Highlight Theme',
            children: createHighlightThemeMenus(context),
        },
    ].map(menu => (Object.assign(Object.assign({}, menu), { options: Object.assign({}, defaultOptions) })));

    const convertTypeMap$6 = {
        int: 'int',
        long: 'long',
        float: 'float',
        double: 'double',
        decimal: 'decimal',
        boolean: 'bool',
        string: 'string',
        lob: 'string',
        date: 'DateTime',
        dateTime: 'DateTime',
        time: 'TimeSpan',
    };
    function createCode$6(store) {
        const stringBuffer = [''];
        const { database, tableCase, columnCase } = store.canvasState;
        const tables = orderByNameASC(store.tableState.tables);
        tables.forEach(table => {
            formatTable$6(table, stringBuffer, database, tableCase, columnCase);
            stringBuffer.push('');
        });
        return stringBuffer.join('\n');
    }
    function formatTable$6(table, buffer, database, tableCase, columnCase) {
        const tableName = getNameCase(table.name, tableCase);
        if (table.comment.trim() !== '') {
            buffer.push(`// ${table.comment}`);
        }
        buffer.push(`public class ${tableName} {`);
        table.columns.forEach(column => {
            formatColumn$6(column, buffer, database, columnCase);
        });
        buffer.push(`}`);
    }
    function formatColumn$6(column, buffer, database, columnCase) {
        const columnName = getNameCase(column.name, columnCase);
        const primitiveType = getPrimitiveType(column.dataType, database);
        if (column.comment.trim() !== '') {
            buffer.push(`  // ${column.comment}`);
        }
        buffer.push(`  public ${convertTypeMap$6[primitiveType]} ${columnName.charAt(0).toLocaleUpperCase() + columnName.slice(1)} { get; set; }`);
    }

    const convertTypeMap$5 = {
        int: 'Int',
        long: 'Int',
        float: 'Float',
        double: 'Float',
        decimal: 'Float',
        boolean: 'Boolean',
        string: 'String',
        lob: 'String',
        date: 'String',
        dateTime: 'String',
        time: 'String',
    };
    function createCode$5(store) {
        const stringBuffer = [''];
        const { database, tableCase, columnCase } = store.canvasState;
        const tables = orderByNameASC(store.tableState.tables);
        const relationships = store.relationshipState.relationships;
        tables.forEach(table => {
            formatTable$5(table, stringBuffer, database, relationships, tables, tableCase, columnCase);
            stringBuffer.push('');
        });
        return stringBuffer.join('\n');
    }
    function formatTable$5(table, buffer, database, relationships, tables, tableCase, columnCase) {
        const tableName = getNameCase(table.name, tableCase);
        if (table.comment.trim() !== '') {
            buffer.push(`# ${table.comment}`);
        }
        buffer.push(`type ${tableName} {`);
        table.columns.forEach(column => {
            formatColumn$5(column, buffer, database, columnCase);
        });
        formatRelation$1(table, buffer, relationships, tables, tableCase, columnCase);
        buffer.push(`}`);
    }
    function formatColumn$5(column, buffer, database, columnCase) {
        if (!column.ui.fk) {
            const columnName = getNameCase(column.name, columnCase);
            if (column.comment.trim() !== '') {
                buffer.push(`  # ${column.comment}`);
            }
            const idType = column.option.primaryKey || column.ui.fk;
            if (idType) {
                buffer.push(`  ${columnName}: ID${column.option.notNull ? '!' : ''}`);
            }
            else {
                const primitiveType = getPrimitiveType(column.dataType, database);
                buffer.push(`  ${columnName}: ${convertTypeMap$5[primitiveType]}${column.option.notNull ? '!' : ''}`);
            }
        }
    }
    function formatRelation$1(table, buffer, relationships, tables, tableCase, columnCase) {
        relationships
            .filter(relationship => relationship.end.tableId === table.id)
            .forEach(relationship => {
            const startTable = getData(tables, relationship.start.tableId);
            if (startTable) {
                const typeName = getNameCase(startTable.name, tableCase);
                const fieldName = getNameCase(startTable.name, columnCase);
                if (startTable.comment.trim() !== '') {
                    buffer.push(`  # ${startTable.comment}`);
                }
                buffer.push(`  ${fieldName}: ${typeName}`);
            }
        });
        relationships
            .filter(relationship => relationship.start.tableId === table.id)
            .forEach(relationship => {
            const endTable = getData(tables, relationship.end.tableId);
            if (endTable) {
                const typeName = getNameCase(endTable.name, tableCase);
                const fieldName = getNameCase(endTable.name, columnCase);
                if (endTable.comment.trim() !== '') {
                    buffer.push(`  # ${endTable.comment}`);
                }
                if (oneRelationshipTypes.includes(relationship.relationshipType)) {
                    buffer.push(`  ${fieldName}: ${typeName}`);
                }
                else if (nRelationshipTypes.includes(relationship.relationshipType)) {
                    buffer.push(`  ${getNameCase(`${fieldName}List`, columnCase)}: [${typeName}!]!`);
                }
            }
        });
    }

    const convertTypeMap$4 = {
        int: 'Integer',
        long: 'Long',
        float: 'Float',
        double: 'Double',
        decimal: 'BigDecimal',
        boolean: 'Boolean',
        string: 'String',
        lob: 'String',
        date: 'LocalDate',
        dateTime: 'LocalDateTime',
        time: 'LocalTime',
    };
    function createCode$4(store) {
        const stringBuffer = [''];
        const { database, tableCase, columnCase } = store.canvasState;
        const tables = orderByNameASC(store.tableState.tables);
        tables.forEach(table => {
            formatTable$4(table, stringBuffer, database, tableCase, columnCase);
            stringBuffer.push('');
        });
        return stringBuffer.join('\n');
    }
    function formatTable$4(table, buffer, database, tableCase, columnCase) {
        const tableName = getNameCase(table.name, tableCase);
        if (table.comment.trim() !== '') {
            buffer.push(`// ${table.comment}`);
        }
        buffer.push(`@Data`);
        buffer.push(`public class ${tableName} {`);
        table.columns.forEach(column => {
            formatColumn$4(column, buffer, database, columnCase);
        });
        buffer.push(`}`);
    }
    function formatColumn$4(column, buffer, database, columnCase) {
        const columnName = getNameCase(column.name, columnCase);
        const primitiveType = getPrimitiveType(column.dataType, database);
        if (column.comment.trim() !== '') {
            buffer.push(`  // ${column.comment}`);
        }
        buffer.push(`  private ${convertTypeMap$4[primitiveType]} ${columnName};`);
    }

    const convertTypeMap$3 = {
        int: 'Integer',
        long: 'Long',
        float: 'Float',
        double: 'Double',
        decimal: 'BigDecimal',
        boolean: 'Boolean',
        string: 'String',
        lob: 'String',
        date: 'LocalDate',
        dateTime: 'LocalDateTime',
        time: 'LocalTime',
    };
    function createCode$3(store) {
        const stringBuffer = [''];
        const { database, tableCase, columnCase } = store.canvasState;
        const tables = orderByNameASC(store.tableState.tables);
        const relationships = store.relationshipState.relationships;
        tables.forEach(table => {
            formatTable$3(table, stringBuffer, database, relationships, tables, tableCase, columnCase);
            stringBuffer.push('');
        });
        return stringBuffer.join('\n');
    }
    function formatTable$3(table, buffer, database, relationships, tables, tableCase, columnCase) {
        const tableName = getNameCase(table.name, tableCase);
        const pkColumns = primaryKeyColumns(table.columns);
        if (pkColumns.length > 1) {
            buffer.push(`@Data`);
            buffer.push(`public class ${getNameCase(`${table.name}Id`, tableCase)} implements Serializable {`);
            const pfkTables = [];
            pkColumns.forEach(column => {
                if (column.ui.pfk) {
                    relationships
                        .filter(relationship => relationship.end.columnIds.includes(column.id))
                        .map(relationship => getData(tables, relationship.start.tableId))
                        .filter(table => table !== null).forEach(table => {
                        if (!pfkTables.some(pfkTable => pfkTable.id === table.id)) {
                            pfkTables.push(table);
                        }
                    });
                }
                else {
                    const columnName = getNameCase(column.name, columnCase);
                    const primitiveType = getPrimitiveType(column.dataType, database);
                    buffer.push(`  private ${convertTypeMap$3[primitiveType]} ${columnName};`);
                }
            });
            pfkTables.forEach(table => {
                buffer.push(`  private ${getNameCase(table.name, tableCase)} ${getNameCase(table.name, columnCase)};`);
            });
            buffer.push(`}`);
        }
        if (table.comment.trim() !== '') {
            buffer.push(`// ${table.comment}`);
        }
        buffer.push(`@Data`);
        buffer.push(`@Entity`);
        if (pkColumns.length > 1) {
            buffer.push(`@IdClass(${getNameCase(`${table.name}Id`, tableCase)}.class)`);
        }
        // if (unique(table.columns)) {
        //   const uqColumns = uniqueColumns(table.columns).map(column => {
        //     return { name: getNameCase(column.name, Case.snakeCase) };
        //   });
        //   buffer.push(`@Table(uniqueConstraints = {`);
        //   buffer.push(`  @UniqueConstraint(`);
        //   buffer.push(`    columnNames={${formatNames(uqColumns, '"')}}`);
        //   buffer.push(`  )`);
        //   buffer.push(`})`);
        // }
        buffer.push(`public class ${tableName} {`);
        table.columns.forEach(column => {
            formatColumn$3(column, buffer, database, columnCase);
        });
        formatRelation(table, buffer, relationships, tables, tableCase, columnCase);
        buffer.push(`}`);
    }
    function formatColumn$3(column, buffer, database, columnCase) {
        if (!column.ui.fk && !column.ui.pfk) {
            const columnName = getNameCase(column.name, columnCase);
            const primitiveType = getPrimitiveType(column.dataType, database);
            if (column.comment.trim() !== '') {
                buffer.push(`  // ${column.comment}`);
            }
            if (column.option.primaryKey) {
                buffer.push(`  @Id`);
                if (column.option.autoIncrement) {
                    buffer.push(`  @GeneratedValue`);
                }
            }
            else if (column.option.notNull) {
                buffer.push(`  @Column(nullable = false)`);
            }
            if (primitiveType === 'lob') {
                buffer.push(`  @Lob`);
            }
            buffer.push(`  private ${convertTypeMap$3[primitiveType]} ${columnName};`);
        }
    }
    function formatRelation(table, buffer, relationships, tables, tableCase, columnCase) {
        relationships
            .filter(relationship => relationship.end.tableId === table.id)
            .forEach(relationship => {
            const startTable = getData(tables, relationship.start.tableId);
            const endColumns = relationship.end.columnIds
                .map(columnId => getData(table.columns, columnId))
                .filter(column => column !== null);
            if (startTable && endColumns.length !== 0) {
                const typeName = getNameCase(startTable.name, tableCase);
                const fieldName = getNameCase(startTable.name, columnCase);
                if (startTable.comment.trim() !== '') {
                    buffer.push(`  // ${startTable.comment}`);
                }
                if (primaryKey(endColumns)) {
                    buffer.push(`  @Id`);
                }
                if (oneRelationshipTypes.includes(relationship.relationshipType)) {
                    buffer.push(`  @OneToOne`);
                }
                else if (nRelationshipTypes.includes(relationship.relationshipType)) {
                    buffer.push(`  @ManyToOne`);
                }
                if (endColumns.length > 1) {
                    buffer.push(`  @JoinColumns(value = {`);
                    endColumns.forEach((column, index) => {
                        buffer.push(`    @JoinColumn(name = "${getNameCase(column.name, 'snakeCase')}")${endColumns.length - 1 > index ? ',' : ''}`);
                    });
                    buffer.push(`  })`);
                }
                else {
                    buffer.push(`  @JoinColumn(name = "${getNameCase(endColumns[0].name, 'snakeCase')}")`);
                }
                buffer.push(`  private ${typeName} ${fieldName};`);
            }
        });
        relationships
            .filter(relationship => relationship.start.tableId === table.id)
            .forEach(relationship => {
            const endTable = getData(tables, relationship.end.tableId);
            if (endTable) {
                const typeName = getNameCase(endTable.name, tableCase);
                const fieldName = getNameCase(endTable.name, columnCase);
                if (endTable.comment.trim() !== '') {
                    buffer.push(`  // ${endTable.comment}`);
                }
                if (oneRelationshipTypes.includes(relationship.relationshipType)) {
                    buffer.push(`  @OneToOne(mappedBy = "${getNameCase(table.name, columnCase)}")`);
                    buffer.push(`  private ${typeName} ${fieldName};`);
                }
                else if (nRelationshipTypes.includes(relationship.relationshipType)) {
                    buffer.push(`  @OneToMany(mappedBy = "${getNameCase(table.name, columnCase)}")`);
                    buffer.push(`  private List<${typeName}> ${getNameCase(`${fieldName}List`, columnCase)} = new ArrayList<>();`);
                }
            }
        });
    }

    const convertTypeMap$2 = {
        int: 'Int',
        long: 'Long',
        float: 'Float',
        double: 'Double',
        decimal: 'BigDecimal',
        boolean: 'Boolean',
        string: 'String',
        lob: 'String',
        date: 'LocalDate',
        dateTime: 'LocalDateTime',
        time: 'LocalTime',
    };
    function createCode$2(store) {
        const stringBuffer = [''];
        const { database, tableCase, columnCase } = store.canvasState;
        const tables = orderByNameASC(store.tableState.tables);
        tables.forEach(table => {
            formatTable$2(table, stringBuffer, database, tableCase, columnCase);
            stringBuffer.push('');
        });
        return stringBuffer.join('\n');
    }
    function formatTable$2(table, buffer, database, tableCase, columnCase) {
        const tableName = getNameCase(table.name, tableCase);
        if (table.comment.trim() !== '') {
            buffer.push(`// ${table.comment}`);
        }
        buffer.push(`class ${tableName} {`);
        table.columns.forEach(column => {
            formatColumn$2(column, buffer, database, columnCase);
        });
        buffer.push(`}`);
    }
    function formatColumn$2(column, buffer, database, columnCase) {
        const columnName = getNameCase(column.name, columnCase);
        const primitiveType = getPrimitiveType(column.dataType, database);
        if (column.comment.trim() !== '') {
            buffer.push(`  // ${column.comment}`);
        }
        if (column.option.notNull &&
            primitiveType !== 'date' &&
            primitiveType !== 'dateTime' &&
            primitiveType !== 'time') {
            buffer.push(`  var ${columnName}: ${convertTypeMap$2[primitiveType]} = ${getDefault(primitiveType)}`);
        }
        else {
            buffer.push(`  var ${columnName}: ${convertTypeMap$2[primitiveType]}? = null`);
        }
    }
    function getDefault(primitiveType) {
        switch (primitiveType) {
            case 'int':
            case 'long':
                return 0;
            case 'float':
                return '0.0f';
            case 'double':
                return '0.0';
            case 'boolean':
                return false;
            case 'string':
            case 'lob':
                return '""';
            case 'decimal':
                return 'BigDecimal.ZERO';
            case 'date':
            case 'dateTime':
            case 'time':
                return null;
        }
    }

    const convertTypeMap$1 = {
        int: 'Int',
        long: 'Long',
        float: 'Float',
        double: 'Double',
        decimal: 'BigDecimal',
        boolean: 'Boolean',
        string: 'String',
        lob: 'String',
        date: 'LocalDate',
        dateTime: 'LocalDateTime',
        time: 'LocalTime',
    };
    function createCode$1(store) {
        const stringBuffer = [''];
        const { database, tableCase, columnCase } = store.canvasState;
        const tables = orderByNameASC(store.tableState.tables);
        tables.forEach(table => {
            formatTable$1(table, stringBuffer, database, tableCase, columnCase);
            stringBuffer.push('');
        });
        return stringBuffer.join('\n');
    }
    function formatTable$1(table, buffer, database, tableCase, columnCase) {
        const tableName = getNameCase(table.name, tableCase);
        if (table.comment.trim() !== '') {
            buffer.push(`// ${table.comment}`);
        }
        buffer.push(`@Data`);
        buffer.push(`case class ${tableName}(`);
        table.columns.forEach((column, idx, array) => {
            var notLastElem = true;
            if (idx === array.length - 1) {
                notLastElem = false;
            }
            formatColumn$1(column, buffer, database, columnCase, notLastElem);
        });
        buffer.push(`)`);
    }
    function formatColumn$1(column, buffer, database, columnCase, addComma) {
        const columnName = getNameCase(column.name, columnCase);
        const primitiveType = getPrimitiveType(column.dataType, database);
        if (column.comment.trim() !== '') {
            buffer.push(` // ${column.comment}`);
        }
        buffer.push(` ${columnName}: ${convertTypeMap$1[primitiveType]}${addComma ? ',' : ''}`);
    }

    const convertTypeMap = {
        int: 'number',
        long: 'number',
        float: 'number',
        double: 'number',
        decimal: 'number',
        boolean: 'boolean',
        string: 'string',
        lob: 'string',
        date: 'string',
        dateTime: 'string',
        time: 'string',
    };
    function createCode(store) {
        const stringBuffer = [''];
        const { database, tableCase, columnCase } = store.canvasState;
        const tables = orderByNameASC(store.tableState.tables);
        tables.forEach(table => {
            formatTable(table, stringBuffer, database, tableCase, columnCase);
            stringBuffer.push('');
        });
        return stringBuffer.join('\n');
    }
    function formatTable(table, buffer, database, tableCase, columnCase) {
        const tableName = getNameCase(table.name, tableCase);
        if (table.comment.trim() !== '') {
            buffer.push(`// ${table.comment}`);
        }
        buffer.push(`export interface ${tableName} {`);
        table.columns.forEach(column => {
            formatColumn(column, buffer, database, columnCase);
        });
        buffer.push(`}`);
    }
    function formatColumn(column, buffer, database, columnCase) {
        const columnName = getNameCase(column.name, columnCase);
        const primitiveType = getPrimitiveType(column.dataType, database);
        if (column.comment.trim() !== '') {
            buffer.push(`  // ${column.comment}`);
        }
        buffer.push(`  ${columnName}: ${convertTypeMap[primitiveType]}${column.option.notNull ? '' : ' | null'};`);
    }

    function createGeneratorCode(store) {
        const { language } = store.canvasState;
        switch (language) {
            case 'GraphQL':
                return createCode$5(store);
            case 'C#':
                return createCode$6(store);
            case 'Java':
                return createCode$4(store);
            case 'Kotlin':
                return createCode$2(store);
            case 'TypeScript':
                return createCode(store);
            case 'JPA':
                return createCode$3(store);
            case 'Scala':
                return createCode$1(store);
        }
        return '';
    }
    function createGeneratorCodeTable(store, table) {
        const stringBuffer = [''];
        const { language, database, tableCase, columnCase } = store.canvasState;
        const { tables } = store.tableState;
        const { relationships } = store.relationshipState;
        switch (language) {
            case 'GraphQL':
                formatTable$5(table, stringBuffer, database, relationships, tables, tableCase, columnCase);
                stringBuffer.push('');
                break;
            case 'C#':
                formatTable$6(table, stringBuffer, database, tableCase, columnCase);
                stringBuffer.push('');
                break;
            case 'Java':
                formatTable$4(table, stringBuffer, database, tableCase, columnCase);
                stringBuffer.push('');
                break;
            case 'Kotlin':
                formatTable$2(table, stringBuffer, database, tableCase, columnCase);
                stringBuffer.push('');
                break;
            case 'TypeScript':
                formatTable(table, stringBuffer, database, tableCase, columnCase);
                stringBuffer.push('');
                break;
            case 'JPA':
                formatTable$3(table, stringBuffer, database, relationships, tables, tableCase, columnCase);
                stringBuffer.push('');
                break;
            case 'Scala':
                formatTable$1(table, stringBuffer, database, tableCase, columnCase);
                stringBuffer.push('');
                break;
        }
        return stringBuffer.join('\n');
    }

    const GeneratorCodeStyle = css `
  .vuerd-generator-code {
    height: 100%;
    white-space: pre;
    box-sizing: border-box;
    overflow: auto;
    font-family: monospace !important;
    outline: none;
  }
`;

    const GeneratorCode = (props, ctx) => {
        const contextRef = useContext$1(ctx);
        const state = observable$1({
            menus: null,
            contextmenuX: 0,
            contextmenuY: 0,
        });
        const { unmountedGroup } = useUnmounted();
        const onContextmenu = (event) => {
            event.preventDefault();
            state.contextmenuX = event.clientX;
            state.contextmenuY = event.clientY;
            state.menus = createGeneratorCodeMenus(contextRef.value);
        };
        const onCloseContextmenu = () => (state.menus = null);
        const onMousedown = () => onCloseContextmenu();
        beforeMount(() => {
            const context = contextRef.value;
            const { store: { canvasState }, eventBus, } = context;
            unmountedGroup.push(watch(canvasState, propName => {
                var _a;
                if (propName !== 'language')
                    return;
                const menue = (_a = state.menus) === null || _a === void 0 ? void 0 : _a.find(menu => menu.name === 'Language');
                if (!menue)
                    return;
                menue.children = createLanguageMenus(context);
            }), watch(canvasState, propName => {
                var _a;
                if (propName !== 'highlightTheme')
                    return;
                const menue = (_a = state.menus) === null || _a === void 0 ? void 0 : _a.find(menu => menu.name === 'Highlight Theme');
                if (!menue)
                    return;
                menue.children = createHighlightThemeMenus(context);
            }), watch(canvasState, propName => {
                var _a;
                if (propName !== 'tableCase')
                    return;
                const menue = (_a = state.menus) === null || _a === void 0 ? void 0 : _a.find(menu => menu.name === 'Table Name Case');
                if (!menue)
                    return;
                menue.children = createTableNameCaseMenus(context);
            }), watch(canvasState, propName => {
                var _a;
                if (propName !== 'columnCase')
                    return;
                const menue = (_a = state.menus) === null || _a === void 0 ? void 0 : _a.find(menu => menu.name === 'Column Name Case');
                if (!menue)
                    return;
                menue.children = createColumnNameCaseMenus(context);
            }), eventBus.on(Bus.Contextmenu.close).subscribe(onCloseContextmenu));
        });
        return () => {
            const { store } = contextRef.value;
            const { canvasState: { highlightTheme, language }, } = store;
            const code = props.mode === 'all' || !props.table
                ? createGeneratorCode(store)
                : createGeneratorCodeTable(store, props.table);
            const codeHTML = core.highlight(code, {
                language: languageMap[language],
            }).value;
            return html `
      <style type="text/css">
        ${highlightThemeMap[highlightTheme]}
      </style>
      <div
        class="vuerd-generator-code vuerd-scrollbar hljs"
        contenteditable="true"
        spellcheck="false"
        @mousedown=${onMousedown}
        @contextmenu=${onContextmenu}
      >
        ${unsafeHTML(codeHTML)}
        ${state.menus
            ? html `
              <vuerd-contextmenu
                .menus=${state.menus}
                .x=${state.contextmenuX}
                .y=${state.contextmenuY}
                @close=${onCloseContextmenu}
              >
              </vuerd-contextmenu>
            `
            : null}
      </div>
    `;
        };
    };
    defineComponent('vuerd-generator-code', {
        observedProps: [
            {
                name: 'table',
                default: null,
            },
            {
                name: 'mode',
                default: 'all',
            },
        ],
        styleMap: {
            width: '100%',
            height: '100%',
        },
        style: [GeneratorCodeStyle, ScrollbarStyle].join(''),
        render: GeneratorCode,
    });

    const findIndex$1 = findIndex$5(propEq$1('active', true));
    function useColumnHint(props, ctx) {
        const contextRef = useContext$1(ctx);
        const { unmountedGroup } = useUnmounted();
        const state = observable$1({
            value: '',
            hints: [],
            isFilter: true,
            focus: false,
        });
        const inputRef = query('input');
        const getActiveIndex = () => findIndex$1(state.hints);
        const setHints = () => {
            if (!state.isFilter)
                return;
            const columns = props.table.columns;
            state.hints =
                state.value.trim().length < 1
                    ? []
                    : columns
                        .filter(column => column.name.toLowerCase().indexOf(state.value.toLowerCase()) !==
                        -1)
                        .map(column => {
                        return {
                            id: column.id,
                            name: column.name,
                            html: markToHTML('vuerd-index-add-column-hint-mark', column.name, state.value),
                            active: false,
                        };
                    });
        };
        const activeEnd = () => {
            state.hints.forEach(hint => (hint.active = false));
        };
        const onSelectHint = (hint) => {
            const { store } = contextRef.value;
            const { indexes } = store.tableState;
            const columns = props.table.columns;
            activeEnd();
            state.isFilter = false;
            lastCursorFocus(inputRef.value);
            const indexModel = getData(indexes, props.indexId);
            const targetColumn = getData(columns, hint.id);
            if (targetColumn &&
                indexModel &&
                !indexModel.columns.some(column => column.id === targetColumn.id)) {
                store.dispatch(addIndexColumn(props.indexId, targetColumn.id));
            }
        };
        const onArrowUp = (event) => {
            state.hints.length !== 0 && event.preventDefault();
            const index = getActiveIndex();
            if (index > 0) {
                state.hints[index].active = false;
                state.hints[index - 1].active = true;
            }
            else if (state.hints.length) {
                index === 0 && (state.hints[index].active = false);
                state.hints[state.hints.length - 1].active = true;
            }
        };
        const onArrowDown = (event) => {
            state.hints.length !== 0 && event.preventDefault();
            const index = getActiveIndex();
            if (index !== -1 && index !== state.hints.length - 1) {
                state.hints[index].active = false;
                state.hints[index + 1].active = true;
            }
            else if (state.hints.length) {
                index === state.hints.length - 1 && (state.hints[index].active = false);
                state.hints[0].active = true;
            }
        };
        const onArrowLeft = () => activeEnd();
        const onArrowRight = (event) => {
            const index = getActiveIndex();
            if (index < 0)
                return;
            event.preventDefault();
            const { store } = contextRef.value;
            const { indexes } = store.tableState;
            const columns = props.table.columns;
            state.isFilter = false;
            const indexModel = getData(indexes, props.indexId);
            const targetColumn = getData(columns, state.hints[index].id);
            if (targetColumn &&
                indexModel &&
                !indexModel.columns.some(column => column.id === targetColumn.id)) {
                store.dispatch(addIndexColumn(props.indexId, targetColumn.id));
            }
        };
        const arrowMap = {
            ArrowUp: onArrowUp,
            ArrowDown: onArrowDown,
            ArrowLeft: onArrowLeft,
            ArrowRight: onArrowRight,
        };
        const onKeydown = (event) => {
            switch (event.key) {
                case 'ArrowUp':
                case 'ArrowDown':
                case 'ArrowLeft':
                case 'ArrowRight':
                    arrowMap[event.key](event);
                    break;
            }
        };
        const onInput = (event) => {
            const input = event.target;
            state.value = input.value;
            state.isFilter = true;
        };
        beforeMount(() => unmountedGroup.push(watch(state, propName => {
            if (propName !== 'value')
                return;
            setHints();
        })));
        return {
            hintState: state,
            onSelectHint,
            onKeydown,
            onInput,
        };
    }

    const hintTpl = (props, state) => html `
  <ul class="vuerd-index-add-column-list">
    ${repeat(state.hints, hint => hint.id, hint => {
    return html `
          <li
            class=${classMap({
        'vuerd-index-add-column-hint': true,
        active: hint.active,
    })}
            @click=${() => props.onSelectHint(hint)}
          >
            ${unsafeHTML(hint.html)}
          </li>
        `;
})}
  </ul>
`;

    const IndexAddColumn = (props, ctx) => {
        const contextRef = useContext$1(ctx);
        const { hintState, onSelectHint, onKeydown, onInput } = useColumnHint(props, ctx);
        useFlipAnimation(ctx, '.vuerd-index-add-column-hint', 'vuerd-index-add-column-hint-move');
        const onFocus = () => {
            hintState.focus = true;
        };
        const onBlur = () => {
            hintState.focus = false;
            setTimeout(() => {
                if (hintState.focus)
                    return;
                hintState.hints = [];
            }, 200);
        };
        return () => {
            const { store: { editorState: { readonly }, }, } = contextRef.value;
            return html `
      <div class="vuerd-index-add-column">
        <input
          style="width: 80px;"
          type="text"
          placeholder="add column"
          spellcheck="false"
          ?disabled=${readonly}
          .value=${hintState.value}
          @keydown=${onKeydown}
          @input=${onInput}
          @focus=${onFocus}
          @blur=${onBlur}
        />
        ${hintTpl({ onSelectHint }, hintState)}
      </div>
    `;
        };
    };
    defineComponent('vuerd-index-add-column', {
        observedProps: ['table', 'indexId'],
        shadow: false,
        render: IndexAddColumn,
    });

    const IndexColumn = (props, ctx) => {
        const contextRef = useContext$1(ctx);
        const state = observable$1({ currentColumnId: '' });
        const columnsRef = queryAll('.vuerd-index-column');
        const columnNamesRef = queryAll('.vuerd-index-column-name');
        const flipAnimation = new FlipAnimation(ctx.shadowRoot ? ctx.shadowRoot : ctx, '.vuerd-index-column', 'vuerd-index-column-move');
        const { unmountedGroup } = useUnmounted();
        const { resetTooltip } = useTooltip(['.vuerd-index-column-button'], ctx);
        const getIndex = () => {
            const { indexes } = contextRef.value.store.tableState;
            const index = getData(indexes, props.indexId);
            if (!index)
                return null;
            return {
                id: index.id,
                columns: index.columns
                    .map(column => {
                    const data = getData(props.table.columns, column.id);
                    if (!data)
                        return null;
                    const newData = cloneDeep(data);
                    newData.orderType = column.orderType;
                    return newData;
                })
                    .filter(column => !!column),
            };
        };
        const onChangeColumnOrderType = (column) => {
            const { store } = contextRef.value;
            let value = 'ASC';
            if (column.orderType === 'ASC') {
                value = 'DESC';
            }
            store.dispatch(changeIndexColumnOrderType(props.indexId, column.id, value));
        };
        const onRemoveColumn = (column) => {
            const { store } = contextRef.value;
            store.dispatch(removeIndexColumn(props.indexId, column.id));
        };
        const onMoveIndexColumn = (currentId, targetId) => {
            const { store } = contextRef.value;
            if (currentId === targetId)
                return;
            flipAnimation.snapshot();
            store.dispatch(moveIndexColumn(props.indexId, currentId, targetId));
        };
        const onDragstart = (currentId) => {
            state.currentColumnId = currentId;
            columnNamesRef.value.forEach(el => el.classList.add('none-hover'));
            fromShadowDraggable(columnsRef.value).subscribe({
                next: id => onMoveIndexColumn(currentId, id),
                complete: () => {
                    state.currentColumnId = '';
                    columnNamesRef.value.forEach(el => el.classList.remove('none-hover'));
                },
            });
        };
        beforeMount(() => {
            const { indexes } = contextRef.value.store.tableState;
            const index = getData(indexes, props.indexId);
            unmountedGroup.push(watch(index.columns, () => resetTooltip()));
        });
        updated(() => flipAnimation.play());
        return () => {
            const index = getIndex();
            return index
                ? html `
          ${repeat(index.columns, column => column.id, column => html `
              <div
                class=${classMap({
                'vuerd-index-column': true,
                draggable: state.currentColumnId === column.id,
            })}
                data-id=${column.id}
                draggable="true"
                @dragstart=${() => onDragstart(column.id)}
              >
                <div class="vuerd-index-column-name">${column.name}</div>
                <div
                  class="vuerd-index-column-order"
                  @click=${() => onChangeColumnOrderType(column)}
                >
                  ${column.orderType}
                </div>
                <div style="display: inline-block;">
                  <vuerd-icon
                    class="vuerd-button vuerd-index-column-button"
                    data-tippy-content="Remove Column"
                    name="times"
                    size="9"
                    @click=${() => onRemoveColumn(column)}
                  ></vuerd-icon>
                </div>
              </div>
            `)}
        `
                : null;
        };
    };
    defineComponent('vuerd-index-column', {
        observedProps: ['table', 'indexId'],
        shadow: false,
        render: IndexColumn,
    });

    const IndexesStyle = css `
  .vuerd-indexes {
    display: flex;
    flex-direction: column;
    height: 100%;
  }

  .vuerd-indexes input {
    display: inline-flex;
    vertical-align: middle;
    align-items: center;
    margin-right: ${SIZE_COLUMN_MARGIN_RIGHT}px;
    color: var(--vuerd-color-font-active);
    background-color: var(--vuerd-color-contextmenu);
    outline: none;
    border: none;
    opacity: 0.9;
    padding: 1px 0 1px 0;
    height: 23.5px;
    font-size: ${SIZE_FONT}px;
    font-family: var(--vuerd-font-family);
    border-bottom: solid #fff0 1.5px;
  }
  .vuerd-indexes input:focus {
    border-bottom: solid var(--vuerd-color-edit) 1.5px;
  }
  .vuerd-index {
    fill: #fff0;
    color: var(--vuerd-color-font-active);
  }
  .vuerd-index:hover,
  .vuerd-index-column:hover {
    fill: var(--vuerd-color-font);
  }
  .vuerd-index-column {
    fill: #fff0;
    display: inline-block;
  }
  .vuerd-index-column.draggable {
    opacity: 0.5;
  }
  .vuerd-index-unique {
    display: inline-block;
    cursor: pointer;
    color: var(--vuerd-color-font-placeholder);
  }
  .vuerd-index-unique.checked {
    color: var(--vuerd-color-font-active);
  }
  .vuerd-index-column-name {
    display: inline-block;
    cursor: move;
    padding: 5px;
  }
  .vuerd-index-column-name:hover {
    background-color: var(--vuerd-color-contextmenu-active);
  }
  .vuerd-index-column-name.none-hover:hover {
    background-color: var(--vuerd-color-contextmenu);
  }
  .vuerd-index-column-order {
    display: inline-block;
    cursor: pointer;
  }
  .vuerd-index-add-column {
    display: inline-block;
    position: relative;
  }
  .vuerd-index-add-column-list {
    position: absolute;
    top: 27px;
    left: 0;
    z-index: 100;
    color: var(--vuerd-color-font);
    background-color: var(--vuerd-color-contextmenu);
    opacity: 0.9;
    list-style: none;
    padding: 0;
    margin: 0;
  }
  .vuerd-index-add-column-list > li {
    padding: 5px;
    cursor: pointer;
    font-size: ${SIZE_FONT}px;
  }
  .vuerd-index-add-column-list > li:hover,
  .vuerd-index-add-column-hint.active {
    color: var(--vuerd-color-font-active);
    background-color: var(--vuerd-color-contextmenu-active);
  }
  .vuerd-index-add-column-list > li:hover .vuerd-index-add-column-hint-mark,
  .vuerd-index-add-column-hint.active .vuerd-index-add-column-hint-mark {
    color: var(--vuerd-color-font-active);
  }
  /* animation flip */
  .vuerd-index-add-column-hint-move {
    transition: transform 0.2s;
  }
  .vuerd-index-column-move {
    transition: transform 0.3s;
  }

  .vuerd-index-add-column-hint-mark {
    color: var(--vuerd-color-edit);
  }
`;

    const IndexStyle$3 = [DefaultStyle, IndexesStyle].join('');

    const Indexes = (props, ctx) => {
        const contextRef = useContext$1(ctx);
        const { resetTooltip } = useTooltip(['.vuerd-indexes-button', '.vuerd-index-unique'], ctx);
        const { unmountedGroup } = useUnmounted();
        const getIndexes = () => {
            const { indexes } = contextRef.value.store.tableState;
            return indexes.filter(index => { var _a; return index.tableId === ((_a = props.table) === null || _a === void 0 ? void 0 : _a.id); });
        };
        const onAddIndex = () => {
            if (!props.table)
                return;
            const { store } = contextRef.value;
            store.dispatch(addIndex(props.table.id));
        };
        const onRemoveIndex = (index) => {
            const { store } = contextRef.value;
            store.dispatch(removeIndex([index.id]));
        };
        const onChangeIndexUnique = (index) => {
            const { store } = contextRef.value;
            store.dispatch(changeIndexUnique(index.id, !index.unique));
        };
        const onInput = (event, index) => {
            const { store } = contextRef.value;
            const input = event.target;
            store.dispatch(changeIndexName(index.id, input.value));
        };
        beforeMount(() => {
            const { indexes } = contextRef.value.store.tableState;
            unmountedGroup.push(watch(indexes, () => resetTooltip()));
        });
        return () => {
            const { store: { editorState: { readonly }, }, } = contextRef.value;
            const { table } = props;
            const indexes = getIndexes();
            return table
                ? html `
          <div class="vuerd-indexes">
            <div style="display: inline-block;">
              <vuerd-icon
                class="vuerd-button vuerd-indexes-button"
                data-tippy-content="New Index"
                name="plus"
                size="12"
                @click=${onAddIndex}
              ></vuerd-icon>
            </div>
            <div class="vuerd-scrollbar" style="height: 100%; overflow: auto;">
              ${repeat(indexes, index => index.id, index => html `
                  <div class="vuerd-index">
                    <div style="display: inline-block;">
                      <vuerd-icon
                        class="vuerd-button vuerd-indexes-button"
                        data-tippy-content="Remove Index"
                        name="times"
                        size="9"
                        @click=${() => onRemoveIndex(index)}
                      ></vuerd-icon>
                    </div>
                    <div
                      class=${classMap({
                'vuerd-index-unique': true,
                checked: index.unique,
            })}
                      style="width: 22px;"
                      data-tippy-content="Unique"
                      @click=${() => onChangeIndexUnique(index)}
                    >
                      UQ
                    </div>
                    <input
                      type="text"
                      placeholder="index name"
                      spellcheck="false"
                      ?disabled=${readonly}
                      .value=${index.name}
                      @input=${(event) => onInput(event, index)}
                    />
                    <vuerd-index-add-column
                      .table=${table}
                      .indexId=${index.id}
                    ></vuerd-index-add-column>
                    <vuerd-index-column
                      .table=${table}
                      .indexId=${index.id}
                      @dragenter=${onPreventDefault}
                      @dragover=${onPreventDefault}
                    ></vuerd-index-column>
                  </div>
                `)}
            </div>
          </div>
        `
                : null;
        };
    };
    defineComponent('vuerd-indexes', {
        observedProps: [
            {
                name: 'table',
                default: null,
            },
        ],
        styleMap: {
            width: '100%',
            height: '100%',
        },
        style: IndexStyle$3,
        render: Indexes,
    });

    const tabs = [
        {
            name: 'Indexes',
            type: 'indexes',
        },
        {
            name: 'SQL DDL',
            type: 'SQL',
        },
        {
            name: 'Generator Code',
            type: 'GeneratorCode',
        },
    ];
    const TablePropertiesDrawer = (props, ctx) => {
        const state = observable$1({
            tabType: 'indexes',
        });
        const contextRef = useContext$1(ctx);
        const onClose = () => ctx.dispatchEvent(new CustomEvent('close'));
        const onChangeTab = (tabType) => (state.tabType = tabType);
        return () => {
            var _a;
            const { tables } = contextRef.value.store.tableState;
            const table = getData(tables, props.tableId);
            return html `
      <vuerd-drawer
        .name=${`Table Properties "${(_a = table === null || table === void 0 ? void 0 : table.name) !== null && _a !== void 0 ? _a : ''}"`}
        .width=${props.width}
        .visible=${props.visible}
        @close=${onClose}
      >
        <div class="vuerd-table-properties">
          <ul class="vuerd-table-properties-tab">
            ${tabs.map(tab => html `
                  <li
                    class=${classMap({
            active: tab.type === state.tabType,
        })}
                    @click=${() => onChangeTab(tab.type)}
                  >
                    ${tab.name}
                  </li>
                `)}
          </ul>
          <div class="vuerd-table-properties-body">
            ${table
            ? state.tabType === 'indexes'
                ? html `<vuerd-indexes .table=${table}></vuerd-indexes>`
                : state.tabType === 'SQL'
                    ? html `<vuerd-sql-ddl
                    mode="table"
                    .table=${table}
                  ></vuerd-sql-ddl>`
                    : state.tabType === 'GeneratorCode'
                        ? html `
                    <vuerd-generator-code
                      mode="table"
                      .table=${table}
                    ></vuerd-generator-code>
                  `
                        : null
            : null}
          </div>
        </div>
      </vuerd-drawer>
    `;
        };
    };
    defineComponent('vuerd-table-properties-drawer', {
        observedProps: ['width', 'visible', 'tableId'],
        shadow: false,
        render: TablePropertiesDrawer,
    });

    const ToastBarStyle = css `
  .vuerd-toast-bar {
    position: absolute;
    z-index: 9999999;
    right: 50px;
    bottom: 50px;
    display: flex;
    flex-direction: column;
  }

  .vuerd-toast-bar-container {
    padding: 8px 16px 16px 16px;
    margin-top: 20px;
    width: 200px;
    box-shadow: 0 0 6px 0 black;
    background-color: var(--vuerd-color-contextmenu);
    color: var(--vuerd-color-font);
    fill: var(--vuerd-color-font);
    animation: showMove 0.3s ease;
  }

  .vuerd-toast-bar-header {
    display: flex;
    margin-bottom: 10px;
  }

  .vuerd-toast-bar-body {
  }

  .vuerd-btn {
    color: var(--vuerd-color-font-active);
    background-color: var(--vuerd-color-contextmenu);
    cursor: pointer;
    padding: 5px;
    display: inline-block;
  }

  .vuerd-btn:hover {
    background-color: var(--vuerd-color-contextmenu-active);
  }

  .vuerd-button {
    cursor: pointer;
    margin-left: auto;
  }

  .vuerd-button:hover {
    fill: var(--vuerd-color-font-active);
  }

  /* animation flip */
  .vuerd-toast-bar-container-move {
    transition: transform 0.3s;
  }

  @keyframes showMove {
    0% {
      transform: translateY(30px);
      opacity: 0;
    }
    100% {
      transform: translateY(0);
      opacity: 1;
    }
  }
`;

    const DEFAULT_TIME = 1000 * 5;
    const ToastBar = (props, ctx) => {
        const contextRef = useContext$1(ctx);
        const { unmountedGroup } = useUnmounted();
        const state = observable$1({
            toastBars: [],
        });
        useFlipAnimation(ctx, '.vuerd-toast-bar-container', 'vuerd-toast-bar-container-move');
        const onClose = (toastBar) => {
            const index = getIndex(state.toastBars, toastBar.id);
            index !== -1 && state.toastBars.splice(index, 1);
        };
        const addToastBar = (options) => {
            const toastBar = Object.assign({
                close: new Promise(resolve => setTimeout(resolve, DEFAULT_TIME)),
            }, options, { id: v4() });
            state.toastBars.push(toastBar);
            toastBar.close.finally(() => onClose(toastBar));
        };
        beforeMount(() => {
            const { eventBus } = contextRef.value;
            unmountedGroup.push(eventBus.on(Bus.ToastBar.add).subscribe(addToastBar));
        });
        return () => html `
    <div class="vuerd-toast-bar">
      ${repeat(state.toastBars, toastBar => toastBar.id, toastBar => html `
          <div class="vuerd-toast-bar-container">
            <div class="vuerd-toast-bar-header">
              ${toastBar.headerTpl}
              <vuerd-icon
                class="vuerd-button"
                name="times"
                size="12"
                @click=${() => onClose(toastBar)}
              ></vuerd-icon>
            </div>
            <div class="vuerd-toast-bar-body">${toastBar.bodyTpl}</div>
          </div>
        `)}
    </div>
  `;
    };
    defineComponent('vuerd-toast-bar', {
        style: ToastBarStyle,
        render: ToastBar,
    });

    const AlertStyle = css `
  @keyframes alert {
    0% {
      transform: translateY(-50px);
      opacity: 0;
    }
    100% {
      transform: translateY(0);
      opacity: 100;
    }
  }

  .vuerd-alert {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
  }

  .vuerd-alert-header {
    width: 100%;
  }

  .vuerd-alert > .vuerd-alert-message {
    margin-bottom: 10px;
  }

  .vuerd-alert-message {
    word-break: break-all;
    margin: 10px 0;
  }

  .vuerd-button {
    fill: var(--vuerd-color-font);
    float: right;
  }

  .vuerd-button:hover {
    fill: var(--vuerd-color-font-active);
    cursor: pointer;
  }
`;
    defineComponent('vuerd-alert', {
        shadow: false,
        observedProps: ['message', 'onClose', 'visible'],
        styleMap: {
            width: '200px',
            position: 'absolute',
            color: 'var(--vuerd-color-font-active)',
            backgroundColor: 'var(--vuerd-color-contextmenu)',
            margin: '10px',
            padding: '8px',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            boxShadow: '0 1px 6px var(--vuerd-color-minimap-shadow)',
            left: '50%',
            marginLeft: '-100px',
            marginTop: '40px',
            animation: 'alert 1s ease forwards',
        },
        style: AlertStyle,
        render(props, ctx) {
            const onClose = (e) => {
                e.preventDefault();
                props.onClose();
            };
            return () => html `
      <div class="vuerd-alert">
        <div class="vuerd-alert-header">
          <vuerd-icon
            class="vuerd-button"
            name="times"
            size="12"
            @click=${(e) => onClose(e)}
          ></vuerd-icon>
        </div>
        <span class="vuerd-alert-message"> ${props.message} </span>
      </div>
    `;
        },
    });

    function useAlert() {
        var timer = null;
        const state = observable$1({
            message: '',
            visible: false,
        });
        const showAlert = (message) => {
            state.message = message;
            state.visible = true;
            if (timer)
                clearTimeout(timer);
            timer = setTimeout(() => {
                state.visible = false;
                timer = null;
            }, 6000);
        };
        const onClose = () => {
            state.visible = false;
        };
        return {
            showAlert,
            alertTpl() {
                return state.visible
                    ? html `
            <vuerd-alert
              .message=${state.message}
              .onClose=${onClose}
            ></vuerd-alert>
          `
                    : null;
            },
        };
    }

    function useERDEditorDrawer(props, { eventBus, store }) {
        const state = observable$1({
            help: false,
            setting: false,
            tableProperties: false,
            tree: false,
        });
        const { unmountedGroup } = useUnmounted();
        let tableId = '';
        const createOpen = (key) => () => {
            Object.keys(state).forEach(stateKey => {
                if (stateKey === key)
                    return;
                state[stateKey] = false;
            });
            store.dispatch(findActiveEnd(), filterActiveEnd());
            state[key] = !state[key];
        };
        const createClose = (key) => () => (state[key] = false);
        const openHelp = createOpen('help');
        const closeHelp = createClose('help');
        const openSetting = createOpen('setting');
        const closeSetting = createClose('setting');
        const openTableProperties = createOpen('tableProperties');
        const closeTableProperties = createClose('tableProperties');
        const openTree = createOpen('tree');
        const closeTree = createClose('tree');
        const closeDrawer = () => {
            if (state.tableProperties && tableId) {
                store.dispatch(selectTable$(store, false, tableId));
            }
            closeHelp();
            closeSetting();
            closeTableProperties();
            closeTree();
            tableId = '';
        };
        beforeMount(() => unmountedGroup.push(eventBus.on(Bus.Drawer.openTableProperties).subscribe(data => {
            store.dispatch(selectEndMemo(), drawEndRelationship(), selectEndTable$());
            tableId = data.tableId;
            openTableProperties();
        }), eventBus.on(Bus.Drawer.close).subscribe(closeDrawer)));
        return {
            drawerTpl: () => html `
      <vuerd-help-drawer
        .width=${props.width}
        .visible=${state.help}
        @close=${closeHelp}
      ></vuerd-help-drawer>
      <vuerd-setting-drawer
        .width=${props.width}
        .visible=${state.setting}
        @close=${closeSetting}
      ></vuerd-setting-drawer>
      <vuerd-tree-drawer
        .width=${props.width}
        .visible=${state.tree}
        @close=${closeTree}
      ></vuerd-tree-drawer>
      <vuerd-table-properties-drawer
        .width=${props.width}
        .visible=${state.tableProperties}
        .tableId=${tableId}
        @close=${closeTableProperties}
      >
      </vuerd-table-properties-drawer>
    `,
            closeDrawer,
            openHelp,
            closeHelp,
            openSetting,
            closeSetting,
            openTableProperties,
            closeTableProperties,
            openTree,
            closeTree,
        };
    }

    function useERDEditorElement(context, ctx, { setFocus, }) {
        const { store, helper, eventBus } = context;
        const { editorState } = store;
        const { unmountedGroup } = useUnmounted();
        Object.defineProperty(ctx, 'value', {
            get() {
                const { store } = context;
                return createJsonStringify(store);
            },
            set(json) {
                const { store } = context;
                isString$2(json) && json.trim()
                    ? store.dispatch(loadJson$(json))
                    : store.dispatch(clear());
            },
        });
        ctx.focus = () => {
            helper.focus();
            setFocus();
        };
        ctx.blur = () => {
            helper.blur();
            setFocus();
        };
        ctx.clear = () => {
            store.dispatch(clear());
        };
        ctx.initLoadJson = (json) => {
            if (isString$2(json) && json.trim()) {
                store.dispatch(initLoadJson$(json));
            }
        };
        ctx.loadSQLDDL = (sql) => {
            if (isString$2(sql) && sql.trim()) {
                const statements = DDLParser(sql);
                // @ts-ignore
                const json = createJson(statements, helper, store.canvasState.database);
                store.dispatch(loadJson$(json), sortTable());
            }
        };
        ctx.loadLiquibase = (data) => {
            loadLiquibaseChangelog(context, data, 'postgresql');
        };
        ctx.getSQLDDL = (database) => {
            return database && databaseList.includes(database)
                ? createDDL(store, database)
                : createDDL(store);
        };
        ctx.setTheme = (theme) => loadTheme(context.theme, theme);
        ctx.setKeymap = (keymap) => loadKeymap(context.keymap, keymap);
        ctx.extension = (config) => {
            isArray$4(config.panels) &&
                editorState.panels.push(...config.panels);
            isArray$4(config.excludePanel) &&
                (editorState.excludePanel = config.excludePanel);
        };
        eventBus.on(Bus.Liquibase.progress).subscribe(message => ctx.dispatchEvent(new CustomEvent('liquibase-progress', {
            detail: message,
        })));
        eventBus
            .on(Bus.Liquibase.progressEnd)
            .subscribe(() => ctx.dispatchEvent(new CustomEvent('liquibase-progress-end')));
        const emitChange = () => editorState.readonly || ctx.dispatchEvent(new CustomEvent('change'));
        beforeMount(() => unmountedGroup.push(store.change$.subscribe(emitChange), eventBus.on(Bus.Editor.change).subscribe(emitChange)));
    }

    const FOCUS_TIME = 50;
    function useERDEditorGhost({ helper, globalEvent: { moveStart$ } }, ctx) {
        const editorRef = query('.vuerd-editor');
        const ghostTextRef = query('.vuerd-ghost-text-helper');
        const ghostInputRef = query('.vuerd-ghost-focus-helper');
        const state = observable$1({ focus: false });
        const { unmountedGroup } = useUnmounted();
        let timerId = null;
        const setFocus = () => {
            state.focus = document.activeElement === ctx && document.hasFocus();
        };
        const onFocus = () => {
            setTimeout(() => {
                document.activeElement !== ctx && helper.focus();
                setFocus();
            }, 0);
        };
        mounted(() => {
            helper.setGhostText(ghostTextRef.value);
            helper.setGhostInput(ghostInputRef.value);
            helper.focus();
            setFocus();
            timerId = setInterval(() => setFocus(), 200);
            unmountedGroup.push(merge(fromEvent(editorRef.value, 'mousedown'), fromEvent(editorRef.value, 'touchstart'), fromEvent(editorRef.value, 'vuerd-contextmenu-mousedown'), fromEvent(editorRef.value, 'vuerd-contextmenu-touchstart'), fromEvent(editorRef.value, 'vuerd-input-blur'))
                .pipe(throttleTime(FOCUS_TIME))
                .subscribe(onFocus), moveStart$
                .pipe(throttleTime(FOCUS_TIME))
                .subscribe(() => setTimeout(setFocus, 0)), () => clearInterval(timerId));
        });
        return {
            ghostTpl: html `
      <input class="vuerd-ghost-focus-helper" type="text" />
      <span class="vuerd-ghost-text-helper"></span>
    `,
            ghostState: state,
            setFocus,
            onFocus,
        };
    }

    function usePanelView(props, { store: { editorState, canvasState } }) {
        const state = observable$1({ count: 0 });
        const data = {
            isPanel: false,
            canvasType: '',
        };
        const hasPanel = () => {
            const canvasType = canvasState.canvasType;
            const panels = [...contextPanelConfig.panels, ...editorState.panels].filter(panel => !isRegExp(contextPanelConfig.exclude, panel.key) &&
                !isRegExp(editorState.excludePanel, panel.key));
            return (canvasType !== 'ERD' && panels.some(panel => panel.key === canvasType));
        };
        const renderPanel = () => queueMicrotask(() => {
            data.isPanel = true;
            state.count++;
        });
        beforeFirstUpdate(() => state.count);
        beforeUpdate(() => state.count);
        return {
            hasPanel,
            panelTpl() {
                const width = props.width;
                const height = props.height - SIZE_MENUBAR_HEIGHT;
                const canvasType = canvasState.canvasType;
                const panels = [
                    ...contextPanelConfig.panels,
                    ...editorState.panels,
                ].filter(panel => !isRegExp(contextPanelConfig.exclude, panel.key) &&
                    !isRegExp(editorState.excludePanel, panel.key));
                const isPanel = hasPanel();
                data.isPanel = isPanel;
                if (isPanel && data.canvasType != canvasType) {
                    data.isPanel = false;
                    renderPanel();
                }
                data.canvasType = canvasType;
                return data.isPanel
                    ? html `
            <vuerd-panel-view
              .width=${width}
              .height=${height}
              .panel=${panels.find(panel => panel.key === canvasType)}
            ></vuerd-panel-view>
          `
                    : null;
            },
        };
    }

    const PromptStyle = css `
  .vuerd-prompt {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
  }

  .vuerd-prompt-header {
    width: 100%;
  }

  .vuerd-prompt > .vuerd-prompt-message,
  .vuerd-prompt > .vuerd-prompt-input {
    margin-bottom: 10px;
  }

  .vuerd-prompt-message {
    word-break: break-all;
    margin: 10px 0;
  }

  .vuerd-button {
    fill: var(--vuerd-color-font);
    float: right;
  }

  .vuerd-button:hover {
    fill: var(--vuerd-color-font-active);
    cursor: pointer;
  }

  .vuerd-prompt-button {
    box-sizing: border-box;
    padding: 5px;
    display: inline-block;
    cursor: pointer;
    fill: var(--vuerd-color-font);
  }

  .vuerd-prompt-button:hover {
    color: var(--vuerd-color-font-active);
    background-color: var(--vuerd-color-contextmenu-active);
    fill: var(--vuerd-color-font-active);
  }
`;
    defineComponent('vuerd-prompt', {
        shadow: false,
        observedProps: ['prompt', 'onSubmit', 'visible'],
        styleMap: {
            width: '200px',
            position: 'absolute',
            color: 'var(--vuerd-color-font-active)',
            backgroundColor: 'var(--vuerd-color-contextmenu)',
            margin: '10px',
            padding: '8px',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            boxShadow: '0 1px 6px var(--vuerd-color-minimap-shadow)',
            left: '50%',
            marginLeft: '-100px',
            marginTop: '40px',
        },
        style: PromptStyle,
        render(props, ctx) {
            const state = observable$1({ input: '' });
            const onInput = (event) => {
                const input = event.target;
                state.input = input.value;
            };
            const onSubmit = (e, cancel) => {
                e.preventDefault();
                props.onSubmit(cancel ? '' : state.input.trim());
                state.input = '';
            };
            return () => html `
      <div class="vuerd-prompt">
        <div class="vuerd-prompt-header">
          <vuerd-icon
            class="vuerd-button"
            name="times"
            size="12"
            @click=${(e) => onSubmit(e, true)}
          ></vuerd-icon>
        </div>
        <span class="vuerd-prompt-message"> ${props.prompt} </span>
        <vuerd-input
          .width=${170}
          .edit=${true}
          .value=${state.input}
          .placeholder=${'unknown'}
          class="vuerd-prompt-input"
          @input=${onInput}
          @keyup-enter=${onSubmit}
        ></vuerd-input>
        <div class="vuerd-prompt-button" @click=${onSubmit}>Confirm</div>
      </div>
    `;
        },
    });

    function usePrompt() {
        const state = observable$1({
            prompt: '',
            callback: (reply) => { },
            visible: false,
        });
        const showPrompt = (prompt, callback) => {
            state.prompt = prompt;
            state.callback = callback;
            state.visible = true;
        };
        return {
            showPrompt,
            promptTpl() {
                return state.visible
                    ? html `
            <vuerd-prompt
              .prompt=${state.prompt}
              .onSubmit=${(message) => {
                    state.visible = false;
                    state.callback(message);
                }}
            ></vuerd-prompt>
          `
                    : null;
            },
        };
    }

    const ignoreEnterProcess = (source$) => new Observable(subscriber => source$
        .pipe(groupBy(event => event.code === 'Enter'), mergeMap(group$ => group$.key
        ? group$.pipe(filter$1(event => event.key !== 'Process'), throttleTime(100))
        : group$))
        .subscribe(subscriber));

    /**
     * https://github.com/easylogic/colorpicker
     */
    const ColorPicker = css `
  /* easylogic-colorpicker */
  .easylogic-colorpicker {
    position: relative;
    width: 224px;
    z-index: 1000;
    display: inline-block;
    border: 1px solid rgba(0, 0, 0, 0.2);
    background-color: #fff;
    border-radius: 3px;
    -webkit-box-shadow: 0 0px 10px 2px rgba(0, 0, 0, 0.12);
    box-shadow: 0 0px 10px 2px rgba(0, 0, 0, 0.12);
    outline: none;
    /* theme */
  }
  .easylogic-colorpicker > .arrow {
    position: absolute;
    top: -10px;
    left: 7px;
    width: 0;
    height: 0;
    border-left: 10px solid transparent;
    border-right: 10px solid transparent;
    display: none;
    border-bottom: 10px solid rgba(0, 0, 0, 0.2);
    pointer-events: none;
  }
  .easylogic-colorpicker > .arrow:after {
    position: absolute;
    content: '';
    top: 1px;
    left: -9px;
    width: 0;
    height: 0;
    border-left: 9px solid transparent;
    border-right: 9px solid transparent;
    border-bottom: 9px solid white;
  }
  .easylogic-colorpicker .colorpicker-body .arrow-button {
    position: relative;
    width: 10px;
    height: 12px;
    padding: 0px;
    background-color: transparent;
  }
  .easylogic-colorpicker .colorpicker-body .arrow-button:before {
    content: '';
    display: inline-block;
    position: absolute;
    left: 0px;
    right: 0px;
    top: 0px;
    height: 50%;
    width: 0;
    height: 0;
    border-left: 3px solid transparent;
    border-right: 3px solid transparent;
    border-bottom: 3px solid black;
    pointer-events: none;
    margin: 2px;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
  }
  .easylogic-colorpicker .colorpicker-body .arrow-button:after {
    content: '';
    display: inline-block;
    position: absolute;
    left: 0px;
    right: 0px;
    bottom: 0px;
    top: 50%;
    width: 0;
    height: 0;
    border-left: 3px solid transparent;
    border-right: 3px solid transparent;
    border-top: 3px solid black;
    pointer-events: none;
    margin: 2px;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
  }
  .easylogic-colorpicker .colorpicker-body .color {
    position: relative;
    height: 120px;
    overflow: hidden;
    cursor: pointer;
  }
  .easylogic-colorpicker .colorpicker-body .color > .saturation {
    position: relative;
    width: 100%;
    height: 100%;
  }
  .easylogic-colorpicker .colorpicker-body .color > .saturation > .value {
    position: relative;
    width: 100%;
    height: 100%;
  }
  .easylogic-colorpicker
    .colorpicker-body
    .color
    > .saturation
    > .value
    > .drag-pointer {
    position: absolute;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    -webkit-transform: translateX(-50%) translateY(-50%);
    transform: translateX(-50%) translateY(-50%);
  }
  .easylogic-colorpicker
    .colorpicker-body
    .color
    > .saturation
    > .value
    > .drag-pointer
    > div {
    border: 1px solid #ececec;
    -webkit-box-shadow: 0 0 2px 0 rgba(0, 0, 0, 0.05);
    box-shadow: 0 0 2px 0 rgba(0, 0, 0, 0.05);
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    position: absolute;
    width: 10px;
    height: 4px;
    background-color: white;
  }
  .easylogic-colorpicker
    .colorpicker-body
    .color
    > .saturation
    > .value
    > .drag-pointer
    .left-saturation {
    left: 0%;
    top: 50%;
    -webkit-transform: translateX(calc(-100% - 4px)) translateY(-50%);
    transform: translateX(calc(-100% - 4px)) translateY(-50%);
    cursor: col-resize;
  }
  .easylogic-colorpicker
    .colorpicker-body
    .color
    > .saturation
    > .value
    > .drag-pointer
    .right-saturation {
    left: 100%;
    top: 50%;
    -webkit-transform: translateX(4px) translateY(-50%);
    transform: translateX(4px) translateY(-50%);
    cursor: col-resize;
  }
  .easylogic-colorpicker
    .colorpicker-body
    .color
    > .saturation
    > .value
    > .drag-pointer
    .top-value {
    width: 4px;
    height: 10px;
    left: 50%;
    top: 0%;
    -webkit-transform: translateX(-50%) translateY(calc(-100% - 4px));
    transform: translateX(-50%) translateY(calc(-100% - 4px));
    cursor: row-resize;
  }
  .easylogic-colorpicker
    .colorpicker-body
    .color
    > .saturation
    > .value
    > .drag-pointer
    .bottom-value {
    width: 4px;
    height: 10px;
    left: 50%;
    top: 100%;
    -webkit-transform: translateX(-50%) translateY(4px);
    transform: translateX(-50%) translateY(4px);
    cursor: row-resize;
  }
  .easylogic-colorpicker .colorpicker-body .color > .saturation {
    background-color: rgba(204, 154, 129, 0);
    background-image: -webkit-gradient(
      linear,
      left top,
      right top,
      from(#fff),
      to(rgba(204, 154, 129, 0))
    );
    background-image: linear-gradient(to right, #fff, rgba(204, 154, 129, 0));
    background-repeat: repeat-x;
  }
  .easylogic-colorpicker .colorpicker-body .color > .saturation > .value {
    background-image: -webkit-gradient(
      linear,
      left bottom,
      left top,
      from(#000000),
      to(rgba(204, 154, 129, 0))
    );
    background-image: linear-gradient(to top, #000000, rgba(204, 154, 129, 0));
  }
  .easylogic-colorpicker
    .colorpicker-body
    .color
    > .saturation
    > .value
    > .drag-pointer {
    border: 1px solid #fff;
    -webkit-box-shadow: 0 0 2px 0 rgba(0, 0, 0, 0.05);
    box-shadow: 0 0 2px 0 rgba(0, 0, 0, 0.05);
  }
  .easylogic-colorpicker .colorpicker-body .control {
    position: relative;
    padding: 10px 0px 10px 0px;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
  }
  .easylogic-colorpicker .colorpicker-body .control > .color,
  .easylogic-colorpicker .colorpicker-body .control > .empty {
    position: absolute;
    left: 12px;
    top: 14px;
    width: 30px;
    height: 30px;
    border-radius: 50%;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
  }
  .easylogic-colorpicker .colorpicker-body .control > .color2,
  .easylogic-colorpicker .colorpicker-body .control > .empty2 {
    position: absolute;
    left: 12px;
    top: 50px;
    width: 30px;
    height: 20px;
    border-radius: 4px;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
  }
  .easylogic-colorpicker .colorpicker-body .control > .color {
    border: 1px solid rgba(0, 0, 0, 0.1);
  }
  .easylogic-colorpicker .colorpicker-body .control > .hue {
    position: relative;
    padding: 3px 16px;
    margin: 0px 0px 0px 42px;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    cursor: pointer;
  }
  .easylogic-colorpicker .colorpicker-body .control > .hue > .hue-container {
    position: relative;
    width: 100%;
    height: 14px;
    border-radius: 3px;
  }
  .easylogic-colorpicker .colorpicker-body .control > .hue-scale {
    position: relative;
    padding: 3px 16px;
    margin: 0px 0px 0px 42px;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    cursor: pointer;
  }
  .easylogic-colorpicker
    .colorpicker-body
    .control
    > .hue-scale
    > .hue-scale-container {
    position: relative;
    width: 100%;
    height: 14px;
  }
  .easylogic-colorpicker .colorpicker-body .control > .opacity {
    position: relative;
    padding: 3px 16px;
    margin: 0px 0px 0px 42px;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    cursor: pointer;
  }
  .easylogic-colorpicker
    .colorpicker-body
    .control
    > .opacity
    > .opacity-container {
    position: relative;
    width: 100%;
    height: 14px;
    border-radius: 3px;
  }
  .easylogic-colorpicker .colorpicker-body .control .drag-bar,
  .easylogic-colorpicker .colorpicker-body .control .drag-bar2 {
    position: absolute;
    cursor: pointer;
    top: 50%;
    left: 0px;
    -webkit-transform: translateX(-50%) translateY(-50%);
    transform: translateX(-50%) translateY(-50%);
    width: 12px;
    height: 12px;
    border-radius: 50%;
  }
  .easylogic-colorpicker .colorpicker-body .control > .hue > .hue-container {
    background: -webkit-gradient(
      linear,
      left top,
      right top,
      from(#ff0000),
      color-stop(17%, #ffff00),
      color-stop(33%, #00ff00),
      color-stop(50%, #00ffff),
      color-stop(67%, #0000ff),
      color-stop(83%, #ff00ff),
      to(#ff0000)
    );
    background: linear-gradient(
      to right,
      #ff0000 0%,
      #ffff00 17%,
      #00ff00 33%,
      #00ffff 50%,
      #0000ff 67%,
      #ff00ff 83%,
      #ff0000 100%
    );
  }
  .easylogic-colorpicker
    .colorpicker-body
    .control
    > .opacity
    > .opacity-container {
    background-color: transparent;
    background-image: linear-gradient(45deg, #ccc 25%, transparent 25%),
      linear-gradient(-45deg, #ccc 25%, transparent 25%),
      linear-gradient(45deg, transparent 75%, #ccc 75%),
      linear-gradient(-45deg, transparent 75%, #ccc 75%);
    background-size: 10px 10px;
    background-position: 0 0, 0 5px, 5px -5px, -5px 0px;
  }
  .easylogic-colorpicker
    .colorpicker-body
    .control
    > .opacity
    > .opacity-container
    > .color-bar {
    position: absolute;
    display: block;
    content: '';
    left: 0px;
    right: 0px;
    bottom: 0px;
    top: 0px;
  }
  .easylogic-colorpicker .colorpicker-body .control > .empty,
  .easylogic-colorpicker .colorpicker-body .control > .empty2 {
    background-color: transparent;
    background-image: linear-gradient(45deg, #ccc 25%, transparent 25%),
      linear-gradient(-45deg, #ccc 25%, transparent 25%),
      linear-gradient(45deg, transparent 75%, #ccc 75%),
      linear-gradient(-45deg, transparent 75%, #ccc 75%);
    background-size: 10px 10px;
    background-position: 0 0, 0 5px, 5px -5px, -5px 0px;
  }
  .easylogic-colorpicker .colorpicker-body .control .drag-bar,
  .easylogic-colorpicker .colorpicker-body .control .drag-bar2 {
    border: 1px solid rgba(0, 0, 0, 0.05);
    -webkit-box-shadow: 2px 2px 2px 0px rgba(0, 0, 0, 0.2);
    box-shadow: 2px 2px 2px 0px rgba(0, 0, 0, 0.2);
    background-color: #fefefe;
  }
  .easylogic-colorpicker .colorpicker-body .information {
    /*border-top: 1px solid #e8e8e8;*/
    position: relative;
    -webkit-box-sizing: padding-box;
    box-sizing: padding-box;
  }
  .easylogic-colorpicker .colorpicker-body .information > input {
    position: absolute;
    font-size: 10px;
    height: 20px;
    bottom: 20px;
    padding: 0 0 0 2px;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    -webkit-user-select: text;
    -moz-user-select: text;
    -ms-user-select: text;
    user-select: text;
  }
  .easylogic-colorpicker .colorpicker-body .information > input[type='number'] {
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
  }
  .easylogic-colorpicker
    .colorpicker-body
    .information
    > input[type='number']::-webkit-inner-spin-button,
  .easylogic-colorpicker
    .colorpicker-body
    .information
    > input[type='number']::-webkit-outer-spin-button {
    -webkit-appearance: none;
    appearance: none;
    margin: 0;
  }
  .easylogic-colorpicker
    .colorpicker-body
    .information.hex
    > .information-item.hex {
    display: -webkit-box;
    display: -ms-flexbox;
    display: flex;
  }
  .easylogic-colorpicker
    .colorpicker-body
    .information.rgb
    > .information-item.rgb {
    display: -webkit-box;
    display: -ms-flexbox;
    display: flex;
  }
  .easylogic-colorpicker
    .colorpicker-body
    .information.hsl
    > .information-item.hsl {
    display: -webkit-box;
    display: -ms-flexbox;
    display: flex;
  }
  .easylogic-colorpicker .colorpicker-body .information > .information-item {
    display: none;
    position: relative;
    padding: 0px 5px;
    padding-left: 9px;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    margin-right: 40px;
  }
  .easylogic-colorpicker
    .colorpicker-body
    .information
    > .information-item
    > .input-field {
    display: block;
    -webkit-box-flex: 1;
    -ms-flex: 1;
    flex: 1;
    padding: 3px;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    position: relative;
  }
  .easylogic-colorpicker
    .colorpicker-body
    .information
    > .information-item
    > .input-field
    > .title {
    text-align: center;
    font-size: 12px;
    color: #a9a9a9;
    padding-top: 2px;
  }
  .easylogic-colorpicker
    .colorpicker-body
    .information
    > .information-item
    > .input-field
    input {
    text-align: center;
    width: 100%;
    padding: 3px;
    height: 21px;
    font-size: 11px;
    color: #333;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    -webkit-user-select: text;
    -moz-user-select: text;
    -ms-user-select: text;
    user-select: text;
    border: 1px solid #cbcbcb;
    border-radius: 2px;
  }
  .easylogic-colorpicker
    .colorpicker-body
    .information
    > .information-item
    > .input-field
    input[type='number'] {
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
  }
  .easylogic-colorpicker
    .colorpicker-body
    .information
    > .information-item
    > .input-field
    input[type='number']::-webkit-inner-spin-button,
  .easylogic-colorpicker
    .colorpicker-body
    .information
    > .information-item
    > .input-field
    input[type='number']::-webkit-outer-spin-button {
    -webkit-appearance: none;
    appearance: none;
    margin: 0;
  }
  .easylogic-colorpicker
    .colorpicker-body
    .information
    > .information-item
    > .input-field.hsl-l
    input[type='number'],
  .easylogic-colorpicker
    .colorpicker-body
    .information
    > .information-item
    > .input-field.hsl-s
    input[type='number'] {
    padding-left: 1px;
    padding-right: 10px;
  }
  .easylogic-colorpicker
    .colorpicker-body
    .information
    > .information-item
    > .input-field
    .postfix {
    display: inline-block;
    position: absolute;
    right: 3px;
    top: 2px;
    height: 21px;
    line-height: 2;
    padding: 2px;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    text-align: center;
    font-size: 11px;
  }
  .easylogic-colorpicker .colorpicker-body .information > .information-change {
    position: absolute;
    display: block;
    width: 40px;
    top: 0px;
    right: 0px;
    bottom: 0px;
    text-align: center;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    padding-top: 5px;
  }
  .easylogic-colorpicker
    .colorpicker-body
    .information
    > .information-change
    > .format-change-button {
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    background: transparent;
    border: 0px;
    cursor: pointer;
    outline: none;
  }
  .easylogic-colorpicker .colorpicker-body .information > .title {
    color: #a3a3a3;
  }
  .easylogic-colorpicker .colorpicker-body .information > .input {
    color: #333;
  }
  .easylogic-colorpicker .colorpicker-body .colorsets {
    border-top: 1px solid #e2e2e2;
  }
  .easylogic-colorpicker .colorpicker-body .colorsets > .menu {
    float: right;
    padding: 10px 5px;
    padding-right: 15px;
  }
  .easylogic-colorpicker .colorpicker-body .colorsets > .menu button {
    border: 0px;
    font-size: 14px;
    font-weight: 300;
    font-family: serif, sans-serif;
    outline: none;
    cursor: pointer;
  }
  .easylogic-colorpicker .colorpicker-body .colorsets > .color-list {
    margin-right: 30px;
    display: block;
    padding: 12px 0px 0px 12px;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    line-height: 0;
  }
  .easylogic-colorpicker .colorpicker-body .colorsets > .color-list h6 {
    margin-top: 0px;
    margin-bottom: 8px;
  }
  .easylogic-colorpicker
    .colorpicker-body
    .colorsets
    > .color-list
    .color-item {
    width: 13px;
    height: 13px;
    border-radius: 2px;
    display: inline-block;
    margin-right: 12px;
    margin-bottom: 12px;
    position: relative;
    background-size: contain;
    overflow: hidden;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    cursor: pointer;
    vertical-align: middle;
  }
  .easylogic-colorpicker
    .colorpicker-body
    .colorsets
    > .color-list
    .color-item:hover {
    -webkit-transform: scale(1.2);
    transform: scale(1.2);
  }
  .easylogic-colorpicker
    .colorpicker-body
    .colorsets
    > .color-list
    .color-item
    .empty {
    position: absolute;
    left: 0px;
    top: 0px;
    background-color: transparent;
    background-image: linear-gradient(45deg, #ccc 25%, transparent 25%),
      linear-gradient(-45deg, #ccc 25%, transparent 25%),
      linear-gradient(45deg, transparent 75%, #ccc 75%),
      linear-gradient(-45deg, transparent 75%, #ccc 75%);
    background-size: 10px 10px;
    background-position: 0 0, 0 5px, 5px -5px, -5px 0px;
    width: 100%;
    height: 100%;
    padding: 0px;
    margin: 0px;
    pointer-events: none;
  }
  .easylogic-colorpicker
    .colorpicker-body
    .colorsets
    > .color-list
    .color-item
    .color-view {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
    padding: 0px;
    margin: 0px;
    pointer-events: none;
    border: 1px solid rgba(0, 0, 0, 0.1);
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
  }
  .easylogic-colorpicker
    .colorpicker-body
    .colorsets
    > .color-list
    .add-color-item {
    width: 13px;
    height: 13px;
    display: inline-block;
    margin-right: 12px;
    margin-bottom: 12px;
    cursor: pointer;
    line-height: 1;
    text-align: center;
    font-size: 16px;
    font-weight: 400;
    font-family: serif, sans-serif;
    color: #8e8e8e;
    vertical-align: middle;
  }
  .easylogic-colorpicker .colorpicker-body .color-chooser {
    position: absolute;
    left: 0px;
    right: 0px;
    bottom: 0px;
    top: 0px;
    opacity: 0;
    background-color: rgba(0, 0, 0, 0.5);
    -webkit-transition: opacity 0.05s ease-out;
    transition: opacity 0.05s ease-out;
    pointer-events: none;
  }
  .easylogic-colorpicker .colorpicker-body .color-chooser.open {
    opacity: 1;
    pointer-events: all;
  }
  .easylogic-colorpicker
    .colorpicker-body
    .color-chooser
    .color-chooser-container {
    position: absolute;
    top: 120px;
    left: 0px;
    right: 0px;
    bottom: 0px;
    background-color: white;
  }
  .easylogic-colorpicker
    .colorpicker-body
    .color-chooser
    .color-chooser-container
    .colorsets-item-header {
    position: absolute;
    top: 0px;
    left: 0px;
    right: 0px;
    height: 34px;
    display: -webkit-box;
    display: -ms-flexbox;
    display: flex;
    padding: 3px 0px;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    border-bottom: 1px solid rgba(0, 0, 0, 0.2);
  }
  .easylogic-colorpicker
    .colorpicker-body
    .color-chooser
    .color-chooser-container
    .colorsets-item-header
    .title {
    -webkit-box-flex: 2;
    -ms-flex: 2;
    flex: 2;
    font-weight: bold;
    font-size: 15px;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    margin-right: 30px;
    vertical-align: middle;
    margin: 0px;
    padding: 5px;
    padding-left: 14px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    color: #000;
    text-align: left;
  }
  .easylogic-colorpicker
    .colorpicker-body
    .color-chooser
    .color-chooser-container
    .colorsets-item-header
    .items {
    -webkit-box-flex: 1;
    -ms-flex: 1;
    flex: 1;
    text-align: right;
    padding-right: 10px;
    display: block;
    height: 100%;
    line-height: 2;
    cursor: pointer;
  }
  .easylogic-colorpicker
    .colorpicker-body
    .color-chooser
    .color-chooser-container
    .colorsets-list {
    position: absolute;
    top: 34px;
    left: 0px;
    right: 0px;
    bottom: 0px;
    overflow: auto;
  }
  .easylogic-colorpicker
    .colorpicker-body
    .color-chooser
    .color-chooser-container
    .colorsets-list
    .colorsets-item {
    cursor: pointer;
    display: -webkit-box;
    display: -ms-flexbox;
    display: flex;
    padding: 3px 0px;
    border-bottom: 1px solid rgba(0, 0, 0, 0.1);
  }
  .easylogic-colorpicker
    .colorpicker-body
    .color-chooser
    .color-chooser-container
    .colorsets-list
    .colorsets-item:hover {
    background-color: rgba(0, 0, 0, 0.05);
  }
  .easylogic-colorpicker
    .colorpicker-body
    .color-chooser
    .color-chooser-container
    .colorsets-list
    .colorsets-item
    .title {
    -webkit-box-flex: 2;
    -ms-flex: 2;
    flex: 2;
    font-size: 14px;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    margin-right: 30px;
    vertical-align: middle;
    pointer-events: none;
    margin: 0px;
    padding: 5px;
    padding-left: 14px;
    font-weight: normal;
    font-size: 13px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    color: #000;
    text-align: left;
  }
  .easylogic-colorpicker
    .colorpicker-body
    .color-chooser
    .color-chooser-container
    .colorsets-list
    .colorsets-item
    .items {
    -webkit-box-flex: 3;
    -ms-flex: 3;
    flex: 3;
    display: block;
    height: 100%;
    line-height: 1.6;
    cursor: pointer;
    pointer-events: none;
  }
  .easylogic-colorpicker
    .colorpicker-body
    .color-chooser
    .color-chooser-container
    .colorsets-list
    .colorsets-item
    .items
    .color-item {
    width: 13px;
    height: 13px;
    border-radius: 3px;
    display: inline-block;
    margin-right: 10px;
    background-color: transparent;
    background-image: linear-gradient(45deg, #ccc 25%, transparent 25%),
      linear-gradient(-45deg, #ccc 25%, transparent 25%),
      linear-gradient(45deg, transparent 75%, #ccc 75%),
      linear-gradient(-45deg, transparent 75%, #ccc 75%);
    background-size: 10px 10px;
    background-position: 0 0, 0 5px, 5px -5px, -5px 0px;
    background-size: contain;
    border: 1px solid #dddddd;
    overflow: hidden;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    cursor: pointer;
    vertical-align: middle;
  }
  .easylogic-colorpicker
    .colorpicker-body
    .color-chooser
    .color-chooser-container
    .colorsets-list
    .colorsets-item
    .items
    .color-item
    .color-view {
    width: 100%;
    height: 100%;
    padding: 0px;
    margin: 0px;
    pointer-events: none;
  }
  .easylogic-colorpicker .gradient-editor {
    position: relative;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
  }
  .easylogic-colorpicker .gradient-editor .tools {
    padding: 4px 6px;
  }
  .easylogic-colorpicker .gradient-editor .unit {
    display: grid;
    grid-template-columns: 110px 35px 50px;
    grid-column-gap: 5px;
    font-size: 11px;
  }
  .easylogic-colorpicker .gradient-editor .unit input,
  .easylogic-colorpicker .gradient-editor .unit select {
    width: 100%;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
  }
  .easylogic-colorpicker .gradient-editor .unit input {
    width: 35px;
  }
  .easylogic-colorpicker .gradient-editor [data-editor] {
    display: none;
    margin-top: 2px;
  }
  .easylogic-colorpicker .gradient-editor [data-editor] > label {
    font-size: 11px;
  }
  .easylogic-colorpicker
    .gradient-editor:not([data-selected-editor*='static-gradient'])
    [data-editor='gradient'],
  .easylogic-colorpicker
    .gradient-editor:not([data-selected-editor*='static-gradient'])
    [data-editor='tools'] {
    display: block;
  }
  .easylogic-colorpicker
    .gradient-editor[data-selected-editor='linear-gradient']
    [data-editor='angle'],
  .easylogic-colorpicker
    .gradient-editor[data-selected-editor='repeating-linear-gradient']
    [data-editor='angle'],
  .easylogic-colorpicker
    .gradient-editor[data-selected-editor='conic-gradient']
    [data-editor='angle'],
  .easylogic-colorpicker
    .gradient-editor[data-selected-editor='repeating-conic-gradient']
    [data-editor='angle'] {
    display: block;
  }
  .easylogic-colorpicker
    .gradient-editor[data-selected-editor='radial-gradient']
    [data-editor='centerX'],
  .easylogic-colorpicker
    .gradient-editor[data-selected-editor='radial-gradient']
    [data-editor='centerY'],
  .easylogic-colorpicker
    .gradient-editor[data-selected-editor='repeating-radial-gradient']
    [data-editor='centerX'],
  .easylogic-colorpicker
    .gradient-editor[data-selected-editor='repeating-radial-gradient']
    [data-editor='centerY'],
  .easylogic-colorpicker
    .gradient-editor[data-selected-editor='conic-gradient']
    [data-editor='centerX'],
  .easylogic-colorpicker
    .gradient-editor[data-selected-editor='conic-gradient']
    [data-editor='centerY'],
  .easylogic-colorpicker
    .gradient-editor[data-selected-editor='repeating-conic-gradient']
    [data-editor='centerX'],
  .easylogic-colorpicker
    .gradient-editor[data-selected-editor='repeating-conic-gradient']
    [data-editor='centerY'] {
    display: block;
  }
  .easylogic-colorpicker
    .gradient-editor[data-selected-editor='radial-gradient']
    [data-editor='radialType'],
  .easylogic-colorpicker
    .gradient-editor[data-selected-editor='repeating-radial-gradient']
    [data-editor='radialType'] {
    margin-top: 5px;
    display: grid;
    grid-template-columns: 110px 90px;
    grid-column-gap: 2px;
  }
  .easylogic-colorpicker
    .gradient-editor[data-selected-editor='radial-gradient']
    [data-editor='radialType']
    select,
  .easylogic-colorpicker
    .gradient-editor[data-selected-editor='repeating-radial-gradient']
    [data-editor='radialType']
    select {
    width: 100%;
  }
  .easylogic-colorpicker .gradient-editor .sub-editor {
    padding: 0px 8px;
  }
  .easylogic-colorpicker .gradient-editor .gradient-steps {
    position: relative;
    height: 30px;
  }
  .easylogic-colorpicker .gradient-editor .hue-container,
  .easylogic-colorpicker .gradient-editor .hue {
    position: absolute;
    left: 10px;
    right: 10px;
    top: 4px;
    height: 14px;
    border-radius: 10px;
    border: 1px solid #cccccc;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    background-color: transparent;
    background-image: linear-gradient(45deg, #ccc 25%, transparent 25%),
      linear-gradient(-45deg, #ccc 25%, transparent 25%),
      linear-gradient(45deg, transparent 75%, #ccc 75%),
      linear-gradient(-45deg, transparent 75%, #ccc 75%);
    background-size: 10px 10px;
    background-position: 0 0, 0 5px, 5px -5px, -5px 0px;
    pointer-events: all;
  }
  .easylogic-colorpicker .gradient-editor .hue {
    pointer-events: none;
  }
  .easylogic-colorpicker .gradient-editor .hue .step-list {
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0px;
    left: 0px;
    border-radius: 10px;
    pointer-events: none;
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='0']
    [data-index='0'] {
    border: 0px;
    -webkit-transform: translateX(-50%) translateY(calc(100%));
    transform: translateX(-50%) translateY(calc(100%));
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='0']
    [data-index='0']
    .arrow {
    display: block;
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='1']
    [data-index='1'] {
    border: 0px;
    -webkit-transform: translateX(-50%) translateY(calc(100%));
    transform: translateX(-50%) translateY(calc(100%));
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='1']
    [data-index='1']
    .arrow {
    display: block;
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='2']
    [data-index='2'] {
    border: 0px;
    -webkit-transform: translateX(-50%) translateY(calc(100%));
    transform: translateX(-50%) translateY(calc(100%));
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='2']
    [data-index='2']
    .arrow {
    display: block;
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='3']
    [data-index='3'] {
    border: 0px;
    -webkit-transform: translateX(-50%) translateY(calc(100%));
    transform: translateX(-50%) translateY(calc(100%));
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='3']
    [data-index='3']
    .arrow {
    display: block;
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='4']
    [data-index='4'] {
    border: 0px;
    -webkit-transform: translateX(-50%) translateY(calc(100%));
    transform: translateX(-50%) translateY(calc(100%));
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='4']
    [data-index='4']
    .arrow {
    display: block;
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='5']
    [data-index='5'] {
    border: 0px;
    -webkit-transform: translateX(-50%) translateY(calc(100%));
    transform: translateX(-50%) translateY(calc(100%));
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='5']
    [data-index='5']
    .arrow {
    display: block;
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='6']
    [data-index='6'] {
    border: 0px;
    -webkit-transform: translateX(-50%) translateY(calc(100%));
    transform: translateX(-50%) translateY(calc(100%));
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='6']
    [data-index='6']
    .arrow {
    display: block;
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='7']
    [data-index='7'] {
    border: 0px;
    -webkit-transform: translateX(-50%) translateY(calc(100%));
    transform: translateX(-50%) translateY(calc(100%));
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='7']
    [data-index='7']
    .arrow {
    display: block;
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='8']
    [data-index='8'] {
    border: 0px;
    -webkit-transform: translateX(-50%) translateY(calc(100%));
    transform: translateX(-50%) translateY(calc(100%));
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='8']
    [data-index='8']
    .arrow {
    display: block;
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='9']
    [data-index='9'] {
    border: 0px;
    -webkit-transform: translateX(-50%) translateY(calc(100%));
    transform: translateX(-50%) translateY(calc(100%));
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='9']
    [data-index='9']
    .arrow {
    display: block;
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='10']
    [data-index='10'] {
    border: 0px;
    -webkit-transform: translateX(-50%) translateY(calc(100%));
    transform: translateX(-50%) translateY(calc(100%));
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='10']
    [data-index='10']
    .arrow {
    display: block;
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='11']
    [data-index='11'] {
    border: 0px;
    -webkit-transform: translateX(-50%) translateY(calc(100%));
    transform: translateX(-50%) translateY(calc(100%));
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='11']
    [data-index='11']
    .arrow {
    display: block;
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='12']
    [data-index='12'] {
    border: 0px;
    -webkit-transform: translateX(-50%) translateY(calc(100%));
    transform: translateX(-50%) translateY(calc(100%));
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='12']
    [data-index='12']
    .arrow {
    display: block;
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='13']
    [data-index='13'] {
    border: 0px;
    -webkit-transform: translateX(-50%) translateY(calc(100%));
    transform: translateX(-50%) translateY(calc(100%));
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='13']
    [data-index='13']
    .arrow {
    display: block;
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='14']
    [data-index='14'] {
    border: 0px;
    -webkit-transform: translateX(-50%) translateY(calc(100%));
    transform: translateX(-50%) translateY(calc(100%));
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='14']
    [data-index='14']
    .arrow {
    display: block;
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='15']
    [data-index='15'] {
    border: 0px;
    -webkit-transform: translateX(-50%) translateY(calc(100%));
    transform: translateX(-50%) translateY(calc(100%));
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='15']
    [data-index='15']
    .arrow {
    display: block;
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='16']
    [data-index='16'] {
    border: 0px;
    -webkit-transform: translateX(-50%) translateY(calc(100%));
    transform: translateX(-50%) translateY(calc(100%));
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='16']
    [data-index='16']
    .arrow {
    display: block;
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='17']
    [data-index='17'] {
    border: 0px;
    -webkit-transform: translateX(-50%) translateY(calc(100%));
    transform: translateX(-50%) translateY(calc(100%));
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='17']
    [data-index='17']
    .arrow {
    display: block;
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='18']
    [data-index='18'] {
    border: 0px;
    -webkit-transform: translateX(-50%) translateY(calc(100%));
    transform: translateX(-50%) translateY(calc(100%));
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='18']
    [data-index='18']
    .arrow {
    display: block;
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='19']
    [data-index='19'] {
    border: 0px;
    -webkit-transform: translateX(-50%) translateY(calc(100%));
    transform: translateX(-50%) translateY(calc(100%));
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list[data-selected-index='19']
    [data-index='19']
    .arrow {
    display: block;
  }
  .easylogic-colorpicker .gradient-editor .hue .step-list .step {
    pointer-events: all;
    width: 10px;
    height: 10px;
    border: 1px solid white;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    display: inline-block;
    position: absolute;
    top: 50%;
    border-radius: 100%;
    -webkit-box-shadow: 0 0 2px 0px rgba(0, 0, 0, 0.5);
    box-shadow: 0 0 2px 0px rgba(0, 0, 0, 0.5);
    -webkit-transform: translateX(-50%) translateY(-50%);
    transform: translateX(-50%) translateY(-50%);
    background-color: transparent;
    background-image: linear-gradient(45deg, #ccc 25%, transparent 25%),
      linear-gradient(-45deg, #ccc 25%, transparent 25%),
      linear-gradient(45deg, transparent 75%, #ccc 75%),
      linear-gradient(-45deg, transparent 75%, #ccc 75%);
    background-size: 10px 10px;
    background-position: 0 0, 0 5px, 5px -5px, -5px 0px;
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list
    .step[data-cut='true'] {
    border-radius: 0%;
  }
  .easylogic-colorpicker
    .gradient-editor
    .hue
    .step-list
    .step[data-cut='true']
    .color-view {
    border-radius: 0%;
  }
  .easylogic-colorpicker .gradient-editor .hue .step-list .step .color-view {
    position: absolute;
    left: 0px;
    top: 0px;
    bottom: 0px;
    right: 0px;
    border-radius: 100%;
    pointer-events: none;
  }
  .easylogic-colorpicker .gradient-editor .hue .step-list .step .arrow {
    position: absolute;
    left: 50%;
    display: none;
    top: 0%;
    width: 5px;
    height: 5px;
    -webkit-transform: translateX(-50%) translateY(-120%);
    transform: translateX(-50%) translateY(-120%);
    pointer-events: none;
    -webkit-clip-path: polygon(40% 0%, 60% 0%, 60% 100%, 40% 100%);
    clip-path: polygon(40% 0%, 60% 0%, 60% 100%, 40% 100%);
  }
  .easylogic-colorpicker .gradient-editor input[type='range'] {
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    width: 100%;
    margin: 6.2px 0;
    background-color: transparent;
  }
  .easylogic-colorpicker .gradient-editor input[type='range']:focus {
    outline: none;
  }
  .easylogic-colorpicker
    .gradient-editor
    input[type='range']::-webkit-slider-runnable-track {
    width: 100%;
    height: 1px;
    cursor: pointer;
    background: #556375;
    border-radius: 0px;
    border: 0px solid #010101;
  }
  .easylogic-colorpicker
    .gradient-editor
    input[type='range']::-webkit-slider-thumb {
    height: 10px;
    width: 10px;
    border-radius: 10px;
    background: #556375;
    cursor: pointer;
    -webkit-appearance: none;
    appearance: none;
    margin-top: -5px;
  }
  .easylogic-colorpicker
    .gradient-editor
    input[type='range']:focus::-webkit-slider-runnable-track {
    background: #3174ad;
  }
  .easylogic-colorpicker
    .gradient-editor
    input[type='range']::-moz-range-track {
    width: 100%;
    height: 1px;
    cursor: pointer;
    background: #556375;
    border-radius: 0px;
    border: 0px solid #010101;
  }
  .easylogic-colorpicker
    .gradient-editor
    input[type='range']::-moz-range-thumb {
    border: 1px solid #000000;
    height: 10px;
    width: 10px;
    border-radius: 9px;
    background: #556375;
    cursor: pointer;
  }
  .easylogic-colorpicker .gradient-editor input[type='range']::-ms-track {
    width: 100%;
    height: 1px;
    cursor: pointer;
    background: transparent;
    border-color: transparent;
    color: transparent;
  }
  .easylogic-colorpicker .gradient-editor input[type='range']::-ms-fill-lower {
    background: #556375;
    border: 0px solid #010101;
    border-radius: 0px;
    box-shadow: 0px 0px 0px #000000, 0px 0px 0px #0d0d0d;
  }
  .easylogic-colorpicker .gradient-editor input[type='range']::-ms-fill-upper {
    background: #556375;
    border: 0px solid #010101;
    border-radius: 0px;
  }
  .easylogic-colorpicker .gradient-editor input[type='range']::-ms-thumb {
    height: 10px;
    width: 10px;
    border-radius: 9px;
    background: #556375;
    cursor: pointer;
  }
  .easylogic-colorpicker
    .gradient-editor
    input[type='range']:focus::-ms-fill-lower {
    background: #556375;
  }
  .easylogic-colorpicker
    .gradient-editor
    input[type='range']:focus::-ms-fill-upper {
    background: #556375;
  }
  .easylogic-colorpicker.gradient-picker {
    width: 460px;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
  }
  .easylogic-colorpicker.gradient-picker .gradient-body {
    display: grid;
    grid-template-columns: 1fr 224px;
  }
  .easylogic-colorpicker.gradient-picker .gradient-body > div:first-child {
    padding: 5px;
    border-right: 1px solid #cccccc;
  }
  .easylogic-colorpicker.gradient-picker .popup-item {
    margin-bottom: 5px;
  }
  .easylogic-colorpicker.gradient-picker .grid-2 {
    display: grid;
    grid-template-columns: 60px 1fr;
  }
  .easylogic-colorpicker.gradient-picker .grid-2 label {
    font-size: 11px;
    padding-right: 2px;
    text-align: left;
  }
  .easylogic-colorpicker.gradient-picker label {
    font-size: 11px;
  }
  .easylogic-colorpicker.gradient-picker .gradient-preview {
    width: 100%;
    height: 100px;
    position: relative;
    margin-bottom: 5px;
    border: 1px solid #cccccc;
    border-radius: 3px;
    overflow: hidden;
    background-color: transparent;
    background-image: linear-gradient(45deg, #ccc 25%, transparent 25%),
      linear-gradient(-45deg, #ccc 25%, transparent 25%),
      linear-gradient(45deg, transparent 75%, #ccc 75%),
      linear-gradient(-45deg, transparent 75%, #ccc 75%);
    background-size: 10px 10px;
    background-position: 0 0, 0 5px, 5px -5px, -5px 0px;
  }
  .easylogic-colorpicker.gradient-picker .gradient-preview .gradient-view {
    position: absolute;
    left: 0px;
    top: 0px;
    right: 0px;
    bottom: 0px;
  }
  .easylogic-colorpicker.gradient-picker .picker-tab {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
  }
  .easylogic-colorpicker.gradient-picker .picker-tab .picker-tab-list {
    text-align: center;
    padding: 2px 5px;
  }
  .easylogic-colorpicker.gradient-picker
    .picker-tab
    .picker-tab-list[data-value='linear-gradient']
    .picker-tab-item[data-selected-value='linear-gradient'] {
    -webkit-box-shadow: 0px 0px 3px 0px rgba(0, 0, 0, 0.5);
    box-shadow: 0px 0px 3px 0px rgba(0, 0, 0, 0.5);
  }
  .easylogic-colorpicker.gradient-picker
    .picker-tab
    .picker-tab-list[data-value='linear-gradient']
    .picker-tab-item[data-selected-value='linear-gradient']
    .icon
    svg
    path {
    fill: rgba(0, 0, 255, 0.5);
  }
  .easylogic-colorpicker.gradient-picker
    .picker-tab
    .picker-tab-list[data-value='repeating-linear-gradient']
    .picker-tab-item[data-selected-value='repeating-linear-gradient'] {
    -webkit-box-shadow: 0px 0px 3px 0px rgba(0, 0, 0, 0.5);
    box-shadow: 0px 0px 3px 0px rgba(0, 0, 0, 0.5);
  }
  .easylogic-colorpicker.gradient-picker
    .picker-tab
    .picker-tab-list[data-value='repeating-linear-gradient']
    .picker-tab-item[data-selected-value='repeating-linear-gradient']
    .icon
    svg
    path {
    fill: rgba(0, 0, 255, 0.5);
  }
  .easylogic-colorpicker.gradient-picker
    .picker-tab
    .picker-tab-list[data-value='radial-gradient']
    .picker-tab-item[data-selected-value='radial-gradient'] {
    -webkit-box-shadow: 0px 0px 3px 0px rgba(0, 0, 0, 0.5);
    box-shadow: 0px 0px 3px 0px rgba(0, 0, 0, 0.5);
  }
  .easylogic-colorpicker.gradient-picker
    .picker-tab
    .picker-tab-list[data-value='radial-gradient']
    .picker-tab-item[data-selected-value='radial-gradient']
    .icon
    svg
    path {
    fill: rgba(0, 0, 255, 0.5);
  }
  .easylogic-colorpicker.gradient-picker
    .picker-tab
    .picker-tab-list[data-value='repeating-radial-gradient']
    .picker-tab-item[data-selected-value='repeating-radial-gradient'] {
    -webkit-box-shadow: 0px 0px 3px 0px rgba(0, 0, 0, 0.5);
    box-shadow: 0px 0px 3px 0px rgba(0, 0, 0, 0.5);
  }
  .easylogic-colorpicker.gradient-picker
    .picker-tab
    .picker-tab-list[data-value='repeating-radial-gradient']
    .picker-tab-item[data-selected-value='repeating-radial-gradient']
    .icon
    svg
    path {
    fill: rgba(0, 0, 255, 0.5);
  }
  .easylogic-colorpicker.gradient-picker
    .picker-tab
    .picker-tab-list[data-value='conic-gradient']
    .picker-tab-item[data-selected-value='conic-gradient'] {
    -webkit-box-shadow: 0px 0px 3px 0px rgba(0, 0, 0, 0.5);
    box-shadow: 0px 0px 3px 0px rgba(0, 0, 0, 0.5);
  }
  .easylogic-colorpicker.gradient-picker
    .picker-tab
    .picker-tab-list[data-value='conic-gradient']
    .picker-tab-item[data-selected-value='conic-gradient']
    .icon
    svg
    path {
    fill: rgba(0, 0, 255, 0.5);
  }
  .easylogic-colorpicker.gradient-picker
    .picker-tab
    .picker-tab-list[data-value='repeating-conic-gradient']
    .picker-tab-item[data-selected-value='repeating-conic-gradient'] {
    -webkit-box-shadow: 0px 0px 3px 0px rgba(0, 0, 0, 0.5);
    box-shadow: 0px 0px 3px 0px rgba(0, 0, 0, 0.5);
  }
  .easylogic-colorpicker.gradient-picker
    .picker-tab
    .picker-tab-list[data-value='repeating-conic-gradient']
    .picker-tab-item[data-selected-value='repeating-conic-gradient']
    .icon
    svg
    path {
    fill: rgba(0, 0, 255, 0.5);
  }
  .easylogic-colorpicker.gradient-picker
    .picker-tab
    .picker-tab-list
    .picker-tab-item {
    display: inline-block;
    vertical-align: middle;
    height: 20px;
    width: 20px;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    cursor: pointer;
    position: relative;
    border-radius: 20%;
  }
  .easylogic-colorpicker.gradient-picker
    .picker-tab
    .picker-tab-list
    .picker-tab-item
    .icon {
    pointer-events: none;
    border-radius: 100%;
    display: inline-block;
    width: 90%;
    height: 90%;
    position: absolute;
    left: 50%;
    top: 50%;
    -webkit-transform: translateX(-50%) translateY(-50%);
    transform: translateX(-50%) translateY(-50%);
  }
  .easylogic-colorpicker.gradient-picker
    .picker-tab
    .picker-tab-list
    .picker-tab-item
    .icon
    svg {
    width: 100%;
    height: 100%;
  }
  .easylogic-colorpicker.gradient-picker
    .picker-tab
    .picker-tab-list
    .picker-tab-item[data-selected-value='static-gradient']
    .icon {
    background-image: -webkit-gradient(
      linear,
      left top,
      right top,
      from(red),
      to(red)
    );
    background-image: linear-gradient(to right, red, red);
  }
  .easylogic-colorpicker.gradient-picker
    .picker-tab
    .picker-tab-list
    .picker-tab-item[data-selected-value='linear-gradient']
    .icon {
    background-image: -webkit-gradient(
      linear,
      left top,
      right top,
      from(black),
      to(gray)
    );
    background-image: linear-gradient(to right, black, gray);
  }
  .easylogic-colorpicker.gradient-picker
    .picker-tab
    .picker-tab-list
    .picker-tab-item[data-selected-value='radial-gradient']
    .icon {
    background-image: radial-gradient(closest-side, black, #ebf8e1, gray);
  }
  .easylogic-colorpicker.gradient-picker
    .picker-tab
    .picker-tab-list
    .picker-tab-item[data-selected-value='conic-gradient']
    .icon {
    background-image: conic-gradient(black, #ebf8e1);
  }
  .easylogic-colorpicker.gradient-picker
    .picker-tab
    .picker-tab-list
    .picker-tab-item[data-selected-value='repeating-linear-gradient']
    .icon {
    background-image: repeating-linear-gradient(
      45deg,
      #3f87a6,
      #ebf8e1 15%,
      #f69d3c 20%
    );
  }
  .easylogic-colorpicker.gradient-picker
    .picker-tab
    .picker-tab-list
    .picker-tab-item[data-selected-value='repeating-radial-gradient']
    .icon {
    background-image: repeating-radial-gradient(
      circle,
      #3f87a6,
      #ebf8e1 15%,
      #f69d3c 20%
    );
  }
  .easylogic-colorpicker.gradient-picker
    .picker-tab
    .picker-tab-list
    .picker-tab-item[data-selected-value='repeating-conic-gradient']
    .icon {
    background-image: repeating-conic-gradient(
      #3f87a6,
      #ebf8e1 5%,
      #f69d3c 10%
    );
  }
  .easylogic-colorpicker.gradient-picker .picker-tab .picker-gradient-selector {
    padding: 2px 10px;
  }
  .easylogic-colorpicker.gradient-picker
    .picker-tab
    .picker-gradient-selector
    .gradient-steps {
    position: relative;
    display: block;
    height: 30px;
  }
  .easylogic-colorpicker.gradient-picker
    .picker-tab
    .picker-gradient-selector
    .gradient-steps
    .hue-container {
    width: 100%;
    height: 14px;
    position: absolute;
    z-index: 0;
    background-color: transparent;
    background-image: linear-gradient(45deg, #ccc 25%, transparent 25%),
      linear-gradient(-45deg, #ccc 25%, transparent 25%),
      linear-gradient(45deg, transparent 75%, #ccc 75%),
      linear-gradient(-45deg, transparent 75%, #ccc 75%);
    background-size: 10px 10px;
    background-position: 0 0, 0 5px, 5px -5px, -5px 0px;
    -webkit-box-shadow: 0 0 1px 0 rgba(0, 0, 0, 0.1);
    box-shadow: 0 0 1px 0 rgba(0, 0, 0, 0.1);
  }
  .easylogic-colorpicker.gradient-picker
    .picker-tab
    .picker-gradient-selector
    .gradient-steps
    .hue {
    position: relative;
    padding: 0px;
    margin: 0px;
    cursor: pointer;
  }
  .easylogic-colorpicker.gradient-picker
    .picker-tab
    .picker-gradient-selector
    .gradient-steps
    .hue
    > .step-list {
    position: relative;
    width: 100%;
    cursor: copy;
    height: 14px;
    z-index: 1;
  }
  .easylogic-colorpicker.gradient-picker
    .picker-tab
    .picker-gradient-selector
    .gradient-steps
    .hue
    > .step-list.mode-drag {
    cursor: pointer;
  }
  .easylogic-colorpicker.gradient-picker
    .picker-tab
    .picker-gradient-selector
    .gradient-steps
    .hue
    .drag-bar {
    border: 0px;
    background-color: transparent;
    border: 2px solid white;
    -webkit-box-shadow: 0 0 2px 0px rgba(0, 0, 0, 0.6);
    box-shadow: 0 0 2px 0px rgba(0, 0, 0, 0.6);
    width: 10px;
    height: 10px;
    -webkit-transform: none;
    transform: none;
    border-radius: 50%;
    display: inline-block;
    left: 0px;
    top: 17px;
    -webkit-transform: translateX(-50%);
    transform: translateX(-50%);
    position: absolute;
    background-color: rgba(255, 255, 255, 0.8);
    cursor: pointer;
    -webkit-transition: top 0.3s ease-out;
    transition: top 0.3s ease-out;
  }
  .easylogic-colorpicker.gradient-picker
    .picker-tab
    .picker-gradient-selector
    .gradient-steps
    .hue
    .drag-bar
    .guide-line {
    pointer-events: none;
    position: absolute;
    width: 1px;
    height: 0px;
    bottom: 8px;
    left: 3px;
    -webkit-transform: translateX(-1px);
    transform: translateX(-1px);
    -webkit-transition: all 0.3s ease-out;
    transition: all 0.3s ease-out;
  }
  .easylogic-colorpicker.gradient-picker
    .picker-tab
    .picker-gradient-selector
    .gradient-steps
    .hue
    .drag-bar.selected {
    z-index: 1;
    top: 30px;
  }
  .easylogic-colorpicker.gradient-picker
    .picker-tab
    .picker-gradient-selector
    .gradient-steps
    .hue
    .drag-bar.selected
    .guide-line {
    height: 17px;
  }
  .easylogic-colorpicker.gradient-picker
    .picker-tab
    .picker-gradient-selector
    .gradient-steps
    .hue
    .drag-bar.selected
    .guide-change {
    opacity: 1;
  }
  .easylogic-colorpicker.gradient-picker .easylogic-colorpicker {
    width: 223px;
    border-radius: 0px;
    border-top-right-radius: 3px;
    border-bottom-right-radius: 3px;
    border: 0px;
    -webkit-box-shadow: none;
    box-shadow: none;
  }
  .easylogic-colorpicker.sketch {
    border-radius: 5px;
  }
  .easylogic-colorpicker.sketch > .colorpicker-body > .color {
    margin: 10px 10px 2px 10px;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    height: 150px;
  }
  .easylogic-colorpicker.sketch > .colorpicker-body > .control {
    padding: 0px;
  }
  .easylogic-colorpicker.sketch > .colorpicker-body > .control > .color,
  .easylogic-colorpicker.sketch > .colorpicker-body > .control > .empty {
    position: absolute;
    right: 10px;
    left: auto;
    top: 2px;
    width: 40px;
    height: 44px;
    border-radius: 2px;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
  }
  .easylogic-colorpicker.sketch > .colorpicker-body > .control > .color2,
  .easylogic-colorpicker.sketch > .colorpicker-body > .control > .empty2 {
    position: absolute;
    right: 10px;
    left: auto;
    top: 50px;
    width: 40px;
    height: 20px;
    border-radius: 2px;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
  }
  .easylogic-colorpicker.sketch > .colorpicker-body > .control > .color {
    -webkit-box-shadow: inset 0px 0px 1px 0px rgba(0, 0, 0, 0.5);
    box-shadow: inset 0px 0px 1px 0px rgba(0, 0, 0, 0.5);
  }
  .easylogic-colorpicker.sketch > .colorpicker-body > .control > .hue {
    position: relative;
    padding: 2px 2px 2px 10px;
    margin: 0px 50px 0px 0px;
  }
  .easylogic-colorpicker.sketch
    > .colorpicker-body
    > .control
    > .hue
    > .hue-container {
    border-radius: 0px;
    height: 20px;
  }
  .easylogic-colorpicker.sketch > .colorpicker-body > .control > .hue-scale {
    position: relative;
    padding: 2px 2px 2px 10px;
    margin: 0px 50px 0px 0px;
  }
  .easylogic-colorpicker.sketch
    > .colorpicker-body
    > .control
    > .hue-scale
    > .hue-scale-container {
    border-radius: 0px;
    height: 20px;
  }
  .easylogic-colorpicker.sketch > .colorpicker-body > .control > .opacity {
    position: relative;
    padding: 2px 2px 2px 10px;
    margin: 0px 50px 0px 0px;
  }
  .easylogic-colorpicker.sketch
    > .colorpicker-body
    > .control
    > .opacity
    > .opacity-container {
    border-radius: 0px;
    height: 20px;
  }
  .easylogic-colorpicker.sketch > .colorpicker-body > .control .drag-bar,
  .easylogic-colorpicker.sketch > .colorpicker-body > .control .drag-bar2 {
    border-radius: 0px;
    top: 50%;
    left: 0px;
    width: 5px;
    height: 80%;
    -webkit-transform: translateX(-50%) translateY(-50%);
    transform: translateX(-50%) translateY(-50%);
    border-radius: 1px;
    bottom: 1px !important;
  }
  .easylogic-colorpicker.sketch > .colorpicker-body > .control .drag-bar.first,
  .easylogic-colorpicker.sketch
    > .colorpicker-body
    > .control
    .drag-bar2.first {
    left: 0px;
    -webkit-transform: translateX(50%) translateY(-50%) !important;
    transform: translateX(50%) translateY(-50%) !important;
  }
  .easylogic-colorpicker.sketch > .colorpicker-body > .control .drag-bar.last,
  .easylogic-colorpicker.sketch > .colorpicker-body > .control .drag-bar2.last {
    -webkit-transform: translateX(-110%) translateY(-50%) !important;
    transform: translateX(-110%) translateY(-50%) !important;
  }
  .easylogic-colorpicker.sketch
    > .colorpicker-body
    > .information
    .information-change {
    display: none;
  }
  .easylogic-colorpicker.sketch
    > .colorpicker-body
    > .information.rgb
    .information-item.rgb {
    display: inherit;
  }
  .easylogic-colorpicker.sketch
    > .colorpicker-body
    > .information.rgb
    .information-item.hsl {
    display: none !important;
  }
  .easylogic-colorpicker.sketch
    > .colorpicker-body
    > .information.hex
    .information-item.hex {
    display: inherit;
  }
  .easylogic-colorpicker.sketch
    > .colorpicker-body
    > .information.hex
    .information-item.hsl {
    display: none !important;
  }
  .easylogic-colorpicker.sketch
    > .colorpicker-body
    > .information.hsl
    .information-item.rgb {
    display: none !important;
  }
  .easylogic-colorpicker.sketch
    > .colorpicker-body
    > .information.hsl
    .information-item.hsl {
    display: inherit;
  }
  .easylogic-colorpicker.sketch
    > .colorpicker-body
    > .information
    .information-item {
    display: -webkit-inline-box !important;
    display: -ms-inline-flexbox !important;
    display: inline-flex !important;
    margin-right: 0px;
  }
  .easylogic-colorpicker.sketch
    > .colorpicker-body
    > .information
    .information-item
    > .input-field {
    padding-left: 0px;
  }
  .easylogic-colorpicker.sketch
    > .colorpicker-body
    > .information
    .information-item
    > .input-field:last-child {
    padding-right: 0px;
  }
  .easylogic-colorpicker.sketch
    > .colorpicker-body
    > .information
    .information-item
    > .input-field
    > .title {
    color: black;
    font-size: 11px;
    cursor: pointer;
  }
  .easylogic-colorpicker.sketch
    > .colorpicker-body
    > .information
    .information-item
    > .input-field:last-child:not(:first-child) {
    padding-right: 0px;
  }
  .easylogic-colorpicker.sketch
    > .colorpicker-body
    > .information
    .information-item.hex {
    width: 74px;
    padding-right: 0px;
    padding-left: 5px;
  }
  .easylogic-colorpicker.sketch
    > .colorpicker-body
    > .information
    .information-item.rgb {
    width: 140px;
    padding-left: 0px;
    padding-right: 0px;
  }
  .easylogic-colorpicker.sketch
    > .colorpicker-body
    > .information
    .information-item.hsl {
    display: none;
    width: 140px;
    padding-left: 0px;
    padding-right: 0px;
  }
  .easylogic-colorpicker.sketch > .colorpicker-body > .colorsets > .color-list {
    margin-right: 0px;
    padding-right: 12px;
  }
  .easylogic-colorpicker.sketch
    > .colorpicker-body
    > .colorsets
    > .color-list
    h6 {
    margin-top: 0px;
    margin-bottom: 8px;
  }
  .easylogic-colorpicker.sketch
    > .colorpicker-body
    > .colorsets
    > .color-list
    .color-item {
    width: 16px;
    height: 16px;
    border-radius: 3px;
    margin-right: 9px;
    margin-bottom: 10px;
  }
  .easylogic-colorpicker.palette {
    border-radius: 3px;
    -webkit-box-shadow: none;
    box-shadow: none;
  }
  .easylogic-colorpicker.palette > .colorpicker-body > .color {
    display: none;
  }
  .easylogic-colorpicker.palette > .colorpicker-body > .control {
    display: none;
  }
  .easylogic-colorpicker.palette > .colorpicker-body > .information {
    display: none;
  }
  .easylogic-colorpicker.palette > .colorpicker-body > .colorsets {
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    border-top: 0px;
  }
  .easylogic-colorpicker.palette
    > .colorpicker-body
    > .colorsets
    > .color-list
    h6 {
    margin-top: 0px;
    margin-bottom: 8px;
  }
  .easylogic-colorpicker.palette
    > .colorpicker-body
    > .colorsets
    > .color-list
    .color-item {
    width: 15px;
    height: 15px;
    margin-right: 10px;
    margin-bottom: 10px;
  }
  .easylogic-colorpicker.palette > .colorpicker-body > .color-chooser {
    display: none;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
  }
  .easylogic-colorpicker.palette > .colorpicker-body > .color-chooser.open {
    display: block;
    top: -1px;
    left: -1px;
    right: -1px;
    bottom: auto;
    border-radius: 3px;
    border: 1px solid #d8d8d8;
    -webkit-box-shadow: 0 0px 10px 2px rgba(0, 0, 0, 0.12);
    box-shadow: 0 0px 10px 2px rgba(0, 0, 0, 0.12);
  }
  .easylogic-colorpicker.palette
    > .colorpicker-body
    > .color-chooser.open
    .color-chooser-container {
    position: relative;
    top: auto;
    left: auto;
    right: auto;
    bottom: auto;
    background-color: white;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    border-radius: 2px;
  }
  .easylogic-colorpicker.palette
    > .colorpicker-body
    > .color-chooser.open
    .color-chooser-container
    .colorsets-item-header {
    position: relative;
    left: auto;
    top: auto;
    right: auto;
    bottom: auto;
    border-top-left-radius: 3px;
    border-top-right-radius: 3px;
  }
  .easylogic-colorpicker.palette
    > .colorpicker-body
    > .color-chooser.open
    .color-chooser-container
    .colorsets-list {
    position: relative;
    top: auto;
    left: auto;
    right: auto;
    bottom: auto;
    overflow: auto;
  }
  .easylogic-colorpicker.palette
    > .colorpicker-body
    > .color-chooser.open
    .color-chooser-container
    .colorsets-list
    .colorsets-item:last-child {
    border-bottom-left-radius: 3px;
    border-bottom-right-radius: 3px;
  }
  .easylogic-colorpicker.macos .colorpicker-body .wheel {
    width: 224px;
    height: 224px;
    position: relative;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
  }
  .easylogic-colorpicker.macos .colorpicker-body .wheel .wheel-canvas {
    width: 214px;
    height: 214px;
    border-radius: 50%;
    position: absolute;
    left: 5px;
    top: 5px;
  }
  .easylogic-colorpicker.macos .colorpicker-body .wheel .drag-pointer {
    display: inline-block;
    position: absolute;
    width: 10px;
    height: 10px;
    left: 50%;
    top: 50%;
    border: 1px solid white;
    border-radius: 50%;
    -webkit-transform: translateX(-50%) translateY(-50%);
    transform: translateX(-50%) translateY(-50%);
    z-index: 2;
  }
  .easylogic-colorpicker.macos .control {
    padding-top: 0px;
  }
  .easylogic-colorpicker.macos .control > .color,
  .easylogic-colorpicker.macos .control > .empty {
    top: 4px;
  }
  .easylogic-colorpicker.macos .value {
    position: relative;
    padding: 6px 16px;
    margin: 0px 0px 0px 42px;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    cursor: pointer;
  }
  .easylogic-colorpicker.macos .value > .value-container {
    position: relative;
    width: 100%;
    height: 10px;
    border-radius: 3px;
    background-image: -webkit-gradient(
      linear,
      left top,
      right top,
      from(#000000),
      to(rgba(255, 255, 255, 0))
    );
    background-image: linear-gradient(
      to right,
      #000000 0%,
      rgba(255, 255, 255, 0) 100%
    );
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
  }
  .easylogic-colorpicker.macos .value > .value-container .drag-bar {
    position: absolute;
    cursor: pointer;
    top: 50%;
    left: 0px;
    -webkit-transform: translateX(-50%) translateY(-50%);
    transform: translateX(-50%) translateY(-50%);
    width: 12px;
    height: 12px;
    border-radius: 50%;
  }
  .easylogic-colorpicker.mini {
    width: 180px;
    display: inline-block;
  }
  .easylogic-colorpicker.mini .control {
    padding: 0px;
  }
  .easylogic-colorpicker.mini .control .hue,
  .easylogic-colorpicker.mini .control .opacity {
    margin: 0px;
    padding: 0px;
  }
  .easylogic-colorpicker.mini .control .hue > .hue-container {
    border-radius: 0px;
    overflow: hidden;
    height: 20px;
  }
  .easylogic-colorpicker.mini .control .opacity > .opacity-container {
    border-radius: 0px;
    overflow: hidden;
    height: 20px;
  }
  .easylogic-colorpicker.mini .control .drag-bar,
  .easylogic-colorpicker.mini .control .drag-bar2 {
    border: 0px;
    background-color: transparent;
    height: 100%;
    width: 5px;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    -webkit-box-shadow: none;
    box-shadow: none;
  }
  .easylogic-colorpicker.mini .control .drag-bar.last:before,
  .easylogic-colorpicker.mini .control .drag-bar.lastafter,
  .easylogic-colorpicker.mini .control .drag-bar2.last:before,
  .easylogic-colorpicker.mini .control .drag-bar2.lastafter {
    left: 1px;
  }
  .easylogic-colorpicker.mini .control .drag-bar.first:before,
  .easylogic-colorpicker.mini .control .drag-bar.first:after,
  .easylogic-colorpicker.mini .control .drag-bar2.first:before,
  .easylogic-colorpicker.mini .control .drag-bar2.first:after {
    left: 3px;
  }
  .easylogic-colorpicker.mini .control .drag-bar:before,
  .easylogic-colorpicker.mini .control .drag-bar2:before {
    content: '';
    position: absolute;
    left: 2px;
    top: 0px;
    width: 0;
    height: 0;
    -webkit-transform: translateX(-50%);
    transform: translateX(-50%);
    border-left: 4px solid transparent;
    border-right: 4px solid transparent;
    border-top: 4px solid black;
  }
  .easylogic-colorpicker.mini .control .drag-bar:after,
  .easylogic-colorpicker.mini .control .drag-bar2:after {
    content: '';
    position: absolute;
    left: 2px;
    bottom: 0px;
    width: 0;
    height: 0;
    -webkit-transform: translateX(-50%);
    transform: translateX(-50%);
    border-left: 4px solid transparent;
    border-right: 4px solid transparent;
    border-bottom: 4px solid black;
  }
  .easylogic-colorpicker.mini-vertical {
    width: 180px;
    display: inline-block;
  }
  .easylogic-colorpicker.mini-vertical .color {
    display: inline-block;
    width: 140px;
    height: 160px;
    vertical-align: middle;
  }
  .easylogic-colorpicker.mini-vertical .control {
    height: 160px;
    padding: 0px;
    vertical-align: middle;
    display: inline-block;
  }
  .easylogic-colorpicker.mini-vertical .control .hue,
  .easylogic-colorpicker.mini-vertical .control .opacity {
    margin: 0px;
    padding: 0px;
    width: 20px;
    display: inline-block;
    vertical-align: middle;
    height: 100%;
    position: relative;
  }
  .easylogic-colorpicker.mini-vertical .control .hue > .hue-container {
    border-radius: 0px;
    overflow: hidden;
    height: 100%;
    background: -webkit-gradient(
      linear,
      left bottom,
      left top,
      from(#ff0000),
      color-stop(17%, #ffff00),
      color-stop(33%, #00ff00),
      color-stop(50%, #00ffff),
      color-stop(67%, #0000ff),
      color-stop(83%, #ff00ff),
      to(#ff0000)
    );
    background: linear-gradient(
      to top,
      #ff0000 0%,
      #ffff00 17%,
      #00ff00 33%,
      #00ffff 50%,
      #0000ff 67%,
      #ff00ff 83%,
      #ff0000 100%
    );
  }
  .easylogic-colorpicker.mini-vertical .control .opacity > .opacity-container {
    border-radius: 0px;
    overflow: hidden;
    height: 100%;
    width: 20px;
  }
  .easylogic-colorpicker.mini-vertical .control .drag-bar,
  .easylogic-colorpicker.mini-vertical .control .drag-bar2 {
    border: 0px;
    background-color: transparent;
    height: 2px;
    width: 100%;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    -webkit-box-shadow: none;
    box-shadow: none;
    -webkit-transform: none;
    transform: none;
  }
  .easylogic-colorpicker.mini-vertical .control .drag-bar.last:before,
  .easylogic-colorpicker.mini-vertical .control .drag-bar.last:after,
  .easylogic-colorpicker.mini-vertical .control .drag-bar2.last:before,
  .easylogic-colorpicker.mini-vertical .control .drag-bar2.last:after {
    top: 2px;
  }
  .easylogic-colorpicker.mini-vertical .control .drag-bar.first:before,
  .easylogic-colorpicker.mini-vertical .control .drag-bar.first:after,
  .easylogic-colorpicker.mini-vertical .control .drag-bar2.first:before,
  .easylogic-colorpicker.mini-vertical .control .drag-bar2.first:after {
    top: -1px;
  }
  .easylogic-colorpicker.mini-vertical .control .drag-bar:before,
  .easylogic-colorpicker.mini-vertical .control .drag-bar2:before {
    content: '';
    position: absolute;
    left: 0px;
    top: 2px;
    width: 0;
    height: 0;
    -webkit-transform: translateY(-50%);
    transform: translateY(-50%);
    border-top: 4px solid transparent;
    border-bottom: 4px solid transparent;
    border-left: 4px solid black;
  }
  .easylogic-colorpicker.mini-vertical .control .drag-bar:after,
  .easylogic-colorpicker.mini-vertical .control .drag-bar2:after {
    content: '';
    position: absolute;
    top: 2px;
    right: 0px;
    width: 0;
    height: 0;
    -webkit-transform: translateY(-50%);
    transform: translateY(-50%);
    border-top: 4px solid transparent;
    border-bottom: 4px solid transparent;
    border-right: 4px solid black;
  }
  .easylogic-colorpicker.ring .colorpicker-body > .color {
    position: absolute;
    width: 120px;
    height: 120px;
    left: 52px;
    top: 52px;
  }
  .easylogic-colorpicker.ring .colorpicker-body .wheel {
    width: 224px;
    height: 224px;
    position: relative;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
  }
  .easylogic-colorpicker.ring .colorpicker-body .wheel .wheel-canvas {
    width: 214px;
    height: 214px;
    border-radius: 50%;
    position: absolute;
    left: 5px;
    top: 5px;
  }
  .easylogic-colorpicker.ring .colorpicker-body .wheel .drag-pointer {
    display: inline-block;
    position: absolute;
    width: 10px;
    height: 10px;
    left: 50%;
    top: 50%;
    border: 1px solid white;
    border-radius: 50%;
    -webkit-transform: translateX(-50%) translateY(-50%);
    transform: translateX(-50%) translateY(-50%);
    z-index: 2;
  }
  .easylogic-colorpicker.ring .control {
    padding-top: 0px;
  }
  .easylogic-colorpicker.ring .control .value {
    display: none;
  }
  .easylogic-colorpicker.ring .control > .color,
  .easylogic-colorpicker.ring .control > .empty {
    top: -17px;
    width: 30px;
    height: 30px;
    border-radius: 2px;
  }
  .easylogic-colorpicker.xd {
    display: inline-block;
    padding-top: 12px;
    width: 245px;
  }
  .easylogic-colorpicker.xd .color {
    display: inline-block;
    margin-left: 12px;
    margin-bottom: 12px;
    width: 170px;
    height: 170px;
    vertical-align: middle;
    border-radius: 3px;
    overflow: hidden;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    border: 1px solid #cecece;
  }
  .easylogic-colorpicker.xd .color > .saturation > .value > .drag-pointer {
    border: 2px solid white;
    width: 7px;
    height: 7px;
    -webkit-box-shadow: 0 0 1px 0px black, inset 0 0 1px 0px black;
    box-shadow: 0 0 1px 0px black, inset 0 0 1px 0px black;
  }
  .easylogic-colorpicker.xd .control {
    height: 170px;
    padding: 0px;
    vertical-align: middle;
    display: inline-block;
    margin-right: 12px;
    margin-bottom: 12px;
  }
  .easylogic-colorpicker.xd .control .hue,
  .easylogic-colorpicker.xd .control .opacity {
    margin: 0px;
    padding: 0px;
    width: 13px;
    display: inline-block;
    vertical-align: middle;
    height: 100%;
    position: relative;
    overflow: hidden;
    border-radius: 3px;
    margin-left: 8px;
  }
  .easylogic-colorpicker.xd .control .hue > .hue-container {
    border-radius: 0px;
    overflow: hidden;
    height: 100%;
    background: -webkit-gradient(
      linear,
      left bottom,
      left top,
      from(#ff0000),
      color-stop(17%, #ffff00),
      color-stop(33%, #00ff00),
      color-stop(50%, #00ffff),
      color-stop(67%, #0000ff),
      color-stop(83%, #ff00ff),
      to(#ff0000)
    );
    background: linear-gradient(
      to top,
      #ff0000 0%,
      #ffff00 17%,
      #00ff00 33%,
      #00ffff 50%,
      #0000ff 67%,
      #ff00ff 83%,
      #ff0000 100%
    );
  }
  .easylogic-colorpicker.xd .control .opacity > .opacity-container {
    border-radius: 0px;
    overflow: hidden;
    height: 100%;
  }
  .easylogic-colorpicker.xd .control .drag-bar,
  .easylogic-colorpicker.xd .control .drag-bar2 {
    border: 0px;
    background-color: transparent;
    border: 2px solid white;
    -webkit-box-shadow: 0 0 1px 0px black, inset 0 0 1px 0px black;
    box-shadow: 0 0 1px 0px black, inset 0 0 1px 0px black;
    width: 10px;
    height: 10px;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    -webkit-transform: none;
    transform: none;
    overflow: hidden;
    left: 50%;
    -webkit-transform: translateX(-50%) translateY(-50%);
    transform: translateX(-50%) translateY(-50%);
  }
  .easylogic-colorpicker.xd .information {
    margin-top: 5px;
  }
  .easylogic-colorpicker.vscode {
    width: 336px;
    display: inline-block;
    background-color: #333;
    border: 1px solid #ececec;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    border-radius: 0px;
  }
  .easylogic-colorpicker.vscode .colorpicker-body {
    border-radius: 0px;
    display: inline-block;
  }
  .easylogic-colorpicker.vscode .colorpicker-body .color-view {
    height: 34px;
    background-color: transparent;
    background-image: linear-gradient(45deg, #ccc 25%, transparent 25%),
      linear-gradient(-45deg, #ccc 25%, transparent 25%),
      linear-gradient(45deg, transparent 75%, #ccc 75%),
      linear-gradient(-45deg, transparent 75%, #ccc 75%);
    background-size: 10px 10px;
    background-position: 0 0, 0 5px, 5px -5px, -5px 0px;
  }
  .easylogic-colorpicker.vscode
    .colorpicker-body
    .color-view
    .color-view-container {
    line-height: 34px;
    font-size: 14px;
    text-align: center;
    width: 100%;
    height: 100%;
    cursor: pointer;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    text-shadow: 0 0 3px #535353;
  }
  .easylogic-colorpicker.vscode .colorpicker-body .color-tool {
    padding: 8px;
  }
  .easylogic-colorpicker.vscode .color {
    display: inline-block;
    width: 240px;
    height: 160px;
    vertical-align: middle;
  }
  .easylogic-colorpicker.vscode .control {
    height: 160px;
    vertical-align: middle;
    display: inline-block;
    padding: 0px 0px 0px 4px;
  }
  .easylogic-colorpicker.vscode .control .hue,
  .easylogic-colorpicker.vscode .control .opacity {
    margin: 0px;
    padding: 0px;
    width: 30px;
    display: inline-block;
    vertical-align: middle;
    height: 100%;
    position: relative;
  }
  .easylogic-colorpicker.vscode .control .hue {
    padding-left: 5px;
    width: 35px;
  }
  .easylogic-colorpicker.vscode .control .hue > .hue-container {
    border-radius: 0px;
    height: 100%;
    background: -webkit-gradient(
      linear,
      left bottom,
      left top,
      from(#ff0000),
      color-stop(17%, #ffff00),
      color-stop(33%, #00ff00),
      color-stop(50%, #00ffff),
      color-stop(67%, #0000ff),
      color-stop(83%, #ff00ff),
      to(#ff0000)
    );
    background: linear-gradient(
      to top,
      #ff0000 0%,
      #ffff00 17%,
      #00ff00 33%,
      #00ffff 50%,
      #0000ff 67%,
      #ff00ff 83%,
      #ff0000 100%
    );
  }
  .easylogic-colorpicker.vscode .control .opacity > .opacity-container {
    border-radius: 0px;
    height: 100%;
    width: 30px;
  }
  .easylogic-colorpicker.vscode .control .drag-bar,
  .easylogic-colorpicker.vscode .control .drag-bar2 {
    background-color: transparent;
    height: 5px;
    width: 33px;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    -webkit-box-shadow: none;
    box-shadow: none;
    -webkit-transform: translateY(-50%) translateX(-2px);
    transform: translateY(-50%) translateX(-2px);
    border: 1px solid rgba(255, 255, 255, 0);
    border-radius: 0px;
    -webkit-box-shadow: 0 0 2px 0 black, inset 0 0 0 0 black;
    box-shadow: 0 0 2px 0 black, inset 0 0 0 0 black;
  }
  .easylogic-colorpicker.hide-colorsets .colorsets {
    display: none !important;
  }

  .colorsets-contextmenu {
    position: fixed;
    padding-top: 4px;
    padding-bottom: 4px;
    border-radius: 6px;
    background-color: #ececec;
    border: 1px solid #cccccc;
    display: none;
    list-style: none;
    font-size: 13px;
    padding-left: 0px;
    padding-right: 0px;
  }
  .colorsets-contextmenu.show {
    display: inline-block;
  }
  .colorsets-contextmenu .menu-item {
    padding: 2px 20px;
    cursor: default;
  }
  .colorsets-contextmenu .menu-item:hover {
    background-color: #5ea3fb;
    color: white;
  }
  .colorsets-contextmenu.small .menu-item.small-hide {
    display: none;
  }
`;

    /**
     * https://github.com/atomiks/tippyjs
     */
    const TippyStyle = css `
  .tippy-box[data-animation='fade'][data-state='hidden'] {
    opacity: 0;
  }
  [data-tippy-root] {
    max-width: calc(100vw - 10px);
  }
  .tippy-box {
    position: relative;
    background-color: black;
    color: #fff;
    border-radius: 4px;
    font-size: 14px;
    line-height: 1.4;
    outline: 0;
    transition-property: transform, visibility, opacity;
  }
  .tippy-box[data-placement^='top'] > .tippy-arrow {
    bottom: 0;
  }
  .tippy-box[data-placement^='top'] > .tippy-arrow:before {
    bottom: -7px;
    left: 0;
    border-width: 8px 8px 0;
    border-top-color: initial;
    transform-origin: center top;
  }
  .tippy-box[data-placement^='bottom'] > .tippy-arrow {
    top: 0;
  }
  .tippy-box[data-placement^='bottom'] > .tippy-arrow:before {
    top: -7px;
    left: 0;
    border-width: 0 8px 8px;
    border-bottom-color: initial;
    transform-origin: center bottom;
  }
  .tippy-box[data-placement^='left'] > .tippy-arrow {
    right: 0;
  }
  .tippy-box[data-placement^='left'] > .tippy-arrow:before {
    border-width: 8px 0 8px 8px;
    border-left-color: initial;
    right: -7px;
    transform-origin: center left;
  }
  .tippy-box[data-placement^='right'] > .tippy-arrow {
    left: 0;
  }
  .tippy-box[data-placement^='right'] > .tippy-arrow:before {
    left: -7px;
    border-width: 8px 8px 8px 0;
    border-right-color: initial;
    transform-origin: center right;
  }
  .tippy-box[data-inertia][data-state='visible'] {
    transition-timing-function: cubic-bezier(0.54, 1.5, 0.38, 1.11);
  }
  .tippy-arrow {
    width: 16px;
    height: 16px;
    color: black;
  }
  .tippy-arrow:before {
    content: '';
    position: absolute;
    border-color: transparent;
    border-style: solid;
  }
  .tippy-content {
    position: relative;
    padding: 5px 9px;
    z-index: 1;
    word-break: break-all;
  }
`;

    const SettingDrawerStyle = css `
  .vuerd-setting-drawer tbody tr td {
    padding-right: 20px;
    padding-bottom: 10px;
  }

  .vuerd-setting-drawer .vuerd-column-order {
    cursor: move;
    box-sizing: border-box;
    padding: 5px;
    display: inline-block;
  }
  .vuerd-setting-drawer .vuerd-column-order:hover {
    color: var(--vuerd-color-font-active);
    background-color: var(--vuerd-color-contextmenu-active);
  }
  .vuerd-setting-drawer .vuerd-column-order.draggable {
    opacity: 0.5;
  }
  .vuerd-setting-drawer .vuerd-column-order.none-hover:hover {
    color: var(--vuerd-color-font);
    background-color: var(--vuerd-color-contextmenu);
  }

  /* animation flip */
  .vuerd-setting-drawer .vuerd-column-order-move {
    transition: transform 0.3s;
  }

  .vuerd-setting-drawer .vuerd-recalculating-table-width-button {
    box-sizing: border-box;
    padding: 5px;
    display: inline-block;
    cursor: pointer;
    fill: var(--vuerd-color-font);
    font-size: 15px;
  }
  .vuerd-setting-drawer .vuerd-recalculating-table-width-button:hover {
    color: var(--vuerd-color-font-active);
    background-color: var(--vuerd-color-contextmenu-active);
    fill: var(--vuerd-color-font-active);
  }
`;

    const TablePropertiesDrawerStyle = css `
  .vuerd-table-properties {
    display: flex;
    flex-direction: column;
    height: 100%;
  }

  .vuerd-table-properties-tab {
    list-style: none;
    padding: 0;
    margin: 0;
    display: flex;
    margin-bottom: 10px;
  }
  .vuerd-table-properties-tab > li {
    padding: 10px;
    box-sizing: border-box;
    cursor: pointer;
    font-size: ${SIZE_FONT}px;
    white-space: nowrap;
    display: inline-block;
  }
  .vuerd-table-properties-tab > li:hover {
    color: var(--vuerd-color-font-active);
    background-color: var(--vuerd-color-contextmenu-active);
  }
  .vuerd-table-properties-tab > li.active {
    color: var(--vuerd-color-font-active);
    background-color: var(--vuerd-color-contextmenu-active);
  }

  .vuerd-table-properties-body {
    width: 100%;
    height: 100%;
    overflow: hidden;
  }
`;

    const ERDEditorStyle = css `
  .vuerd-editor {
    display: flex;
    flex-direction: column;
    overflow: hidden;
    background-color: #f8f8f8;
    box-sizing: border-box;
    position: relative;
  }

  .vuerd-ghost-text-helper {
    visibility: hidden;
    position: fixed;
    top: -100px;
    font-size: ${SIZE_FONT}px;
    font-family: var(--vuerd-font-family);
    white-space: nowrap;
  }

  .vuerd-ghost-focus-helper {
    position: fixed;
    top: -100px;
  }

  .easylogic-colorpicker {
    display: none;
  }

  .easylogic-colorpicker[data-show] {
    display: block;
  }
`;

    const IndexStyle$2 = [
        ColorPicker,
        TippyStyle,
        ERDEditorStyle,
        TablePropertiesDrawerStyle,
        SettingDrawerStyle,
        IconStyle,
        InputStyle,
    ].join('');

    const ERDEditor = (props, ctx) => {
        const context = createdERDEditorContext();
        const { store, helper, keymap, eventBus } = context;
        const editorRef = query('.vuerd-editor');
        const { ghostTpl, ghostState, setFocus, onFocus } = useERDEditorGhost(context, ctx);
        const { drawerTpl, closeDrawer, openHelp, openSetting, openTree } = useERDEditorDrawer(props, context);
        const { hasPanel, panelTpl } = usePanelView(props, context);
        const { showPrompt, promptTpl } = usePrompt();
        const { showAlert, alertTpl } = useAlert();
        const { unmountedGroup } = useUnmounted();
        useERDEditorElement(context, ctx, { setFocus });
        context.showPrompt = showPrompt;
        context.showAlert = showAlert;
        const resizeObserver = new ResizeObserver(entries => {
            entries.forEach((entry) => {
                const { width, height } = entry.contentRect;
                ctx.setAttribute('width', width);
                ctx.setAttribute('height', height);
            });
        });
        const onOutside = (event) => {
            const el = event.target;
            if (el.closest('vuerd-menubar') || el.closest('vuerd-drawer')) {
                store.dispatch(editTableEnd(), editFilterEnd());
            }
            if (!el.closest('vuerd-menubar') && !el.closest('vuerd-drawer')) {
                closeDrawer();
            }
        };
        mounted(() => {
            props.automaticLayout && resizeObserver.observe(editorRef.value);
            store.dispatch(readonlyEditor$(props.readonly));
            unmountedGroup.push(watch(props, propName => {
                if (propName !== 'automaticLayout')
                    return;
                if (props.automaticLayout) {
                    resizeObserver.observe(editorRef.value);
                }
                else {
                    resizeObserver.disconnect();
                }
            }), watch(props, propName => {
                if (propName !== 'width' && propName !== 'height')
                    return;
                store.dispatch(changeViewport(props.width, props.height));
            }), watch(props, propName => {
                if (propName !== 'readonly')
                    return;
                store.dispatch(readonlyEditor$(props.readonly));
            }), fromEvent(editorRef.value, 'keydown')
                .pipe(ignoreEnterProcess)
                .subscribe(event => {
                helper.keydown$.next(event);
                if (keymapMatchAndStop(event, keymap.stop)) {
                    eventBus.emit(Bus.Contextmenu.close);
                    closeDrawer();
                    onFocus();
                }
            }));
        });
        unmounted(() => {
            // globalEvent.destroy();
            // store.destroy();
            // helper.destroy();
            resizeObserver.disconnect();
        });
        return () => {
            const width = props.width;
            const height = props.height - SIZE_MENUBAR_HEIGHT;
            return html `
      <vuerd-provider .value=${context}>
        <div
          class="vuerd-editor"
          style=${styleMap({
            width: props.automaticLayout ? `100%` : `${props.width}px`,
            height: props.automaticLayout ? `100%` : `${props.height}px`,
        })}
          @mousedown=${onOutside}
          @touchstart=${onOutside}
        >
          <vuerd-menubar
            .focusState=${ghostState.focus}
            @open-help=${openHelp}
            @open-setting=${openSetting}
            @open-tree=${openTree}
          ></vuerd-menubar>
          ${cache(!hasPanel()
            ? html `<vuerd-erd .width=${width} .height=${height}></vuerd-erd>`
            : null)}
          ${panelTpl()} ${drawerTpl()} ${ghostTpl} ${promptTpl()} ${alertTpl()}
          <vuerd-toast-bar></vuerd-toast-bar>
        </div>
      </vuerd-provider>
    `;
        };
    };
    const componentOptions = {
        observedProps: [
            {
                name: 'width',
                type: Number,
                default: DEFAULT_WIDTH,
            },
            {
                name: 'height',
                type: Number,
                default: DEFAULT_HEIGHT,
            },
            {
                name: 'automaticLayout',
                type: Boolean,
                default: false,
            },
            {
                name: 'readonly',
                type: Boolean,
                default: false,
            },
        ],
        style: IndexStyle$2,
        render: ERDEditor,
    };
    defineComponent('vuerd-editor', componentOptions);
    defineComponent('erd-editor', componentOptions);

    function extension(config) {
        config.panels && addPanel(...config.panels);
        config.excludePanel && setExcludePanel(config.excludePanel);
    }

    class GeneratorCodePanel {
        constructor() {
            this.el = document.createElement('vuerd-generator-code');
        }
        render() {
            return this.el;
        }
    }

    const generatorCodePanelConfig = {
        type: GeneratorCodePanel,
        icon: {
            prefix: 'fas',
            name: 'file-code',
        },
        key: '@vuerd/builtin-generator-code',
        name: 'Generator Code',
    };
    const generatorCodePanel = () => generatorCodePanelConfig;

    defineComponent('vuerd-grid-editor-provider', {
        render: (_, ctx) => () => html `<slot></slot>`,
    });
    const getGridContext = (ctx) => getContext('vuerd-grid-editor-provider', ctx);

    function useContext(ctx) {
        const ref = { value: null };
        beforeMount(() => (ref.value = getGridContext(ctx)));
        return ref;
    }

    const radioGroupTpl = (props, { secret, activeIndex, onClick, onActiveIndex }) => html `
  <ul class="vuerd-filter-radio-group">
    ${props.items.map((item, index) => html `
        <li
          class=${classMap({ active: index === activeIndex })}
          @click=${() => onClick(item)}
          @mouseover=${() => onActiveIndex(index)}
        >
          <input
            type="radio"
            id=${`${secret}_${item.value}`}
            name=${secret}
            .value=${item.value}
            .checked=${props.value === item.value}
          />
          <label for=${`${secret}_${item.value}`}>${item.name}</label>
        </li>
      `)}
  </ul>
`;

    const FilterRadioEditor = (props, ctx) => {
        const secret = v4();
        const state = observable$1({
            activeIndex: 0,
        });
        const contextRef = useContext(ctx);
        const { unmountedGroup } = useUnmounted();
        let subscription = null;
        const getClassMap = () => ({
            'vuerd-group-value': true,
            placeholder: props.value.trim() === '' && !props.edit,
            focus: props.focusState && !props.edit,
            edit: props.edit,
            select: props.select,
        });
        const onActiveIndex = (index) => (state.activeIndex = index);
        const onKeydown$ = () => {
            const { keydown$ } = contextRef.value;
            subscription === null || subscription === void 0 ? void 0 : subscription.unsubscribe();
            subscription = keydown$.subscribe(onKeydown);
        };
        const offKeydown$ = () => subscription === null || subscription === void 0 ? void 0 : subscription.unsubscribe();
        const onClick = (item) => {
            if (props.value === item.value)
                return;
            ctx.dispatchEvent(new CustomEvent('change-radio', {
                detail: {
                    value: item.value,
                },
            }));
        };
        const onKeydown = (event) => {
            if (moveKeys.includes(event.key)) {
                event.preventDefault();
                const move = event.key === 'ArrowUp' || event.key === 'ArrowLeft' ? -1 : 1;
                let index = state.activeIndex + move;
                if (index < 0) {
                    index = props.items.length - 1;
                }
                else if (index > props.items.length - 1) {
                    index = 0;
                }
                onActiveIndex(index);
            }
            else if (event.code === 'Space') {
                onClick(props.items[state.activeIndex]);
            }
        };
        beforeMount(() => unmountedGroup.push(watch(props, propName => {
            if (propName !== 'edit')
                return;
            props.edit ? onKeydown$() : offKeydown$();
        }), offKeydown$));
        return () => html `
    <div class="vuerd-filter-radio-editor">
      <span
        class=${classMap(getClassMap())}
        style=${styleMap({
        width: `${props.width}px`,
    })}
      >
        ${props.value}
      </span>
      ${props.edit
        ? radioGroupTpl(props, {
            secret,
            activeIndex: state.activeIndex,
            onClick,
            onActiveIndex,
        })
        : null}
    </div>
  `;
    };
    defineComponent('vuerd-filter-radio-editor', {
        observedProps: [
            'items',
            {
                name: 'width',
                type: Number,
                default: 100,
            },
            {
                name: 'select',
                type: Boolean,
                default: false,
            },
            {
                name: 'edit',
                type: Boolean,
                default: false,
            },
            {
                name: 'focusState',
                type: Boolean,
                default: false,
            },
            {
                name: 'value',
                default: '',
            },
            {
                name: 'placeholder',
                default: '',
            },
        ],
        shadow: false,
        render: FilterRadioEditor,
    });

    const columnTypeRadioItems = columnTypes.map(columnType => ({
        name: columnType,
        value: columnType,
    }));
    const textFilterCodeRadioItems = textFilterCodeList.map(textFilterCode => ({
        name: textFilterCode,
        value: textFilterCode,
    }));
    const FilterItem = (props, ctx) => {
        const contextRef = useContext(ctx);
        const dragover$ = new Subject();
        useTooltip(['.vuerd-filter-item-button'], ctx, { placement: 'right' });
        const onFocus = (event, focusFilterType) => {
            const { store, command } = contextRef.value.api;
            const { focusFilter, editFilterEnd } = command.editor;
            const { focus } = store.editorState.filterState;
            const commands = [];
            if ((focus === null || focus === void 0 ? void 0 : focus.filterId) !== props.filter.id ||
                focus.focusType !== focusFilterType) {
                commands.push(editFilterEnd());
            }
            commands.push(focusFilter(props.filter.id, focusFilterType, event.ctrlKey || event.metaKey, event.shiftKey));
            store.dispatch(...commands);
        };
        const onEdit = () => {
            const { store, command } = contextRef.value.api;
            const { editFilter } = command.editor;
            store.dispatch(editFilter());
        };
        const onChangeColumnType = ({ detail: { value }, }) => {
            const { store, command } = contextRef.value.api;
            const { changeFilterColumnType } = command.editor;
            store.dispatch(changeFilterColumnType(props.filter.id, value));
        };
        const onChangeFilterCode = ({ detail: { value }, }) => {
            const { store, command } = contextRef.value.api;
            const { changeFilterCode } = command.editor;
            store.dispatch(changeFilterCode(props.filter.id, value));
        };
        const onInput = (event) => {
            const { store, command } = contextRef.value.api;
            const { changeFilterValue } = command.editor;
            const input = event.target;
            store.dispatch(changeFilterValue(props.filter.id, input.value));
        };
        const onRemoveFilter = () => {
            const { store, command } = contextRef.value.api;
            const { removeFilter$ } = command.editor;
            store.dispatch(removeFilter$(store, [props.filter.id]));
        };
        const onDragstart = (event) => {
            const { store, command } = contextRef.value.api;
            const { draggableFilter } = command.editor;
            store.dispatch(draggableFilter(store, props.filter.id, event.ctrlKey || event.metaKey));
        };
        const onDragend = () => {
            const { store, command } = contextRef.value.api;
            const { draggableFilterEnd } = command.editor;
            store.dispatch(draggableFilterEnd());
        };
        const onDragover = () => dragover$.next(null);
        const onDragoverFilter = () => ctx.dispatchEvent(new CustomEvent('dragover-filter', {
            detail: {
                filterId: props.filter.id,
            },
        }));
        dragover$.pipe(throttleTime(300)).subscribe(onDragoverFilter);
        return () => {
            const { keymap } = contextRef.value.api;
            const { filter } = props;
            return html `
      <div
        class=${classMap({
            'vuerd-filter-item': true,
            select: props.select,
            draggable: props.draggable,
        })}
        data-id=${filter.id}
        draggable="true"
        @dragstart=${onDragstart}
        @dragend=${onDragend}
        @dragover=${onDragover}
      >
        <vuerd-filter-radio-editor
          width="90"
          .items=${columnTypeRadioItems}
          .value=${filter.columnType}
          .select=${props.select}
          .focusState=${props.focusColumnType}
          .edit=${props.editColumnType}
          @change-radio=${onChangeColumnType}
          @mousedown=${(event) => onFocus(event, 'columnType')}
          @dblclick=${onEdit}
        ></vuerd-filter-radio-editor>
        <vuerd-filter-radio-editor
          width="50"
          .items=${textFilterCodeRadioItems}
          .value=${filter.filterCode}
          .select=${props.select}
          .focusState=${props.focusFilterCode}
          .edit=${props.editFilterCode}
          @change-radio=${onChangeFilterCode}
          @mousedown=${(event) => onFocus(event, 'filterCode')}
          @dblclick=${onEdit}
        >
        </vuerd-filter-radio-editor>
        <vuerd-filter-input
          width="150"
          .value=${filter.value}
          .select=${props.select}
          .focusState=${props.focusValue}
          .edit=${props.editValue}
          placeholder="value"
          @input=${onInput}
          @mousedown=${(event) => onFocus(event, 'value')}
          @dblclick=${onEdit}
        ></vuerd-filter-input>
        <vuerd-icon
          class="vuerd-button vuerd-filter-item-button"
          data-tippy-content=${keymapOptionsToString(keymap.removeColumn)}
          name="times"
          size="9"
          @click=${onRemoveFilter}
        ></vuerd-icon>
      </div>
    `;
        };
    };
    defineComponent('vuerd-filter-item', {
        observedProps: [
            'filter',
            'select',
            'draggable',
            'focusColumnType',
            'focusFilterCode',
            'focusValue',
            'editColumnType',
            'editFilterCode',
            'editValue',
        ],
        shadow: false,
        styleMap: {
            display: 'flex',
        },
        render: FilterItem,
    });

    const FilterInput = (props, ctx) => {
        const { unmountedGroup } = useUnmounted();
        const inputRef = query('input');
        const getClassMap = () => ({
            'vuerd-filter-input': true,
            placeholder: props.value.trim() === '' && !props.edit,
            focus: props.focusState && !props.edit,
            edit: props.edit,
            select: props.select,
            active: props.active,
        });
        const getPlaceholderValue = () => props.value.trim() === '' ? props.placeholder : props.value;
        const onBlur = () => ctx.dispatchEvent(new CustomEvent('vuerd-input-blur', {
            composed: true,
            bubbles: true,
        }));
        beforeMount(() => unmountedGroup.push(watch(props, propName => {
            const input = inputRef.value;
            if (propName !== 'edit' || !props.edit || !input)
                return;
            lastCursorFocus(input);
        }), 
        // firefox
        watch(props, propName => {
            if (propName !== 'edit')
                return;
            props.edit || onBlur();
        })));
        return () => props.edit
            ? html `
          <input
            class=${classMap(getClassMap())}
            style=${styleMap({
            width: `${props.width}px`,
        })}
            type="text"
            spellcheck="false"
            .value=${props.value}
            placeholder=${props.placeholder}
            @blur=${onBlur}
          />
        `
            : html `
          <div
            class=${classMap(getClassMap())}
            style=${styleMap({
            width: `${props.width}px`,
        })}
          >
            <span>${getPlaceholderValue()}</span>
          </div>
        `;
    };
    defineComponent('vuerd-filter-input', {
        observedProps: [
            {
                name: 'edit',
                type: Boolean,
                default: false,
            },
            {
                name: 'focusState',
                type: Boolean,
                default: false,
            },
            {
                name: 'select',
                type: Boolean,
                default: false,
            },
            {
                name: 'active',
                type: Boolean,
                default: false,
            },
            {
                name: 'width',
                type: Number,
                default: SIZE_MIN_WIDTH,
            },
            {
                name: 'value',
                default: '',
            },
            {
                name: 'placeholder',
                default: '',
            },
        ],
        shadow: false,
        styleMap: {
            display: 'inline-flex',
        },
        render: FilterInput,
    });

    function isFocus(focus, focusType, filterId = null) {
        if (!focus)
            return false;
        switch (focusType) {
            case 'operatorType':
                return focusType === focus.focusType;
        }
        return filterId === focus.filterId && focusType === focus.focusType;
    }
    function isEdit(focus, focusType, filterId = null) {
        if (!focus)
            return false;
        switch (focusType) {
            case 'operatorType':
                return focusType === focus.focusType && focus.edit;
        }
        return (filterId === focus.filterId && focusType === focus.focusType && focus.edit);
    }
    const isSelectFilter = (focus, filterId) => focus === null || focus === void 0 ? void 0 : focus.selectFilterIds.includes(filterId);
    const isDraggableFilter = (draggable, filterId) => draggable === null || draggable === void 0 ? void 0 : draggable.filterIds.includes(filterId);

    function useHasFilter(ctx) {
        const contextRef = useContext(ctx);
        const getFocus = () => contextRef.value.api.store.editorState.filterState.focus;
        const hasFocusState = (focusType, filterId) => isFocus(getFocus(), focusType, filterId);
        const hasEdit = (focusType, filterId) => isEdit(getFocus(), focusType, filterId);
        const hasSelectFilter = (filterId) => isSelectFilter(getFocus(), filterId);
        const hasDraggableFilter = (filterId) => {
            const draggable = contextRef.value.api.store.editorState.filterState.draggable;
            return isDraggableFilter(draggable, filterId);
        };
        return {
            hasFocusState,
            hasEdit,
            hasSelectFilter,
            hasDraggableFilter,
        };
    }

    const ANIMATION_TIME = 200;
    const HEIGHT$1 = 20 + SIZE_COLUMN_HEIGHT;
    const operatorTypeRadioItems = operatorTypes.map(operatorType => ({
        name: operatorType,
        value: operatorType,
    }));
    const Filter = (props, ctx) => {
        const contextRef = useContext(ctx);
        const state = observable$1({ top: 0, visible: false });
        const { unmountedGroup } = useUnmounted();
        const { resetTooltip } = useTooltip(['.vuerd-filter-button'], ctx);
        const { hasFocusState, hasEdit, hasSelectFilter, hasDraggableFilter } = useHasFilter(ctx);
        const flipAnimation = new FlipAnimation(ctx.shadowRoot ? ctx.shadowRoot : ctx, 'vuerd-filter-item', 'vuerd-filter-item-move');
        const draggable$ = new Subject();
        let openTween = null;
        let closeTween = null;
        const getHeight = () => {
            const { filters } = contextRef.value.api.store.editorState.filterState;
            return HEIGHT$1 + filters.length * SIZE_COLUMN_HEIGHT;
        };
        const onOpen = () => {
            if (openTween)
                return;
            closeTween === null || closeTween === void 0 ? void 0 : closeTween.stop();
            closeTween = null;
            state.visible = true;
            state.top = state.top === 0 ? -1 * getHeight() : state.top;
            openTween = new Tween(state)
                .to({ top: 0 }, ANIMATION_TIME)
                .easing(Easing.Quadratic.Out)
                .onComplete(() => (openTween = null))
                .start();
        };
        const onClose = () => {
            if (closeTween)
                return;
            openTween === null || openTween === void 0 ? void 0 : openTween.stop();
            openTween = null;
            closeTween = new Tween(state)
                .to({ top: -1 * getHeight() }, ANIMATION_TIME)
                .easing(Easing.Quadratic.In)
                .onComplete(() => {
                closeTween = null;
                state.visible = false;
                ctx.dispatchEvent(new CustomEvent('close'));
            })
                .start();
        };
        const onAddFilter = () => {
            const { store, command } = contextRef.value.api;
            const { addFilter$ } = command.editor;
            store.dispatch(addFilter$());
        };
        const onChangeOperatorType = ({ detail: { value }, }) => {
            const { store, command } = contextRef.value.api;
            const { changeFilterOperatorType } = command.editor;
            store.dispatch(changeFilterOperatorType(value));
        };
        const onFocus = () => {
            const { store, command } = contextRef.value.api;
            const { filterFocus, editFilterEnd } = command.editor;
            const { focus } = store.editorState.filterState;
            const commands = [];
            (focus === null || focus === void 0 ? void 0 : focus.focusType) !== 'operatorType' && commands.push(editFilterEnd());
            commands.push(filterFocus());
            store.dispatch(...commands);
        };
        const onEdit = () => {
            const { store, command } = contextRef.value.api;
            const { editFilter } = command.editor;
            store.dispatch(editFilter());
        };
        const onDragoverGroupFilter = (event) => draggable$.next(event);
        const onDraggableFilter = ({ detail: { filterId }, }) => {
            const { store, command } = contextRef.value.api;
            const { draggable } = store.editorState.filterState;
            const { moveFilter } = command.editor;
            if (!draggable || draggable.filterIds.includes(filterId))
                return;
            flipAnimation.snapshot();
            store.dispatch(moveFilter(draggable.filterIds, filterId));
        };
        updated(() => flipAnimation.play());
        beforeMount(() => unmountedGroup.push(draggable$.pipe(debounceTime(50)).subscribe(onDraggableFilter), watch(props, propName => {
            if (propName !== 'visible')
                return;
            props.visible ? onOpen() : onClose();
            props.visible &&
                setTimeout(() => {
                    resetTooltip();
                }, 0);
        })));
        return () => {
            const { keymap, store: { editorState: { filterState }, }, } = contextRef.value.api;
            const keymapStop = keymapOptionsToString(keymap.stop);
            return state.visible
                ? html `
          <div
            class="vuerd-filter"
            style=${styleMap({
                top: `${state.top}px`,
                height: `${getHeight()}px`,
            })}
          >
            <div class="vuerd-filter-header">
              <vuerd-filter-radio-editor
                width="50"
                .items=${operatorTypeRadioItems}
                .value=${filterState.operatorType}
                .focusState=${hasFocusState('operatorType')}
                .edit=${hasEdit('operatorType')}
                @change-radio=${onChangeOperatorType}
                @mousedown=${onFocus}
                @dblclick=${onEdit}
              ></vuerd-filter-radio-editor>
              <vuerd-icon
                class="vuerd-button vuerd-filter-button"
                data-tippy-content=${keymapStop}
                name="times"
                size="12"
                @click=${onClose}
              ></vuerd-icon>
              <vuerd-icon
                class="vuerd-button vuerd-filter-button"
                data-tippy-content=${keymapOptionsToString(keymap.addColumn)}
                name="plus"
                size="12"
                @click=${onAddFilter}
              ></vuerd-icon>
            </div>
            <div
              class="vuerd-filter-body"
              @dragenter=${onPreventDefault}
              @dragover=${onPreventDefault}
            >
              ${repeat(filterState.filters, filter => filter.id, filter => html `
                    <vuerd-filter-item
                      .filter=${filter}
                      .select=${hasSelectFilter(filter.id)}
                      .draggable=${hasDraggableFilter(filter.id)}
                      .focusColumnType=${hasFocusState('columnType', filter.id)}
                      .focusFilterCode=${hasFocusState('filterCode', filter.id)}
                      .focusValue=${hasFocusState('value', filter.id)}
                      .editColumnType=${hasEdit('columnType', filter.id)}
                      .editFilterCode=${hasEdit('filterCode', filter.id)}
                      .editValue=${hasEdit('value', filter.id)}
                      @dragover-filter=${onDragoverGroupFilter}
                    ></vuerd-filter-item>
                  `)}
            </div>
          </div>
        `
                : null;
        };
    };
    defineComponent('vuerd-filter', {
        observedProps: [
            {
                name: 'visible',
                type: Boolean,
                default: false,
            },
        ],
        shadow: false,
        render: Filter,
    });

    var tuiGrid = {exports: {}};

    var tuiDatePicker = {exports: {}};

    var tuiTimePicker = {exports: {}};

    /*!
     * TOAST UI Time Picker
     * @version 2.1.3
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     * @license MIT
     */

    (function (module, exports) {
    (function webpackUniversalModuleDefinition(root, factory) {
    	module.exports = factory();
    })(window, function() {
    return /******/ (function(modules) { // webpackBootstrap
    /******/ 	// The module cache
    /******/ 	var installedModules = {};
    /******/
    /******/ 	// The require function
    /******/ 	function __webpack_require__(moduleId) {
    /******/
    /******/ 		// Check if module is in cache
    /******/ 		if(installedModules[moduleId]) {
    /******/ 			return installedModules[moduleId].exports;
    /******/ 		}
    /******/ 		// Create a new module (and put it into the cache)
    /******/ 		var module = installedModules[moduleId] = {
    /******/ 			i: moduleId,
    /******/ 			l: false,
    /******/ 			exports: {}
    /******/ 		};
    /******/
    /******/ 		// Execute the module function
    /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    /******/
    /******/ 		// Flag the module as loaded
    /******/ 		module.l = true;
    /******/
    /******/ 		// Return the exports of the module
    /******/ 		return module.exports;
    /******/ 	}
    /******/
    /******/
    /******/ 	// expose the modules object (__webpack_modules__)
    /******/ 	__webpack_require__.m = modules;
    /******/
    /******/ 	// expose the module cache
    /******/ 	__webpack_require__.c = installedModules;
    /******/
    /******/ 	// define getter function for harmony exports
    /******/ 	__webpack_require__.d = function(exports, name, getter) {
    /******/ 		if(!__webpack_require__.o(exports, name)) {
    /******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
    /******/ 		}
    /******/ 	};
    /******/
    /******/ 	// define __esModule on exports
    /******/ 	__webpack_require__.r = function(exports) {
    /******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
    /******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
    /******/ 		}
    /******/ 		Object.defineProperty(exports, '__esModule', { value: true });
    /******/ 	};
    /******/
    /******/ 	// create a fake namespace object
    /******/ 	// mode & 1: value is a module id, require it
    /******/ 	// mode & 2: merge all properties of value into the ns
    /******/ 	// mode & 4: return value when already ns object
    /******/ 	// mode & 8|1: behave like require
    /******/ 	__webpack_require__.t = function(value, mode) {
    /******/ 		if(mode & 1) value = __webpack_require__(value);
    /******/ 		if(mode & 8) return value;
    /******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
    /******/ 		var ns = Object.create(null);
    /******/ 		__webpack_require__.r(ns);
    /******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
    /******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
    /******/ 		return ns;
    /******/ 	};
    /******/
    /******/ 	// getDefaultExport function for compatibility with non-harmony modules
    /******/ 	__webpack_require__.n = function(module) {
    /******/ 		var getter = module && module.__esModule ?
    /******/ 			function getDefault() { return module['default']; } :
    /******/ 			function getModuleExports() { return module; };
    /******/ 		__webpack_require__.d(getter, 'a', getter);
    /******/ 		return getter;
    /******/ 	};
    /******/
    /******/ 	// Object.prototype.hasOwnProperty.call
    /******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
    /******/
    /******/ 	// __webpack_public_path__
    /******/ 	__webpack_require__.p = "dist";
    /******/
    /******/
    /******/ 	// Load entry module and return exports
    /******/ 	return __webpack_require__(__webpack_require__.s = 20);
    /******/ })
    /************************************************************************/
    /******/ ([
    /* 0 */
    /***/ (function(module, exports, __webpack_require__) {
    /* eslint-disable complexity */
    /**
     * @fileoverview Returns the first index at which a given element can be found in the array.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var isArray = __webpack_require__(3);

    /**
     * @module array
     */

    /**
     * Returns the first index at which a given element can be found in the array
     * from start index(default 0), or -1 if it is not present.
     * It compares searchElement to elements of the Array using strict equality
     * (the same method used by the ===, or triple-equals, operator).
     * @param {*} searchElement Element to locate in the array
     * @param {Array} array Array that will be traversed.
     * @param {number} startIndex Start index in array for searching (default 0)
     * @returns {number} the First index at which a given element, or -1 if it is not present
     * @memberof module:array
     * @example
     * var inArray = require('tui-code-snippet/array/inArray'); // node, commonjs
     *
     * var arr = ['one', 'two', 'three', 'four'];
     * var idx1 = inArray('one', arr, 3); // -1
     * var idx2 = inArray('one', arr); // 0
     */
    function inArray(searchElement, array, startIndex) {
      var i;
      var length;
      startIndex = startIndex || 0;

      if (!isArray(array)) {
        return -1;
      }

      if (Array.prototype.indexOf) {
        return Array.prototype.indexOf.call(array, searchElement, startIndex);
      }

      length = array.length;
      for (i = startIndex; startIndex >= 0 && i < length; i += 1) {
        if (array[i] === searchElement) {
          return i;
        }
      }

      return -1;
    }

    module.exports = inArray;


    /***/ }),
    /* 1 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Execute the provided callback once for each element present in the array(or Array-like object) in ascending order.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Execute the provided callback once for each element present
     * in the array(or Array-like object) in ascending order.
     * If the callback function returns false, the loop will be stopped.
     * Callback function(iteratee) is invoked with three arguments:
     *  1) The value of the element
     *  2) The index of the element
     *  3) The array(or Array-like object) being traversed
     * @param {Array|Arguments|NodeList} arr The array(or Array-like object) that will be traversed
     * @param {function} iteratee Callback function
     * @param {Object} [context] Context(this) of callback function
     * @memberof module:collection
     * @example
     * var forEachArray = require('tui-code-snippet/collection/forEachArray'); // node, commonjs
     *
     * var sum = 0;
     *
     * forEachArray([1,2,3], function(value){
     *     sum += value;
     * });
     * alert(sum); // 6
     */
    function forEachArray(arr, iteratee, context) {
      var index = 0;
      var len = arr.length;

      context = context || null;

      for (; index < len; index += 1) {
        if (iteratee.call(context, arr[index], index, arr) === false) {
          break;
        }
      }
    }

    module.exports = forEachArray;


    /***/ }),
    /* 2 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Extend the target object from other objects.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * @module object
     */

    /**
     * Extend the target object from other objects.
     * @param {object} target - Object that will be extended
     * @param {...object} objects - Objects as sources
     * @returns {object} Extended object
     * @memberof module:object
     */
    function extend(target, objects) { // eslint-disable-line no-unused-vars
      var hasOwnProp = Object.prototype.hasOwnProperty;
      var source, prop, i, len;

      for (i = 1, len = arguments.length; i < len; i += 1) {
        source = arguments[i];
        for (prop in source) {
          if (hasOwnProp.call(source, prop)) {
            target[prop] = source[prop];
          }
        }
      }

      return target;
    }

    module.exports = extend;


    /***/ }),
    /* 3 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is an instance of Array or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Check whether the given variable is an instance of Array or not.
     * If the given variable is an instance of Array, return true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is array instance?
     * @memberof module:type
     */
    function isArray(obj) {
      return obj instanceof Array;
    }

    module.exports = isArray;


    /***/ }),
    /* 4 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Execute the provided callback once for each property of object(or element of array) which actually exist.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var isArray = __webpack_require__(3);
    var forEachArray = __webpack_require__(1);
    var forEachOwnProperties = __webpack_require__(16);

    /**
     * @module collection
     */

    /**
     * Execute the provided callback once for each property of object(or element of array) which actually exist.
     * If the object is Array-like object(ex-arguments object), It needs to transform to Array.(see 'ex2' of example).
     * If the callback function returns false, the loop will be stopped.
     * Callback function(iteratee) is invoked with three arguments:
     *  1) The value of the property(or The value of the element)
     *  2) The name of the property(or The index of the element)
     *  3) The object being traversed
     * @param {Object} obj The object that will be traversed
     * @param {function} iteratee Callback function
     * @param {Object} [context] Context(this) of callback function
     * @memberof module:collection
     * @example
     * var forEach = require('tui-code-snippet/collection/forEach'); // node, commonjs
     *
     * var sum = 0;
     *
     * forEach([1,2,3], function(value){
     *     sum += value;
     * });
     * alert(sum); // 6
     *
     * // In case of Array-like object
     * var array = Array.prototype.slice.call(arrayLike); // change to array
     * forEach(array, function(value){
     *     sum += value;
     * });
     */
    function forEach(obj, iteratee, context) {
      if (isArray(obj)) {
        forEachArray(obj, iteratee, context);
      } else {
        forEachOwnProperties(obj, iteratee, context);
      }
    }

    module.exports = forEach;


    /***/ }),
    /* 5 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is undefined or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Check whether the given variable is undefined or not.
     * If the given variable is undefined, returns true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is undefined?
     * @memberof module:type
     */
    function isUndefined(obj) {
      return obj === undefined; // eslint-disable-line no-undefined
    }

    module.exports = isUndefined;


    /***/ }),
    /* 6 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is a string or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Check whether the given variable is a string or not.
     * If the given variable is a string, return true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is string?
     * @memberof module:type
     */
    function isString(obj) {
      return typeof obj === 'string' || obj instanceof String;
    }

    module.exports = isString;


    /***/ }),
    /* 7 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Convert text by binding expressions with context.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var inArray = __webpack_require__(0);
    var forEach = __webpack_require__(4);
    var isArray = __webpack_require__(3);
    var isString = __webpack_require__(6);
    var extend = __webpack_require__(2);

    // IE8 does not support capture groups.
    var EXPRESSION_REGEXP = /{{\s?|\s?}}/g;
    var BRACKET_NOTATION_REGEXP = /^[a-zA-Z0-9_@]+\[[a-zA-Z0-9_@"']+\]$/;
    var BRACKET_REGEXP = /\[\s?|\s?\]/;
    var DOT_NOTATION_REGEXP = /^[a-zA-Z_]+\.[a-zA-Z_]+$/;
    var DOT_REGEXP = /\./;
    var STRING_NOTATION_REGEXP = /^["']\w+["']$/;
    var STRING_REGEXP = /"|'/g;
    var NUMBER_REGEXP = /^-?\d+\.?\d*$/;

    var EXPRESSION_INTERVAL = 2;

    var BLOCK_HELPERS = {
      'if': handleIf,
      'each': handleEach,
      'with': handleWith
    };

    var isValidSplit = 'a'.split(/a/).length === 3;

    /**
     * Split by RegExp. (Polyfill for IE8)
     * @param {string} text - text to be splitted\
     * @param {RegExp} regexp - regular expression
     * @returns {Array.<string>}
     */
    var splitByRegExp = (function() {
      if (isValidSplit) {
        return function(text, regexp) {
          return text.split(regexp);
        };
      }

      return function(text, regexp) {
        var result = [];
        var prevIndex = 0;
        var match, index;

        if (!regexp.global) {
          regexp = new RegExp(regexp, 'g');
        }

        match = regexp.exec(text);
        while (match !== null) {
          index = match.index;
          result.push(text.slice(prevIndex, index));

          prevIndex = index + match[0].length;
          match = regexp.exec(text);
        }
        result.push(text.slice(prevIndex));

        return result;
      };
    })();

    /**
     * Find value in the context by an expression.
     * @param {string} exp - an expression
     * @param {object} context - context
     * @returns {*}
     * @private
     */
    // eslint-disable-next-line complexity
    function getValueFromContext(exp, context) {
      var splitedExps;
      var value = context[exp];

      if (exp === 'true') {
        value = true;
      } else if (exp === 'false') {
        value = false;
      } else if (STRING_NOTATION_REGEXP.test(exp)) {
        value = exp.replace(STRING_REGEXP, '');
      } else if (BRACKET_NOTATION_REGEXP.test(exp)) {
        splitedExps = exp.split(BRACKET_REGEXP);
        value = getValueFromContext(splitedExps[0], context)[getValueFromContext(splitedExps[1], context)];
      } else if (DOT_NOTATION_REGEXP.test(exp)) {
        splitedExps = exp.split(DOT_REGEXP);
        value = getValueFromContext(splitedExps[0], context)[splitedExps[1]];
      } else if (NUMBER_REGEXP.test(exp)) {
        value = parseFloat(exp);
      }

      return value;
    }

    /**
     * Extract elseif and else expressions.
     * @param {Array.<string>} ifExps - args of if expression
     * @param {Array.<string>} sourcesInsideBlock - sources inside if block
     * @returns {object} - exps: expressions of if, elseif, and else / sourcesInsideIf: sources inside if, elseif, and else block.
     * @private
     */
    function extractElseif(ifExps, sourcesInsideBlock) {
      var exps = [ifExps];
      var sourcesInsideIf = [];
      var otherIfCount = 0;
      var start = 0;

      // eslint-disable-next-line complexity
      forEach(sourcesInsideBlock, function(source, index) {
        if (source.indexOf('if') === 0) {
          otherIfCount += 1;
        } else if (source === '/if') {
          otherIfCount -= 1;
        } else if (!otherIfCount && (source.indexOf('elseif') === 0 || source === 'else')) {
          exps.push(source === 'else' ? ['true'] : source.split(' ').slice(1));
          sourcesInsideIf.push(sourcesInsideBlock.slice(start, index));
          start = index + 1;
        }
      });

      sourcesInsideIf.push(sourcesInsideBlock.slice(start));

      return {
        exps: exps,
        sourcesInsideIf: sourcesInsideIf
      };
    }

    /**
     * Helper function for "if". 
     * @param {Array.<string>} exps - array of expressions split by spaces
     * @param {Array.<string>} sourcesInsideBlock - array of sources inside the if block
     * @param {object} context - context
     * @returns {string}
     * @private
     */
    function handleIf(exps, sourcesInsideBlock, context) {
      var analyzed = extractElseif(exps, sourcesInsideBlock);
      var result = false;
      var compiledSource = '';

      forEach(analyzed.exps, function(exp, index) {
        result = handleExpression(exp, context);
        if (result) {
          compiledSource = compile(analyzed.sourcesInsideIf[index], context);
        }

        return !result;
      });

      return compiledSource;
    }

    /**
     * Helper function for "each".
     * @param {Array.<string>} exps - array of expressions split by spaces
     * @param {Array.<string>} sourcesInsideBlock - array of sources inside the each block
     * @param {object} context - context
     * @returns {string}
     * @private
     */
    function handleEach(exps, sourcesInsideBlock, context) {
      var collection = handleExpression(exps, context);
      var additionalKey = isArray(collection) ? '@index' : '@key';
      var additionalContext = {};
      var result = '';

      forEach(collection, function(item, key) {
        additionalContext[additionalKey] = key;
        additionalContext['@this'] = item;
        extend(context, additionalContext);

        result += compile(sourcesInsideBlock.slice(), context);
      });

      return result;
    }

    /**
     * Helper function for "with ... as"
     * @param {Array.<string>} exps - array of expressions split by spaces
     * @param {Array.<string>} sourcesInsideBlock - array of sources inside the with block
     * @param {object} context - context
     * @returns {string}
     * @private
     */
    function handleWith(exps, sourcesInsideBlock, context) {
      var asIndex = inArray('as', exps);
      var alias = exps[asIndex + 1];
      var result = handleExpression(exps.slice(0, asIndex), context);

      var additionalContext = {};
      additionalContext[alias] = result;

      return compile(sourcesInsideBlock, extend(context, additionalContext)) || '';
    }

    /**
     * Extract sources inside block in place.
     * @param {Array.<string>} sources - array of sources
     * @param {number} start - index of start block
     * @param {number} end - index of end block
     * @returns {Array.<string>}
     * @private
     */
    function extractSourcesInsideBlock(sources, start, end) {
      var sourcesInsideBlock = sources.splice(start + 1, end - start);
      sourcesInsideBlock.pop();

      return sourcesInsideBlock;
    }

    /**
     * Handle block helper function
     * @param {string} helperKeyword - helper keyword (ex. if, each, with)
     * @param {Array.<string>} sourcesToEnd - array of sources after the starting block
     * @param {object} context - context
     * @returns {Array.<string>}
     * @private
     */
    function handleBlockHelper(helperKeyword, sourcesToEnd, context) {
      var executeBlockHelper = BLOCK_HELPERS[helperKeyword];
      var helperCount = 1;
      var startBlockIndex = 0;
      var endBlockIndex;
      var index = startBlockIndex + EXPRESSION_INTERVAL;
      var expression = sourcesToEnd[index];

      while (helperCount && isString(expression)) {
        if (expression.indexOf(helperKeyword) === 0) {
          helperCount += 1;
        } else if (expression.indexOf('/' + helperKeyword) === 0) {
          helperCount -= 1;
          endBlockIndex = index;
        }

        index += EXPRESSION_INTERVAL;
        expression = sourcesToEnd[index];
      }

      if (helperCount) {
        throw Error(helperKeyword + ' needs {{/' + helperKeyword + '}} expression.');
      }

      sourcesToEnd[startBlockIndex] = executeBlockHelper(
        sourcesToEnd[startBlockIndex].split(' ').slice(1),
        extractSourcesInsideBlock(sourcesToEnd, startBlockIndex, endBlockIndex),
        context
      );

      return sourcesToEnd;
    }

    /**
     * Helper function for "custom helper".
     * If helper is not a function, return helper itself.
     * @param {Array.<string>} exps - array of expressions split by spaces (first element: helper)
     * @param {object} context - context
     * @returns {string}
     * @private
     */
    function handleExpression(exps, context) {
      var result = getValueFromContext(exps[0], context);

      if (result instanceof Function) {
        return executeFunction(result, exps.slice(1), context);
      }

      return result;
    }

    /**
     * Execute a helper function.
     * @param {Function} helper - helper function
     * @param {Array.<string>} argExps - expressions of arguments
     * @param {object} context - context
     * @returns {string} - result of executing the function with arguments
     * @private
     */
    function executeFunction(helper, argExps, context) {
      var args = [];
      forEach(argExps, function(exp) {
        args.push(getValueFromContext(exp, context));
      });

      return helper.apply(null, args);
    }

    /**
     * Get a result of compiling an expression with the context.
     * @param {Array.<string>} sources - array of sources split by regexp of expression.
     * @param {object} context - context
     * @returns {Array.<string>} - array of sources that bind with its context
     * @private
     */
    function compile(sources, context) {
      var index = 1;
      var expression = sources[index];
      var exps, firstExp, result;

      while (isString(expression)) {
        exps = expression.split(' ');
        firstExp = exps[0];

        if (BLOCK_HELPERS[firstExp]) {
          result = handleBlockHelper(firstExp, sources.splice(index, sources.length - index), context);
          sources = sources.concat(result);
        } else {
          sources[index] = handleExpression(exps, context);
        }

        index += EXPRESSION_INTERVAL;
        expression = sources[index];
      }

      return sources.join('');
    }

    /**
     * Convert text by binding expressions with context.
     * <br>
     * If expression exists in the context, it will be replaced.
     * ex) '{{title}}' with context {title: 'Hello!'} is converted to 'Hello!'.
     * An array or object can be accessed using bracket and dot notation.
     * ex) '{{odds\[2\]}}' with context {odds: \[1, 3, 5\]} is converted to '5'.
     * ex) '{{evens\[first\]}}' with context {evens: \[2, 4\], first: 0} is converted to '2'.
     * ex) '{{project\["name"\]}}' and '{{project.name}}' with context {project: {name: 'CodeSnippet'}} is converted to 'CodeSnippet'.
     * <br>
     * If replaced expression is a function, next expressions will be arguments of the function.
     * ex) '{{add 1 2}}' with context {add: function(a, b) {return a + b;}} is converted to '3'.
     * <br>
     * It has 3 predefined block helpers '{{helper ...}} ... {{/helper}}': 'if', 'each', 'with ... as ...'.
     * 1) 'if' evaluates conditional statements. It can use with 'elseif' and 'else'.
     * 2) 'each' iterates an array or object. It provides '@index'(array), '@key'(object), and '@this'(current element).
     * 3) 'with ... as ...' provides an alias.
     * @param {string} text - text with expressions
     * @param {object} context - context
     * @returns {string} - text that bind with its context
     * @memberof module:domUtil
     * @example
     * var template = require('tui-code-snippet/domUtil/template');
     * 
     * var source = 
     *     '<h1>'
     *   +   '{{if isValidNumber title}}'
     *   +     '{{title}}th'
     *   +   '{{elseif isValidDate title}}'
     *   +     'Date: {{title}}'
     *   +   '{{/if}}'
     *   + '</h1>'
     *   + '{{each list}}'
     *   +   '{{with addOne @index as idx}}'
     *   +     '<p>{{idx}}: {{@this}}</p>'
     *   +   '{{/with}}'
     *   + '{{/each}}';
     * 
     * var context = {
     *   isValidDate: function(text) {
     *     return /^\d{4}-(0|1)\d-(0|1|2|3)\d$/.test(text);
     *   },
     *   isValidNumber: function(text) {
     *     return /^\d+$/.test(text);
     *   }
     *   title: '2019-11-25',
     *   list: ['Clean the room', 'Wash the dishes'],
     *   addOne: function(num) {
     *     return num + 1;
     *   }
     * };
     * 
     * var result = template(source, context);
     * console.log(result); // <h1>Date: 2019-11-25</h1><p>1: Clean the room</p><p>2: Wash the dishes</p>
     */
    function template(text, context) {
      return compile(splitByRegExp(text, EXPRESSION_REGEXP), context);
    }

    module.exports = template;


    /***/ }),
    /* 8 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview This module provides some functions for custom events. And it is implemented in the observer design pattern.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var extend = __webpack_require__(2);
    var isExisty = __webpack_require__(23);
    var isString = __webpack_require__(6);
    var isObject = __webpack_require__(25);
    var isArray = __webpack_require__(3);
    var isFunction = __webpack_require__(26);
    var forEach = __webpack_require__(4);

    var R_EVENTNAME_SPLIT = /\s+/g;

    /**
     * @class
     * @example
     * // node, commonjs
     * var CustomEvents = require('tui-code-snippet/customEvents/customEvents');
     */
    function CustomEvents() {
      /**
         * @type {HandlerItem[]}
         */
      this.events = null;

      /**
         * only for checking specific context event was binded
         * @type {object[]}
         */
      this.contexts = null;
    }

    /**
     * Mixin custom events feature to specific constructor
     * @param {function} func - constructor
     * @example
     * var CustomEvents = require('tui-code-snippet/customEvents/customEvents'); // node, commonjs
     *
     * var model;
     * function Model() {
     *     this.name = '';
     * }
     * CustomEvents.mixin(Model);
     *
     * model = new Model();
     * model.on('change', function() { this.name = 'model'; }, this);
     * model.fire('change');
     * alert(model.name); // 'model';
     */
    CustomEvents.mixin = function(func) {
      extend(func.prototype, CustomEvents.prototype);
    };

    /**
     * Get HandlerItem object
     * @param {function} handler - handler function
     * @param {object} [context] - context for handler
     * @returns {HandlerItem} HandlerItem object
     * @private
     */
    CustomEvents.prototype._getHandlerItem = function(handler, context) {
      var item = {handler: handler};

      if (context) {
        item.context = context;
      }

      return item;
    };

    /**
     * Get event object safely
     * @param {string} [eventName] - create sub event map if not exist.
     * @returns {(object|array)} event object. if you supplied `eventName`
     *  parameter then make new array and return it
     * @private
     */
    CustomEvents.prototype._safeEvent = function(eventName) {
      var events = this.events;
      var byName;

      if (!events) {
        events = this.events = {};
      }

      if (eventName) {
        byName = events[eventName];

        if (!byName) {
          byName = [];
          events[eventName] = byName;
        }

        events = byName;
      }

      return events;
    };

    /**
     * Get context array safely
     * @returns {array} context array
     * @private
     */
    CustomEvents.prototype._safeContext = function() {
      var context = this.contexts;

      if (!context) {
        context = this.contexts = [];
      }

      return context;
    };

    /**
     * Get index of context
     * @param {object} ctx - context that used for bind custom event
     * @returns {number} index of context
     * @private
     */
    CustomEvents.prototype._indexOfContext = function(ctx) {
      var context = this._safeContext();
      var index = 0;

      while (context[index]) {
        if (ctx === context[index][0]) {
          return index;
        }

        index += 1;
      }

      return -1;
    };

    /**
     * Memorize supplied context for recognize supplied object is context or
     *  name: handler pair object when off()
     * @param {object} ctx - context object to memorize
     * @private
     */
    CustomEvents.prototype._memorizeContext = function(ctx) {
      var context, index;

      if (!isExisty(ctx)) {
        return;
      }

      context = this._safeContext();
      index = this._indexOfContext(ctx);

      if (index > -1) {
        context[index][1] += 1;
      } else {
        context.push([ctx, 1]);
      }
    };

    /**
     * Forget supplied context object
     * @param {object} ctx - context object to forget
     * @private
     */
    CustomEvents.prototype._forgetContext = function(ctx) {
      var context, contextIndex;

      if (!isExisty(ctx)) {
        return;
      }

      context = this._safeContext();
      contextIndex = this._indexOfContext(ctx);

      if (contextIndex > -1) {
        context[contextIndex][1] -= 1;

        if (context[contextIndex][1] <= 0) {
          context.splice(contextIndex, 1);
        }
      }
    };

    /**
     * Bind event handler
     * @param {(string|{name:string, handler:function})} eventName - custom
     *  event name or an object {eventName: handler}
     * @param {(function|object)} [handler] - handler function or context
     * @param {object} [context] - context for binding
     * @private
     */
    CustomEvents.prototype._bindEvent = function(eventName, handler, context) {
      var events = this._safeEvent(eventName);
      this._memorizeContext(context);
      events.push(this._getHandlerItem(handler, context));
    };

    /**
     * Bind event handlers
     * @param {(string|{name:string, handler:function})} eventName - custom
     *  event name or an object {eventName: handler}
     * @param {(function|object)} [handler] - handler function or context
     * @param {object} [context] - context for binding
     * //-- #1. Get Module --//
     * var CustomEvents = require('tui-code-snippet/customEvents/customEvents'); // node, commonjs
     *
     * //-- #2. Use method --//
     * // # 2.1 Basic Usage
     * CustomEvents.on('onload', handler);
     *
     * // # 2.2 With context
     * CustomEvents.on('onload', handler, myObj);
     *
     * // # 2.3 Bind by object that name, handler pairs
     * CustomEvents.on({
     *     'play': handler,
     *     'pause': handler2
     * });
     *
     * // # 2.4 Bind by object that name, handler pairs with context object
     * CustomEvents.on({
     *     'play': handler
     * }, myObj);
     */
    CustomEvents.prototype.on = function(eventName, handler, context) {
      var self = this;

      if (isString(eventName)) {
        // [syntax 1, 2]
        eventName = eventName.split(R_EVENTNAME_SPLIT);
        forEach(eventName, function(name) {
          self._bindEvent(name, handler, context);
        });
      } else if (isObject(eventName)) {
        // [syntax 3, 4]
        context = handler;
        forEach(eventName, function(func, name) {
          self.on(name, func, context);
        });
      }
    };

    /**
     * Bind one-shot event handlers
     * @param {(string|{name:string,handler:function})} eventName - custom
     *  event name or an object {eventName: handler}
     * @param {function|object} [handler] - handler function or context
     * @param {object} [context] - context for binding
     */
    CustomEvents.prototype.once = function(eventName, handler, context) {
      var self = this;

      if (isObject(eventName)) {
        context = handler;
        forEach(eventName, function(func, name) {
          self.once(name, func, context);
        });

        return;
      }

      function onceHandler() { // eslint-disable-line require-jsdoc
        handler.apply(context, arguments);
        self.off(eventName, onceHandler, context);
      }

      this.on(eventName, onceHandler, context);
    };

    /**
     * Splice supplied array by callback result
     * @param {array} arr - array to splice
     * @param {function} predicate - function return boolean
     * @private
     */
    CustomEvents.prototype._spliceMatches = function(arr, predicate) {
      var i = 0;
      var len;

      if (!isArray(arr)) {
        return;
      }

      for (len = arr.length; i < len; i += 1) {
        if (predicate(arr[i]) === true) {
          arr.splice(i, 1);
          len -= 1;
          i -= 1;
        }
      }
    };

    /**
     * Get matcher for unbind specific handler events
     * @param {function} handler - handler function
     * @returns {function} handler matcher
     * @private
     */
    CustomEvents.prototype._matchHandler = function(handler) {
      var self = this;

      return function(item) {
        var needRemove = handler === item.handler;

        if (needRemove) {
          self._forgetContext(item.context);
        }

        return needRemove;
      };
    };

    /**
     * Get matcher for unbind specific context events
     * @param {object} context - context
     * @returns {function} object matcher
     * @private
     */
    CustomEvents.prototype._matchContext = function(context) {
      var self = this;

      return function(item) {
        var needRemove = context === item.context;

        if (needRemove) {
          self._forgetContext(item.context);
        }

        return needRemove;
      };
    };

    /**
     * Get matcher for unbind specific hander, context pair events
     * @param {function} handler - handler function
     * @param {object} context - context
     * @returns {function} handler, context matcher
     * @private
     */
    CustomEvents.prototype._matchHandlerAndContext = function(handler, context) {
      var self = this;

      return function(item) {
        var matchHandler = (handler === item.handler);
        var matchContext = (context === item.context);
        var needRemove = (matchHandler && matchContext);

        if (needRemove) {
          self._forgetContext(item.context);
        }

        return needRemove;
      };
    };

    /**
     * Unbind event by event name
     * @param {string} eventName - custom event name to unbind
     * @param {function} [handler] - handler function
     * @private
     */
    CustomEvents.prototype._offByEventName = function(eventName, handler) {
      var self = this;
      var andByHandler = isFunction(handler);
      var matchHandler = self._matchHandler(handler);

      eventName = eventName.split(R_EVENTNAME_SPLIT);

      forEach(eventName, function(name) {
        var handlerItems = self._safeEvent(name);

        if (andByHandler) {
          self._spliceMatches(handlerItems, matchHandler);
        } else {
          forEach(handlerItems, function(item) {
            self._forgetContext(item.context);
          });

          self.events[name] = [];
        }
      });
    };

    /**
     * Unbind event by handler function
     * @param {function} handler - handler function
     * @private
     */
    CustomEvents.prototype._offByHandler = function(handler) {
      var self = this;
      var matchHandler = this._matchHandler(handler);

      forEach(this._safeEvent(), function(handlerItems) {
        self._spliceMatches(handlerItems, matchHandler);
      });
    };

    /**
     * Unbind event by object(name: handler pair object or context object)
     * @param {object} obj - context or {name: handler} pair object
     * @param {function} handler - handler function
     * @private
     */
    CustomEvents.prototype._offByObject = function(obj, handler) {
      var self = this;
      var matchFunc;

      if (this._indexOfContext(obj) < 0) {
        forEach(obj, function(func, name) {
          self.off(name, func);
        });
      } else if (isString(handler)) {
        matchFunc = this._matchContext(obj);

        self._spliceMatches(this._safeEvent(handler), matchFunc);
      } else if (isFunction(handler)) {
        matchFunc = this._matchHandlerAndContext(handler, obj);

        forEach(this._safeEvent(), function(handlerItems) {
          self._spliceMatches(handlerItems, matchFunc);
        });
      } else {
        matchFunc = this._matchContext(obj);

        forEach(this._safeEvent(), function(handlerItems) {
          self._spliceMatches(handlerItems, matchFunc);
        });
      }
    };

    /**
     * Unbind custom events
     * @param {(string|object|function)} eventName - event name or context or
     *  {name: handler} pair object or handler function
     * @param {(function)} handler - handler function
     * @example
     * //-- #1. Get Module --//
     * var CustomEvents = require('tui-code-snippet/customEvents/customEvents'); // node, commonjs
     *
     * //-- #2. Use method --//
     * // # 2.1 off by event name
     * CustomEvents.off('onload');
     *
     * // # 2.2 off by event name and handler
     * CustomEvents.off('play', handler);
     *
     * // # 2.3 off by handler
     * CustomEvents.off(handler);
     *
     * // # 2.4 off by context
     * CustomEvents.off(myObj);
     *
     * // # 2.5 off by context and handler
     * CustomEvents.off(myObj, handler);
     *
     * // # 2.6 off by context and event name
     * CustomEvents.off(myObj, 'onload');
     *
     * // # 2.7 off by an Object.<string, function> that is {eventName: handler}
     * CustomEvents.off({
     *   'play': handler,
     *   'pause': handler2
     * });
     *
     * // # 2.8 off the all events
     * CustomEvents.off();
     */
    CustomEvents.prototype.off = function(eventName, handler) {
      if (isString(eventName)) {
        // [syntax 1, 2]
        this._offByEventName(eventName, handler);
      } else if (!arguments.length) {
        // [syntax 8]
        this.events = {};
        this.contexts = [];
      } else if (isFunction(eventName)) {
        // [syntax 3]
        this._offByHandler(eventName);
      } else if (isObject(eventName)) {
        // [syntax 4, 5, 6]
        this._offByObject(eventName, handler);
      }
    };

    /**
     * Fire custom event
     * @param {string} eventName - name of custom event
     */
    CustomEvents.prototype.fire = function(eventName) {  // eslint-disable-line
      this.invoke.apply(this, arguments);
    };

    /**
     * Fire a event and returns the result of operation 'boolean AND' with all
     *  listener's results.
     *
     * So, It is different from {@link CustomEvents#fire}.
     *
     * In service code, use this as a before event in component level usually
     *  for notifying that the event is cancelable.
     * @param {string} eventName - Custom event name
     * @param {...*} data - Data for event
     * @returns {boolean} The result of operation 'boolean AND'
     * @example
     * var map = new Map();
     * map.on({
     *     'beforeZoom': function() {
     *         // It should cancel the 'zoom' event by some conditions.
     *         if (that.disabled && this.getState()) {
     *             return false;
     *         }
     *         return true;
     *     }
     * });
     *
     * if (this.invoke('beforeZoom')) {    // check the result of 'beforeZoom'
     *     // if true,
     *     // doSomething
     * }
     */
    CustomEvents.prototype.invoke = function(eventName) {
      var events, args, index, item;

      if (!this.hasListener(eventName)) {
        return true;
      }

      events = this._safeEvent(eventName);
      args = Array.prototype.slice.call(arguments, 1);
      index = 0;

      while (events[index]) {
        item = events[index];

        if (item.handler.apply(item.context, args) === false) {
          return false;
        }

        index += 1;
      }

      return true;
    };

    /**
     * Return whether at least one of the handlers is registered in the given
     *  event name.
     * @param {string} eventName - Custom event name
     * @returns {boolean} Is there at least one handler in event name?
     */
    CustomEvents.prototype.hasListener = function(eventName) {
      return this.getListenerLength(eventName) > 0;
    };

    /**
     * Return a count of events registered.
     * @param {string} eventName - Custom event name
     * @returns {number} number of event
     */
    CustomEvents.prototype.getListenerLength = function(eventName) {
      var events = this._safeEvent(eventName);

      return events.length;
    };

    module.exports = CustomEvents;


    /***/ }),
    /* 9 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview
     * This module provides a function to make a constructor
     * that can inherit from the other constructors like the CLASS easily.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var inherit = __webpack_require__(27);
    var extend = __webpack_require__(2);

    /**
     * @module defineClass
     */

    /**
     * Help a constructor to be defined and to inherit from the other constructors
     * @param {*} [parent] Parent constructor
     * @param {Object} props Members of constructor
     *  @param {Function} props.init Initialization method
     *  @param {Object} [props.static] Static members of constructor
     * @returns {*} Constructor
     * @memberof module:defineClass
     * @example
     * var defineClass = require('tui-code-snippet/defineClass/defineClass'); // node, commonjs
     *
     * //-- #2. Use property --//
     * var Parent = defineClass({
     *     init: function() { // constuructor
     *         this.name = 'made by def';
     *     },
     *     method: function() {
     *         // ...
     *     },
     *     static: {
     *         staticMethod: function() {
     *              // ...
     *         }
     *     }
     * });
     *
     * var Child = defineClass(Parent, {
     *     childMethod: function() {}
     * });
     *
     * Parent.staticMethod();
     *
     * var parentInstance = new Parent();
     * console.log(parentInstance.name); //made by def
     * parentInstance.staticMethod(); // Error
     *
     * var childInstance = new Child();
     * childInstance.method();
     * childInstance.childMethod();
     */
    function defineClass(parent, props) {
      var obj;

      if (!props) {
        props = parent;
        parent = null;
      }

      obj = props.init || function() {};

      if (parent) {
        inherit(obj, parent);
      }

      if (props.hasOwnProperty('static')) {
        extend(obj, props['static']);
        delete props['static'];
      }

      extend(obj.prototype, props);

      return obj;
    }

    module.exports = defineClass;


    /***/ }),
    /* 10 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Bind DOM events
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var isString = __webpack_require__(6);
    var forEach = __webpack_require__(4);

    var safeEvent = __webpack_require__(17);

    /**
     * Bind DOM events.
     * @param {HTMLElement} element - element to bind events
     * @param {(string|object)} types - Space splitted events names or eventName:handler object
     * @param {(function|object)} handler - handler function or context for handler method
     * @param {object} [context] context - context for handler method.
     * @memberof module:domEvent
     * @example
     * var div = document.querySelector('div');
     * 
     * // Bind one event to an element.
     * on(div, 'click', toggle);
     * 
     * // Bind multiple events with a same handler to multiple elements at once.
     * // Use event names splitted by a space.
     * on(div, 'mouseenter mouseleave', changeColor);
     * 
     * // Bind multiple events with different handlers to an element at once.
     * // Use an object which of key is an event name and value is a handler function.
     * on(div, {
     *   keydown: highlight,
     *   keyup: dehighlight
     * });
     * 
     * // Set a context for handler method.
     * var name = 'global';
     * var repository = {name: 'CodeSnippet'};
     * on(div, 'drag', function() {
     *  console.log(this.name);
     * }, repository);
     * // Result when you drag a div: "CodeSnippet"
     */
    function on(element, types, handler, context) {
      if (isString(types)) {
        forEach(types.split(/\s+/g), function(type) {
          bindEvent(element, type, handler, context);
        });

        return;
      }

      forEach(types, function(func, type) {
        bindEvent(element, type, func, handler);
      });
    }

    /**
     * Bind DOM events
     * @param {HTMLElement} element - element to bind events
     * @param {string} type - events name
     * @param {function} handler - handler function or context for handler method
     * @param {object} [context] context - context for handler method.
     * @private
     */
    function bindEvent(element, type, handler, context) {
      /**
         * Event handler
         * @param {Event} e - event object
         */
      function eventHandler(e) {
        handler.call(context || element, e || window.event);
      }

      if ('addEventListener' in element) {
        element.addEventListener(type, eventHandler);
      } else if ('attachEvent' in element) {
        element.attachEvent('on' + type, eventHandler);
      }
      memorizeHandler(element, type, handler, eventHandler);
    }

    /**
     * Memorize DOM event handler for unbinding.
     * @param {HTMLElement} element - element to bind events
     * @param {string} type - events name
     * @param {function} handler - handler function that user passed at on() use
     * @param {function} wrappedHandler - handler function that wrapped by domevent for implementing some features
     * @private
     */
    function memorizeHandler(element, type, handler, wrappedHandler) {
      var events = safeEvent(element, type);
      var existInEvents = false;

      forEach(events, function(obj) {
        if (obj.handler === handler) {
          existInEvents = true;

          return false;
        }

        return true;
      });

      if (!existInEvents) {
        events.push({
          handler: handler,
          wrappedHandler: wrappedHandler
        });
      }
    }

    module.exports = on;


    /***/ }),
    /* 11 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Unbind DOM events
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var isString = __webpack_require__(6);
    var forEach = __webpack_require__(4);

    var safeEvent = __webpack_require__(17);

    /**
     * Unbind DOM events
     * If a handler function is not passed, remove all events of that type.
     * @param {HTMLElement} element - element to unbind events
     * @param {(string|object)} types - Space splitted events names or eventName:handler object
     * @param {function} [handler] - handler function
     * @memberof module:domEvent
     * @example
     * // Following the example of domEvent#on
     * 
     * // Unbind one event from an element.
     * off(div, 'click', toggle);
     * 
     * // Unbind multiple events with a same handler from multiple elements at once.
     * // Use event names splitted by a space.
     * off(element, 'mouseenter mouseleave', changeColor);
     * 
     * // Unbind multiple events with different handlers from an element at once.
     * // Use an object which of key is an event name and value is a handler function.
     * off(div, {
     *   keydown: highlight,
     *   keyup: dehighlight
     * });
     * 
     * // Unbind events without handlers.
     * off(div, 'drag');
     */
    function off(element, types, handler) {
      if (isString(types)) {
        forEach(types.split(/\s+/g), function(type) {
          unbindEvent(element, type, handler);
        });

        return;
      }

      forEach(types, function(func, type) {
        unbindEvent(element, type, func);
      });
    }

    /**
     * Unbind DOM events
     * If a handler function is not passed, remove all events of that type.
     * @param {HTMLElement} element - element to unbind events
     * @param {string} type - events name
     * @param {function} [handler] - handler function
     * @private
     */
    function unbindEvent(element, type, handler) {
      var events = safeEvent(element, type);
      var index;

      if (!handler) {
        forEach(events, function(item) {
          removeHandler(element, type, item.wrappedHandler);
        });
        events.splice(0, events.length);
      } else {
        forEach(events, function(item, idx) {
          if (handler === item.handler) {
            removeHandler(element, type, item.wrappedHandler);
            index = idx;

            return false;
          }

          return true;
        });
        events.splice(index, 1);
      }
    }

    /**
     * Remove an event handler
     * @param {HTMLElement} element - An element to remove an event
     * @param {string} type - event type
     * @param {function} handler - event handler
     * @private
     */
    function removeHandler(element, type, handler) {
      if ('removeEventListener' in element) {
        element.removeEventListener(type, handler);
      } else if ('detachEvent' in element) {
        element.detachEvent('on' + type, handler);
      }
    }

    module.exports = off;


    /***/ }),
    /* 12 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Find parent element recursively
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var matches = __webpack_require__(30);

    /**
     * Find parent element recursively
     * @param {HTMLElement} element - base element to start find
     * @param {string} selector - selector string for find
     * @returns {HTMLElement} - element finded or null
     * @memberof module:domUtil
     */
    function closest(element, selector) {
      var parent = element.parentNode;

      if (matches(element, selector)) {
        return element;
      }

      while (parent && parent !== document) {
        if (matches(parent, selector)) {
          return parent;
        }

        parent = parent.parentNode;
      }

      return null;
    }

    module.exports = closest;


    /***/ }),
    /* 13 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Remove element from parent node.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Remove element from parent node.
     * @param {HTMLElement} element - element to remove.
     * @memberof module:domUtil
     */
    function removeElement(element) {
      if (element && element.parentNode) {
        element.parentNode.removeChild(element);
      }
    }

    module.exports = removeElement;


    /***/ }),
    /* 14 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is a instance of HTMLNode or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Check whether the given variable is a instance of HTMLNode or not.
     * If the given variables is a instance of HTMLNode, return true.
     * @param {*} html - Target for checking
     * @returns {boolean} Is HTMLNode ?
     * @memberof module:type
     */
    function isHTMLNode(html) {
      if (typeof HTMLElement === 'object') {
        return (html && (html instanceof HTMLElement || !!html.nodeType));
      }

      return !!(html && html.nodeType);
    }

    module.exports = isHTMLNode;


    /***/ }),
    /* 15 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Utils for Timepicker component
     * @author NHN. FE dev Lab. <dl_javascript@nhn.com>
     */



    var inArray = __webpack_require__(0);
    var forEachArray = __webpack_require__(1);
    var sendHostname = __webpack_require__(35);

    var uniqueId = 0;

    /**
     * Utils
     * @namespace util
     * @ignore
     */
    var utils = {
      /**
       * Returns unique id
       * @returns {number}
       */
      getUniqueId: function() {
        uniqueId += 1;

        return uniqueId;
      },

      /**
       * Convert a value to meet the format
       * @param {number|string} value 
       * @param {string} format - ex) hh, h, mm, m
       * @returns {string}
       */
      formatTime: function(value, format) {
        var PADDING_ZERO_TYPES = ['hh', 'mm'];
        value = String(value);

        return inArray(format, PADDING_ZERO_TYPES) >= 0
          && value.length === 1
          ? '0' + value
          : value;
      },

      /**
       * Get meridiem hour
       * @param {number} hour - Original hour
       * @returns {number} Converted meridiem hour
       */
      getMeridiemHour: function(hour) {
        hour %= 12;

        if (hour === 0) {
          hour = 12;
        }

        return hour;
      },

      /**
       * Returns range arr
       * @param {number} start - Start value
       * @param {number} end - End value
       * @param {number} [step] - Step value
       * @returns {Array}
       */
      getRangeArr: function(start, end, step) {
        var arr = [];
        var i;

        step = step || 1;

        if (start > end) {
          for (i = end; i >= start; i -= step) {
            arr.push(i);
          }
        } else {
          for (i = start; i <= end; i += step) {
            arr.push(i);
          }
        }

        return arr;
      },

      /**
       * Returns array filled with selected value
       * @param {number} start - Start index of array to fill
       * @param {number} end - End index of array to fill
       * @param {number} value - Value to be filled
       * @param {Array} [target] - Array to fill
       * @returns {Array}
       */
      fill: function(start, end, value, target) {
        var arr = target || [];
        var replaceEnd = Math.min(arr.length - 1, end);
        var i;

        for (i = start; i <= replaceEnd; i += 1) {
          arr[i] = value;
        }

        for (i = replaceEnd; i <= end; i += 1) {
          arr.push(value);
        }

        return arr;
      },

      /**
       * Get a target element
       * @param {Event} ev Event object
       * @returns {HTMLElement} An event target element
       */ 
      getTarget: function(ev) {
        return ev.target || ev.srcElement;
      },

      /**
       * send host name
       * @ignore
       */
      sendHostName: function() {
        sendHostname('time-picker', 'UA-129987462-1');
      },

      /**
       * Get disabled minute array
       * @param {Array} enableRanges array of object which contains range
       */
      getDisabledMinuteArr: function(enableRanges) {
        var arr = this.fill(0, 60, false);

        function setDisabled(enableRange) {
          arr = this.fill(enableRange.begin, enableRange.end, true, arr);
        }

        forEachArray(enableRanges, setDisabled.bind(this));

        return arr;
      },

      /**
       * Set disabled on target element
       * @param {HTMLInputElement} el target element
       * @param {boolean} isDisabled target element
       */
      setDisabled: function(el, isDisabled) {
        el.disabled = isDisabled;
      }
    };

    module.exports = utils;


    /***/ }),
    /* 16 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Execute the provided callback once for each property of object which actually exist.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Execute the provided callback once for each property of object which actually exist.
     * If the callback function returns false, the loop will be stopped.
     * Callback function(iteratee) is invoked with three arguments:
     *  1) The value of the property
     *  2) The name of the property
     *  3) The object being traversed
     * @param {Object} obj The object that will be traversed
     * @param {function} iteratee  Callback function
     * @param {Object} [context] Context(this) of callback function
     * @memberof module:collection
     * @example
     * var forEachOwnProperties = require('tui-code-snippet/collection/forEachOwnProperties'); // node, commonjs
     *
     * var sum = 0;
     *
     * forEachOwnProperties({a:1,b:2,c:3}, function(value){
     *     sum += value;
     * });
     * alert(sum); // 6
     */
    function forEachOwnProperties(obj, iteratee, context) {
      var key;

      context = context || null;

      for (key in obj) {
        if (obj.hasOwnProperty(key)) {
          if (iteratee.call(context, obj[key], key, obj) === false) {
            break;
          }
        }
      }
    }

    module.exports = forEachOwnProperties;


    /***/ }),
    /* 17 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Get event collection for specific HTML element
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var EVENT_KEY = '_feEventKey';

    /**
     * Get event collection for specific HTML element
     * @param {HTMLElement} element - HTML element
     * @param {string} type - event type
     * @returns {array}
     * @private
     */
    function safeEvent(element, type) {
      var events = element[EVENT_KEY];
      var handlers;

      if (!events) {
        events = element[EVENT_KEY] = {};
      }

      handlers = events[type];
      if (!handlers) {
        handlers = events[type] = [];
      }

      return handlers;
    }

    module.exports = safeEvent;


    /***/ }),
    /* 18 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Get HTML element's design classes.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var isUndefined = __webpack_require__(5);

    /**
     * Get HTML element's design classes.
     * @param {(HTMLElement|SVGElement)} element target element
     * @returns {string} element css class name
     * @memberof module:domUtil
     */
    function getClass(element) {
      if (!element || !element.className) {
        return '';
      }

      if (isUndefined(element.className.baseVal)) {
        return element.className;
      }

      return element.className.baseVal;
    }

    module.exports = getClass;


    /***/ }),
    /* 19 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Set className value
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var isArray = __webpack_require__(3);
    var isUndefined = __webpack_require__(5);

    /**
     * Set className value
     * @param {(HTMLElement|SVGElement)} element - target element
     * @param {(string|string[])} cssClass - class names
     * @private
     */
    function setClassName(element, cssClass) {
      cssClass = isArray(cssClass) ? cssClass.join(' ') : cssClass;

      cssClass = cssClass.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

      if (isUndefined(element.className.baseVal)) {
        element.className = cssClass;

        return;
      }

      element.className.baseVal = cssClass;
    }

    module.exports = setClassName;


    /***/ }),
    /* 20 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview The entry file of TimePicker components
     * @author NHN. FE Development Lab <dl_javascript@nhn.com>
     */



    __webpack_require__(21);

    module.exports = __webpack_require__(22);


    /***/ }),
    /* 21 */
    /***/ (function(module, exports, __webpack_require__) {

    // extracted by mini-css-extract-plugin

    /***/ }),
    /* 22 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview TimePicker component
     * @author NHN. FE Development Lab <dl_javascript@nhn.com>
     */



    var inArray = __webpack_require__(0);
    var forEachArray = __webpack_require__(1);
    var CustomEvents = __webpack_require__(8);
    var defineClass = __webpack_require__(9);
    var extend = __webpack_require__(2);
    var on = __webpack_require__(10);
    var off = __webpack_require__(11);
    var addClass = __webpack_require__(29);
    var closest = __webpack_require__(12);
    var removeElement = __webpack_require__(13);
    var removeClass = __webpack_require__(32);
    var isHTMLNode = __webpack_require__(14);
    var isNumber = __webpack_require__(33);

    var Spinbox = __webpack_require__(34);
    var Selectbox = __webpack_require__(38);
    var util = __webpack_require__(15);
    var localeTexts = __webpack_require__(40);
    var tmpl = __webpack_require__(41);
    var meridiemTmpl = __webpack_require__(42);

    var SELECTOR_HOUR_ELEMENT = '.tui-timepicker-hour';
    var SELECTOR_MINUTE_ELEMENT = '.tui-timepicker-minute';
    var SELECTOR_MERIDIEM_ELEMENT = '.tui-timepicker-meridiem';
    var CLASS_NAME_LEFT_MERIDIEM = 'tui-has-left';
    var CLASS_NAME_HIDDEN = 'tui-hidden';
    var CLASS_NAME_CHECKED = 'tui-timepicker-meridiem-checked';
    var INPUT_TYPE_SPINBOX = 'spinbox';
    var INPUT_TYPE_SELECTBOX = 'selectbox';

    var START_NUMBER_OF_TIME = 0;
    var END_NUMBER_OF_MINUTE = 59;
    var END_NUMBER_OF_HOUR = 23;
    var END_NUMBER_OF_HOUR_WITH_MERIDIEM = 12;

    /**
     * Merge default options
     * @ignore
     * @param {object} options - options
     * @returns {object} Merged options
     */
    var mergeDefaultOptions = function(options) {
      return extend(
        {
          language: 'en',
          initialHour: 0,
          initialMinute: 0,
          showMeridiem: true,
          inputType: 'selectbox',
          hourStep: 1,
          minuteStep: 1,
          meridiemPosition: 'right',
          format: 'h:m',
          disabledHours: [],
          disabledMinutes: {},
          usageStatistics: true
        },
        options
      );
    };

    /**
     * @class
     * @param {string|HTMLElement} container - Container element or selector
     * @param {Object} [options] - Options for initialization
     * @param {number} [options.initialHour = 0] - Initial setting value of hour
     * @param {number} [options.initialMinute = 0] - Initial setting value of minute
     * @param {number} [options.hourStep = 1] - Step value of hour
     * @param {number} [options.minuteStep = 1] - Step value of minute
     * @param {string} [options.inputType = 'selectbox'] - 'selectbox' or 'spinbox'
     * @param {string} [options.format = 'h:m'] - hour, minute format for display
     * @param {boolean} [options.showMeridiem = true] - Show meridiem expression?
     * @param {Array} [options.disabledHours = []] - Registered Hours is disabled.
     * @param {Object} [options.disabledMinutes = {}] - Registered Minutes of selected hours is disabled.
     * @param {Object} [options.disabledMinutes.hour] - Key must be hour(number).
     *                 Value is array which contains only true or false and must be 60 of length
     * @param {string} [options.meridiemPosition = 'right'] - Set location of the meridiem element.
     *                 If this option set 'left', the meridiem element is created in front of the hour element.
     * @param {string} [options.language = 'en'] Set locale texts
     * @param {Boolean} [options.usageStatistics=true|false] send hostname to google analytics [default value is true]
     * @example
     * // ES6
     * import TimePicker from 'tui-time-picker'; 
     * 
     * // CommonJS
     * const TimePicker = require('tui-time-picker'); 
     * 
     * // Browser
     * const TimePicker = tui.TimePicker;
     * 
     * const timepicker = new TimePicker('#timepicker-container', {
     *     initialHour: 15,
     *     initialMinute: 13,
     *     inputType: 'selectbox',
     *     showMeridiem: false
     * });
     */
    var TimePicker = defineClass(
      /** @lends TimePicker.prototype */ {
        static: {
          /**
           * Locale text data
           * @type {object}
           * @memberof TimePicker
           * @static
           * @example
           * TimePicker.localeTexts['customKey'] = {
           *     am: 'a.m.',
           *     pm: 'p.m.'
           * };
           *
           * const instance = new TimePicker('#timepicker-container', {
           *     language: 'customKey',
           * });
           */
          localeTexts: localeTexts
        },
        init: function(container, options) {
          options = mergeDefaultOptions(options);

          /**
           * @type {number}
           * @private
           */
          this.id = util.getUniqueId();

          /**
           * @type {HTMLElement}
           * @private
           */
          this.container = isHTMLNode(container)
            ? container
            : document.querySelector(container);

          /**
           * @type {HTMLElement}
           * @private
           */
          this.element = null;

          /**
           * @type {HTMLElement}
           * @private
           */
          this.meridiemElement = null;

          /**
           * @type {HTMLElement}
           * @private
           */
          this.amEl = null;

          /**
           * @type {HTMLElement}
           * @private
           */
          this.pmEl = null;

          /**
           * @type {boolean}
           * @private
           */
          this.showMeridiem = options.showMeridiem;

          /**
           * Meridiem postion
           * @type {'left'|'right'}
           * @private
           */
          this.meridiemPosition = options.meridiemPosition;

          /**
           * @type {Spinbox|Selectbox}
           * @private
           */
          this.hourInput = null;

          /**
           * @type {Spinbox|Selectbox}
           * @private
           */
          this.minuteInput = null;

          /**
           * @type {number}
           * @private
           */
          this.hour = options.initialHour;

          /**
           * @type {number}
           * @private
           */
          this.minute = options.initialMinute;

          /**
           * @type {number}
           * @private
           */
          this.hourStep = options.hourStep;

          /**
           * @type {number}
           * @private
           */
          this.minuteStep = options.minuteStep;

          /**
           * @type {Array}
           * @private
           */
          this.disabledHours = options.disabledHours;

          /**
           * @type {Object}
           * @private
           */
          this.disabledMinutes = options.disabledMinutes;

          /**
           * TimePicker inputType
           * @type {'spinbox'|'selectbox'}
           * @private
           */
          this.inputType = options.inputType;

          /**
           * Locale text for meridiem
           * @type {string}
           * @private
           */
          this.localeText = localeTexts[options.language];

          /**
           * Time format for output
           * @type {string}
           * @private
           */
          this.format = this.getValidTimeFormat(options.format);

          this.render();
          this.setEvents();

          if (options.usageStatistics) {
            util.sendHostName();
          }
        },

        /**
         * Set event handlers to selectors, container
         * @private
         */
        setEvents: function() {
          this.hourInput.on('change', this.onChangeTimeInput, this);
          this.minuteInput.on('change', this.onChangeTimeInput, this);

          if (this.showMeridiem) {
            if (this.inputType === INPUT_TYPE_SELECTBOX) {
              on(
                this.meridiemElement.querySelector('select'),
                'change',
                this.onChangeMeridiem,
                this
              );
            } else if (this.inputType === INPUT_TYPE_SPINBOX) {
              on(this.meridiemElement, 'click', this.onChangeMeridiem, this);
            }
          }
        },

        /**
         * Remove events
         * @private
         */
        removeEvents: function() {
          this.off();

          this.hourInput.destroy();
          this.minuteInput.destroy();

          if (this.showMeridiem) {
            if (this.inputType === INPUT_TYPE_SELECTBOX) {
              off(
                this.meridiemElement.querySelector('select'),
                'change',
                this.onChangeMeridiem,
                this
              );
            } else if (this.inputType === INPUT_TYPE_SPINBOX) {
              off(this.meridiemElement, 'click', this.onChangeMeridiem, this);
            }
          }
        },

        /**
         * Render element
         * @private
         */
        render: function() {
          var context = {
            showMeridiem: this.showMeridiem,
            isSpinbox: this.inputType === 'spinbox'
          };

          if (this.showMeridiem) {
            extend(context, {
              meridiemElement: this.makeMeridiemHTML()
            });
          }

          if (this.element) {
            removeElement(this.element);
          }
          this.container.innerHTML = tmpl(context);
          this.element = this.container.firstChild;

          this.renderTimeInputs();

          if (this.showMeridiem) {
            this.setMeridiemElement();
          }
        },

        /**
         * Set meridiem element on timepicker
         * @private
         */
        setMeridiemElement: function() {
          if (this.meridiemPosition === 'left') {
            addClass(this.element, CLASS_NAME_LEFT_MERIDIEM);
          }
          this.meridiemElement = this.element.querySelector(SELECTOR_MERIDIEM_ELEMENT);
          this.amEl = this.meridiemElement.querySelector('[value="AM"]');
          this.pmEl = this.meridiemElement.querySelector('[value="PM"]');
          this.syncToMeridiemElements();
        },

        /**
         * Make html for meridiem element
         * @returns {HTMLElement} Meridiem element
         * @private
         */
        makeMeridiemHTML: function() {
          var localeText = this.localeText;

          return meridiemTmpl({
            am: localeText.am,
            pm: localeText.pm,
            radioId: this.id,
            isSpinbox: this.inputType === 'spinbox'
          });
        },

        /**
         * Render time selectors
         * @private
         */
        renderTimeInputs: function() {
          var hour = this.hour;
          var showMeridiem = this.showMeridiem;
          var hourElement = this.element.querySelector(SELECTOR_HOUR_ELEMENT);
          var minuteElement = this.element.querySelector(SELECTOR_MINUTE_ELEMENT);
          var BoxComponent = this.inputType.toLowerCase() === 'selectbox' ? Selectbox : Spinbox;
          var formatExplode = this.format.split(':');
          var hourItems = this.getHourItems();

          if (showMeridiem) {
            hour = util.getMeridiemHour(hour);
          }

          this.hourInput = new BoxComponent(hourElement, {
            initialValue: hour,
            items: hourItems,
            format: formatExplode[0],
            disabledItems: this.makeDisabledStatItems(hourItems)
          });

          this.minuteInput = new BoxComponent(minuteElement, {
            initialValue: this.minute,
            items: this.getMinuteItems(),
            format: formatExplode[1]
          });
        },

        makeDisabledStatItems: function(hourItems) {
          var result = [];
          var disabledHours = this.disabledHours.slice();

          if (this.showMeridiem) {
            disabledHours = this.meridiemableTime(disabledHours);
          }

          forEachArray(hourItems, function(hour) {
            result.push(inArray(hour, disabledHours) >= 0);
          });

          return result;
        },

        meridiemableTime: function(disabledHours) {
          var diffHour = 0;
          var startHour = 0;
          var endHour = 11;
          var result = [];

          if (this.hour >= 12) {
            diffHour = 12;
            startHour = 12;
            endHour = 23;
          }

          forEachArray(disabledHours, function(hour) {
            if (hour >= startHour && hour <= endHour) {
              result.push(hour - diffHour === 0 ? 12 : hour - diffHour);
            }
          });

          return result;
        },

        /**
         * Return formatted format.
         * @param {string} format - format option
         * @returns {string}
         * @private
         */
        getValidTimeFormat: function(format) {
          if (!format.match(/^[h]{1,2}:[m]{1,2}$/i)) {
            return 'h:m';
          }

          return format.toLowerCase();
        },

        /**
         * Initialize meridiem elements
         * @private
         */
        syncToMeridiemElements: function() {
          var selectedEl = this.hour >= 12 ? this.pmEl : this.amEl;
          var notSelectedEl = selectedEl === this.pmEl ? this.amEl : this.pmEl;

          selectedEl.setAttribute('selected', true);
          selectedEl.setAttribute('checked', true);
          addClass(selectedEl, CLASS_NAME_CHECKED);
          notSelectedEl.removeAttribute('selected');
          notSelectedEl.removeAttribute('checked');
          removeClass(notSelectedEl, CLASS_NAME_CHECKED);
        },

        /**
         * Set values in spinboxes from time
         * @private
         */
        syncToInputs: function() {
          var hour = this.hour;
          var minute = this.minute;

          if (this.showMeridiem) {
            hour = util.getMeridiemHour(hour);
          }

          this.hourInput.setValue(hour);
          this.minuteInput.setValue(minute);
        },

        /**
         * DOM event handler
         * @param {Event} ev - Change event on meridiem element
         * @private
         */
        onChangeMeridiem: function(ev) {
          var hour = this.hour;
          var target = util.getTarget(ev);

          if (target.value && closest(target, SELECTOR_MERIDIEM_ELEMENT)) {
            hour = this.to24Hour(target.value === 'PM', hour);
            this.setTime(hour, this.minute);
            this.setDisabledHours();
            this.setDisabledMinutes(hour);
          }
        },

        /**
         * Time change event handler
         * @private
         */
        onChangeTimeInput: function() {
          var hour = this.hourInput.getValue();
          var minute = this.minuteInput.getValue();
          var isPM = this.hour >= 12;

          if (this.showMeridiem) {
            hour = this.to24Hour(isPM, hour);
          }
          this.setTime(hour, minute);
          this.setDisabledMinutes(hour);
        },

        /**
         * 12Hour-expression to 24Hour-expression
         * @param {boolean} isPM - Is pm?
         * @param {number} hour - Hour
         * @returns {number}
         * @private
         */
        to24Hour: function(isPM, hour) {
          hour %= 12;
          if (isPM) {
            hour += 12;
          }

          return hour;
        },

        setDisabledHours: function() {
          var hourItems = this.getHourItems();
          var disabledItems = this.makeDisabledStatItems(hourItems);

          this.hourInput.setDisabledItems(disabledItems);
        },

        setDisabledMinutes: function(hour) {
          var disabledItems;
          disabledItems = this.disabledMinutes[hour] || [];

          this.minuteInput.setDisabledItems(disabledItems);
        },

        /**
         * Get items of hour
         * @returns {array} Hour item list
         * @private
         */
        getHourItems: function() {
          var step = this.hourStep;

          return this.showMeridiem ? util.getRangeArr(1, 12, step) : util.getRangeArr(0, 23, step);
        },

        /**
         * Get items of minute
         * @returns {array} Minute item list
         * @private
         */
        getMinuteItems: function() {
          return util.getRangeArr(0, 59, this.minuteStep);
        },

        /**
         * Whether the hour and minute are in valid items or not
         * @param {number} hour - Hour value
         * @param {number} minute - Minute value
         * @returns {boolean} State
         * @private
         */
        validItems: function(hour, minute) {
          if (!isNumber(hour) || !isNumber(minute)) {
            return false;
          }

          if (this.showMeridiem) {
            hour = util.getMeridiemHour(hour);
          }

          return (
            inArray(hour, this.getHourItems()) > -1 &&
            inArray(minute, this.getMinuteItems()) > -1
          );
        },

        /**
         * Set step of hour
         * @param {array} step - Step to create items of hour
         */
        setHourStep: function(step) {
          this.hourStep = step;
          this.hourInput.fire('changeItems', this.getHourItems());
        },

        /**
         * Get step of hour
         * @returns {number} Step of hour
         */
        getHourStep: function() {
          return this.hourStep;
        },

        /**
         * Set step of minute
         * @param {array} step - Step to create items of minute
         */
        setMinuteStep: function(step) {
          this.minuteStep = step;
          this.minuteInput.fire('changeItems', this.getMinuteItems());
        },

        /**
         * Get step of minute
         * @returns {number} Step of minute
         */
        getMinuteStep: function() {
          return this.minuteStep;
        },

        /**
         * Show time picker element
         */
        show: function() {
          removeClass(this.element, CLASS_NAME_HIDDEN);
        },

        /**
         * Hide time picker element
         */
        hide: function() {
          addClass(this.element, CLASS_NAME_HIDDEN);
        },

        /**
         * Set hour
         * @param {number} hour for time picker - (0~23)
         * @returns {boolean} result of set time
         */
        setHour: function(hour) {
          return this.setTime(hour, this.minute);
        },

        /**
         * Set minute
         * @param {number} minute for time picker
         * @returns {boolean} result of set time
         */
        setMinute: function(minute) {
          return this.setTime(this.hour, minute);
        },

        /**
         * Set time
         * @param {number} hour for time picker - (0~23)
         * @param {number} minute for time picker
         */
        setTime: function(hour, minute) {
          if (!this.validItems(hour, minute)) {
            return;
          }

          this.hour = hour;
          this.minute = minute;

          this.syncToInputs();
          if (this.showMeridiem) {
            this.syncToMeridiemElements();
          }

          /**
           * Change event - TimePicker
           * @event TimePicker#change
           * @type {object} event - Event object
           * @property {number} hour - changed hour
           * @property {number} minute - changed minute
           * @example
           * timepicker.on('change', (e) => {
           *   console.log(e.hour, e.minute);
           * });
           */
          this.fire('change', {
            hour: this.hour,
            minute: this.minute
          });
        },

        /**
         * Set selectable range 
         * @param {Object} begin - Contain begin hour and minute of range
         * @param {number} begin.hour - begin hour of range
         * @param {number} begin.minute - begin minute of range
         * @param {Object} [end] - Contain end hour and minute of range
         * @param {number} end.hour - end hour of range
         * @param {number} end.minute - end minute of range
         */
        setRange: function(begin, end) {
          var beginHour = begin.hour;
          var beginMin = begin.minute;
          var endHour, endMin;

          if (!this.isValidRange(begin, end)) {
            return;
          }

          if (end) {
            endHour = end.hour;
            endMin = end.minute;
          }

          this.setRangeHour(beginHour, endHour);
          this.setRangeMinute(beginHour, beginMin, endHour, endMin);

          this.applyRange(beginHour, beginMin, endHour);
        },

        /**
         * Set selectable range on hour
         * @param {number} begin.hour - begin hour of range
         * @param {number} [end.hour] - end hour of range
         * @private
         */
        setRangeHour: function(beginHour, endHour) {
          var disabledHours = util.getRangeArr(START_NUMBER_OF_TIME, beginHour - 1);

          if (endHour) {
            disabledHours = disabledHours.concat(util.getRangeArr(endHour + 1, END_NUMBER_OF_HOUR));
          }

          this.disabledHours = disabledHours.slice();
        },

        /**
         * Set selectable range on minute
         * @param {number} begin.hour - begin hour of range
         * @param {number} begin.minute - begin minute of range
         * @param {number} [end.hour] - end hour of range
         * @param {number} [end.minute] - end minute of range
         * @private
         */
        setRangeMinute: function(beginHour, beginMin, endHour, endMin) {
          var disabledMinRanges = [];

          if (!beginHour && !beginMin) {
            return;
          }

          disabledMinRanges.push({
            begin: START_NUMBER_OF_TIME,
            end: beginMin
          });

          if (endHour && endMin) {
            disabledMinRanges.push({
              begin: endMin,
              end: END_NUMBER_OF_MINUTE
            });

            if (beginHour === endHour) {
              this.disabledMinutes[beginHour] = util.getDisabledMinuteArr(disabledMinRanges).slice();

              return;
            }

            this.disabledMinutes[endHour] = util.getDisabledMinuteArr([disabledMinRanges[1]]).slice();
          }

          this.disabledMinutes[beginHour] = util.getDisabledMinuteArr([disabledMinRanges[0]]).slice();
        },

        /**
         * Apply range
         * @param {number} begin.hour - begin hour of range
         * @param {number} begin.minute - begin minute of range
         * @param {number} [end.hour] - end hour of range
         * @private
         */
        applyRange: function(beginHour, beginMin, endHour) {
          if (this.isLaterThanSetTime(beginHour, beginMin)) {
            this.setTime(beginHour, beginMin);
          }
          this.setDisabledHours();

          if (this.showMeridiem) {
            this.syncToMeridiemElements();

            util.setDisabled(this.amEl, beginHour >= END_NUMBER_OF_HOUR_WITH_MERIDIEM);
            util.setDisabled(this.pmEl, endHour < END_NUMBER_OF_HOUR_WITH_MERIDIEM);
          }
        },

        /**
         * Reset minute selectable range
         */
        resetMinuteRange: function() {
          var i;

          this.disabledMinutes = {};

          for (i = 0; i <= END_NUMBER_OF_HOUR; i += 1) {
            this.setDisabledMinutes(this.hour);
          }
        },

        /**
         * Whether the given range a valid range 
         * @param {Object} begin - Contain begin hour and minute of range
         * @param {number} begin.hour - begin hour of range
         * @param {number} begin.minute - begin minute of range
         * @param {Object} [end] - Contain end hour and minute of range
         * @param {number} end.hour - end hour of range
         * @param {number} end.minute - end minute of range
         * @returns {boolean} result of range validation
         * @private
         */
        isValidRange: function(begin, end) {
          var beginHour = begin.hour;
          var beginMin = begin.minute;
          var endHour, endMin;

          if (!this.isValidTime(beginHour, beginMin)) {
            return false;
          }

          if (!end) {
            return true;
          }

          endHour = end.hour;
          endMin = end.minute;

          return this.isValidTime(endHour, endMin) && this.compareTimes(begin, end) > 0;
        },

        /**
         * Whether the given time a valid time 
         * @param {number} hour - hour for validation
         * @param {number} minute - minute for validation
         * @returns {boolean} result of time validation
         * @private
         */
        isValidTime: function(hour, minute) {
          return hour >= START_NUMBER_OF_TIME &&
          hour <= END_NUMBER_OF_HOUR &&
          minute >= START_NUMBER_OF_TIME &&
          minute <= END_NUMBER_OF_MINUTE;
        },

        /**
         * Compare given time with set time 
         * @param {number} hour - given hour
         * @param {number} minute - given minute
         * @returns {boolean} result of compare
         * @private
         */
        isLaterThanSetTime: function(hour, minute) {
          return hour > this.hour || (hour === this.hour && minute > this.minute);
        },

        /**
         * Compare two times
         * it returns
         *  0: when begin equals end
         *  positive: when end later than begin
         *  negative: when begin later than end
         * @param {Object} begin - Contain begin hour and minute of range
         * @param {number} begin.hour - begin hour of range
         * @param {number} begin.minute - begin minute of range
         * @param {Object} end - Contain end hour and minute of range
         * @param {number} end.hour - end hour of range
         * @param {number} end.minute - end minute of range
         * @returns {boolean} result of range validation
         * @private
         */
        compareTimes: function(begin, end) {
          var first = new Date(0);
          var second = new Date(0);

          first.setHours(begin.hour, begin.minute);
          second.setHours(end.hour, end.minute);

          return second.getTime() - first.getTime();
        },

        /**
         * Get hour
         * @returns {number} hour - (0~23)
         */
        getHour: function() {
          return this.hour;
        },

        /**
         * Get minute
         * @returns {number} minute
         */
        getMinute: function() {
          return this.minute;
        },

        /**
         * Change locale text of meridiem by language code
         * @param {string} language - Language code
         */
        changeLanguage: function(language) {
          this.localeText = localeTexts[language];
          this.render();
        },

        /**
         * Destroy
         */
        destroy: function() {
          this.removeEvents();
          removeElement(this.element);

          this.container
            = this.showMeridiem
            = this.hourInput
            = this.minuteInput
            = this.hour
            = this.minute
            = this.inputType
            = this.element
            = this.meridiemElement
            = this.amEl
            = this.pmEl
            = null;
        }
      }
    );

    CustomEvents.mixin(TimePicker);
    module.exports = TimePicker;


    /***/ }),
    /* 23 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is existing or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var isUndefined = __webpack_require__(5);
    var isNull = __webpack_require__(24);

    /**
     * Check whether the given variable is existing or not.
     * If the given variable is not null and not undefined, returns true.
     * @param {*} param - Target for checking
     * @returns {boolean} Is existy?
     * @memberof module:type
     * @example
     * var isExisty = require('tui-code-snippet/type/isExisty'); // node, commonjs
     *
     * isExisty(''); //true
     * isExisty(0); //true
     * isExisty([]); //true
     * isExisty({}); //true
     * isExisty(null); //false
     * isExisty(undefined); //false
    */
    function isExisty(param) {
      return !isUndefined(param) && !isNull(param);
    }

    module.exports = isExisty;


    /***/ }),
    /* 24 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is null or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Check whether the given variable is null or not.
     * If the given variable(arguments[0]) is null, returns true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is null?
     * @memberof module:type
     */
    function isNull(obj) {
      return obj === null;
    }

    module.exports = isNull;


    /***/ }),
    /* 25 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is an object or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Check whether the given variable is an object or not.
     * If the given variable is an object, return true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is object?
     * @memberof module:type
     */
    function isObject(obj) {
      return obj === Object(obj);
    }

    module.exports = isObject;


    /***/ }),
    /* 26 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is a function or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Check whether the given variable is a function or not.
     * If the given variable is a function, return true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is function?
     * @memberof module:type
     */
    function isFunction(obj) {
      return obj instanceof Function;
    }

    module.exports = isFunction;


    /***/ }),
    /* 27 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Provide a simple inheritance in prototype-oriented.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var createObject = __webpack_require__(28);

    /**
     * Provide a simple inheritance in prototype-oriented.
     * Caution :
     *  Don't overwrite the prototype of child constructor.
     *
     * @param {function} subType Child constructor
     * @param {function} superType Parent constructor
     * @memberof module:inheritance
     * @example
     * var inherit = require('tui-code-snippet/inheritance/inherit'); // node, commonjs
     *
     * // Parent constructor
     * function Animal(leg) {
     *     this.leg = leg;
     * }
     * Animal.prototype.growl = function() {
     *     // ...
     * };
     *
     * // Child constructor
     * function Person(name) {
     *     this.name = name;
     * }
     *
     * // Inheritance
     * inherit(Person, Animal);
     *
     * // After this inheritance, please use only the extending of property.
     * // Do not overwrite prototype.
     * Person.prototype.walk = function(direction) {
     *     // ...
     * };
     */
    function inherit(subType, superType) {
      var prototype = createObject(superType.prototype);
      prototype.constructor = subType;
      subType.prototype = prototype;
    }

    module.exports = inherit;


    /***/ }),
    /* 28 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Create a new object with the specified prototype object and properties.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * @module inheritance
     */

    /**
     * Create a new object with the specified prototype object and properties.
     * @param {Object} obj This object will be a prototype of the newly-created object.
     * @returns {Object}
     * @memberof module:inheritance
     */
    function createObject(obj) {
      function F() {} // eslint-disable-line require-jsdoc
      F.prototype = obj;

      return new F();
    }

    module.exports = createObject;


    /***/ }),
    /* 29 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Add css class to element
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var forEach = __webpack_require__(4);
    var inArray = __webpack_require__(0);
    var getClass = __webpack_require__(18);
    var setClassName = __webpack_require__(19);

    /**
     * domUtil module
     * @module domUtil
     */

    /**
     * Add css class to element
     * @param {(HTMLElement|SVGElement)} element - target element
     * @param {...string} cssClass - css classes to add
     * @memberof module:domUtil
     */
    function addClass(element) {
      var cssClass = Array.prototype.slice.call(arguments, 1);
      var classList = element.classList;
      var newClass = [];
      var origin;

      if (classList) {
        forEach(cssClass, function(name) {
          element.classList.add(name);
        });

        return;
      }

      origin = getClass(element);

      if (origin) {
        cssClass = [].concat(origin.split(/\s+/), cssClass);
      }

      forEach(cssClass, function(cls) {
        if (inArray(cls, newClass) < 0) {
          newClass.push(cls);
        }
      });

      setClassName(element, newClass);
    }

    module.exports = addClass;


    /***/ }),
    /* 30 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check element match selector
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var inArray = __webpack_require__(0);
    var toArray = __webpack_require__(31);

    var elProto = Element.prototype;
    var matchSelector = elProto.matches ||
        elProto.webkitMatchesSelector ||
        elProto.mozMatchesSelector ||
        elProto.msMatchesSelector ||
        function(selector) {
          var doc = this.document || this.ownerDocument;

          return inArray(this, toArray(doc.querySelectorAll(selector))) > -1;
        };

    /**
     * Check element match selector
     * @param {HTMLElement} element - element to check
     * @param {string} selector - selector to check
     * @returns {boolean} is selector matched to element?
     * @memberof module:domUtil
     */
    function matches(element, selector) {
      return matchSelector.call(element, selector);
    }

    module.exports = matches;


    /***/ }),
    /* 31 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Transform the Array-like object to Array.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var forEachArray = __webpack_require__(1);

    /**
     * Transform the Array-like object to Array.
     * In low IE (below 8), Array.prototype.slice.call is not perfect. So, try-catch statement is used.
     * @param {*} arrayLike Array-like object
     * @returns {Array} Array
     * @memberof module:collection
     * @example
     * var toArray = require('tui-code-snippet/collection/toArray'); // node, commonjs
     *
     * var arrayLike = {
     *     0: 'one',
     *     1: 'two',
     *     2: 'three',
     *     3: 'four',
     *     length: 4
     * };
     * var result = toArray(arrayLike);
     *
     * alert(result instanceof Array); // true
     * alert(result); // one,two,three,four
     */
    function toArray(arrayLike) {
      var arr;
      try {
        arr = Array.prototype.slice.call(arrayLike);
      } catch (e) {
        arr = [];
        forEachArray(arrayLike, function(value) {
          arr.push(value);
        });
      }

      return arr;
    }

    module.exports = toArray;


    /***/ }),
    /* 32 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Remove css class from element
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var forEachArray = __webpack_require__(1);
    var inArray = __webpack_require__(0);
    var getClass = __webpack_require__(18);
    var setClassName = __webpack_require__(19);

    /**
     * Remove css class from element
     * @param {(HTMLElement|SVGElement)} element - target element
     * @param {...string} cssClass - css classes to remove
     * @memberof module:domUtil
     */
    function removeClass(element) {
      var cssClass = Array.prototype.slice.call(arguments, 1);
      var classList = element.classList;
      var origin, newClass;

      if (classList) {
        forEachArray(cssClass, function(name) {
          classList.remove(name);
        });

        return;
      }

      origin = getClass(element).split(/\s+/);
      newClass = [];
      forEachArray(origin, function(name) {
        if (inArray(name, cssClass) < 0) {
          newClass.push(name);
        }
      });

      setClassName(element, newClass);
    }

    module.exports = removeClass;


    /***/ }),
    /* 33 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is a number or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Check whether the given variable is a number or not.
     * If the given variable is a number, return true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is number?
     * @memberof module:type
     */
    function isNumber(obj) {
      return typeof obj === 'number' || obj instanceof Number;
    }

    module.exports = isNumber;


    /***/ }),
    /* 34 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Spinbox (in TimePicker)
     * @author NHN. FE Development Lab <dl_javascript@nhn.com>
     */



    var inArray = __webpack_require__(0);
    var forEachArray = __webpack_require__(1);
    var CustomEvents = __webpack_require__(8);
    var defineClass = __webpack_require__(9);
    var extend = __webpack_require__(2);
    var on = __webpack_require__(10);
    var off = __webpack_require__(11);
    var closest = __webpack_require__(12);
    var removeElement = __webpack_require__(13);
    var isHTMLNode = __webpack_require__(14);

    var util = __webpack_require__(15);
    var tmpl = __webpack_require__(37);

    var SELECTOR_UP_BUTTON = '.tui-timepicker-btn-up';
    var SELECTOR_DOWN_BUTTON = '.tui-timepicker-btn-down';

    /**
     * @class
     * @ignore
     * @param {String|HTMLElement} container - Container of spinbox or selector
     * @param {Object} [options] - Options for initialization
     * @param {number} [options.initialValue] - initial setting value
     * @param {Array.<number>} items - Items
     */
    var Spinbox = defineClass(
      /** @lends Spinbox.prototype */ {
        init: function(container, options) {
          options = extend(
            {
              items: []
            },
            options
          );

          /**
           * @type {HTMLElement}
           * @private
           */
          this._container = isHTMLNode(container)
            ? container
            : document.querySelector(container);

          /**
           * Spinbox element
           * @type {HTMLElement}
           * @private
           */
          this._element = null;

          /**
           * @type {HTMLElement}
           * @private
           */
          this._inputElement = null;

          /**
           * Spinbox value items
           * @type {Array.<number>}
           * @private
           */
          this._items = options.items;

          /**
           * Selectbox disabled items info
           * @type {Array.<number>}
           * @private
           */
          this._disabledItems = options.disabledItems || [];

          /**
           * @type {number}
           * @private
           */
          this._selectedIndex = Math.max(0, inArray(options.initialValue, this._items));

          /**
           * Time format for output
           * @type {string}
           * @private
           */
          this._format = options.format;

          this._render();
          this._setEvents();
        },

        /**
         * Render spinbox
         * @private
         */
        _render: function() {
          var index = inArray(this.getValue(), this._items);
          var context;

          if (this._disabledItems[index]) {
            this._selectedIndex = this._findEnabledIndex();
          }
          context = {
            maxLength: this._getMaxLength(),
            initialValue: this.getValue(),
            format: this._format,
            formatTime: util.formatTime
          };

          this._container.innerHTML = tmpl(context);
          this._element = this._container.firstChild;
          this._inputElement = this._element.querySelector('input');
        },

        /**
         * Find the index of the enabled item
         * @returns {number} - find selected index
         * @private
         */
        _findEnabledIndex: function() {
          return inArray(false, this._disabledItems);
        },

        /**
         * Returns maxlength of value
         * @returns {number}
         * @private
         */
        _getMaxLength: function() {
          var lengths = [];

          forEachArray(this._items, function(item) {
            lengths.push(String(item).length);
          });

          return Math.max.apply(null, lengths);
        },

        /**
         * Set disabledItems
         * @param {object} disabledItems - disabled status of items
         */
        setDisabledItems: function(disabledItems) {
          this._disabledItems = disabledItems;
          this._changeToInputValue();
        },

        /**
         * Assign default events to up/down button
         * @private
         */
        _setEvents: function() {
          on(this._container, 'click', this._onClickHandler, this);
          on(this._inputElement, 'keydown', this._onKeydownInputElement, this);
          on(this._inputElement, 'change', this._onChangeHandler, this);

          this.on(
            'changeItems',
            function(items) {
              this._items = items;
              this._render();
            },
            this
          );
        },

        /**
         * Remove events to up/down button
         * @private
         */
        _removeEvents: function() {
          this.off();

          off(this._container, 'click', this._onClickHandler, this);
          off(this._inputElement, 'keydown', this._onKeydownInputElement, this);
          off(this._inputElement, 'change', this._onChangeHandler, this);
        },

        /**
         * Click event handler
         * @param {Event} ev - Change event on up/down buttons.
         */
        _onClickHandler: function(ev) {
          var target = util.getTarget(ev);

          if (closest(target, SELECTOR_DOWN_BUTTON)) {
            this._setNextValue(true);
          } else if (closest(target, SELECTOR_UP_BUTTON)) {
            this._setNextValue(false);
          }
        },

        /**
         * Set input value
         * @param {boolean} isDown - From down-action?
         * @private
         */
        _setNextValue: function(isDown) {
          var index = this._selectedIndex;

          if (isDown) {
            index = index ? index - 1 : this._items.length - 1;
          } else {
            index = index < this._items.length - 1 ? index + 1 : 0;
          }

          if (this._disabledItems[index]) {
            this._selectedIndex = index;
            this._setNextValue(isDown);
          } else {
            this.setValue(this._items[index]);
          }
        },

        /**
         * DOM(Input element) Keydown Event handler
         * @param {Event} ev event-object
         * @private
         */
        _onKeydownInputElement: function(ev) {
          var keyCode = ev.which || ev.keyCode;
          var isDown;

          if (closest(util.getTarget(ev), 'input')) {
            switch (keyCode) {
              case 38:
                isDown = false;
                break;
              case 40:
                isDown = true;
                break;
              default:
                return;
            }

            this._setNextValue(isDown);
          }
        },

        /**
         * DOM(Input element) Change Event handler
         * @param {Event} ev Change event on an input element.
         * @private
         */
        _onChangeHandler: function(ev) {
          if (closest(util.getTarget(ev), 'input')) {
            this._changeToInputValue();
          }
        },

        /**
         * Change value to input-box if it is valid.
         * @private
         */
        _changeToInputValue: function() {
          var newValue = Number(this._inputElement.value);
          var newIndex = inArray(newValue, this._items);

          if (this._disabledItems[newIndex]) {
            newIndex = this._findEnabledIndex();
            newValue = this._items[newIndex];
          } else if (newIndex === this._selectedIndex) {
            return;
          }

          if (newIndex === -1) {
            this.setValue(this._items[this._selectedIndex]);
          } else {
            this._selectedIndex = newIndex;
            this.fire('change', {
              value: newValue
            });
          }
        },

        /**
         * Set value to input-box.
         * @param {number} value - Value
         */
        setValue: function(value) {
          this._inputElement.value = util.formatTime(value, this._format);
          this._changeToInputValue();
        },

        /**
         * Returns current value
         * @returns {number}
         */
        getValue: function() {
          return this._items[this._selectedIndex];
        },

        /**
         * Destory
         */
        destroy: function() {
          this._removeEvents();
          removeElement(this._element);
          this._container = this._element = this._inputElement = this._items = this._selectedIndex = null;
        }
      }
    );

    CustomEvents.mixin(Spinbox);
    module.exports = Spinbox;


    /***/ }),
    /* 35 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Send hostname on DOMContentLoaded.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var isUndefined = __webpack_require__(5);
    var imagePing = __webpack_require__(36);

    var ms7days = 7 * 24 * 60 * 60 * 1000;

    /**
     * Check if the date has passed 7 days
     * @param {number} date - milliseconds
     * @returns {boolean}
     * @private
     */
    function isExpired(date) {
      var now = new Date().getTime();

      return now - date > ms7days;
    }

    /**
     * Send hostname on DOMContentLoaded.
     * To prevent hostname set tui.usageStatistics to false.
     * @param {string} appName - application name
     * @param {string} trackingId - GA tracking ID
     * @ignore
     */
    function sendHostname(appName, trackingId) {
      var url = 'https://www.google-analytics.com/collect';
      var hostname = location.hostname;
      var hitType = 'event';
      var eventCategory = 'use';
      var applicationKeyForStorage = 'TOAST UI ' + appName + ' for ' + hostname + ': Statistics';
      var date = window.localStorage.getItem(applicationKeyForStorage);

      // skip if the flag is defined and is set to false explicitly
      if (!isUndefined(window.tui) && window.tui.usageStatistics === false) {
        return;
      }

      // skip if not pass seven days old
      if (date && !isExpired(date)) {
        return;
      }

      window.localStorage.setItem(applicationKeyForStorage, new Date().getTime());

      setTimeout(function() {
        if (document.readyState === 'interactive' || document.readyState === 'complete') {
          imagePing(url, {
            v: 1,
            t: hitType,
            tid: trackingId,
            cid: hostname,
            dp: hostname,
            dh: appName,
            el: appName,
            ec: eventCategory
          });
        }
      }, 1000);
    }

    module.exports = sendHostname;


    /***/ }),
    /* 36 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Request image ping.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var forEachOwnProperties = __webpack_require__(16);

    /**
     * @module request
     */

    /**
     * Request image ping.
     * @param {String} url url for ping request
     * @param {Object} trackingInfo infos for make query string
     * @returns {HTMLElement}
     * @memberof module:request
     * @example
     * var imagePing = require('tui-code-snippet/request/imagePing'); // node, commonjs
     *
     * imagePing('https://www.google-analytics.com/collect', {
     *     v: 1,
     *     t: 'event',
     *     tid: 'trackingid',
     *     cid: 'cid',
     *     dp: 'dp',
     *     dh: 'dh'
     * });
     */
    function imagePing(url, trackingInfo) {
      var trackingElement = document.createElement('img');
      var queryString = '';
      forEachOwnProperties(trackingInfo, function(value, key) {
        queryString += '&' + key + '=' + value;
      });
      queryString = queryString.substring(1);

      trackingElement.src = url + '?' + queryString;

      trackingElement.style.display = 'none';
      document.body.appendChild(trackingElement);
      document.body.removeChild(trackingElement);

      return trackingElement;
    }

    module.exports = imagePing;


    /***/ }),
    /* 37 */
    /***/ (function(module, exports, __webpack_require__) {


    var template = __webpack_require__(7);

    module.exports = function(context) {
      var source =
          '<div class="tui-timepicker-btn-area">'
        + '  <input type="text" class="tui-timepicker-spinbox-input"'
        + '        maxlength="{{maxLength}}"'
        + '        size="{{maxLength}}"'
        + '        value="{{formatTime initialValue format}}"'
        + '        aria-label="TimePicker spinbox value">'
        + '  <button type="button" class="tui-timepicker-btn tui-timepicker-btn-up">'
        + '    <span class="tui-ico-t-btn">Increase</span>'
        + '  </button>'
        + '  <button type="button" class="tui-timepicker-btn tui-timepicker-btn-down">'
        + '    <span class="tui-ico-t-btn">Decrease</span>'
        + '  </button>'
        + '</div>';

      return template(source, context);
    };



    /***/ }),
    /* 38 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Selectbox (in TimePicker)
     * @author NHN. FE Development Lab <dl_javascript@nhn.com>
     */



    var inArray = __webpack_require__(0);
    var CustomEvents = __webpack_require__(8);
    var defineClass = __webpack_require__(9);
    var extend = __webpack_require__(2);
    var on = __webpack_require__(10);
    var off = __webpack_require__(11);
    var closest = __webpack_require__(12);
    var removeElement = __webpack_require__(13);
    var isHTMLNode = __webpack_require__(14);

    var util = __webpack_require__(15);
    var tmpl = __webpack_require__(39);

    /**
     * @class
     * @ignore
     * @param {string|HTMLElement} container - Container element or selector
     * @param {object} options - Options
     * @param {Array.<number>} options.items - Items
     * @param {number} options.initialValue - Initial value
     */
    var Selectbox = defineClass(
      /** @lends Selectbox.prototype */ {
        init: function(container, options) {
          options = extend(
            {
              items: []
            },
            options
          );

          /**
           * Container element
           * @type {HTMLElement}
           * @private
           */
          this._container = isHTMLNode(container)
            ? container
            : document.querySelector(container);

          /**
           * Selectbox items
           * @type {Array.<number>}
           * @private
           */
          this._items = options.items || [];

          /**
           * Selectbox disabled items info
           * @type {Array.<number>}
           * @private
           */
          this._disabledItems = options.disabledItems || [];

          /**
           * Selected index
           * @type {number}
           * @private
           */
          this._selectedIndex = Math.max(0, inArray(options.initialValue, this._items));

          /**
           * Time format for output
           * @type {string}
           * @private
           */
          this._format = options.format;

          /**
           * Select element
           * @type {HTMLElement}
           * @private
           */
          this._element = null;

          this._render();
          this._setEvents();
        },

        /**
         * Render selectbox
         * @private
         */
        _render: function() {
          var context;

          this._changeEnabledIndex();
          context = {
            items: this._items,
            format: this._format,
            initialValue: this.getValue(),
            disabledItems: this._disabledItems,
            formatTime: util.formatTime,
            equals: function(a, b) {
              return a === b;
            }
          };

          if (this._element) {
            this._removeElement();
          }

          this._container.innerHTML = tmpl(context);
          this._element = this._container.firstChild;
          on(this._element, 'change', this._onChangeHandler, this);
        },

        /**
         * Change the index of the enabled item
         * @private
         */
        _changeEnabledIndex: function() {
          var index = inArray(this.getValue(), this._items);
          if (this._disabledItems[index]) {
            this._selectedIndex = inArray(false, this._disabledItems);
          }
        },

        /**
         * Set disabledItems
         * @param {object} disabledItems - disabled status of items
         * @private
         */
        setDisabledItems: function(disabledItems) {
          this._disabledItems = disabledItems;
          this._render();
        },

        /**
         * Set events
         * @private
         */
        _setEvents: function() {
          this.on(
            'changeItems',
            function(items) {
              this._items = items;
              this._render();
            },
            this
          );
        },

        /**
         * Remove events
         * @private
         */
        _removeEvents: function() {
          this.off();
        },

        /**
         * Remove element
         * @private
         */
        _removeElement: function() {
          off(this._element, 'change', this._onChangeHandler, this);
          removeElement(this._element);
        },

        /**
         * Change event handler
         * @param {Event} ev Change event on a select element.
         * @private
         */
        _onChangeHandler: function(ev) {
          if (closest(util.getTarget(ev), 'select')) {
            this._setNewValue();
          }
        },

        /**
         * Set new value
         * @private
         */
        _setNewValue: function() {
          var newValue = Number(this._element.value);
          this._selectedIndex = inArray(newValue, this._items);
          this.fire('change', {
            value: newValue
          });
        },

        /**
         * Returns current value
         * @returns {number}
         */
        getValue: function() {
          return this._items[this._selectedIndex];
        },

        /**
         * Set value
         * @param {number} value - New value
         */
        setValue: function(value) {
          var newIndex = inArray(value, this._items);

          if (newIndex > -1 && newIndex !== this._selectedIndex) {
            this._selectedIndex = newIndex;
            this._element.value = value;
            this._setNewValue();
          }
        },

        /**
         * Destory
         */
        destroy: function() {
          this._removeEvents();
          this._removeElement();
          this._container = this._items = this._selectedIndex = this._element = null;
        }
      }
    );

    CustomEvents.mixin(Selectbox);
    module.exports = Selectbox;


    /***/ }),
    /* 39 */
    /***/ (function(module, exports, __webpack_require__) {


    var template = __webpack_require__(7);

    module.exports = function(context) {
      var source =
          '<select class="tui-timepicker-select" aria-label="Time">'
        + '  {{each items}}'
        + '    {{if equals initialValue @this}}'
        + '      <option value="{{@this}}" selected {{if disabledItems[@index]}}disabled{{/if}}>{{formatTime @this format}}</option>'
        + '    {{else}}'
        + '      <option value="{{@this}}" {{if disabledItems[@index]}}disabled{{/if}}>{{formatTime @this format}}</option>'
        + '    {{/if}}'
        + '  {{/each}}'
        + '</select>';

      return template(source, context);
    };



    /***/ }),
    /* 40 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Default locale texts
     * @author NHN. FE Development Lab <dl_javascript@nhn.com>
     */



    module.exports = {
      en: {
        am: 'AM',
        pm: 'PM'
      },
      ko: {
        am: '',
        pm: ''
      }
    };


    /***/ }),
    /* 41 */
    /***/ (function(module, exports, __webpack_require__) {


    var template = __webpack_require__(7);

    module.exports = function(context) {
      var source =
          '<div class="tui-timepicker">'
        + '  <div class="tui-timepicker-body">'
        + '    <div class="tui-timepicker-row">'
        + '      {{if isSpinbox}}'
        + '        <div class="tui-timepicker-column tui-timepicker-spinbox tui-timepicker-hour"></div>'
        + '        <span class="tui-timepicker-column tui-timepicker-colon"><span class="tui-ico-colon">:</span></span>'
        + '        <div class="tui-timepicker-column tui-timepicker-spinbox tui-timepicker-minute"></div>'
        + '        {{if showMeridiem}}'
        + '          {{meridiemElement}}'
        + '        {{/if}}'
        + '      {{else}}'
        + '        <div class="tui-timepicker-column tui-timepicker-selectbox tui-timepicker-hour"></div>'
        + '        <span class="tui-timepicker-column tui-timepicker-colon"><span class="tui-ico-colon">:</span></span>'
        + '        <div class="tui-timepicker-column tui-timepicker-selectbox tui-timepicker-minute"></div>'
        + '        {{if showMeridiem}}'
        + '          {{meridiemElement}}'
        + '        {{/if}}'
        + '      {{/if}}'
        + '    </div>'
        + '  </div>'
        + '</div>';

      return template(source, context);
    };



    /***/ }),
    /* 42 */
    /***/ (function(module, exports, __webpack_require__) {


    var template = __webpack_require__(7);

    module.exports = function(context) {
      var source =
          '{{if isSpinbox}}'
        + '  <div class="tui-timepicker-column tui-timepicker-checkbox tui-timepicker-meridiem">'
        + '    <div class="tui-timepicker-check-area">'
        + '      <ul class="tui-timepicker-check-lst">'
        + '        <li class="tui-timepicker-check">'
        + '          <div class="tui-timepicker-radio">'
        + '            <input type="radio"'
        + '                  name="optionsRadios-{{radioId}}"'
        + '                  value="AM"'
        + '                  class="tui-timepicker-radio-am"'
        + '                  id="tui-timepicker-radio-am-{{radioId}}">'
        + '            <label for="tui-timepicker-radio-am-{{radioId}}" class="tui-timepicker-radio-label">'
        + '              <span class="tui-timepicker-input-radio"></span>{{am}}'
        + '            </label>'
        + '          </div>'
        + '        </li>'
        + '        <li class="tui-timepicker-check">'
        + '          <div class="tui-timepicker-radio">'
        + '            <input type="radio"'
        + '                  name="optionsRadios-{{radioId}}"'
        + '                  value="PM"'
        + '                  class="tui-timepicker-radio-pm"'
        + '                  id="tui-timepicker-radio-pm-{{radioId}}">'
        + '            <label for="tui-timepicker-radio-pm-{{radioId}}" class="tui-timepicker-radio-label">'
        + '              <span class="tui-timepicker-input-radio"></span>{{pm}}'
        + '            </label>'
        + '          </div>'
        + '        </li>'
        + '      </ul>'
        + '    </div>'
        + '  </div>'
        + '{{else}}'
        + '  <div class="tui-timepicker-column tui-timepicker-selectbox tui-is-add-picker tui-timepicker-meridiem">'
        + '    <select class="tui-timepicker-select" aria-label="AM/PM">'
        + '      <option value="AM">{{am}}</option>'
        + '      <option value="PM">{{pm}}</option>'
        + '    </select>'
        + '  </div>'
        + '{{/if}}';

      return template(source, context);
    };



    /***/ })
    /******/ ]);
    });
    }(tuiTimePicker));

    /*!
     * TOAST UI Date Picker
     * @version 4.3.0
     * @author NHN. FE Development Lab <dl_javascript@nhn.com>
     * @license MIT
     */

    (function (module, exports) {
    (function webpackUniversalModuleDefinition(root, factory) {
    	module.exports = factory(tuiTimePicker.exports);
    })(window, function(__WEBPACK_EXTERNAL_MODULE__43__) {
    return /******/ (function(modules) { // webpackBootstrap
    /******/ 	// The module cache
    /******/ 	var installedModules = {};
    /******/
    /******/ 	// The require function
    /******/ 	function __webpack_require__(moduleId) {
    /******/
    /******/ 		// Check if module is in cache
    /******/ 		if(installedModules[moduleId]) {
    /******/ 			return installedModules[moduleId].exports;
    /******/ 		}
    /******/ 		// Create a new module (and put it into the cache)
    /******/ 		var module = installedModules[moduleId] = {
    /******/ 			i: moduleId,
    /******/ 			l: false,
    /******/ 			exports: {}
    /******/ 		};
    /******/
    /******/ 		// Execute the module function
    /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    /******/
    /******/ 		// Flag the module as loaded
    /******/ 		module.l = true;
    /******/
    /******/ 		// Return the exports of the module
    /******/ 		return module.exports;
    /******/ 	}
    /******/
    /******/
    /******/ 	// expose the modules object (__webpack_modules__)
    /******/ 	__webpack_require__.m = modules;
    /******/
    /******/ 	// expose the module cache
    /******/ 	__webpack_require__.c = installedModules;
    /******/
    /******/ 	// define getter function for harmony exports
    /******/ 	__webpack_require__.d = function(exports, name, getter) {
    /******/ 		if(!__webpack_require__.o(exports, name)) {
    /******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
    /******/ 		}
    /******/ 	};
    /******/
    /******/ 	// define __esModule on exports
    /******/ 	__webpack_require__.r = function(exports) {
    /******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
    /******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
    /******/ 		}
    /******/ 		Object.defineProperty(exports, '__esModule', { value: true });
    /******/ 	};
    /******/
    /******/ 	// create a fake namespace object
    /******/ 	// mode & 1: value is a module id, require it
    /******/ 	// mode & 2: merge all properties of value into the ns
    /******/ 	// mode & 4: return value when already ns object
    /******/ 	// mode & 8|1: behave like require
    /******/ 	__webpack_require__.t = function(value, mode) {
    /******/ 		if(mode & 1) value = __webpack_require__(value);
    /******/ 		if(mode & 8) return value;
    /******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
    /******/ 		var ns = Object.create(null);
    /******/ 		__webpack_require__.r(ns);
    /******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
    /******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
    /******/ 		return ns;
    /******/ 	};
    /******/
    /******/ 	// getDefaultExport function for compatibility with non-harmony modules
    /******/ 	__webpack_require__.n = function(module) {
    /******/ 		var getter = module && module.__esModule ?
    /******/ 			function getDefault() { return module['default']; } :
    /******/ 			function getModuleExports() { return module; };
    /******/ 		__webpack_require__.d(getter, 'a', getter);
    /******/ 		return getter;
    /******/ 	};
    /******/
    /******/ 	// Object.prototype.hasOwnProperty.call
    /******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
    /******/
    /******/ 	// __webpack_public_path__
    /******/ 	__webpack_require__.p = "dist";
    /******/
    /******/
    /******/ 	// Load entry module and return exports
    /******/ 	return __webpack_require__(__webpack_require__.s = 34);
    /******/ })
    /************************************************************************/
    /******/ ([
    /* 0 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview
     * This module provides a function to make a constructor
     * that can inherit from the other constructors like the CLASS easily.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var inherit = __webpack_require__(35);
    var extend = __webpack_require__(7);

    /**
     * @module defineClass
     */

    /**
     * Help a constructor to be defined and to inherit from the other constructors
     * @param {*} [parent] Parent constructor
     * @param {Object} props Members of constructor
     *  @param {Function} props.init Initialization method
     *  @param {Object} [props.static] Static members of constructor
     * @returns {*} Constructor
     * @memberof module:defineClass
     * @example
     * var defineClass = require('tui-code-snippet/defineClass/defineClass'); // node, commonjs
     *
     * //-- #2. Use property --//
     * var Parent = defineClass({
     *     init: function() { // constuructor
     *         this.name = 'made by def';
     *     },
     *     method: function() {
     *         // ...
     *     },
     *     static: {
     *         staticMethod: function() {
     *              // ...
     *         }
     *     }
     * });
     *
     * var Child = defineClass(Parent, {
     *     childMethod: function() {}
     * });
     *
     * Parent.staticMethod();
     *
     * var parentInstance = new Parent();
     * console.log(parentInstance.name); //made by def
     * parentInstance.staticMethod(); // Error
     *
     * var childInstance = new Child();
     * childInstance.method();
     * childInstance.childMethod();
     */
    function defineClass(parent, props) {
      var obj;

      if (!props) {
        props = parent;
        parent = null;
      }

      obj = props.init || function() {};

      if (parent) {
        inherit(obj, parent);
      }

      if (props.hasOwnProperty('static')) {
        extend(obj, props['static']);
        delete props['static'];
      }

      extend(obj.prototype, props);

      return obj;
    }

    module.exports = defineClass;


    /***/ }),
    /* 1 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Constants of date-picker
     * @author NHN. FE Development Lab <dl_javascript@nhn.com>
     */



    module.exports = {
      TYPE_DATE: 'date',
      TYPE_MONTH: 'month',
      TYPE_YEAR: 'year',
      TYPE_HOUR: 'hour',
      TYPE_MINUTE: 'minute',
      TYPE_MERIDIEM: 'meridiem',
      MIN_DATE: new Date(1900, 0, 1),
      MAX_DATE: new Date(2999, 11, 31),

      DEFAULT_LANGUAGE_TYPE: 'en',

      CLASS_NAME_SELECTED: 'tui-is-selected',

      CLASS_NAME_PREV_MONTH_BTN: 'tui-calendar-btn-prev-month',
      CLASS_NAME_PREV_YEAR_BTN: 'tui-calendar-btn-prev-year',
      CLASS_NAME_NEXT_YEAR_BTN: 'tui-calendar-btn-next-year',
      CLASS_NAME_NEXT_MONTH_BTN: 'tui-calendar-btn-next-month',
      CLASS_NAME_TITLE_TODAY: 'tui-calendar-title-today',

      DEFAULT_WEEK_START_DAY: 'Sun',
      WEEK_START_DAY_MAP: {
        sun: 0,
        mon: 1,
        tue: 2,
        wed: 3,
        thu: 4,
        fri: 5,
        sat: 6
      }
    };


    /***/ }),
    /* 2 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Execute the provided callback once for each element present in the array(or Array-like object) in ascending order.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Execute the provided callback once for each element present
     * in the array(or Array-like object) in ascending order.
     * If the callback function returns false, the loop will be stopped.
     * Callback function(iteratee) is invoked with three arguments:
     *  1) The value of the element
     *  2) The index of the element
     *  3) The array(or Array-like object) being traversed
     * @param {Array|Arguments|NodeList} arr The array(or Array-like object) that will be traversed
     * @param {function} iteratee Callback function
     * @param {Object} [context] Context(this) of callback function
     * @memberof module:collection
     * @example
     * var forEachArray = require('tui-code-snippet/collection/forEachArray'); // node, commonjs
     *
     * var sum = 0;
     *
     * forEachArray([1,2,3], function(value){
     *     sum += value;
     * });
     * alert(sum); // 6
     */
    function forEachArray(arr, iteratee, context) {
      var index = 0;
      var len = arr.length;

      context = context || null;

      for (; index < len; index += 1) {
        if (iteratee.call(context, arr[index], index, arr) === false) {
          break;
        }
      }
    }

    module.exports = forEachArray;


    /***/ }),
    /* 3 */
    /***/ (function(module, exports, __webpack_require__) {
    /* eslint-disable complexity */
    /**
     * @fileoverview Returns the first index at which a given element can be found in the array.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var isArray = __webpack_require__(6);

    /**
     * @module array
     */

    /**
     * Returns the first index at which a given element can be found in the array
     * from start index(default 0), or -1 if it is not present.
     * It compares searchElement to elements of the Array using strict equality
     * (the same method used by the ===, or triple-equals, operator).
     * @param {*} searchElement Element to locate in the array
     * @param {Array} array Array that will be traversed.
     * @param {number} startIndex Start index in array for searching (default 0)
     * @returns {number} the First index at which a given element, or -1 if it is not present
     * @memberof module:array
     * @example
     * var inArray = require('tui-code-snippet/array/inArray'); // node, commonjs
     *
     * var arr = ['one', 'two', 'three', 'four'];
     * var idx1 = inArray('one', arr, 3); // -1
     * var idx2 = inArray('one', arr); // 0
     */
    function inArray(searchElement, array, startIndex) {
      var i;
      var length;
      startIndex = startIndex || 0;

      if (!isArray(array)) {
        return -1;
      }

      if (Array.prototype.indexOf) {
        return Array.prototype.indexOf.call(array, searchElement, startIndex);
      }

      length = array.length;
      for (i = startIndex; startIndex >= 0 && i < length; i += 1) {
        if (array[i] === searchElement) {
          return i;
        }
      }

      return -1;
    }

    module.exports = inArray;


    /***/ }),
    /* 4 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Utils for Datepicker component
     * @author NHN. FE Development Lab <dl_javascript@nhn.com>
     */



    var forEachArray = __webpack_require__(2);
    var isHTMLNode = __webpack_require__(46);
    var sendHostname = __webpack_require__(47);

    var currentId = 0;

    var utils = {
      /**
       * Get a target element
       * @param {Event} ev Event object
       * @returns {HTMLElement} An event target element
       */
      getTarget: function(ev) {
        return ev.target || ev.srcElement;
      },

      /**
       * Return the same element with an element or a matched element searched by a selector.
       * @param {HTMLElement|string} param HTMLElement or selector
       * @returns {HTMLElement} A matched element
       */
      getElement: function(param) {
        return isHTMLNode(param) ? param : document.querySelector(param);
      },

      /**
       * Get a selector of the element.
       * @param {HTMLElement} elem An element
       * @returns {string}
       */
      getSelector: function(elem) {
        var selector = '';
        if (elem.id) {
          selector = '#' + elem.id;
        } else if (elem.className) {
          selector = '.' + elem.className.split(' ')[0];
        }

        return selector;
      },

      /**
       * Create an unique id.
       * @returns {number}
       */
      generateId: function() {
        currentId += 1;

        return currentId;
      },

      /**
       * Create a new array with all elements that pass the test implemented by the provided function.
       * @param {Array} arr - Array that will be traversed
       * @param {function} iteratee - iteratee callback function
       * @returns {Array}
       */
      filter: function(arr, iteratee) {
        var result = [];

        forEachArray(arr, function(item) {
          if (iteratee(item)) {
            result.push(item);
          }
        });

        return result;
      },

      /**
       * Send hostname for GA
       * @ignore
       */
      sendHostName: function() {
        sendHostname('date-picker', 'UA-129987462-1');
      }
    };

    module.exports = utils;


    /***/ }),
    /* 5 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Utils for DatePicker component
     * @author NHN. FE dev Lab. <dl_javascript@nhn.com>
     */



    var isDate = __webpack_require__(28);
    var isNumber = __webpack_require__(15);

    var constants = __webpack_require__(1);

    var TYPE_DATE = constants.TYPE_DATE;
    var TYPE_MONTH = constants.TYPE_MONTH;
    var TYPE_YEAR = constants.TYPE_YEAR;

    /**
     * Utils of calendar
     * @namespace dateUtil
     * @ignore
     */
    var utils = {
      /**
       * Get weeks count by paramenter
       * @param {number} year A year
       * @param {number} month A month
       * @returns {number} Weeks count (4~6)
       **/
      getWeeksCount: function(year, month) {
        var firstDay = utils.getFirstDay(year, month),
          lastDate = utils.getLastDayInMonth(year, month);

        return Math.ceil((firstDay + lastDate) / 7);
      },

      /**
       * @param {Date} date - Date instance
       * @returns {boolean}
       */
      isValidDate: function(date) {
        return isDate(date) && !isNaN(date.getTime());
      },

      /**
       * Get which day is first by parameters that include year and month information.
       * @param {number} year A year
       * @param {number} month A month
       * @returns {number} (0~6)
       */
      getFirstDay: function(year, month) {
        return new Date(year, month - 1, 1).getDay();
      },

      /**
       * Get timestamp of the first day.
       * @param {number} year A year
       * @param {number} month A month
       * @returns {number} timestamp
       */
      getFirstDayTimestamp: function(year, month) {
        return new Date(year, month, 1).getTime();
      },

      /**
       * Get last date by parameters that include year and month information.
       * @param {number} year A year
       * @param {number} month A month
       * @returns {number} (1~31)
       */
      getLastDayInMonth: function(year, month) {
        return new Date(year, month, 0).getDate();
      },

      /**
       * Chagne number 0~9 to '00~09'
       * @param {number} number number
       * @returns {string}
       * @example
       *  dateUtil.prependLeadingZero(0); //  '00'
       *  dateUtil.prependLeadingZero(9); //  '09'
       *  dateUtil.prependLeadingZero(12); //  '12'
       */
      prependLeadingZero: function(number) {
        var prefix = '';

        if (number < 10) {
          prefix = '0';
        }

        return prefix + number;
      },

      /**
       * Get meridiem hour
       * @param {number} hour - Original hour
       * @returns {number} Converted meridiem hour
       */
      getMeridiemHour: function(hour) {
        hour %= 12;

        if (hour === 0) {
          hour = 12;
        }

        return hour;
      },

      /**
       * Returns number or default
       * @param {*} any - Any value
       * @param {number} defaultNumber - Default number
       * @throws Will throw an error if the defaultNumber is invalid.
       * @returns {number}
       */
      getSafeNumber: function(any, defaultNumber) {
        if (isNaN(defaultNumber) || !isNumber(defaultNumber)) {
          throw Error('The defaultNumber must be a valid number.');
        }
        if (isNaN(any)) {
          return defaultNumber;
        }

        return Number(any);
      },

      /**
       * Return date of the week
       * @param {number} year - Year
       * @param {number} month - Month
       * @param {number} weekNumber - Week number (0~5)
       * @param {number} dayNumber - Day number (0: sunday, 1: monday, ....)
       * @returns {number}
       */
      getDateOfWeek: function(year, month, weekNumber, dayNumber) {
        var firstDayOfMonth = new Date(year, month - 1).getDay();
        var dateOffset = firstDayOfMonth - dayNumber - 1;

        return new Date(year, month - 1, weekNumber * 7 - dateOffset);
      },

      /**
       * Returns range arr
       * @param {number} start - Start value
       * @param {number} end - End value
       * @returns {Array}
       */
      getRangeArr: function(start, end) {
        var arr = [];
        var i;

        if (start > end) {
          for (i = end; i >= start; i -= 1) {
            arr.push(i);
          }
        } else {
          for (i = start; i <= end; i += 1) {
            arr.push(i);
          }
        }

        return arr;
      },

      /**
       * Returns cloned date with the start of a unit of time
       * @param {Date|number} date - Original date
       * @param {string} [type = TYPE_DATE] - Unit type
       * @throws {Error}
       * @returns {Date}
       */
      cloneWithStartOf: function(date, type) {
        type = type || TYPE_DATE;
        date = new Date(date);

        // Does not consider time-level yet.
        date.setHours(0, 0, 0, 0);

        switch (type) {
          case TYPE_DATE:
            break;
          case TYPE_MONTH:
            date.setDate(1);
            break;
          case TYPE_YEAR:
            date.setMonth(0, 1);
            break;
          default:
            throw Error('Unsupported type: ' + type);
        }

        return date;
      },

      /**
       * Returns cloned date with the end of a unit of time
       * @param {Date|number} date - Original date
       * @param {string} [type = TYPE_DATE] - Unit type
       * @throws {Error}
       * @returns {Date}
       */
      cloneWithEndOf: function(date, type) {
        type = type || TYPE_DATE;
        date = new Date(date);

        // Does not consider time-level yet.
        date.setHours(23, 59, 59, 999);

        switch (type) {
          case TYPE_DATE:
            break;
          case TYPE_MONTH:
            date.setMonth(date.getMonth() + 1, 0);
            break;
          case TYPE_YEAR:
            date.setMonth(11, 31);
            break;
          default:
            throw Error('Unsupported type: ' + type);
        }

        return date;
      },

      /**
       * Compare two dates
       * @param {Date|number} dateA - Date
       * @param {Date|number} dateB - Date
       * @param {string} [cmpLevel] - Comparing level
       * @returns {number}
       */
      compare: function(dateA, dateB, cmpLevel) {
        var aTimestamp, bTimestamp;

        if (!(utils.isValidDate(dateA) && utils.isValidDate(dateB))) {
          return NaN;
        }

        if (!cmpLevel) {
          aTimestamp = dateA.getTime();
          bTimestamp = dateB.getTime();
        } else {
          aTimestamp = utils.cloneWithStartOf(dateA, cmpLevel).getTime();
          bTimestamp = utils.cloneWithStartOf(dateB, cmpLevel).getTime();
        }

        if (aTimestamp > bTimestamp) {
          return 1;
        }

        return aTimestamp === bTimestamp ? 0 : -1;
      },

      /**
       * Returns whether two dates are same
       * @param {Date|number} dateA - Date
       * @param {Date|number} dateB - Date
       * @param {string} [cmpLevel] - Comparing level
       * @returns {boolean}
       */
      isSame: function(dateA, dateB, cmpLevel) {
        return utils.compare(dateA, dateB, cmpLevel) === 0;
      },

      /**
       * Returns whether the target is in range
       * @param {Date|number} start - Range start
       * @param {Date|number} end - Range end
       * @param {Date|number} target - Target
       * @param {string} [cmpLevel = TYPE_DATE] - Comparing level
       * @returns {boolean}
       */
      inRange: function(start, end, target, cmpLevel) {
        return utils.compare(start, target, cmpLevel) < 1 && utils.compare(end, target, cmpLevel) > -1;
      }
    };

    module.exports = utils;


    /***/ }),
    /* 6 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is an instance of Array or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Check whether the given variable is an instance of Array or not.
     * If the given variable is an instance of Array, return true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is array instance?
     * @memberof module:type
     */
    function isArray(obj) {
      return obj instanceof Array;
    }

    module.exports = isArray;


    /***/ }),
    /* 7 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Extend the target object from other objects.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * @module object
     */

    /**
     * Extend the target object from other objects.
     * @param {object} target - Object that will be extended
     * @param {...object} objects - Objects as sources
     * @returns {object} Extended object
     * @memberof module:object
     */
    function extend(target, objects) { // eslint-disable-line no-unused-vars
      var hasOwnProp = Object.prototype.hasOwnProperty;
      var source, prop, i, len;

      for (i = 1, len = arguments.length; i < len; i += 1) {
        source = arguments[i];
        for (prop in source) {
          if (hasOwnProp.call(source, prop)) {
            target[prop] = source[prop];
          }
        }
      }

      return target;
    }

    module.exports = extend;


    /***/ }),
    /* 8 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview This module provides some functions for custom events. And it is implemented in the observer design pattern.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var extend = __webpack_require__(7);
    var isExisty = __webpack_require__(37);
    var isString = __webpack_require__(13);
    var isObject = __webpack_require__(22);
    var isArray = __webpack_require__(6);
    var isFunction = __webpack_require__(39);
    var forEach = __webpack_require__(9);

    var R_EVENTNAME_SPLIT = /\s+/g;

    /**
     * @class
     * @example
     * // node, commonjs
     * var CustomEvents = require('tui-code-snippet/customEvents/customEvents');
     */
    function CustomEvents() {
      /**
         * @type {HandlerItem[]}
         */
      this.events = null;

      /**
         * only for checking specific context event was binded
         * @type {object[]}
         */
      this.contexts = null;
    }

    /**
     * Mixin custom events feature to specific constructor
     * @param {function} func - constructor
     * @example
     * var CustomEvents = require('tui-code-snippet/customEvents/customEvents'); // node, commonjs
     *
     * var model;
     * function Model() {
     *     this.name = '';
     * }
     * CustomEvents.mixin(Model);
     *
     * model = new Model();
     * model.on('change', function() { this.name = 'model'; }, this);
     * model.fire('change');
     * alert(model.name); // 'model';
     */
    CustomEvents.mixin = function(func) {
      extend(func.prototype, CustomEvents.prototype);
    };

    /**
     * Get HandlerItem object
     * @param {function} handler - handler function
     * @param {object} [context] - context for handler
     * @returns {HandlerItem} HandlerItem object
     * @private
     */
    CustomEvents.prototype._getHandlerItem = function(handler, context) {
      var item = {handler: handler};

      if (context) {
        item.context = context;
      }

      return item;
    };

    /**
     * Get event object safely
     * @param {string} [eventName] - create sub event map if not exist.
     * @returns {(object|array)} event object. if you supplied `eventName`
     *  parameter then make new array and return it
     * @private
     */
    CustomEvents.prototype._safeEvent = function(eventName) {
      var events = this.events;
      var byName;

      if (!events) {
        events = this.events = {};
      }

      if (eventName) {
        byName = events[eventName];

        if (!byName) {
          byName = [];
          events[eventName] = byName;
        }

        events = byName;
      }

      return events;
    };

    /**
     * Get context array safely
     * @returns {array} context array
     * @private
     */
    CustomEvents.prototype._safeContext = function() {
      var context = this.contexts;

      if (!context) {
        context = this.contexts = [];
      }

      return context;
    };

    /**
     * Get index of context
     * @param {object} ctx - context that used for bind custom event
     * @returns {number} index of context
     * @private
     */
    CustomEvents.prototype._indexOfContext = function(ctx) {
      var context = this._safeContext();
      var index = 0;

      while (context[index]) {
        if (ctx === context[index][0]) {
          return index;
        }

        index += 1;
      }

      return -1;
    };

    /**
     * Memorize supplied context for recognize supplied object is context or
     *  name: handler pair object when off()
     * @param {object} ctx - context object to memorize
     * @private
     */
    CustomEvents.prototype._memorizeContext = function(ctx) {
      var context, index;

      if (!isExisty(ctx)) {
        return;
      }

      context = this._safeContext();
      index = this._indexOfContext(ctx);

      if (index > -1) {
        context[index][1] += 1;
      } else {
        context.push([ctx, 1]);
      }
    };

    /**
     * Forget supplied context object
     * @param {object} ctx - context object to forget
     * @private
     */
    CustomEvents.prototype._forgetContext = function(ctx) {
      var context, contextIndex;

      if (!isExisty(ctx)) {
        return;
      }

      context = this._safeContext();
      contextIndex = this._indexOfContext(ctx);

      if (contextIndex > -1) {
        context[contextIndex][1] -= 1;

        if (context[contextIndex][1] <= 0) {
          context.splice(contextIndex, 1);
        }
      }
    };

    /**
     * Bind event handler
     * @param {(string|{name:string, handler:function})} eventName - custom
     *  event name or an object {eventName: handler}
     * @param {(function|object)} [handler] - handler function or context
     * @param {object} [context] - context for binding
     * @private
     */
    CustomEvents.prototype._bindEvent = function(eventName, handler, context) {
      var events = this._safeEvent(eventName);
      this._memorizeContext(context);
      events.push(this._getHandlerItem(handler, context));
    };

    /**
     * Bind event handlers
     * @param {(string|{name:string, handler:function})} eventName - custom
     *  event name or an object {eventName: handler}
     * @param {(function|object)} [handler] - handler function or context
     * @param {object} [context] - context for binding
     * //-- #1. Get Module --//
     * var CustomEvents = require('tui-code-snippet/customEvents/customEvents'); // node, commonjs
     *
     * //-- #2. Use method --//
     * // # 2.1 Basic Usage
     * CustomEvents.on('onload', handler);
     *
     * // # 2.2 With context
     * CustomEvents.on('onload', handler, myObj);
     *
     * // # 2.3 Bind by object that name, handler pairs
     * CustomEvents.on({
     *     'play': handler,
     *     'pause': handler2
     * });
     *
     * // # 2.4 Bind by object that name, handler pairs with context object
     * CustomEvents.on({
     *     'play': handler
     * }, myObj);
     */
    CustomEvents.prototype.on = function(eventName, handler, context) {
      var self = this;

      if (isString(eventName)) {
        // [syntax 1, 2]
        eventName = eventName.split(R_EVENTNAME_SPLIT);
        forEach(eventName, function(name) {
          self._bindEvent(name, handler, context);
        });
      } else if (isObject(eventName)) {
        // [syntax 3, 4]
        context = handler;
        forEach(eventName, function(func, name) {
          self.on(name, func, context);
        });
      }
    };

    /**
     * Bind one-shot event handlers
     * @param {(string|{name:string,handler:function})} eventName - custom
     *  event name or an object {eventName: handler}
     * @param {function|object} [handler] - handler function or context
     * @param {object} [context] - context for binding
     */
    CustomEvents.prototype.once = function(eventName, handler, context) {
      var self = this;

      if (isObject(eventName)) {
        context = handler;
        forEach(eventName, function(func, name) {
          self.once(name, func, context);
        });

        return;
      }

      function onceHandler() { // eslint-disable-line require-jsdoc
        handler.apply(context, arguments);
        self.off(eventName, onceHandler, context);
      }

      this.on(eventName, onceHandler, context);
    };

    /**
     * Splice supplied array by callback result
     * @param {array} arr - array to splice
     * @param {function} predicate - function return boolean
     * @private
     */
    CustomEvents.prototype._spliceMatches = function(arr, predicate) {
      var i = 0;
      var len;

      if (!isArray(arr)) {
        return;
      }

      for (len = arr.length; i < len; i += 1) {
        if (predicate(arr[i]) === true) {
          arr.splice(i, 1);
          len -= 1;
          i -= 1;
        }
      }
    };

    /**
     * Get matcher for unbind specific handler events
     * @param {function} handler - handler function
     * @returns {function} handler matcher
     * @private
     */
    CustomEvents.prototype._matchHandler = function(handler) {
      var self = this;

      return function(item) {
        var needRemove = handler === item.handler;

        if (needRemove) {
          self._forgetContext(item.context);
        }

        return needRemove;
      };
    };

    /**
     * Get matcher for unbind specific context events
     * @param {object} context - context
     * @returns {function} object matcher
     * @private
     */
    CustomEvents.prototype._matchContext = function(context) {
      var self = this;

      return function(item) {
        var needRemove = context === item.context;

        if (needRemove) {
          self._forgetContext(item.context);
        }

        return needRemove;
      };
    };

    /**
     * Get matcher for unbind specific hander, context pair events
     * @param {function} handler - handler function
     * @param {object} context - context
     * @returns {function} handler, context matcher
     * @private
     */
    CustomEvents.prototype._matchHandlerAndContext = function(handler, context) {
      var self = this;

      return function(item) {
        var matchHandler = (handler === item.handler);
        var matchContext = (context === item.context);
        var needRemove = (matchHandler && matchContext);

        if (needRemove) {
          self._forgetContext(item.context);
        }

        return needRemove;
      };
    };

    /**
     * Unbind event by event name
     * @param {string} eventName - custom event name to unbind
     * @param {function} [handler] - handler function
     * @private
     */
    CustomEvents.prototype._offByEventName = function(eventName, handler) {
      var self = this;
      var andByHandler = isFunction(handler);
      var matchHandler = self._matchHandler(handler);

      eventName = eventName.split(R_EVENTNAME_SPLIT);

      forEach(eventName, function(name) {
        var handlerItems = self._safeEvent(name);

        if (andByHandler) {
          self._spliceMatches(handlerItems, matchHandler);
        } else {
          forEach(handlerItems, function(item) {
            self._forgetContext(item.context);
          });

          self.events[name] = [];
        }
      });
    };

    /**
     * Unbind event by handler function
     * @param {function} handler - handler function
     * @private
     */
    CustomEvents.prototype._offByHandler = function(handler) {
      var self = this;
      var matchHandler = this._matchHandler(handler);

      forEach(this._safeEvent(), function(handlerItems) {
        self._spliceMatches(handlerItems, matchHandler);
      });
    };

    /**
     * Unbind event by object(name: handler pair object or context object)
     * @param {object} obj - context or {name: handler} pair object
     * @param {function} handler - handler function
     * @private
     */
    CustomEvents.prototype._offByObject = function(obj, handler) {
      var self = this;
      var matchFunc;

      if (this._indexOfContext(obj) < 0) {
        forEach(obj, function(func, name) {
          self.off(name, func);
        });
      } else if (isString(handler)) {
        matchFunc = this._matchContext(obj);

        self._spliceMatches(this._safeEvent(handler), matchFunc);
      } else if (isFunction(handler)) {
        matchFunc = this._matchHandlerAndContext(handler, obj);

        forEach(this._safeEvent(), function(handlerItems) {
          self._spliceMatches(handlerItems, matchFunc);
        });
      } else {
        matchFunc = this._matchContext(obj);

        forEach(this._safeEvent(), function(handlerItems) {
          self._spliceMatches(handlerItems, matchFunc);
        });
      }
    };

    /**
     * Unbind custom events
     * @param {(string|object|function)} eventName - event name or context or
     *  {name: handler} pair object or handler function
     * @param {(function)} handler - handler function
     * @example
     * //-- #1. Get Module --//
     * var CustomEvents = require('tui-code-snippet/customEvents/customEvents'); // node, commonjs
     *
     * //-- #2. Use method --//
     * // # 2.1 off by event name
     * CustomEvents.off('onload');
     *
     * // # 2.2 off by event name and handler
     * CustomEvents.off('play', handler);
     *
     * // # 2.3 off by handler
     * CustomEvents.off(handler);
     *
     * // # 2.4 off by context
     * CustomEvents.off(myObj);
     *
     * // # 2.5 off by context and handler
     * CustomEvents.off(myObj, handler);
     *
     * // # 2.6 off by context and event name
     * CustomEvents.off(myObj, 'onload');
     *
     * // # 2.7 off by an Object.<string, function> that is {eventName: handler}
     * CustomEvents.off({
     *   'play': handler,
     *   'pause': handler2
     * });
     *
     * // # 2.8 off the all events
     * CustomEvents.off();
     */
    CustomEvents.prototype.off = function(eventName, handler) {
      if (isString(eventName)) {
        // [syntax 1, 2]
        this._offByEventName(eventName, handler);
      } else if (!arguments.length) {
        // [syntax 8]
        this.events = {};
        this.contexts = [];
      } else if (isFunction(eventName)) {
        // [syntax 3]
        this._offByHandler(eventName);
      } else if (isObject(eventName)) {
        // [syntax 4, 5, 6]
        this._offByObject(eventName, handler);
      }
    };

    /**
     * Fire custom event
     * @param {string} eventName - name of custom event
     */
    CustomEvents.prototype.fire = function(eventName) {  // eslint-disable-line
      this.invoke.apply(this, arguments);
    };

    /**
     * Fire a event and returns the result of operation 'boolean AND' with all
     *  listener's results.
     *
     * So, It is different from {@link CustomEvents#fire}.
     *
     * In service code, use this as a before event in component level usually
     *  for notifying that the event is cancelable.
     * @param {string} eventName - Custom event name
     * @param {...*} data - Data for event
     * @returns {boolean} The result of operation 'boolean AND'
     * @example
     * var map = new Map();
     * map.on({
     *     'beforeZoom': function() {
     *         // It should cancel the 'zoom' event by some conditions.
     *         if (that.disabled && this.getState()) {
     *             return false;
     *         }
     *         return true;
     *     }
     * });
     *
     * if (this.invoke('beforeZoom')) {    // check the result of 'beforeZoom'
     *     // if true,
     *     // doSomething
     * }
     */
    CustomEvents.prototype.invoke = function(eventName) {
      var events, args, index, item;

      if (!this.hasListener(eventName)) {
        return true;
      }

      events = this._safeEvent(eventName);
      args = Array.prototype.slice.call(arguments, 1);
      index = 0;

      while (events[index]) {
        item = events[index];

        if (item.handler.apply(item.context, args) === false) {
          return false;
        }

        index += 1;
      }

      return true;
    };

    /**
     * Return whether at least one of the handlers is registered in the given
     *  event name.
     * @param {string} eventName - Custom event name
     * @returns {boolean} Is there at least one handler in event name?
     */
    CustomEvents.prototype.hasListener = function(eventName) {
      return this.getListenerLength(eventName) > 0;
    };

    /**
     * Return a count of events registered.
     * @param {string} eventName - Custom event name
     * @returns {number} number of event
     */
    CustomEvents.prototype.getListenerLength = function(eventName) {
      var events = this._safeEvent(eventName);

      return events.length;
    };

    module.exports = CustomEvents;


    /***/ }),
    /* 9 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Execute the provided callback once for each property of object(or element of array) which actually exist.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var isArray = __webpack_require__(6);
    var forEachArray = __webpack_require__(2);
    var forEachOwnProperties = __webpack_require__(23);

    /**
     * @module collection
     */

    /**
     * Execute the provided callback once for each property of object(or element of array) which actually exist.
     * If the object is Array-like object(ex-arguments object), It needs to transform to Array.(see 'ex2' of example).
     * If the callback function returns false, the loop will be stopped.
     * Callback function(iteratee) is invoked with three arguments:
     *  1) The value of the property(or The value of the element)
     *  2) The name of the property(or The index of the element)
     *  3) The object being traversed
     * @param {Object} obj The object that will be traversed
     * @param {function} iteratee Callback function
     * @param {Object} [context] Context(this) of callback function
     * @memberof module:collection
     * @example
     * var forEach = require('tui-code-snippet/collection/forEach'); // node, commonjs
     *
     * var sum = 0;
     *
     * forEach([1,2,3], function(value){
     *     sum += value;
     * });
     * alert(sum); // 6
     *
     * // In case of Array-like object
     * var array = Array.prototype.slice.call(arrayLike); // change to array
     * forEach(array, function(value){
     *     sum += value;
     * });
     */
    function forEach(obj, iteratee, context) {
      if (isArray(obj)) {
        forEachArray(obj, iteratee, context);
      } else {
        forEachOwnProperties(obj, iteratee, context);
      }
    }

    module.exports = forEach;


    /***/ }),
    /* 10 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Default locale texts
     * @author NHN. FE Development Lab <dl_javascript@nhn.com>
     */



    module.exports = {
      en: {
        titles: {
          DD: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
          D: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
          MMM: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
          MMMM: [
            'January',
            'February',
            'March',
            'April',
            'May',
            'June',
            'July',
            'August',
            'September',
            'October',
            'November',
            'December'
          ]
        },
        titleFormat: 'MMMM yyyy',
        todayFormat: 'To\\d\\ay: DD, MMMM d, yyyy',
        time: 'Time',
        date: 'Date'
      },
      ko: {
        titles: {
          DD: ['', '', '', '', '', '', ''],
          D: ['', '', '', '', '', '', ''],
          MMM: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
          MMMM: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12']
        },
        titleFormat: 'yyyy.MM',
        todayFormat: ': yyyy.MM.dd (D)',
        date: '',
        time: ''
      }
    };


    /***/ }),
    /* 11 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Convert text by binding expressions with context.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var inArray = __webpack_require__(3);
    var forEach = __webpack_require__(9);
    var isArray = __webpack_require__(6);
    var isString = __webpack_require__(13);
    var extend = __webpack_require__(7);

    // IE8 does not support capture groups.
    var EXPRESSION_REGEXP = /{{\s?|\s?}}/g;
    var BRACKET_NOTATION_REGEXP = /^[a-zA-Z0-9_@]+\[[a-zA-Z0-9_@"']+\]$/;
    var BRACKET_REGEXP = /\[\s?|\s?\]/;
    var DOT_NOTATION_REGEXP = /^[a-zA-Z_]+\.[a-zA-Z_]+$/;
    var DOT_REGEXP = /\./;
    var STRING_NOTATION_REGEXP = /^["']\w+["']$/;
    var STRING_REGEXP = /"|'/g;
    var NUMBER_REGEXP = /^-?\d+\.?\d*$/;

    var EXPRESSION_INTERVAL = 2;

    var BLOCK_HELPERS = {
      'if': handleIf,
      'each': handleEach,
      'with': handleWith
    };

    var isValidSplit = 'a'.split(/a/).length === 3;

    /**
     * Split by RegExp. (Polyfill for IE8)
     * @param {string} text - text to be splitted\
     * @param {RegExp} regexp - regular expression
     * @returns {Array.<string>}
     */
    var splitByRegExp = (function() {
      if (isValidSplit) {
        return function(text, regexp) {
          return text.split(regexp);
        };
      }

      return function(text, regexp) {
        var result = [];
        var prevIndex = 0;
        var match, index;

        if (!regexp.global) {
          regexp = new RegExp(regexp, 'g');
        }

        match = regexp.exec(text);
        while (match !== null) {
          index = match.index;
          result.push(text.slice(prevIndex, index));

          prevIndex = index + match[0].length;
          match = regexp.exec(text);
        }
        result.push(text.slice(prevIndex));

        return result;
      };
    })();

    /**
     * Find value in the context by an expression.
     * @param {string} exp - an expression
     * @param {object} context - context
     * @returns {*}
     * @private
     */
    // eslint-disable-next-line complexity
    function getValueFromContext(exp, context) {
      var splitedExps;
      var value = context[exp];

      if (exp === 'true') {
        value = true;
      } else if (exp === 'false') {
        value = false;
      } else if (STRING_NOTATION_REGEXP.test(exp)) {
        value = exp.replace(STRING_REGEXP, '');
      } else if (BRACKET_NOTATION_REGEXP.test(exp)) {
        splitedExps = exp.split(BRACKET_REGEXP);
        value = getValueFromContext(splitedExps[0], context)[getValueFromContext(splitedExps[1], context)];
      } else if (DOT_NOTATION_REGEXP.test(exp)) {
        splitedExps = exp.split(DOT_REGEXP);
        value = getValueFromContext(splitedExps[0], context)[splitedExps[1]];
      } else if (NUMBER_REGEXP.test(exp)) {
        value = parseFloat(exp);
      }

      return value;
    }

    /**
     * Extract elseif and else expressions.
     * @param {Array.<string>} ifExps - args of if expression
     * @param {Array.<string>} sourcesInsideBlock - sources inside if block
     * @returns {object} - exps: expressions of if, elseif, and else / sourcesInsideIf: sources inside if, elseif, and else block.
     * @private
     */
    function extractElseif(ifExps, sourcesInsideBlock) {
      var exps = [ifExps];
      var sourcesInsideIf = [];
      var otherIfCount = 0;
      var start = 0;

      // eslint-disable-next-line complexity
      forEach(sourcesInsideBlock, function(source, index) {
        if (source.indexOf('if') === 0) {
          otherIfCount += 1;
        } else if (source === '/if') {
          otherIfCount -= 1;
        } else if (!otherIfCount && (source.indexOf('elseif') === 0 || source === 'else')) {
          exps.push(source === 'else' ? ['true'] : source.split(' ').slice(1));
          sourcesInsideIf.push(sourcesInsideBlock.slice(start, index));
          start = index + 1;
        }
      });

      sourcesInsideIf.push(sourcesInsideBlock.slice(start));

      return {
        exps: exps,
        sourcesInsideIf: sourcesInsideIf
      };
    }

    /**
     * Helper function for "if". 
     * @param {Array.<string>} exps - array of expressions split by spaces
     * @param {Array.<string>} sourcesInsideBlock - array of sources inside the if block
     * @param {object} context - context
     * @returns {string}
     * @private
     */
    function handleIf(exps, sourcesInsideBlock, context) {
      var analyzed = extractElseif(exps, sourcesInsideBlock);
      var result = false;
      var compiledSource = '';

      forEach(analyzed.exps, function(exp, index) {
        result = handleExpression(exp, context);
        if (result) {
          compiledSource = compile(analyzed.sourcesInsideIf[index], context);
        }

        return !result;
      });

      return compiledSource;
    }

    /**
     * Helper function for "each".
     * @param {Array.<string>} exps - array of expressions split by spaces
     * @param {Array.<string>} sourcesInsideBlock - array of sources inside the each block
     * @param {object} context - context
     * @returns {string}
     * @private
     */
    function handleEach(exps, sourcesInsideBlock, context) {
      var collection = handleExpression(exps, context);
      var additionalKey = isArray(collection) ? '@index' : '@key';
      var additionalContext = {};
      var result = '';

      forEach(collection, function(item, key) {
        additionalContext[additionalKey] = key;
        additionalContext['@this'] = item;
        extend(context, additionalContext);

        result += compile(sourcesInsideBlock.slice(), context);
      });

      return result;
    }

    /**
     * Helper function for "with ... as"
     * @param {Array.<string>} exps - array of expressions split by spaces
     * @param {Array.<string>} sourcesInsideBlock - array of sources inside the with block
     * @param {object} context - context
     * @returns {string}
     * @private
     */
    function handleWith(exps, sourcesInsideBlock, context) {
      var asIndex = inArray('as', exps);
      var alias = exps[asIndex + 1];
      var result = handleExpression(exps.slice(0, asIndex), context);

      var additionalContext = {};
      additionalContext[alias] = result;

      return compile(sourcesInsideBlock, extend(context, additionalContext)) || '';
    }

    /**
     * Extract sources inside block in place.
     * @param {Array.<string>} sources - array of sources
     * @param {number} start - index of start block
     * @param {number} end - index of end block
     * @returns {Array.<string>}
     * @private
     */
    function extractSourcesInsideBlock(sources, start, end) {
      var sourcesInsideBlock = sources.splice(start + 1, end - start);
      sourcesInsideBlock.pop();

      return sourcesInsideBlock;
    }

    /**
     * Handle block helper function
     * @param {string} helperKeyword - helper keyword (ex. if, each, with)
     * @param {Array.<string>} sourcesToEnd - array of sources after the starting block
     * @param {object} context - context
     * @returns {Array.<string>}
     * @private
     */
    function handleBlockHelper(helperKeyword, sourcesToEnd, context) {
      var executeBlockHelper = BLOCK_HELPERS[helperKeyword];
      var helperCount = 1;
      var startBlockIndex = 0;
      var endBlockIndex;
      var index = startBlockIndex + EXPRESSION_INTERVAL;
      var expression = sourcesToEnd[index];

      while (helperCount && isString(expression)) {
        if (expression.indexOf(helperKeyword) === 0) {
          helperCount += 1;
        } else if (expression.indexOf('/' + helperKeyword) === 0) {
          helperCount -= 1;
          endBlockIndex = index;
        }

        index += EXPRESSION_INTERVAL;
        expression = sourcesToEnd[index];
      }

      if (helperCount) {
        throw Error(helperKeyword + ' needs {{/' + helperKeyword + '}} expression.');
      }

      sourcesToEnd[startBlockIndex] = executeBlockHelper(
        sourcesToEnd[startBlockIndex].split(' ').slice(1),
        extractSourcesInsideBlock(sourcesToEnd, startBlockIndex, endBlockIndex),
        context
      );

      return sourcesToEnd;
    }

    /**
     * Helper function for "custom helper".
     * If helper is not a function, return helper itself.
     * @param {Array.<string>} exps - array of expressions split by spaces (first element: helper)
     * @param {object} context - context
     * @returns {string}
     * @private
     */
    function handleExpression(exps, context) {
      var result = getValueFromContext(exps[0], context);

      if (result instanceof Function) {
        return executeFunction(result, exps.slice(1), context);
      }

      return result;
    }

    /**
     * Execute a helper function.
     * @param {Function} helper - helper function
     * @param {Array.<string>} argExps - expressions of arguments
     * @param {object} context - context
     * @returns {string} - result of executing the function with arguments
     * @private
     */
    function executeFunction(helper, argExps, context) {
      var args = [];
      forEach(argExps, function(exp) {
        args.push(getValueFromContext(exp, context));
      });

      return helper.apply(null, args);
    }

    /**
     * Get a result of compiling an expression with the context.
     * @param {Array.<string>} sources - array of sources split by regexp of expression.
     * @param {object} context - context
     * @returns {Array.<string>} - array of sources that bind with its context
     * @private
     */
    function compile(sources, context) {
      var index = 1;
      var expression = sources[index];
      var exps, firstExp, result;

      while (isString(expression)) {
        exps = expression.split(' ');
        firstExp = exps[0];

        if (BLOCK_HELPERS[firstExp]) {
          result = handleBlockHelper(firstExp, sources.splice(index, sources.length - index), context);
          sources = sources.concat(result);
        } else {
          sources[index] = handleExpression(exps, context);
        }

        index += EXPRESSION_INTERVAL;
        expression = sources[index];
      }

      return sources.join('');
    }

    /**
     * Convert text by binding expressions with context.
     * <br>
     * If expression exists in the context, it will be replaced.
     * ex) '{{title}}' with context {title: 'Hello!'} is converted to 'Hello!'.
     * An array or object can be accessed using bracket and dot notation.
     * ex) '{{odds\[2\]}}' with context {odds: \[1, 3, 5\]} is converted to '5'.
     * ex) '{{evens\[first\]}}' with context {evens: \[2, 4\], first: 0} is converted to '2'.
     * ex) '{{project\["name"\]}}' and '{{project.name}}' with context {project: {name: 'CodeSnippet'}} is converted to 'CodeSnippet'.
     * <br>
     * If replaced expression is a function, next expressions will be arguments of the function.
     * ex) '{{add 1 2}}' with context {add: function(a, b) {return a + b;}} is converted to '3'.
     * <br>
     * It has 3 predefined block helpers '{{helper ...}} ... {{/helper}}': 'if', 'each', 'with ... as ...'.
     * 1) 'if' evaluates conditional statements. It can use with 'elseif' and 'else'.
     * 2) 'each' iterates an array or object. It provides '@index'(array), '@key'(object), and '@this'(current element).
     * 3) 'with ... as ...' provides an alias.
     * @param {string} text - text with expressions
     * @param {object} context - context
     * @returns {string} - text that bind with its context
     * @memberof module:domUtil
     * @example
     * var template = require('tui-code-snippet/domUtil/template');
     * 
     * var source = 
     *     '<h1>'
     *   +   '{{if isValidNumber title}}'
     *   +     '{{title}}th'
     *   +   '{{elseif isValidDate title}}'
     *   +     'Date: {{title}}'
     *   +   '{{/if}}'
     *   + '</h1>'
     *   + '{{each list}}'
     *   +   '{{with addOne @index as idx}}'
     *   +     '<p>{{idx}}: {{@this}}</p>'
     *   +   '{{/with}}'
     *   + '{{/each}}';
     * 
     * var context = {
     *   isValidDate: function(text) {
     *     return /^\d{4}-(0|1)\d-(0|1|2|3)\d$/.test(text);
     *   },
     *   isValidNumber: function(text) {
     *     return /^\d+$/.test(text);
     *   }
     *   title: '2019-11-25',
     *   list: ['Clean the room', 'Wash the dishes'],
     *   addOne: function(num) {
     *     return num + 1;
     *   }
     * };
     * 
     * var result = template(source, context);
     * console.log(result); // <h1>Date: 2019-11-25</h1><p>1: Clean the room</p><p>2: Wash the dishes</p>
     */
    function template(text, context) {
      return compile(splitByRegExp(text, EXPRESSION_REGEXP), context);
    }

    module.exports = template;


    /***/ }),
    /* 12 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is undefined or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Check whether the given variable is undefined or not.
     * If the given variable is undefined, returns true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is undefined?
     * @memberof module:type
     */
    function isUndefined(obj) {
      return obj === undefined; // eslint-disable-line no-undefined
    }

    module.exports = isUndefined;


    /***/ }),
    /* 13 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is a string or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Check whether the given variable is a string or not.
     * If the given variable is a string, return true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is string?
     * @memberof module:type
     */
    function isString(obj) {
      return typeof obj === 'string' || obj instanceof String;
    }

    module.exports = isString;


    /***/ }),
    /* 14 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Remove element from parent node.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Remove element from parent node.
     * @param {HTMLElement} element - element to remove.
     * @memberof module:domUtil
     */
    function removeElement(element) {
      if (element && element.parentNode) {
        element.parentNode.removeChild(element);
      }
    }

    module.exports = removeElement;


    /***/ }),
    /* 15 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is a number or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Check whether the given variable is a number or not.
     * If the given variable is a number, return true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is number?
     * @memberof module:type
     */
    function isNumber(obj) {
      return typeof obj === 'number' || obj instanceof Number;
    }

    module.exports = isNumber;


    /***/ }),
    /* 16 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Add css class to element
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var forEach = __webpack_require__(9);
    var inArray = __webpack_require__(3);
    var getClass = __webpack_require__(17);
    var setClassName = __webpack_require__(24);

    /**
     * domUtil module
     * @module domUtil
     */

    /**
     * Add css class to element
     * @param {(HTMLElement|SVGElement)} element - target element
     * @param {...string} cssClass - css classes to add
     * @memberof module:domUtil
     */
    function addClass(element) {
      var cssClass = Array.prototype.slice.call(arguments, 1);
      var classList = element.classList;
      var newClass = [];
      var origin;

      if (classList) {
        forEach(cssClass, function(name) {
          element.classList.add(name);
        });

        return;
      }

      origin = getClass(element);

      if (origin) {
        cssClass = [].concat(origin.split(/\s+/), cssClass);
      }

      forEach(cssClass, function(cls) {
        if (inArray(cls, newClass) < 0) {
          newClass.push(cls);
        }
      });

      setClassName(element, newClass);
    }

    module.exports = addClass;


    /***/ }),
    /* 17 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Get HTML element's design classes.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var isUndefined = __webpack_require__(12);

    /**
     * Get HTML element's design classes.
     * @param {(HTMLElement|SVGElement)} element target element
     * @returns {string} element css class name
     * @memberof module:domUtil
     */
    function getClass(element) {
      if (!element || !element.className) {
        return '';
      }

      if (isUndefined(element.className.baseVal)) {
        return element.className;
      }

      return element.className.baseVal;
    }

    module.exports = getClass;


    /***/ }),
    /* 18 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Remove css class from element
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var forEachArray = __webpack_require__(2);
    var inArray = __webpack_require__(3);
    var getClass = __webpack_require__(17);
    var setClassName = __webpack_require__(24);

    /**
     * Remove css class from element
     * @param {(HTMLElement|SVGElement)} element - target element
     * @param {...string} cssClass - css classes to remove
     * @memberof module:domUtil
     */
    function removeClass(element) {
      var cssClass = Array.prototype.slice.call(arguments, 1);
      var classList = element.classList;
      var origin, newClass;

      if (classList) {
        forEachArray(cssClass, function(name) {
          classList.remove(name);
        });

        return;
      }

      origin = getClass(element).split(/\s+/);
      newClass = [];
      forEachArray(origin, function(name) {
        if (inArray(name, cssClass) < 0) {
          newClass.push(name);
        }
      });

      setClassName(element, newClass);
    }

    module.exports = removeClass;


    /***/ }),
    /* 19 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Set mouse-touch event
     * @author NHN. FE Development Lab <dl_javascript@nhn.com>
     */



    var on = __webpack_require__(31);
    var off = __webpack_require__(33);

    var mouseTouchEvent = {
      /**
       * Detect mobile browser
       * @type {boolean} Whether using Mobile browser
       * @private
       */
      _isMobile: (function() {
        return /Android|BlackBerry|iPhone|iPad|iPod|Opera Mini|IEMobile|WPDesktop/i.test(
          navigator.userAgent
        );
      })(),

      /**
       * Return a matched event type by a mouse event type
       * @param {string} type A mouse event type - mousedown, click
       * @returns {string}
       * @private
       */
      _getEventType: function(type) {
        if (this._isMobile) {
          if (type === 'mousedown') {
            type = 'touchstart';
          } else if (type === 'click') {
            type = 'touchend';
          }
        }

        return type;
      },

      /**
       * Bind touch or mouse events
       * @param {HTMLElement} element An element to bind
       * @param {string} type A mouse event type - mousedown, click
       * @param {Function} handler A handler function
       * @param {object} [context] A context for handler.
       */
      on: function(element, type, handler, context) {
        on(element, this._getEventType(type), handler, context);
      },

      /**
       * Unbind touch or mouse events
       * @param {HTMLElement} element - Target element
       * @param {string} type A mouse event type - mousedown, click
       * @param {Function} handler - Handler
       */
      off: function(element, type, handler) {
        off(element, this._getEventType(type), handler);
      }
    };

    module.exports = mouseTouchEvent;


    /***/ }),
    /* 20 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Layer base
     * @author NHN. FE Development Lab <dl_javascript@nhn.com>
     */



    var defineClass = __webpack_require__(0);
    var removeElement = __webpack_require__(14);

    var localeText = __webpack_require__(10);
    var DEFAULT_LANGUAGE_TYPE = __webpack_require__(1).DEFAULT_LANGUAGE_TYPE;

    /**
     * @abstract
     * @class
     * @ignore
     * @param {string} language - Initial language
     * Layer base
     */
    var LayerBase = defineClass(
      /** @lends LayerBase.prototype */ {
        init: function(language) {
          language = language || DEFAULT_LANGUAGE_TYPE;

          /**
           * Layer element
           * @type {HTMLElement}
           * @private
           */
          this._element = null;

          /**
           * Language type
           * @type {string}
           * @private
           */
          this._localeText = localeText[language];

          /**
           * Layer type
           * @type {string}
           * @private
           */
          this._type = 'base';
        },

        /**
         * Make context
         * @abstract
         * @throws {Error}
         * @returns {object}
         * @private
         */
        _makeContext: function() {
          throwOverrideError(this.getType(), '_makeContext');
        },

        /**
         * Render the layer element
         * @abstract
         * @throws {Error}
         */
        render: function() {
          throwOverrideError(this.getType(), 'render');
        },

        /**
         * Returns date elements
         * @abstract
         * @throws {Error}
         * @returns {HTMLElement[]}
         */
        getDateElements: function() {
          throwOverrideError(this.getType(), 'getDateElements');
        },

        /**
         * Returns layer type
         * @returns {string}
         */
        getType: function() {
          return this._type;
        },

        /**
         * Set language
         * @param {string} language - Language name
         */
        changeLanguage: function(language) {
          this._localeText = localeText[language];
        },

        /**
         * Remove elements
         */
        remove: function() {
          if (this._element) {
            removeElement(this._element);
          }
          this._element = null;
        }
      }
    );

    /**
     * Throw - method override error
     * @ignore
     * @param {string} layerType - Layer type
     * @param {string} methodName - Method name
     * @throws {Error}
     */
    function throwOverrideError(layerType, methodName) {
      throw new Error(layerType + ' layer does not have the "' + methodName + '" method.');
    }

    module.exports = LayerBase;


    /***/ }),
    /* 21 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview DatePicker component
     * @author NHN. FE dev Lab <dl_javascript@nhn.com>
     */



    var inArray = __webpack_require__(3);
    var forEachArray = __webpack_require__(2);
    var defineClass = __webpack_require__(0);
    var CustomEvents = __webpack_require__(8);
    var addClass = __webpack_require__(16);
    var closest = __webpack_require__(25);
    var getData = __webpack_require__(26);
    var hasClass = __webpack_require__(27);
    var removeClass = __webpack_require__(18);
    var removeElement = __webpack_require__(14);
    var extend = __webpack_require__(7);
    var isArray = __webpack_require__(6);
    var isDate = __webpack_require__(28);
    var isNumber = __webpack_require__(15);
    var isObject = __webpack_require__(22);

    var TimePicker = __webpack_require__(43);

    var Calendar = __webpack_require__(29);
    var RangeModel = __webpack_require__(56);
    var constants = __webpack_require__(1);
    var localeTexts = __webpack_require__(10);
    var dateUtil = __webpack_require__(5);
    var util = __webpack_require__(4);
    var mouseTouchEvent = __webpack_require__(19);
    var tmpl = __webpack_require__(58);
    var DatePickerInput = __webpack_require__(59);

    var DEFAULT_WEEK_START_DAY = constants.DEFAULT_WEEK_START_DAY;
    var DEFAULT_LANGUAGE_TYPE = constants.DEFAULT_LANGUAGE_TYPE;
    var TYPE_DATE = constants.TYPE_DATE;
    var TYPE_MONTH = constants.TYPE_MONTH;
    var TYPE_YEAR = constants.TYPE_YEAR;
    var CLASS_NAME_NEXT_YEAR_BTN = constants.CLASS_NAME_NEXT_YEAR_BTN;
    var CLASS_NAME_NEXT_MONTH_BTN = constants.CLASS_NAME_NEXT_MONTH_BTN;
    var CLASS_NAME_PREV_YEAR_BTN = constants.CLASS_NAME_PREV_YEAR_BTN;
    var CLASS_NAME_PREV_MONTH_BTN = constants.CLASS_NAME_PREV_MONTH_BTN;
    var CLASS_NAME_SELECTED = constants.CLASS_NAME_SELECTED;

    var CLASS_NAME_SELECTABLE = 'tui-is-selectable';
    var CLASS_NAME_BLOCKED = 'tui-is-blocked';
    var CLASS_NAME_CHECKED = 'tui-is-checked';
    var CLASS_NAME_SELECTOR_BUTTON = 'tui-datepicker-selector-button';
    var CLASS_NAME_TODAY = 'tui-calendar-today';
    var CLASS_NAME_HIDDEN = 'tui-hidden';

    var SELECTOR_BODY = '.tui-datepicker-body';
    var SELECTOR_DATE_ICO = '.tui-ico-date';
    var SELECTOR_CALENDAR_TITLE = '.tui-calendar-title';
    var SELECTOR_CALENDAR_CONTAINER = '.tui-calendar-container';
    var SELECTOR_TIMEPICKER_CONTAINER = '.tui-timepicker-container';

    /**
     * Merge default option
     * @ignore
     * @param {object} option - DatePicker option
     * @returns {object}
     */
    var mergeDefaultOption = function(option) {
      option = extend(
        {
          language: DEFAULT_LANGUAGE_TYPE,
          calendar: {},
          input: {
            element: null,
            format: null
          },
          timePicker: null,
          date: null,
          showAlways: false,
          type: TYPE_DATE,
          selectableRanges: null,
          openers: [],
          autoClose: true,
          usageStatistics: true,
          weekStartDay: DEFAULT_WEEK_START_DAY
        },
        option
      );

      option.selectableRanges = option.selectableRanges || [[constants.MIN_DATE, constants.MAX_DATE]];

      if (!isObject(option.calendar)) {
        throw new Error('Calendar option must be an object');
      }
      if (!isObject(option.input)) {
        throw new Error('Input option must be an object');
      }
      if (!isArray(option.selectableRanges)) {
        throw new Error('Selectable-ranges must be a 2d-array');
      }

      option.localeText = localeTexts[option.language];

      // override calendar option
      option.calendar.language = option.language;
      option.calendar.type = option.type;

      // @TODO: after v5.0.0, remove option.timepicker
      option.timePicker = option.timePicker || option.timepicker;

      return option;
    };

    /**
     * @class
     * @description
     * Create a date picker.
     * @see {@link /tutorial-example01-basic DatePicker example}
     * @param {HTMLElement|string} container - Container element or selector of DatePicker
     * @param {Object} [options] - Options
     *      @param {Date|number} [options.date = null] - Initial date. Set by a Date instance or a number(timestamp). (default: no initial date)
     *      @param {('date'|'month'|'year')} [options.type = 'date'] - DatePicker type. Determine whether to choose a date, month, or year.
     *      @param {string} [options.language='en'] - Language code. English('en') and Korean('ko') are provided as default. To set to the other languages, use {@link DatePicker#localeTexts DatePicker.localeTexts}.
     *      @param {object|boolean} [options.timePicker] - [TimePicker](https://nhn.github.io/tui.time-picker/latest) options. Refer to the [TimePicker instance's options](https://nhn.github.io/tui.time-picker/latest/TimePicker). To create the TimePicker without customization, set to true.
     *      @param {object} [options.calendar] - {@link Calendar} options. Refer to the {@link Calendar Calendar instance's options}.
     *      @param {object} [options.input] - Input option
     *      @param {HTMLElement|string} [options.input.element] - Input element or selector
     *      @param {string} [options.input.format = 'yyyy-mm-dd'] - Format of the Date string
     *      @param {Array.<Array.<Date|number>>} [options.selectableRanges = 1900/1/1 ~ 2999/12/31]
     *        - Ranges of selectable date. Set by Date instances or numbers(timestamp).
     *      @param {Array<HTMLElement|string>} [options.openers = []] - List of the openers to open the DatePicker (example - icon, button, etc.)
     *      @param {boolean} [options.showAlways = false] - Show the DatePicker always
     *      @param {boolean} [options.autoClose = true] - Close the DatePicker after clicking the date
     *      @param {boolean} [options.usageStatistics = true] - Send a hostname to Google Analytics (default: true)
     *      @param {string} [options.weekStartDay = 'Sun'] - Start of the week. 'Sun', 'Mon', ..., 'Sat'(default: 'Sun'(start on Sunday))
     * @example
     * // ES6
     * import DatePicker from 'tui-date-picker'
     *
     * // CommonJS
     * const DatePicker = require('tui-date-picker');
     *
     * // Browser
     * const DatePicker = tui.DatePicker;
     *
     * const range1 = [new Date(2015, 2, 1), new Date(2015, 3, 1)];
     * const range2 = [1465570800000, 1481266182155]; // timestamps
     *
     * const picker1 = new DatePicker('#datepicker-container1', {
     *     showAlways: true
     * });
     *
     * const picker2 = new DatePicker('#datepicker-container2', {
     *    showAlways: true,
     *    timePicker: true
     * });
     *
     * const picker3 = new DatePicker('#datepicker-container3', {
     *     language: 'ko',
     *     calendar: {
     *         showToday: true
     *     },
     *     timePicker: {
     *         showMeridiem: true,
     *         defaultHour: 13,
     *         defaultMinute: 24
     *     },
     *     input: {
     *         element: '#datepicker-input',
     *         format: 'yyyy MM dd hh:mm A'
     *     }
     *     type: 'date',
     *     date: new Date(2015, 0, 1)
     *     selectableRanges: [range1, range2],
     *     openers: ['#opener'],
     *     weekStartDay: 'Mon',
     * });
     */
    var DatePicker = defineClass(
      /** @lends DatePicker.prototype */ {
        static: {
          /**
           * Locale text data. English('en') and Korean('ko') are provided as default.
           * @type {object}
           * @memberof DatePicker
           * @static
           * @example
           * DatePicker.localeTexts['customKey'] = {
           *     titles: {
           *         // days
           *         DD: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
           *         // daysShort
           *         D: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
           *         // months
           *         MMMM: [
           *             'January', 'February', 'March', 'April', 'May', 'June',
           *             'July', 'August', 'September', 'October', 'November', 'December'
           *         ],
           *         // monthsShort
           *         MMM: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
           *     },
           *     titleFormat: 'MMM yyyy',
           *     todayFormat: 'D, MMMM dd, yyyy',
           *     date: 'Date',
           *     time: 'Time'
           * };
           *
           * const datepicker = new DatePicker('#datepicker-container', {
           *     language: 'customKey'
           * });
           */
          localeTexts: localeTexts
        },
        init: function(container, options) {
          options = mergeDefaultOption(options);

          /**
           * Language type
           * @type {string}
           * @private
           */
          this._language = options.language;

          /**
           * DatePicker container
           * @type {HTMLElement}
           * @private
           */
          this._container = util.getElement(container);
          this._container.innerHTML = tmpl(
            extend(options, {
              isTab: options.timePicker && options.timePicker.layoutType === 'tab'
            })
          );

          /**
           * DatePicker element
           * @type {HTMLElement}
           * @private
           */
          this._element = this._container.firstChild;

          /**
           * Calendar instance
           * @type {Calendar}
           * @private
           */
          this._calendar = new Calendar(
            this._element.querySelector(SELECTOR_CALENDAR_CONTAINER),
            extend(options.calendar, {
              usageStatistics: options.usageStatistics,
              weekStartDay: options.weekStartDay
            })
          );

          /**
           * TimePicker instance
           * @type {TimePicker}
           * @private
           */
          this._timePicker = null;

          /**
           * DatePicker input
           * @type {DatePickerInput}
           * @private
           */
          this._datepickerInput = null;

          /**
           * Object having date values
           * @type {Date}
           * @private
           */
          this._date = null;

          /**
           * Selectable date-ranges model
           * @type {RangeModel}
           * @private
           */
          this._rangeModel = null;

          /**
           * openers - opener list
           * @type {Array}
           * @private
           */
          this._openers = [];

          /**
           * State of picker enable
           * @type {boolean}
           * @private
           */
          this._isEnabled = true;

          /**
           * ID of instance
           * @type {number}
           * @private
           */
          this._id = 'tui-datepicker-' + util.generateId();

          /**
           * DatePicker type
           * @type {TYPE_DATE|TYPE_MONTH|TYPE_YEAR}
           * @private
           */
          this._type = options.type;

          /**
           * Show always or not
           * @type {boolean}
           */
          this.showAlways = options.showAlways;

          /**
           * Close after select a date
           * @type {boolean}
           */
          this.autoClose = options.autoClose;

          this._initializeDatePicker(options);
        },

        /**
         * Initialize method
         * @param {Object} option - user option
         * @private
         */
        _initializeDatePicker: function(option) {
          this.setRanges(option.selectableRanges);
          this._setEvents();
          this._initTimePicker(option.timePicker, option.usageStatistics);
          this.setInput(option.input.element);
          this.setDateFormat(option.input.format);
          this.setDate(option.date);

          forEachArray(option.openers, this.addOpener, this);
          if (!this.showAlways) {
            this._hide();
          }

          if (this.getType() === TYPE_DATE) {
            addClass(this._element.querySelector(SELECTOR_BODY), 'tui-datepicker-type-date');
          }
        },

        /**
         * Set events on the date picker's element
         * @param {object} option - Constructor option
         * @private
         */
        _setEvents: function() {
          mouseTouchEvent.on(this._element, 'click', this._onClickHandler, this);
          this._calendar.on('draw', this._onDrawCalendar, this);
          this._calendar._header.on('today', this._onClickTodayHandler, this);
        },

        /**
         * Remove events on the date picker's element
         * @private
         */
        _removeEvents: function() {
          mouseTouchEvent.off(this._element, 'click', this._onClickHandler, this);
          this._calendar.off();
        },

        /**
         * Set events on the document
         * @private
         */
        _setDocumentEvents: function() {
          mouseTouchEvent.on(document, 'mousedown', this._onMousedownDocument, this);
        },

        /**
         * Remove events on the document
         * @private
         */
        _removeDocumentEvents: function() {
          mouseTouchEvent.off(document, 'mousedown', this._onMousedownDocument);
        },

        /**
         * Set events on the opener
         * @param {HTMLElement} opener An opener to bind the events
         * @private
         */
        _setOpenerEvents: function(opener) {
          mouseTouchEvent.on(opener, 'click', this.toggle, this);
        },

        /**
         * Remove events on the opener
         * @param {HTMLElement} opener An opener to unbind the events
         * @private
         */
        _removeOpenerEvents: function(opener) {
          mouseTouchEvent.off(opener, 'click', this.toggle);
        },

        /**
         * Set TimePicker instance
         * @param {object|boolean} opTimePicker - TimePicker instance options
         * @param {boolean} usageStatistics - GA tracking options
         * @private
         */
        _initTimePicker: function(opTimePicker, usageStatistics) {
          var layoutType;
          if (!opTimePicker) {
            return;
          }

          layoutType = opTimePicker.layoutType || '';

          if (isObject(opTimePicker)) {
            opTimePicker.usageStatistics = usageStatistics;
          } else {
            opTimePicker = {
              usageStatistics: usageStatistics
            };
          }

          this._timePicker = new TimePicker(
            this._element.querySelector(SELECTOR_TIMEPICKER_CONTAINER),
            opTimePicker
          );

          if (layoutType.toLowerCase() === 'tab') {
            this._timePicker.hide();
          }

          this._timePicker.on(
            'change',
            function(ev) {
              var prevDate;
              if (this._date) {
                prevDate = new Date(this._date);
                this.setDate(prevDate.setHours(ev.hour, ev.minute));
              }
            },
            this
          );
        },

        /**
         * Change picker's type by a selector button.
         * @param {HTMLElement} target A target element
         * @private
         */
        _changePicker: function(target) {
          var btnSelector = '.' + CLASS_NAME_SELECTOR_BUTTON;
          var selectedBtn = closest(target, btnSelector);
          var isDateElement = !!selectedBtn.querySelector(SELECTOR_DATE_ICO);

          if (isDateElement) {
            this._calendar.show();
            this._timePicker.hide();
          } else {
            this._calendar.hide();
            this._timePicker.show();
          }
          removeClass(this._element.querySelector('.' + CLASS_NAME_CHECKED), CLASS_NAME_CHECKED);
          addClass(selectedBtn, CLASS_NAME_CHECKED);
        },

        /**
         * Returns whether the element is opener
         * @param {string|HTMLElement} element - Element or selector
         * @returns {boolean}
         * @private
         */
        _isOpener: function(element) {
          var el = util.getElement(element);

          return inArray(el, this._openers) > -1;
        },

        /**
         * add/remove today-class-name to date element
         * @param {HTMLElement} el - date element
         * @private
         */
        _setTodayClassName: function(el) {
          var timestamp, isToday;

          if (this.getCalendarType() !== TYPE_DATE) {
            return;
          }

          timestamp = Number(getData(el, 'timestamp'));
          isToday = timestamp === new Date().setHours(0, 0, 0, 0);

          if (isToday) {
            addClass(el, CLASS_NAME_TODAY);
          } else {
            removeClass(el, CLASS_NAME_TODAY);
          }
        },

        /**
         * add/remove selectable-class-name to date element
         * @param {HTMLElement} el - date element
         * @private
         */
        _setSelectableClassName: function(el) {
          var elDate = new Date(Number(getData(el, 'timestamp')));

          if (this._isSelectableOnCalendar(elDate)) {
            addClass(el, CLASS_NAME_SELECTABLE);
            removeClass(el, CLASS_NAME_BLOCKED);
          } else {
            removeClass(el, CLASS_NAME_SELECTABLE);
            addClass(el, CLASS_NAME_BLOCKED);
          }
        },

        /**
         * add/remove selected-class-name to date element
         * @param {HTMLElement} el - date element
         * @private
         */
        _setSelectedClassName: function(el) {
          var elDate = new Date(Number(getData(el, 'timestamp')));

          if (this._isSelectedOnCalendar(elDate)) {
            addClass(el, CLASS_NAME_SELECTED);
          } else {
            removeClass(el, CLASS_NAME_SELECTED);
          }
        },

        /**
         * Returns whether the date is selectable on calendar
         * @param {Date} date - Date instance
         * @returns {boolean}
         * @private
         */
        _isSelectableOnCalendar: function(date) {
          var type = this.getCalendarType();
          var start = dateUtil.cloneWithStartOf(date, type).getTime();
          var end = dateUtil.cloneWithEndOf(date, type).getTime();

          return this._rangeModel.hasOverlap(start, end);
        },

        /**
         * Returns whether the date is selected on calendar
         * @param {Date} date - Date instance
         * @returns {boolean}
         * @private
         */
        _isSelectedOnCalendar: function(date) {
          var curDate = this.getDate();
          var calendarType = this.getCalendarType();

          return curDate && dateUtil.isSame(curDate, date, calendarType);
        },

        /**
         * Show the date picker element
         * @private
         */
        _show: function() {
          removeClass(this._element, CLASS_NAME_HIDDEN);
        },

        /**
         * Hide the date picker element
         * @private
         */
        _hide: function() {
          addClass(this._element, CLASS_NAME_HIDDEN);
        },

        /**
         * Set value a date-string of current this instance to input element
         * @private
         */
        _syncToInput: function() {
          if (!this._date) {
            return;
          }

          this._datepickerInput.setDate(this._date);
        },

        /**
         * Set date from input value
         * @param {boolean} [shouldRollback = false] - Should rollback from unselectable or error
         * @private
         */
        _syncFromInput: function(shouldRollback) {
          var isFailed = false;
          var date;

          try {
            date = this._datepickerInput.getDate();

            if (this.isSelectable(date)) {
              if (this._timePicker) {
                this._timePicker.setTime(date.getHours(), date.getMinutes());
              }
              this.setDate(date);
            } else {
              isFailed = true;
            }
          } catch (err) {
            this.fire('error', {
              type: 'ParsingError',
              message: err.message
            });
            isFailed = true;
          } finally {
            if (isFailed) {
              if (shouldRollback) {
                this._syncToInput();
              } else {
                this.setNull();
              }
            }
          }
        },

        /**
         * Event handler for mousedown of document<br>
         * - When click the out of layer, close the layer
         * @param {Event} ev - Event object
         * @private
         */
        _onMousedownDocument: function(ev) {
          var target = util.getTarget(ev);
          var selector = util.getSelector(target);
          var isContain = selector ? this._element.querySelector(selector) : false;
          var isInput = this._datepickerInput.is(target);
          var isInOpener = inArray(target, this._openers) > -1;
          var shouldClose = !(this.showAlways || isInput || isContain || isInOpener);

          if (shouldClose) {
            this.close();
          }
        },

        /**
         * Event handler for click of calendar
         * @param {Event} ev An event object
         * @private
         */
        _onClickHandler: function(ev) {
          var target = util.getTarget(ev);
          ev.preventDefault();

          if (closest(target, '.' + CLASS_NAME_SELECTABLE)) {
            this._updateDate(target);
          } else if (closest(target, SELECTOR_CALENDAR_TITLE)) {
            this.drawUpperCalendar(this._date);
          } else if (closest(target, '.' + CLASS_NAME_SELECTOR_BUTTON)) {
            this._changePicker(target);
          }
        },

        /**
         * Event handler for click of today text
         * @param {Event} ev An event object
         * @private
         */
        _onClickTodayHandler: function() {
          this.setDate(Date.now());
          this.close();
        },

        /**
         * Update date from event-target
         * @param {HTMLElement} target An event target element
         * @private
         */
        _updateDate: function(target) {
          var timestamp = Number(getData(target, 'timestamp'));
          var newDate = new Date(timestamp);
          var timePicker = this._timePicker;
          var prevDate = this._date;
          var calendarType = this.getCalendarType();
          var pickerType = this.getType();

          if (calendarType !== pickerType) {
            this.drawLowerCalendar(newDate);
          } else {
            if (timePicker) {
              newDate.setHours(timePicker.getHour(), timePicker.getMinute());
            } else if (prevDate) {
              newDate.setHours(prevDate.getHours(), prevDate.getMinutes());
            }
            this.setDate(newDate);

            if (!this.showAlways && this.autoClose) {
              this.close();
            }
          }
        },

        /**
         * Event handler for 'draw'-custom event of calendar
         * @param {Object} eventData - custom event data
         * @see {@link Calendar#draw}
         * @private
         */
        _onDrawCalendar: function(eventData) {
          forEachArray(
            eventData.dateElements,
            function(el) {
              this._setTodayClassName(el);
              this._setSelectableClassName(el);
              this._setSelectedClassName(el);
            },
            this
          );
          this._setDisplayHeadButtons();

          /**
           * Occur after the calendar is drawn.
           * @event DatePicker#draw
           * @see {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents#on datepicker.on()} to bind event handlers.
           * @see {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents#off datepicker.off()} to unbind event handlers.
           * @see Refer to {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents CustomEvents from tui-code-snippet} for more methods. DatePicker mixes in the methods from CustomEvents.
           * @property {Date} date - Calendar date
           * @property {('date'|'month'|'year')} type - Calendar type
           * @property {HTMLElement[]} dateElements - elements for dates
           * @example
           * // bind the 'draw' event
           * datepicker.on('draw', (event) => {
           *     console.log(`Draw the ${event.type} calendar and its date is ${event.date}.`);
           * });
           *
           * // unbind the 'draw' event
           * datepicker.off('draw');
           */
          this.fire('draw', eventData);
        },

        /**
         * Hide useless buttons (next, next-year, prev, prev-year)
         * @see Don't save buttons reference. The buttons are rerendered every "calendar.draw".
         * @private
         */
        _setDisplayHeadButtons: function() {
          var nextYearDate = this._calendar.getNextYearDate();
          var prevYearDate = this._calendar.getPrevYearDate();
          var maxTimestamp = this._rangeModel.getMaximumValue();
          var minTimestamp = this._rangeModel.getMinimumValue();
          var nextYearBtn = this._element.querySelector('.' + CLASS_NAME_NEXT_YEAR_BTN);
          var prevYearBtn = this._element.querySelector('.' + CLASS_NAME_PREV_YEAR_BTN);
          var nextMonthDate, prevMonthDate, nextMonBtn, prevMonBtn;

          if (this.getCalendarType() === TYPE_DATE) {
            nextMonthDate = dateUtil.cloneWithStartOf(this._calendar.getNextDate(), TYPE_MONTH);
            prevMonthDate = dateUtil.cloneWithEndOf(this._calendar.getPrevDate(), TYPE_MONTH);

            nextMonBtn = this._element.querySelector('.' + CLASS_NAME_NEXT_MONTH_BTN);
            prevMonBtn = this._element.querySelector('.' + CLASS_NAME_PREV_MONTH_BTN);

            this._setDisplay(nextMonBtn, nextMonthDate.getTime() <= maxTimestamp);
            this._setDisplay(prevMonBtn, prevMonthDate.getTime() >= minTimestamp);

            prevYearDate.setDate(1);
            nextYearDate.setDate(1);
          } else {
            prevYearDate.setMonth(12, 0);
            nextYearDate.setMonth(0, 1);
          }

          this._setDisplay(nextYearBtn, nextYearDate.getTime() <= maxTimestamp);
          this._setDisplay(prevYearBtn, prevYearDate.getTime() >= minTimestamp);
        },

        /**
         * Set display show/hide by condition
         * @param {HTMLElement} el - An Element
         * @param {boolean} shouldShow - Condition
         * @private
         */
        _setDisplay: function(el, shouldShow) {
          if (el) {
            if (shouldShow) {
              removeClass(el, CLASS_NAME_HIDDEN);
            } else {
              addClass(el, CLASS_NAME_HIDDEN);
            }
          }
        },

        /**
         * Input change handler
         * @private
         * @throws {Error}
         */
        _onChangeInput: function() {
          this._syncFromInput(true);
        },

        /**
         * Returns whether the date is changed
         * @param {Date} date - Date
         * @returns {boolean}
         * @private
         */
        _isChanged: function(date) {
          var prevDate = this.getDate();

          return !prevDate || date.getTime() !== prevDate.getTime();
        },

        /**
         * Refresh datepicker
         * @private
         */
        _refreshFromRanges: function() {
          if (!this.isSelectable(this._date)) {
            this.setNull();
          } else {
            this._calendar.draw(); // view update
          }
        },

        /**
         * Return the current calendar's type.
         * @returns {('date'|'month'|'year')}
         */
        getCalendarType: function() {
          return this._calendar.getType();
        },

        /**
         * Return the date picker's type.
         * @returns {('date'|'month'|'year')}
         */
        getType: function() {
          return this._type;
        },

        /**
         * Return whether the date is selectable.
         * @param {Date} date - Date to check
         * @returns {boolean}
         */
        isSelectable: function(date) {
          var type = this.getType();
          var start, end;

          if (!dateUtil.isValidDate(date)) {
            return false;
          }
          start = dateUtil.cloneWithStartOf(date, type).getTime();
          end = dateUtil.cloneWithEndOf(date, type).getTime();

          return this._rangeModel.hasOverlap(start, end);
        },

        /**
         * Return whether the date is selected.
         * @param {Date} date - Date to check
         * @returns {boolean}
         */
        isSelected: function(date) {
          return dateUtil.isValidDate(date) && dateUtil.isSame(this._date, date, this.getType());
        },

        /**
         * Set selectable ranges. Previous ranges will be removed.
         * @param {Array.<Array<Date|number>>} ranges - Selectable ranges. Use Date instances or numbers(timestamp).
         * @example
         * datepicker.setRanges([
         *     [new Date(2017, 0, 1), new Date(2018, 0, 2)],
         *     [new Date(2015, 2, 3), new Date(2016, 4, 2)]
         * ]);
         */
        setRanges: function(ranges) {
          var result = [];
          forEachArray(ranges, function(range) {
            var start = new Date(range[0]).getTime();
            var end = new Date(range[1]).getTime();

            result.push([start, end]);
          });

          this._rangeModel = new RangeModel(result);
          this._refreshFromRanges();
        },

        /**
         * Set the calendar's type.
         * @param {('date'|'month'|'year')} type - Calendar type
         * @example
         * datepicker.setType('month');
         */
        setType: function(type) {
          this._type = type;
        },

        /**
         * Add a selectable range. Use Date instances or numbers(timestamp).
         * @param {Date|number} start - the start date
         * @param {Date|number} end - the end date
         * @example
         * const start = new Date(2015, 1, 3);
         * const end = new Date(2015, 2, 6);
         *
         * datepicker.addRange(start, end);
         */
        addRange: function(start, end) {
          start = new Date(start).getTime();
          end = new Date(end).getTime();

          this._rangeModel.add(start, end);
          this._refreshFromRanges();
        },

        /**
         * Remove a range. Use Date instances or numbers(timestamp).
         * @param {Date|number} start - the start date
         * @param {Date|number} end - the end date
         * @param {null|'date'|'month'|'year'} type - Range type. If falsy, start and end values are considered as timestamp
         * @example
         * const start = new Date(2015, 1, 3);
         * const end = new Date(2015, 2, 6);
         *
         * datepicker.removeRange(start, end);
         */
        removeRange: function(start, end, type) {
          start = new Date(start);
          end = new Date(end);

          if (type) {
            // @todo Consider time-range on timePicker
            start = dateUtil.cloneWithStartOf(start, type);
            end = dateUtil.cloneWithEndOf(end, type);
          }

          this._rangeModel.exclude(start.getTime(), end.getTime());
          this._refreshFromRanges();
        },

        /**
         * Add an opener.
         * @param {HTMLElement|string} opener - element or selector of opener
         */
        addOpener: function(opener) {
          opener = util.getElement(opener);

          if (!this._isOpener(opener)) {
            this._openers.push(opener);
            this._setOpenerEvents(opener);
          }
        },

        /**
         * Remove an opener.
         * @param {HTMLElement|string} opener - element or selector of opener
         */
        removeOpener: function(opener) {
          var index;

          opener = util.getElement(opener);
          index = inArray(opener, this._openers);

          if (index > -1) {
            this._removeOpenerEvents(opener);
            this._openers.splice(index, 1);
          }
        },

        /**
         * Remove all openers.
         */
        removeAllOpeners: function() {
          forEachArray(
            this._openers,
            function(opener) {
              this._removeOpenerEvents(opener);
            },
            this
          );
          this._openers = [];
        },

        /**
         * Open the date picker.
         * @example
         * datepicker.open();
         */
        open: function() {
          if (this.isOpened() || !this._isEnabled) {
            return;
          }

          this._calendar.draw({
            date: this._date,
            type: this._type
          });
          this._show();

          if (!this.showAlways) {
            this._setDocumentEvents();
          }

          /**
           * Occur after the date picker opens.
           * @event DatePicker#open
           * @see {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents#on datepicker.on()} to bind event handlers.
           * @see {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents#off datepicker.off()} to unbind event handlers.
           * @see Refer to {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents CustomEvents from tui-code-snippet} for more methods. DatePicker mixes in the methods from CustomEvents.
           * @example
           * // bind the 'open' event
           * datepicker.on('open', () => {
           *     alert('open');
           * });
           *
           * // unbind the 'open' event
           * datepicker.off('open');
           */
          this.fire('open');
        },

        /**
         * Raise the calendar type. (date -> month -> year)
         * @param {Date} [date] - Date to set
         */
        drawUpperCalendar: function(date) {
          var calendarType = this.getCalendarType();

          if (calendarType === TYPE_DATE) {
            this._calendar.draw({
              date: date,
              type: TYPE_MONTH
            });
          } else if (calendarType === TYPE_MONTH) {
            this._calendar.draw({
              date: date,
              type: TYPE_YEAR
            });
          }
        },

        /**
         * Lower the calendar type. (year -> month -> date)
         * @param {Date} [date] - Date to set
         */
        drawLowerCalendar: function(date) {
          var calendarType = this.getCalendarType();
          var pickerType = this.getType();
          var isLast = calendarType === pickerType;

          if (isLast) {
            return;
          }

          if (calendarType === TYPE_MONTH) {
            this._calendar.draw({
              date: date,
              type: TYPE_DATE
            });
          } else if (calendarType === TYPE_YEAR) {
            this._calendar.draw({
              date: date,
              type: TYPE_MONTH
            });
          }
        },

        /**
         * Close the date picker.
         * @exmaple
         * datepicker.close();
         */
        close: function() {
          if (!this.isOpened()) {
            return;
          }
          this._removeDocumentEvents();
          this._hide();

          /**
           * Occur after the date picker closes.
           * @event DatePicker#close
           * @see {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents#on datepicker.on()} to bind event handlers.
           * @see {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents#off datepicker.off()} to unbind event handlers.
           * @see Refer to {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents CustomEvents from tui-code-snippet} for more methods. DatePicker mixes in the methods from CustomEvents.
           * @example
           * // bind the 'close' event
           * datepicker.on('close', () => {
           *     alert('close');
           * });
           *
           * // unbind the 'close' event
           * datepicker.off('close');
           */
          this.fire('close');
        },

        /**
         * Toggle the date picker.
         * @example
         * datepicker.toggle();
         */
        toggle: function() {
          if (this.isOpened()) {
            this.close();
          } else {
            this.open();
          }
        },

        /**
         * Return the selected date.
         * @returns {?Date} - selected date
         * @example
         * // 2015-04-13
         * datepicker.getDate(); // new Date(2015, 3, 13)
         */
        getDate: function() {
          if (!this._date) {
            return null;
          }

          return new Date(this._date);
        },

        /**
         * Select the date.
         * @param {Date|number} date - Date instance or timestamp to set
         * @example
         * datepicker.setDate(new Date()); // Set today
         */
        // eslint-disable-next-line complexity
        setDate: function(date) {
          var isValidInput, newDate, shouldUpdate;

          if (date === null) {
            this.setNull();

            return;
          }

          isValidInput = isNumber(date) || isDate(date);
          newDate = new Date(date);
          shouldUpdate = isValidInput && this._isChanged(newDate) && this.isSelectable(newDate);

          if (shouldUpdate) {
            newDate = new Date(date);
            this._date = newDate;
            this._calendar.draw({ date: newDate });
            if (this._timePicker) {
              this._timePicker.setTime(newDate.getHours(), newDate.getMinutes());
            }
            this._syncToInput();

            /**
             * Occur after the selected date is changed.
             * @event DatePicker#change
             * @see {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents#on datepicker.on()} to bind event handlers.
             * @see {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents#off datepicker.off()} to unbind event handlers.
             * @see Refer to {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents CustomEvents from tui-code-snippet} for more methods. DatePicker mixes in the methods from CustomEvents.
             * @example
             * // bind the 'change' event
             * datepicker.on('change', () => {
             *     console.log(`Selected date: ${datepicker.getDate()}`);
             * });
             *
             * // unbind the 'change' event
             * datepicker.off('change');
             */
            this.fire('change');
          }
        },

        /**
         * Set no date to be selected. (Selected date: null)
         */
        setNull: function() {
          var calendarDate = this._calendar.getDate();
          var isChagned = this._date !== null;

          this._date = null;

          if (this._datepickerInput) {
            this._datepickerInput.clearText();
          }
          if (this._timePicker) {
            this._timePicker.setTime(0, 0);
          }

          // View update
          if (!this.isSelectable(calendarDate)) {
            this._calendar.draw({
              date: new Date(this._rangeModel.getMinimumValue())
            });
          } else {
            this._calendar.draw();
          }

          if (isChagned) {
            this.fire('change');
          }
        },

        /**
         * Select the date by the date string format.
         * @param {String} [format] - Date string format
         * @example
         * datepicker.setDateFormat('yyyy-MM-dd');
         * datepicker.setDateFormat('MM-dd, yyyy');
         * datepicker.setDateFormat('yy/M/d');
         * datepicker.setDateFormat('yy/MM/dd');
         */
        setDateFormat: function(format) {
          this._datepickerInput.setFormat(format);
          this._syncToInput();
        },

        /**
         * Return whether the datepicker opens or not
         * @returns {boolean}
         * @example
         * datepicker.close();
         * datepicker.isOpened(); // false
         *
         * datepicker.open();
         * datepicker.isOpened(); // true
         */
        isOpened: function() {
          return !hasClass(this._element, CLASS_NAME_HIDDEN);
        },

        /**
         * Return the time picker instance
         * @returns {?TimePicker} - TimePicker instance
         * @see {@link https://nhn.github.io/tui.time-picker/latest tui-time-picker}
         * @example
         * const timePicker = this.getTimePicker();
         */
        getTimePicker: function() {
          return this._timePicker;
        },

        /**
         * Return the calendar instance.
         * @see {@link calendar Calendar}
         * @returns {Calendar}
         */
        getCalendar: function() {
          return this._calendar;
        },

        /**
         * Return the locale text object.
         * @see {@link DatePicker#localeTexts DatePicker.localeTexts}
         * @returns {object}
         */
        getLocaleText: function() {
          return localeTexts[this._language] || localeTexts[DEFAULT_LANGUAGE_TYPE];
        },

        /**
         * Set the input element
         * @param {string|HTMLElement} element - Input element or selector
         * @param {object} [options] - Input option
         * @param {string} [options.format = prevInput.format] - Format of the Date string in the input
         * @param {boolean} [options.syncFromInput = false] - Whether set the date from the input
         */
        setInput: function(element, options) {
          var prev = this._datepickerInput;
          var localeText = this.getLocaleText();
          var prevFormat;
          options = options || {};

          if (prev) {
            prevFormat = prev.getFormat();
            prev.destroy();
          }

          this._datepickerInput = new DatePickerInput(element, {
            format: options.format || prevFormat,
            id: this._id,
            localeText: localeText
          });

          this._datepickerInput.on(
            {
              change: this._onChangeInput,
              click: this.open
            },
            this
          );

          if (options.syncFromInput) {
            this._syncFromInput();
          } else {
            this._syncToInput();
          }
        },

        /**
         * Enable the date picker.
         */
        enable: function() {
          if (this._isEnabled) {
            return;
          }
          this._isEnabled = true;
          this._datepickerInput.enable();

          forEachArray(
            this._openers,
            function(opener) {
              opener.removeAttribute('disabled');
              this._setOpenerEvents(opener);
            },
            this
          );
        },

        /**
         * Disable the date picker.
         */
        disable: function() {
          if (!this._isEnabled) {
            return;
          }

          this._isEnabled = false;
          this.close();
          this._datepickerInput.disable();

          forEachArray(
            this._openers,
            function(opener) {
              opener.setAttribute('disabled', true);
              this._removeOpenerEvents(opener);
            },
            this
          );
        },

        /**
         * Return whether the date picker is disabled
         * @returns {boolean}
         */
        isDisabled: function() {
          // @todo this._isEnabled --> this._isDisabled
          return !this._isEnabled;
        },

        /**
         * Apply a CSS class to the date picker.
         * @param {string} className - Class name
         */
        addCssClass: function(className) {
          addClass(this._element, className);
        },

        /**
         * Remove a CSS class from the date picker.
         * @param {string} className - Class name
         */
        removeCssClass: function(className) {
          removeClass(this._element, className);
        },

        /**
         * Return the date elements on the calendar.
         * @returns {HTMLElement[]}
         */
        getDateElements: function() {
          return this._calendar.getDateElements();
        },

        /**
         * Return the first overlapped range from the point or range.
         * @param {Date|number} startDate - Start date to find overlapped range
         * @param {Date|number} endDate - End date to find overlapped range
         * @returns {Array.<Date>} - \[startDate, endDate]
         */
        findOverlappedRange: function(startDate, endDate) {
          var startTimestamp = new Date(startDate).getTime();
          var endTimestamp = new Date(endDate).getTime();
          var overlappedRange = this._rangeModel.findOverlappedRange(startTimestamp, endTimestamp);

          return [new Date(overlappedRange[0]), new Date(overlappedRange[1])];
        },

        /**
         * Change language.
         * @param {string} language - Language code. English('en') and Korean('ko') are provided as default.
         * @see To set to the other languages, use {@link DatePicker#localeTexts DatePicker.localeTexts}.
         */
        changeLanguage: function(language) {
          this._language = language;
          this._calendar.changeLanguage(this._language);
          this._datepickerInput.changeLocaleTitles(this.getLocaleText().titles);
          this.setDateFormat(this._datepickerInput.getFormat());

          if (this._timePicker) {
            this._timePicker.changeLanguage(this._language);
          }
        },

        /**
         * Destroy the date picker.
         */
        destroy: function() {
          this._removeDocumentEvents();
          this._calendar.destroy();
          if (this._timePicker) {
            this._timePicker.destroy();
          }
          if (this._datepickerInput) {
            this._datepickerInput.destroy();
          }
          this._removeEvents();
          removeElement(this._element);
          this.removeAllOpeners();

          this._calendar = this._timePicker = this._datepickerInput = this._container = this._element = this._date = this._rangeModel = this._openers = this._isEnabled = this._id = null;
        }
      }
    );

    CustomEvents.mixin(DatePicker);
    module.exports = DatePicker;


    /***/ }),
    /* 22 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is an object or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Check whether the given variable is an object or not.
     * If the given variable is an object, return true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is object?
     * @memberof module:type
     */
    function isObject(obj) {
      return obj === Object(obj);
    }

    module.exports = isObject;


    /***/ }),
    /* 23 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Execute the provided callback once for each property of object which actually exist.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Execute the provided callback once for each property of object which actually exist.
     * If the callback function returns false, the loop will be stopped.
     * Callback function(iteratee) is invoked with three arguments:
     *  1) The value of the property
     *  2) The name of the property
     *  3) The object being traversed
     * @param {Object} obj The object that will be traversed
     * @param {function} iteratee  Callback function
     * @param {Object} [context] Context(this) of callback function
     * @memberof module:collection
     * @example
     * var forEachOwnProperties = require('tui-code-snippet/collection/forEachOwnProperties'); // node, commonjs
     *
     * var sum = 0;
     *
     * forEachOwnProperties({a:1,b:2,c:3}, function(value){
     *     sum += value;
     * });
     * alert(sum); // 6
     */
    function forEachOwnProperties(obj, iteratee, context) {
      var key;

      context = context || null;

      for (key in obj) {
        if (obj.hasOwnProperty(key)) {
          if (iteratee.call(context, obj[key], key, obj) === false) {
            break;
          }
        }
      }
    }

    module.exports = forEachOwnProperties;


    /***/ }),
    /* 24 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Set className value
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var isArray = __webpack_require__(6);
    var isUndefined = __webpack_require__(12);

    /**
     * Set className value
     * @param {(HTMLElement|SVGElement)} element - target element
     * @param {(string|string[])} cssClass - class names
     * @private
     */
    function setClassName(element, cssClass) {
      cssClass = isArray(cssClass) ? cssClass.join(' ') : cssClass;

      cssClass = cssClass.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

      if (isUndefined(element.className.baseVal)) {
        element.className = cssClass;

        return;
      }

      element.className.baseVal = cssClass;
    }

    module.exports = setClassName;


    /***/ }),
    /* 25 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Find parent element recursively
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var matches = __webpack_require__(40);

    /**
     * Find parent element recursively
     * @param {HTMLElement} element - base element to start find
     * @param {string} selector - selector string for find
     * @returns {HTMLElement} - element finded or null
     * @memberof module:domUtil
     */
    function closest(element, selector) {
      var parent = element.parentNode;

      if (matches(element, selector)) {
        return element;
      }

      while (parent && parent !== document) {
        if (matches(parent, selector)) {
          return parent;
        }

        parent = parent.parentNode;
      }

      return null;
    }

    module.exports = closest;


    /***/ }),
    /* 26 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Get data value from data-attribute
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var convertToKebabCase = __webpack_require__(42);

    /**
     * Get data value from data-attribute
     * @param {HTMLElement} element - target element
     * @param {string} key - key
     * @returns {string} value
     * @memberof module:domUtil
     */
    function getData(element, key) {
      if (element.dataset) {
        return element.dataset[key];
      }

      return element.getAttribute('data-' + convertToKebabCase(key));
    }

    module.exports = getData;


    /***/ }),
    /* 27 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check element has specific css class
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var inArray = __webpack_require__(3);
    var getClass = __webpack_require__(17);

    /**
     * Check element has specific css class
     * @param {(HTMLElement|SVGElement)} element - target element
     * @param {string} cssClass - css class
     * @returns {boolean}
     * @memberof module:domUtil
     */
    function hasClass(element, cssClass) {
      var origin;

      if (element.classList) {
        return element.classList.contains(cssClass);
      }

      origin = getClass(element).split(/\s+/);

      return inArray(cssClass, origin) > -1;
    }

    module.exports = hasClass;


    /***/ }),
    /* 28 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is an instance of Date or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Check whether the given variable is an instance of Date or not.
     * If the given variables is an instance of Date, return true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is an instance of Date?
     * @memberof module:type
     */
    function isDate(obj) {
      return obj instanceof Date;
    }

    module.exports = isDate;


    /***/ }),
    /* 29 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Calendar component
     * @author NHN. FE dev Lab <dl_javascript@nhn.com>
     */



    var defineClass = __webpack_require__(0);
    var CustomEvents = __webpack_require__(8);
    var addClass = __webpack_require__(16);
    var hasClass = __webpack_require__(27);
    var removeClass = __webpack_require__(18);
    var removeElement = __webpack_require__(14);
    var extend = __webpack_require__(7);

    var Header = __webpack_require__(44);
    var Body = __webpack_require__(49);
    var localeTexts = __webpack_require__(10);
    var constants = __webpack_require__(1);
    var dateUtil = __webpack_require__(5);
    var util = __webpack_require__(4);

    var DEFAULT_WEEK_START_DAY = constants.DEFAULT_WEEK_START_DAY;
    var DEFAULT_LANGUAGE_TYPE = constants.DEFAULT_LANGUAGE_TYPE;

    var TYPE_DATE = constants.TYPE_DATE;
    var TYPE_MONTH = constants.TYPE_MONTH;
    var TYPE_YEAR = constants.TYPE_YEAR;

    var CLASS_NAME_PREV_MONTH_BTN = constants.CLASS_NAME_PREV_MONTH_BTN;
    var CLASS_NAME_PREV_YEAR_BTN = constants.CLASS_NAME_PREV_YEAR_BTN;
    var CLASS_NAME_NEXT_YEAR_BTN = constants.CLASS_NAME_NEXT_YEAR_BTN;
    var CLASS_NAME_NEXT_MONTH_BTN = constants.CLASS_NAME_NEXT_MONTH_BTN;

    var CLASS_NAME_CALENDAR_MONTH = 'tui-calendar-month';
    var CLASS_NAME_CALENDAR_YEAR = 'tui-calendar-year';
    var CLASS_NAME_HIDDEN = 'tui-hidden';

    var HEADER_SELECTOR = '.tui-calendar-header';
    var BODY_SELECTOR = '.tui-calendar-body';

    /**
     * @class
     * @description
     * Create a calendar by {@link DatePicker#createCalendar DatePicker.createCalendar()}.
     * @see {@link /tutorial-example07-calendar Calendar example}
     * @param {HTMLElement|string} container - Container or selector of the Calendar
     * @param {Object} [options] - Calendar options
     *     @param {Date} [options.date = new Date()] - Initial date (default: today)
     *     @param {('date'|'month'|'year')} [options.type = 'date'] - Calendar type. Determine whether to show a date, month, or year.
     *     @param {string} [options.language = 'en'] - Language code. English('en') and Korean('ko') are provided as default. To use the other languages, use {@link DatePicker#localeTexts DatePicker.localeTexts}.
     *     @param {boolean} [options.showToday = true] - Show today.
     *     @param {boolean} [options.showJumpButtons = false] - Show the yearly jump buttons (move to the previous and next year in 'date' Calendar)
     *     @param {boolean} [options.usageStatistics = true] - Send a hostname to Google Analytics (default: true)
     *     @param {string} [options.weekStartDay = 'Sun'] - Start of the week. 'Sun', 'Mon', ..., 'Sat'(default: 'Sun'(start on Sunday))
     * @example
     * //ES6
     * import DatePicker from 'tui-date-picker'
     *
     * // CommonJS
     * const DatePicker = require('tui-date-picker');
     *
     * // Browser
     * const DatePicker = tui.DatePicker;
     *
     * const calendar = DatePicker.createCalendar('#calendar-wrapper', {
     *     language: 'en',
     *     showToday: true,
     *     showJumpButtons: false,
     *     date: new Date(),
     *     type: 'date',
     *     weekStartDay: 'Mon',
     * });
     *
     * calendar.on('draw', (event) => {
     *     console.log(event.date);
     *     console.log(event.type);
     *     for (let i = 0, len = event.dateElements.length; i < len; i += 1) {
     *         const el = event.dateElements[i];
     *         const date = new Date(getData(el, 'timestamp'));
     *         console.log(date);
     *     }
     * });
     */
    var Calendar = defineClass(
      /** @lends Calendar.prototype */ {
        static: {
          localeTexts: localeTexts
        },
        init: function(container, options) {
          options = extend(
            {
              language: DEFAULT_LANGUAGE_TYPE,
              showToday: true,
              showJumpButtons: false,
              date: new Date(),
              type: TYPE_DATE,
              usageStatistics: true,
              weekStartDay: DEFAULT_WEEK_START_DAY
            },
            options
          );

          /**
           * Container element
           * @type {HTMLElement}
           * @private
           */
          this._container = util.getElement(container);
          this._container.innerHTML =
            '<div class="tui-calendar">' +
            '    <div class="tui-calendar-header"></div>' +
            '    <div class="tui-calendar-body"></div>' +
            '</div>';

          /**
           * Wrapper element
           * @type {HTMLElement}
           * @private
           */
          this._element = this._container.firstChild;

          /**
           * Date
           * @type {Date}
           * @private
           */
          this._date = null;

          /**
           * Layer type
           * @type {string}
           * @private
           */
          this._type = null;

          /**
           * Header box
           * @type {Header}
           * @private
           */
          this._header = null;

          /**
           * Body box
           * @type {Body}
           * @private
           */
          this._body = null;

          this._initHeader(options);
          this._initBody(options);
          this.draw({
            date: options.date,
            type: options.type
          });

          if (options.usageStatistics) {
            util.sendHostName();
          }
        },

        /**
         * Initialize header
         * @param {object} options - Header options
         * @private
         */
        _initHeader: function(options) {
          var headerContainer = this._element.querySelector(HEADER_SELECTOR);

          this._header = new Header(headerContainer, options);
          this._header.on(
            'click',
            function(ev) {
              var target = util.getTarget(ev);
              if (hasClass(target, CLASS_NAME_PREV_MONTH_BTN)) {
                this.drawPrev();
              } else if (hasClass(target, CLASS_NAME_PREV_YEAR_BTN)) {
                this._onClickPrevYear();
              } else if (hasClass(target, CLASS_NAME_NEXT_MONTH_BTN)) {
                this.drawNext();
              } else if (hasClass(target, CLASS_NAME_NEXT_YEAR_BTN)) {
                this._onClickNextYear();
              }
            },
            this
          );
        },

        /**
         * Initialize body
         * @param {object} options - Body options
         * @private
         */
        _initBody: function(options) {
          var bodyContainer = this._element.querySelector(BODY_SELECTOR);

          this._body = new Body(bodyContainer, options);
        },

        /**
         * clickHandler - prev year button
         * @private
         */
        _onClickPrevYear: function() {
          if (this.getType() === TYPE_DATE) {
            this.draw({
              date: this._getRelativeDate(-12)
            });
          } else {
            this.drawPrev();
          }
        },

        /**
         * clickHandler - next year button
         * @private
         */
        _onClickNextYear: function() {
          if (this.getType() === TYPE_DATE) {
            this.draw({
              date: this._getRelativeDate(12)
            });
          } else {
            this.drawNext();
          }
        },

        /**
         * Returns whether the layer type is valid
         * @param {string} type - Layer type to check
         * @returns {boolean}
         * @private
         */
        _isValidType: function(type) {
          return type === TYPE_DATE || type === TYPE_MONTH || type === TYPE_YEAR;
        },

        /**
         * @param {Date} date - Date to draw
         * @param {string} type - Layer type to draw
         * @returns {boolean}
         * @private
         */
        _shouldUpdate: function(date, type) {
          var prevDate = this._date;

          if (!dateUtil.isValidDate(date)) {
            throw new Error('Invalid date');
          }

          if (!this._isValidType(type)) {
            throw new Error('Invalid layer type');
          }

          return (
            !prevDate ||
            prevDate.getFullYear() !== date.getFullYear() ||
            prevDate.getMonth() !== date.getMonth() ||
            this.getType() !== type
          );
        },

        /**
         * Render header & body elements
         * @private
         */
        _render: function() {
          var date = this._date;
          var type = this.getType();

          this._header.render(date, type);
          this._body.render(date, type);
          removeClass(this._element, CLASS_NAME_CALENDAR_MONTH, CLASS_NAME_CALENDAR_YEAR);

          switch (type) {
            case TYPE_MONTH:
              addClass(this._element, CLASS_NAME_CALENDAR_MONTH);
              break;
            case TYPE_YEAR:
              addClass(this._element, CLASS_NAME_CALENDAR_YEAR);
              break;
          }
        },

        /**
         * Returns relative date
         * @param {number} step - Month step
         * @returns {Date}
         * @private
         */
        _getRelativeDate: function(step) {
          var prev = this._date;

          return new Date(prev.getFullYear(), prev.getMonth() + step);
        },

        /**
         * Draw the calendar.
         * @param {Object} [options] - Draw options
         *   @param {Date} [options.date] - Date to set
         *   @param {('date'|'month'|'year')} [options.type = 'date'] - Calendar type. Determine whether to show a date, month, or year.
         * @example
         * calendar.draw();
         * calendar.draw({
         *     date: new Date()
         * });
         * calendar.draw({
         *     type: 'month'
         * });
         * calendar.draw({
         *     type: 'month',
         *     date: new Date()
         * });
         */
        draw: function(options) {
          var date, type;

          options = options || {};
          date = options.date || this._date;
          type = (options.type || this.getType()).toLowerCase();

          if (this._shouldUpdate(date, type)) {
            this._date = date;
            this._type = type;
            this._render();
          }

          /**
           * Occur after the calendar draws.
           * @event Calendar#draw
           * @see {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents#on calendar.on()} to bind event handlers.
           * @see {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents#off calendar.off()} to unbind event handlers.
           * @see Refer to {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents CustomEvents from tui-code-snippet} for more methods. Calendar mixes in the methods from CustomEvents.
           * @property {Date} date - Calendar date
           * @property {('date'|'month'|'year')} type - Calendar type
           * @property {HTMLElement[]} dateElements - elements for dates
           * @example
           * // bind the 'draw' event
           * calendar.on('draw', ({type, date}) => {
           *     console.log(`Draw the ${type} calendar and its date is ${date}.`);
           * });
           *
           * // unbind the 'draw' event
           * calendar.off('draw');
           */
          this.fire('draw', {
            date: this._date,
            type: type,
            dateElements: this._body.getDateElements()
          });
        },

        /**
         * Show the calendar.
         */
        show: function() {
          removeClass(this._element, CLASS_NAME_HIDDEN);
        },

        /**
         * Hide the calendar.
         */
        hide: function() {
          addClass(this._element, CLASS_NAME_HIDDEN);
        },

        /**
         * Draw the next page.
         */
        drawNext: function() {
          this.draw({
            date: this.getNextDate()
          });
        },

        /**
         * Draw the previous page.
         */
        drawPrev: function() {
          this.draw({
            date: this.getPrevDate()
          });
        },

        /**
         * Return the next date.
         * @returns {Date}
         */
        getNextDate: function() {
          if (this.getType() === TYPE_DATE) {
            return this._getRelativeDate(1);
          }

          return this.getNextYearDate();
        },

        /**
         * Return the previous date.
         * @returns {Date}
         */
        getPrevDate: function() {
          if (this.getType() === TYPE_DATE) {
            return this._getRelativeDate(-1);
          }

          return this.getPrevYearDate();
        },

        /**
         * Return the date a year later.
         * @returns {Date}
         */
        getNextYearDate: function() {
          switch (this.getType()) {
            case TYPE_DATE:
            case TYPE_MONTH:
              return this._getRelativeDate(12); // 12 months = 1 year
            case TYPE_YEAR:
              return this._getRelativeDate(108); // 108 months = 9 years = 12 * 9
            default:
              throw new Error('Unknown layer type');
          }
        },

        /**
         * Return the date a year previously.
         * @returns {Date}
         */
        getPrevYearDate: function() {
          switch (this.getType()) {
            case TYPE_DATE:
            case TYPE_MONTH:
              return this._getRelativeDate(-12); // 12 months = 1 year
            case TYPE_YEAR:
              return this._getRelativeDate(-108); // 108 months = 9 years = 12 * 9
            default:
              throw new Error('Unknown layer type');
          }
        },

        /**
         * Change language.
         * @param {string} language - Language code. English('en') and Korean('ko') are provided as default.
         * @see To set to the other languages, use {@link DatePicker#localeTexts DatePicker.localeTexts}.
         */
        changeLanguage: function(language) {
          this._header.changeLanguage(language);
          this._body.changeLanguage(language);
          this._render();
        },

        /**
         * Return the rendered date.
         * @returns {Date}
         */
        getDate: function() {
          return new Date(this._date);
        },

        /**
         * Return the calendar's type.
         * @returns {('date'|'month'|'year')}
         */
        getType: function() {
          return this._type;
        },

        /**
         * Returns HTML elements for dates.
         * @returns {HTMLElement[]}
         */
        getDateElements: function() {
          return this._body.getDateElements();
        },

        /**
         * Apply a CSS class to the calendar.
         * @param {string} className - Class name
         */
        addCssClass: function(className) {
          addClass(this._element, className);
        },

        /**
         * Remove a CSS class from the calendar.
         * @param {string} className - Class name
         */
        removeCssClass: function(className) {
          removeClass(this._element, className);
        },

        /**
         * Destroy the calendar.
         */
        destroy: function() {
          this._header.destroy();
          this._body.destroy();
          removeElement(this._element);

          this._type = this._date = this._container = this._element = this._header = this._body = null;
        }
      }
    );

    CustomEvents.mixin(Calendar);
    module.exports = Calendar;


    /***/ }),
    /* 30 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Date <-> Text formatting module
     * @author NHN. FE Development Lab <dl_javascript@nhn.com>
     */



    var inArray = __webpack_require__(3);
    var forEachArray = __webpack_require__(2);
    var defineClass = __webpack_require__(0);

    var util = __webpack_require__(4);
    var dateUtil = __webpack_require__(5);
    var constants = __webpack_require__(1);
    var localeTexts = __webpack_require__(10);

    var rFormableKeys = /\\?(yyyy|yy|mmmm|mmm|mm|m|dd|d|hh|h|a)/gi;
    var mapForConverting = {
      yyyy: {
        expression: '(\\d{4}|\\d{2})',
        type: constants.TYPE_YEAR
      },
      yy: {
        expression: '(\\d{4}|\\d{2})',
        type: constants.TYPE_YEAR
      },
      y: {
        expression: '(\\d{4}|\\d{2})',
        type: constants.TYPE_YEAR
      },
      M: {
        expression: '(1[012]|0[1-9]|[1-9])',
        type: constants.TYPE_MONTH
      },
      MM: {
        expression: '(1[012]|0[1-9]|[1-9])',
        type: constants.TYPE_MONTH
      },
      MMM: {
        expression: '(1[012]|0[1-9]|[1-9])',
        type: constants.TYPE_MONTH
      },
      MMMM: {
        expression: '(1[012]|0[1-9]|[1-9])',
        type: constants.TYPE_MONTH
      },
      mmm: {
        expression: '(1[012]|0[1-9]|[1-9])',
        type: constants.TYPE_MONTH
      },
      mmmm: {
        expression: '(1[012]|0[1-9]|[1-9])',
        type: constants.TYPE_MONTH
      },
      dd: {
        expression: '([12]\\d{1}|3[01]|0[1-9]|[1-9])',
        type: constants.TYPE_DATE
      },
      d: {
        expression: '([12]\\d{1}|3[01]|0[1-9]|[1-9])',
        type: constants.TYPE_DATE
      },
      D: {
        expression: '([12]\\d{1}|3[01]|0[1-9]|[1-9])',
        type: constants.TYPE_DATE
      },
      DD: {
        expression: '([12]\\d{1}|3[01]|0[1-9]|[1-9])',
        type: constants.TYPE_DATE
      },
      h: {
        expression: '(d{1}|0\\d{1}|1\\d{1}|2[0123])',
        type: constants.TYPE_HOUR
      },
      hh: {
        expression: '(d{1}|[01]\\d{1}|2[0123])',
        type: constants.TYPE_HOUR
      },
      H: {
        expression: '(d{1}|0\\d{1}|1\\d{1}|2[0123])',
        type: constants.TYPE_HOUR
      },
      HH: {
        expression: '(d{1}|[01]\\d{1}|2[0123])',
        type: constants.TYPE_HOUR
      },
      m: {
        expression: '(d{1}|[012345]\\d{1})',
        type: constants.TYPE_MINUTE
      },
      mm: {
        expression: '(d{1}|[012345]\\d{1})',
        type: constants.TYPE_MINUTE
      },
      a: {
        expression: '([ap]m)',
        type: constants.TYPE_MERIDIEM
      },
      A: {
        expression: '([ap]m)',
        type: constants.TYPE_MERIDIEM
      }
    };

    /**
     * @class
     * @ignore
     */
    var DateTimeFormatter = defineClass(
      /** @lends DateTimeFormatter.prototype */ {
        init: function(rawStr, titles) {
          /**
           * @type {string}
           * @private
           */
          this._rawStr = rawStr;

          /**
           * @type {Array}
           * @private
           * @example
           *  rawStr = "yyyy-MM-dd" --> keyOrder = ['year', 'month', 'date']
           *  rawStr = "MM/dd, yyyy" --> keyOrder = ['month', 'date', 'year']
           */
          this._keyOrder = null;

          /**
           * @type {RegExp}
           * @private
           */
          this._regExp = null;

          /**
           * Titles
           * @type {object}
           * @private
           */
          this._titles = titles || localeTexts.en.titles;

          this._parseFormat();
        },

        /**
         * Parse initial format and make the keyOrder, regExp
         * @private
         */
        _parseFormat: function() {
          var regExpStr = '^';
          var matchedKeys = this._rawStr.match(rFormableKeys);
          var keyOrder = [];

          matchedKeys = util.filter(matchedKeys, function(key) {
            return key[0] !== '\\';
          });

          forEachArray(matchedKeys, function(key, index) {
            if (!/m/i.test(key)) {
              key = key.toLowerCase();
            }

            regExpStr += mapForConverting[key].expression + '[\\D\\s]*';
            keyOrder[index] = mapForConverting[key].type;
          });

          // This formatter does not allow additional numbers at the end of string.
          regExpStr += '$';

          this._keyOrder = keyOrder;

          this._regExp = new RegExp(regExpStr, 'gi');
        },

        /**
         * Parse string to dateHash
         * @param {string} str - Date string
         * @returns {Date}
         */
        parse: function(str) {
          var dateHash = {
            year: 0,
            month: 1,
            date: 1,
            hour: 0,
            minute: 0
          };
          var hasMeridiem = false;
          var isPM = false;
          var matched;

          this._regExp.lastIndex = 0;
          matched = this._regExp.exec(str);

          if (!matched) {
            throw Error('DateTimeFormatter: Not matched - "' + str + '"');
          }

          // eslint-disable-next-line complexity
          forEachArray(this._keyOrder, function(name, index) {
            var value = matched[index + 1];

            if (name === constants.TYPE_MERIDIEM && /[ap]m/i.test(value)) {
              hasMeridiem = true;
              isPM = /pm/i.test(value);
            } else {
              value = Number(value);

              if (value !== 0 && !value) {
                throw Error('DateTimeFormatter: Unknown value - ' + matched[index + 1]);
              }

              if (name === constants.TYPE_YEAR && value < 100) {
                value += 2000;
              }

              dateHash[name] = value;
            }
          });

          if (hasMeridiem) {
            isPM = isPM || dateHash.hour > 12;
            dateHash.hour %= 12;
            if (isPM) {
              dateHash.hour += 12;
            }
          }

          return new Date(
            dateHash.year,
            dateHash.month - 1,
            dateHash.date,
            dateHash.hour,
            dateHash.minute
          );
        },

        /**
         * Returns raw string of format
         * @returns {string}
         */
        getRawString: function() {
          return this._rawStr;
        },

        /**
         * Format date to string
         * @param {Date} dateObj - Date object
         * @returns {string}
         */
        format: function(dateObj) {
          var year = dateObj.getFullYear();
          var month = dateObj.getMonth() + 1;
          var dayInMonth = dateObj.getDate();
          var day = dateObj.getDay();
          var hour = dateObj.getHours();
          var minute = dateObj.getMinutes();
          var meridiem = 'a'; // Default value for unusing meridiem format
          var replaceMap;

          if (inArray(constants.TYPE_MERIDIEM, this._keyOrder) > -1) {
            meridiem = hour >= 12 ? 'pm' : 'am';
            hour = dateUtil.getMeridiemHour(hour);
          }

          replaceMap = {
            yyyy: year,
            yy: String(year).substr(2, 2),
            M: month,
            MM: dateUtil.prependLeadingZero(month),
            MMM: this._titles.MMM[month - 1],
            MMMM: this._titles.MMMM[month - 1],
            d: dayInMonth,
            dd: dateUtil.prependLeadingZero(dayInMonth),
            D: this._titles.D[day],
            DD: this._titles.DD[day],
            hh: dateUtil.prependLeadingZero(hour),
            h: hour,
            mm: dateUtil.prependLeadingZero(minute),
            m: minute,
            A: meridiem.toUpperCase(),
            a: meridiem
          };

          return this._rawStr.replace(rFormableKeys, function(key) {
            if (key[0] === '\\') {
              return key.substr(1);
            }

            return replaceMap[key] || replaceMap[key.toLowerCase()] || '';
          });
        }
      }
    );

    module.exports = DateTimeFormatter;


    /***/ }),
    /* 31 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Bind DOM events
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var isString = __webpack_require__(13);
    var forEach = __webpack_require__(9);

    var safeEvent = __webpack_require__(32);

    /**
     * Bind DOM events.
     * @param {HTMLElement} element - element to bind events
     * @param {(string|object)} types - Space splitted events names or eventName:handler object
     * @param {(function|object)} handler - handler function or context for handler method
     * @param {object} [context] context - context for handler method.
     * @memberof module:domEvent
     * @example
     * var div = document.querySelector('div');
     * 
     * // Bind one event to an element.
     * on(div, 'click', toggle);
     * 
     * // Bind multiple events with a same handler to multiple elements at once.
     * // Use event names splitted by a space.
     * on(div, 'mouseenter mouseleave', changeColor);
     * 
     * // Bind multiple events with different handlers to an element at once.
     * // Use an object which of key is an event name and value is a handler function.
     * on(div, {
     *   keydown: highlight,
     *   keyup: dehighlight
     * });
     * 
     * // Set a context for handler method.
     * var name = 'global';
     * var repository = {name: 'CodeSnippet'};
     * on(div, 'drag', function() {
     *  console.log(this.name);
     * }, repository);
     * // Result when you drag a div: "CodeSnippet"
     */
    function on(element, types, handler, context) {
      if (isString(types)) {
        forEach(types.split(/\s+/g), function(type) {
          bindEvent(element, type, handler, context);
        });

        return;
      }

      forEach(types, function(func, type) {
        bindEvent(element, type, func, handler);
      });
    }

    /**
     * Bind DOM events
     * @param {HTMLElement} element - element to bind events
     * @param {string} type - events name
     * @param {function} handler - handler function or context for handler method
     * @param {object} [context] context - context for handler method.
     * @private
     */
    function bindEvent(element, type, handler, context) {
      /**
         * Event handler
         * @param {Event} e - event object
         */
      function eventHandler(e) {
        handler.call(context || element, e || window.event);
      }

      if ('addEventListener' in element) {
        element.addEventListener(type, eventHandler);
      } else if ('attachEvent' in element) {
        element.attachEvent('on' + type, eventHandler);
      }
      memorizeHandler(element, type, handler, eventHandler);
    }

    /**
     * Memorize DOM event handler for unbinding.
     * @param {HTMLElement} element - element to bind events
     * @param {string} type - events name
     * @param {function} handler - handler function that user passed at on() use
     * @param {function} wrappedHandler - handler function that wrapped by domevent for implementing some features
     * @private
     */
    function memorizeHandler(element, type, handler, wrappedHandler) {
      var events = safeEvent(element, type);
      var existInEvents = false;

      forEach(events, function(obj) {
        if (obj.handler === handler) {
          existInEvents = true;

          return false;
        }

        return true;
      });

      if (!existInEvents) {
        events.push({
          handler: handler,
          wrappedHandler: wrappedHandler
        });
      }
    }

    module.exports = on;


    /***/ }),
    /* 32 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Get event collection for specific HTML element
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var EVENT_KEY = '_feEventKey';

    /**
     * Get event collection for specific HTML element
     * @param {HTMLElement} element - HTML element
     * @param {string} type - event type
     * @returns {array}
     * @private
     */
    function safeEvent(element, type) {
      var events = element[EVENT_KEY];
      var handlers;

      if (!events) {
        events = element[EVENT_KEY] = {};
      }

      handlers = events[type];
      if (!handlers) {
        handlers = events[type] = [];
      }

      return handlers;
    }

    module.exports = safeEvent;


    /***/ }),
    /* 33 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Unbind DOM events
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var isString = __webpack_require__(13);
    var forEach = __webpack_require__(9);

    var safeEvent = __webpack_require__(32);

    /**
     * Unbind DOM events
     * If a handler function is not passed, remove all events of that type.
     * @param {HTMLElement} element - element to unbind events
     * @param {(string|object)} types - Space splitted events names or eventName:handler object
     * @param {function} [handler] - handler function
     * @memberof module:domEvent
     * @example
     * // Following the example of domEvent#on
     * 
     * // Unbind one event from an element.
     * off(div, 'click', toggle);
     * 
     * // Unbind multiple events with a same handler from multiple elements at once.
     * // Use event names splitted by a space.
     * off(element, 'mouseenter mouseleave', changeColor);
     * 
     * // Unbind multiple events with different handlers from an element at once.
     * // Use an object which of key is an event name and value is a handler function.
     * off(div, {
     *   keydown: highlight,
     *   keyup: dehighlight
     * });
     * 
     * // Unbind events without handlers.
     * off(div, 'drag');
     */
    function off(element, types, handler) {
      if (isString(types)) {
        forEach(types.split(/\s+/g), function(type) {
          unbindEvent(element, type, handler);
        });

        return;
      }

      forEach(types, function(func, type) {
        unbindEvent(element, type, func);
      });
    }

    /**
     * Unbind DOM events
     * If a handler function is not passed, remove all events of that type.
     * @param {HTMLElement} element - element to unbind events
     * @param {string} type - events name
     * @param {function} [handler] - handler function
     * @private
     */
    function unbindEvent(element, type, handler) {
      var events = safeEvent(element, type);
      var index;

      if (!handler) {
        forEach(events, function(item) {
          removeHandler(element, type, item.wrappedHandler);
        });
        events.splice(0, events.length);
      } else {
        forEach(events, function(item, idx) {
          if (handler === item.handler) {
            removeHandler(element, type, item.wrappedHandler);
            index = idx;

            return false;
          }

          return true;
        });
        events.splice(index, 1);
      }
    }

    /**
     * Remove an event handler
     * @param {HTMLElement} element - An element to remove an event
     * @param {string} type - event type
     * @param {function} handler - event handler
     * @private
     */
    function removeHandler(element, type, handler) {
      if ('removeEventListener' in element) {
        element.removeEventListener(type, handler);
      } else if ('detachEvent' in element) {
        element.detachEvent('on' + type, handler);
      }
    }

    module.exports = off;


    /***/ }),
    /* 34 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview The entry file of DatePicker components
     * @author NHN. FE Development Team
     */



    var DatePicker = __webpack_require__(21);
    var DateRangePicker = __webpack_require__(60);
    var Calendar = __webpack_require__(29);

    __webpack_require__(61);

    /**
     * Create a calendar.
     * @see {@link Calendar}
     * @see {@link /tutorial-example07-calendar Calendar example}
     * @static
     * @param {HTMLElement|string} wrapperElement - Container element or selector of the Calendar
     * @param {Object} [options] - {@link Calendar} options. Refer to the {@link Calendar Calendar instance's options}.
     * @returns {Calendar}
     * @example
     * const calendar = DatePicker.createCalendar('#calendar-wrapper', {
     *    language: 'en',
     *    showToday: true,
     *    showJumpButtons: false,
     *    date: new Date(),
     *    type: 'date'
     * });
     */
    DatePicker.createCalendar = function(wrapperElement, options) {
      return new Calendar(wrapperElement, options);
    };

    /**
     * Create a date-range picker.
     * @see {@link DateRangePicker}
     * @see {@link /tutorial-example08-daterangepicker DateRangePicker example}
     * @static
     * @param {object} options - {@link DateRangePicker} options. Refer to the {@link DateRangePicker DateRangePicker instance's options}.
     * @returns {DateRangePicker}
     * @example
     * const rangepicker = DatePicker.createRangePicker({
     *     startpicker: {
     *         input: '#start-input',
     *         container: '#start-container'
     *     },
     *     endpicker: {
     *         input: '#end-input',
     *         container: '#end-container'
     *     },
     *     type: 'date',
     *     format: 'yyyy-MM-dd'
     *     selectableRanges: [
     *         [new Date(2017, 3, 1), new Date(2017, 5, 1)],
     *         [new Date(2017, 6, 3), new Date(2017, 10, 5)]
     *     ]
     * });
     */
    DatePicker.createRangePicker = function(options) {
      return new DateRangePicker(options);
    };

    module.exports = DatePicker;


    /***/ }),
    /* 35 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Provide a simple inheritance in prototype-oriented.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var createObject = __webpack_require__(36);

    /**
     * Provide a simple inheritance in prototype-oriented.
     * Caution :
     *  Don't overwrite the prototype of child constructor.
     *
     * @param {function} subType Child constructor
     * @param {function} superType Parent constructor
     * @memberof module:inheritance
     * @example
     * var inherit = require('tui-code-snippet/inheritance/inherit'); // node, commonjs
     *
     * // Parent constructor
     * function Animal(leg) {
     *     this.leg = leg;
     * }
     * Animal.prototype.growl = function() {
     *     // ...
     * };
     *
     * // Child constructor
     * function Person(name) {
     *     this.name = name;
     * }
     *
     * // Inheritance
     * inherit(Person, Animal);
     *
     * // After this inheritance, please use only the extending of property.
     * // Do not overwrite prototype.
     * Person.prototype.walk = function(direction) {
     *     // ...
     * };
     */
    function inherit(subType, superType) {
      var prototype = createObject(superType.prototype);
      prototype.constructor = subType;
      subType.prototype = prototype;
    }

    module.exports = inherit;


    /***/ }),
    /* 36 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Create a new object with the specified prototype object and properties.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * @module inheritance
     */

    /**
     * Create a new object with the specified prototype object and properties.
     * @param {Object} obj This object will be a prototype of the newly-created object.
     * @returns {Object}
     * @memberof module:inheritance
     */
    function createObject(obj) {
      function F() {} // eslint-disable-line require-jsdoc
      F.prototype = obj;

      return new F();
    }

    module.exports = createObject;


    /***/ }),
    /* 37 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is existing or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var isUndefined = __webpack_require__(12);
    var isNull = __webpack_require__(38);

    /**
     * Check whether the given variable is existing or not.
     * If the given variable is not null and not undefined, returns true.
     * @param {*} param - Target for checking
     * @returns {boolean} Is existy?
     * @memberof module:type
     * @example
     * var isExisty = require('tui-code-snippet/type/isExisty'); // node, commonjs
     *
     * isExisty(''); //true
     * isExisty(0); //true
     * isExisty([]); //true
     * isExisty({}); //true
     * isExisty(null); //false
     * isExisty(undefined); //false
    */
    function isExisty(param) {
      return !isUndefined(param) && !isNull(param);
    }

    module.exports = isExisty;


    /***/ }),
    /* 38 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is null or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Check whether the given variable is null or not.
     * If the given variable(arguments[0]) is null, returns true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is null?
     * @memberof module:type
     */
    function isNull(obj) {
      return obj === null;
    }

    module.exports = isNull;


    /***/ }),
    /* 39 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is a function or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Check whether the given variable is a function or not.
     * If the given variable is a function, return true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is function?
     * @memberof module:type
     */
    function isFunction(obj) {
      return obj instanceof Function;
    }

    module.exports = isFunction;


    /***/ }),
    /* 40 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check element match selector
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var inArray = __webpack_require__(3);
    var toArray = __webpack_require__(41);

    var elProto = Element.prototype;
    var matchSelector = elProto.matches ||
        elProto.webkitMatchesSelector ||
        elProto.mozMatchesSelector ||
        elProto.msMatchesSelector ||
        function(selector) {
          var doc = this.document || this.ownerDocument;

          return inArray(this, toArray(doc.querySelectorAll(selector))) > -1;
        };

    /**
     * Check element match selector
     * @param {HTMLElement} element - element to check
     * @param {string} selector - selector to check
     * @returns {boolean} is selector matched to element?
     * @memberof module:domUtil
     */
    function matches(element, selector) {
      return matchSelector.call(element, selector);
    }

    module.exports = matches;


    /***/ }),
    /* 41 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Transform the Array-like object to Array.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var forEachArray = __webpack_require__(2);

    /**
     * Transform the Array-like object to Array.
     * In low IE (below 8), Array.prototype.slice.call is not perfect. So, try-catch statement is used.
     * @param {*} arrayLike Array-like object
     * @returns {Array} Array
     * @memberof module:collection
     * @example
     * var toArray = require('tui-code-snippet/collection/toArray'); // node, commonjs
     *
     * var arrayLike = {
     *     0: 'one',
     *     1: 'two',
     *     2: 'three',
     *     3: 'four',
     *     length: 4
     * };
     * var result = toArray(arrayLike);
     *
     * alert(result instanceof Array); // true
     * alert(result); // one,two,three,four
     */
    function toArray(arrayLike) {
      var arr;
      try {
        arr = Array.prototype.slice.call(arrayLike);
      } catch (e) {
        arr = [];
        forEachArray(arrayLike, function(value) {
          arr.push(value);
        });
      }

      return arr;
    }

    module.exports = toArray;


    /***/ }),
    /* 42 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Convert kebab-case
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Convert kebab-case
     * @param {string} key - string to be converted to Kebab-case
     * @private
     */
    function convertToKebabCase(key) {
      return key.replace(/([A-Z])/g, function(match) {
        return '-' + match.toLowerCase();
      });
    }

    module.exports = convertToKebabCase;


    /***/ }),
    /* 43 */
    /***/ (function(module, exports) {

    module.exports = __WEBPACK_EXTERNAL_MODULE__43__;

    /***/ }),
    /* 44 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Calendar Header
     * @author NHN. FE dev Lab <dl_javascript@nhn.com>
     */



    var defineClass = __webpack_require__(0);
    var CustomEvents = __webpack_require__(8);
    var closest = __webpack_require__(25);
    var removeElement = __webpack_require__(14);

    var localeTexts = __webpack_require__(10);
    var headerTmpl = __webpack_require__(45);
    var DateTimeFormatter = __webpack_require__(30);
    var constants = __webpack_require__(1);
    var util = __webpack_require__(4);
    var mouseTouchEvent = __webpack_require__(19);

    var TYPE_DATE = constants.TYPE_DATE;
    var TYPE_MONTH = constants.TYPE_MONTH;
    var TYPE_YEAR = constants.TYPE_YEAR;

    var CLASS_NAME_TITLE_MONTH = 'tui-calendar-title-month';
    var CLASS_NAME_TITLE_YEAR = 'tui-calendar-title-year';
    var CLASS_NAME_TITLE_YEAR_TO_YEAR = 'tui-calendar-title-year-to-year';

    var SELECTOR_INNER_ELEM = '.tui-calendar-header-inner';
    var SELECTOR_INFO_ELEM = '.tui-calendar-header-info';
    var SELECTOR_BTN = '.tui-calendar-btn';

    var TODAY_TITLE_ELEM = '.tui-calendar-title-today';

    var YEAR_TITLE_FORMAT = 'yyyy';

    /**
     * @ignore
     * @class
     * @param {string|HTMLElement} container - Header container or selector
     * @param {object} option - Header option
     * @param {string} option.language - Header language
     * @param {boolean} option.showToday - Has today box or not.
     * @param {boolean} option.showJumpButtons - Has jump buttons or not.
     */
    var Header = defineClass(
      /** @lends Header.prototype */ {
        init: function(container, option) {
          /**
           * Container element
           * @type {HTMLElement}
           * @private
           */
          this._container = util.getElement(container);

          /**
           * Header inner element
           * @type {HTMLElement}
           * @private
           */
          this._innerElement = null;

          /**
           * Header info element
           * @type {HTMLElement}
           * @private
           */
          this._infoElement = null;

          /**
           * Render today box or not
           * @type {boolean}
           * @private
           */
          this._showToday = option.showToday;

          /**
           * Render jump buttons or not (next,prev year on date calendar)
           * @type {boolean}
           * @private
           */
          this._showJumpButtons = option.showJumpButtons;

          /**
           * Year_Month title formatter
           * @type {DateTimeFormatter}
           * @private
           */
          this._yearMonthTitleFormatter = null;

          /**
           * Year title formatter
           * @type {DateTimeFormatter}
           * @private
           */
          this._yearTitleFormatter = null;

          /**
           * Today formatter
           * @type {DateTimeFormatter}
           * @private
           */
          this._todayFormatter = null;

          this._setFormatters(localeTexts[option.language]);
          this._setEvents(option);
        },

        /**
         * @param {object} localeText - Locale text
         * @private
         */
        _setFormatters: function(localeText) {
          this._yearMonthTitleFormatter = new DateTimeFormatter(
            localeText.titleFormat,
            localeText.titles
          );
          this._yearTitleFormatter = new DateTimeFormatter(YEAR_TITLE_FORMAT, localeText.titles);
          this._todayFormatter = new DateTimeFormatter(localeText.todayFormat, localeText.titles);
        },

        /**
         * @param {object} option - Constructor option
         * @private
         */
        _setEvents: function() {
          mouseTouchEvent.on(this._container, 'click', this._onClickHandler, this);
        },

        /**
         * @private
         */
        _removeEvents: function() {
          this.off();
          mouseTouchEvent.off(this._container, 'click', this._onClickHandler);
        },

        /**
         * Fire customEvents
         * @param {Event} ev An event object
         * @private
         */
        _onClickHandler: function(ev) {
          var target = util.getTarget(ev);

          if (closest(target, SELECTOR_BTN)) {
            this.fire('click', ev);
          } else if (closest(target, TODAY_TITLE_ELEM)) {
            this.fire('today');
          }
        },

        /**
         * @param {string} type - Calendar type
         * @returns {string}
         * @private
         */
        _getTitleClass: function(type) {
          switch (type) {
            case TYPE_DATE:
              return CLASS_NAME_TITLE_MONTH;
            case TYPE_MONTH:
              return CLASS_NAME_TITLE_YEAR;
            case TYPE_YEAR:
              return CLASS_NAME_TITLE_YEAR_TO_YEAR;
            default:
              return '';
          }
        },

        /**
         * @param {Date} date - date
         * @param {string} type - Calendar type
         * @returns {string}
         * @private
         */
        _getTitleText: function(date, type) {
          var currentYear, start, end;

          switch (type) {
            case TYPE_DATE:
              return this._yearMonthTitleFormatter.format(date);
            case TYPE_MONTH:
              return this._yearTitleFormatter.format(date);
            case TYPE_YEAR:
              currentYear = date.getFullYear();
              start = new Date(currentYear - 4, 0, 1);
              end = new Date(currentYear + 4, 0, 1);

              return (
                this._yearTitleFormatter.format(start) + ' - ' + this._yearTitleFormatter.format(end)
              );
            default:
              return '';
          }
        },

        /**
         * Change langauge
         * @param {string} language - Language
         */
        changeLanguage: function(language) {
          this._setFormatters(localeTexts[language]);
        },

        /**
         * Render header
         * @param {Date} date - date
         * @param {string} type - Calendar type
         */
        render: function(date, type) {
          var context = {
            showToday: this._showToday,
            showJumpButtons: this._showJumpButtons,
            todayText: this._todayFormatter.format(new Date()),
            isDateCalendar: type === TYPE_DATE,
            titleClass: this._getTitleClass(type),
            title: this._getTitleText(date, type)
          };

          this._container.innerHTML = headerTmpl(context).replace(/^\s+|\s+$/g, '');
          this._innerElement = this._container.querySelector(SELECTOR_INNER_ELEM);
          if (context.showToday) {
            this._infoElement = this._container.querySelector(SELECTOR_INFO_ELEM);
          }
        },

        /**
         * Destroy header
         */
        destroy: function() {
          this._removeEvents();
          removeElement(this._innerElement);
          removeElement(this._infoElement);
          this._container = this._showToday = this._showJumpButtons = this._yearMonthTitleFormatter = this._yearTitleFormatter = this._todayFormatter = this._innerElement = this._infoElement = null;
        }
      }
    );

    CustomEvents.mixin(Header);
    module.exports = Header;


    /***/ }),
    /* 45 */
    /***/ (function(module, exports, __webpack_require__) {


    var template = __webpack_require__(11);

    module.exports = function(context) {
      var source =
        '{{if isDateCalendar}}' +
        '  {{if showJumpButtons}}' +
        '    <div class="tui-calendar-header-inner tui-calendar-has-btns">' +
        '      <button class="tui-calendar-btn tui-calendar-btn-prev-year">Prev year</button>' +
        '      <button class="tui-calendar-btn tui-calendar-btn-prev-month">Prev month</button>' +
        '      <em class="tui-calendar-title {{titleClass}}">{{title}}</em>' +
        '      <button class="tui-calendar-btn tui-calendar-btn-next-month">Next month</button>' +
        '      <button class="tui-calendar-btn tui-calendar-btn-next-year">Next year</button>' +
        '    </div>' +
        '  {{else}}' +
        '    <div class="tui-calendar-header-inner">' +
        '      <button class="tui-calendar-btn tui-calendar-btn-prev-month">Prev month</button>' +
        '      <em class="tui-calendar-title {{titleClass}}">{{title}}</em>' +
        '      <button class="tui-calendar-btn tui-calendar-btn-next-month">Next month</button>' +
        '    </div>' +
        '  {{/if}}' +
        '{{else}}' +
        '  <div class="tui-calendar-header-inner">' +
        '    <button class="tui-calendar-btn tui-calendar-btn-prev-year">Prev year</button>' +
        '    <em class="tui-calendar-title {{titleClass}}">{{title}}</em>' +
        '    <button class="tui-calendar-btn tui-calendar-btn-next-year">Next year</button>' +
        '  </div>' +
        '{{/if}}' +
        '{{if showToday}}' +
        '  <div class="tui-calendar-header-info">' +
        '    <p class="tui-calendar-title-today">{{todayText}}</p>' +
        '  </div>' +
        '{{/if}}';

      return template(source, context);
    };


    /***/ }),
    /* 46 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is a instance of HTMLNode or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Check whether the given variable is a instance of HTMLNode or not.
     * If the given variables is a instance of HTMLNode, return true.
     * @param {*} html - Target for checking
     * @returns {boolean} Is HTMLNode ?
     * @memberof module:type
     */
    function isHTMLNode(html) {
      if (typeof HTMLElement === 'object') {
        return (html && (html instanceof HTMLElement || !!html.nodeType));
      }

      return !!(html && html.nodeType);
    }

    module.exports = isHTMLNode;


    /***/ }),
    /* 47 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Send hostname on DOMContentLoaded.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var isUndefined = __webpack_require__(12);
    var imagePing = __webpack_require__(48);

    var ms7days = 7 * 24 * 60 * 60 * 1000;

    /**
     * Check if the date has passed 7 days
     * @param {number} date - milliseconds
     * @returns {boolean}
     * @private
     */
    function isExpired(date) {
      var now = new Date().getTime();

      return now - date > ms7days;
    }

    /**
     * Send hostname on DOMContentLoaded.
     * To prevent hostname set tui.usageStatistics to false.
     * @param {string} appName - application name
     * @param {string} trackingId - GA tracking ID
     * @ignore
     */
    function sendHostname(appName, trackingId) {
      var url = 'https://www.google-analytics.com/collect';
      var hostname = location.hostname;
      var hitType = 'event';
      var eventCategory = 'use';
      var applicationKeyForStorage = 'TOAST UI ' + appName + ' for ' + hostname + ': Statistics';
      var date = window.localStorage.getItem(applicationKeyForStorage);

      // skip if the flag is defined and is set to false explicitly
      if (!isUndefined(window.tui) && window.tui.usageStatistics === false) {
        return;
      }

      // skip if not pass seven days old
      if (date && !isExpired(date)) {
        return;
      }

      window.localStorage.setItem(applicationKeyForStorage, new Date().getTime());

      setTimeout(function() {
        if (document.readyState === 'interactive' || document.readyState === 'complete') {
          imagePing(url, {
            v: 1,
            t: hitType,
            tid: trackingId,
            cid: hostname,
            dp: hostname,
            dh: appName,
            el: appName,
            ec: eventCategory
          });
        }
      }, 1000);
    }

    module.exports = sendHostname;


    /***/ }),
    /* 48 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Request image ping.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var forEachOwnProperties = __webpack_require__(23);

    /**
     * @module request
     */

    /**
     * Request image ping.
     * @param {String} url url for ping request
     * @param {Object} trackingInfo infos for make query string
     * @returns {HTMLElement}
     * @memberof module:request
     * @example
     * var imagePing = require('tui-code-snippet/request/imagePing'); // node, commonjs
     *
     * imagePing('https://www.google-analytics.com/collect', {
     *     v: 1,
     *     t: 'event',
     *     tid: 'trackingid',
     *     cid: 'cid',
     *     dp: 'dp',
     *     dh: 'dh'
     * });
     */
    function imagePing(url, trackingInfo) {
      var trackingElement = document.createElement('img');
      var queryString = '';
      forEachOwnProperties(trackingInfo, function(value, key) {
        queryString += '&' + key + '=' + value;
      });
      queryString = queryString.substring(1);

      trackingElement.src = url + '?' + queryString;

      trackingElement.style.display = 'none';
      document.body.appendChild(trackingElement);
      document.body.removeChild(trackingElement);

      return trackingElement;
    }

    module.exports = imagePing;


    /***/ }),
    /* 49 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Calendar body
     * @author NHN. FE Development Lab <dl_javascript@nhn.com>
     */



    var forEachArray = __webpack_require__(2);
    var defineClass = __webpack_require__(0);

    var DateLayer = __webpack_require__(50);
    var MonthLayer = __webpack_require__(52);
    var YearLayer = __webpack_require__(54);
    var constants = __webpack_require__(1);

    var TYPE_DATE = constants.TYPE_DATE;
    var TYPE_MONTH = constants.TYPE_MONTH;
    var TYPE_YEAR = constants.TYPE_YEAR;

    /**
     * @ignore
     * @class
     */
    var Body = defineClass(
      /** @lends Body.prototype */ {
        init: function(bodyContainer, options) {
          var language = options.language;
          var weekStartDay = options.weekStartDay;

          /**
           * Body container element
           * @type {HTMLElement}
           * @private
           */
          this._container = bodyContainer;

          /**
           * DateLayer
           * @type {DateLayer}
           * @private
           */
          this._dateLayer = new DateLayer(language, weekStartDay);

          /**
           * MonthLayer
           * @type {MonthLayer}
           * @private
           */
          this._monthLayer = new MonthLayer(language);

          /**
           * YearLayer
           * @type {YearLayer}
           * @private
           */
          this._yearLayer = new YearLayer(language);

          /**
           * Current Layer
           * @type {DateLayer|MonthLayer|YearLayer}
           * @private
           */
          this._currentLayer = this._dateLayer;
        },

        /**
         * Returns matched layer
         * @param {string} type - Layer type
         * @returns {Base} - Layer
         * @private
         */
        _getLayer: function(type) {
          switch (type) {
            case TYPE_DATE:
              return this._dateLayer;
            case TYPE_MONTH:
              return this._monthLayer;
            case TYPE_YEAR:
              return this._yearLayer;
            default:
              return this._currentLayer;
          }
        },

        /**
         * Iterate each layer
         * @param {Function} fn - function
         * @private
         */
        _eachLayer: function(fn) {
          forEachArray([this._dateLayer, this._monthLayer, this._yearLayer], fn);
        },

        /**
         * Change language
         * @param {string} language - Language
         */
        changeLanguage: function(language) {
          this._eachLayer(function(layer) {
            layer.changeLanguage(language);
          });
        },

        /**
         * Render body
         * @param {Date} date - date
         * @param {string} type - Layer type
         */
        render: function(date, type) {
          var nextLayer = this._getLayer(type);
          var prevLayer = this._currentLayer;

          prevLayer.remove();
          nextLayer.render(date, this._container);

          this._currentLayer = nextLayer;
        },

        /**
         * Returns date elements
         * @returns {HTMLElement[]}
         */
        getDateElements: function() {
          return this._currentLayer.getDateElements();
        },

        /**
         * Destory
         */
        destroy: function() {
          this._eachLayer(function(layer) {
            layer.remove();
          });

          this._container = this._currentLayer = this._dateLayer = this._monthLayer = this._yearLayer = null;
        }
      }
    );

    module.exports = Body;


    /***/ }),
    /* 50 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Date layer
     * @author NHN. FE Development Lab <dl_javascript@nhn.com>
     */



    var defineClass = __webpack_require__(0);

    var dateUtil = __webpack_require__(5);
    var bodyTmpl = __webpack_require__(51);
    var LayerBase = __webpack_require__(20);
    var TYPE_DATE = __webpack_require__(1).TYPE_DATE;
    var WEEK_START_DAY_MAP = __webpack_require__(1).WEEK_START_DAY_MAP;

    var DATE_SELECTOR = '.tui-calendar-date';
    var DAYS_OF_WEEK = 7;

    /**
     * @ignore
     * @class
     * @extends LayerBase
     * @param {string} language - Initial language
     */
    var DateLayer = defineClass(
      LayerBase,
      /** @lends DateLayer.prototype */ {
        init: function(language, weekStartDay) {
          LayerBase.call(this, language);

          this.weekStartDay = WEEK_START_DAY_MAP[String(weekStartDay).toLowerCase()] || 0;
        },

        /**
         * Layer type
         * @type {string}
         * @private
         */
        _type: TYPE_DATE,

        /**
         * @override
         * @private
         * @returns {object} Template context
         */
        _makeContext: function(date) {
          var daysShort = this._localeText.titles.D;
          var year, month, days, i;

          date = date || new Date();
          year = date.getFullYear();
          month = date.getMonth() + 1;

          if (this.weekStartDay) {
            days = daysShort.slice();
            for (i = 0; i < this.weekStartDay; i += 1) {
              days.push(days.shift());
            }
            daysShort = days;
          }

          return {
            Sun: daysShort[0],
            Mon: daysShort[1],
            Tue: daysShort[2],
            Wed: daysShort[3],
            Thu: daysShort[4],
            Fri: daysShort[5],
            Sat: daysShort[6],
            year: year,
            month: month,
            weeks: this._getWeeks(year, month)
          };
        },

        /**
         * weeks (templating) for date-calendar
         * @param {number} year - Year
         * @param {number} month - Month
         * @returns {Array.<Array.<Date>>}
         * @private
         */
        _getWeeks: function(year, month) {
          var weekNumber = 0;
          var weeksCount = 6; // Fix for no changing height
          var weeks = [];
          var week, dates, i;

          while (weekNumber < weeksCount) {
            dates = [];

            for (i = this.weekStartDay; i < DAYS_OF_WEEK + this.weekStartDay; i += 1) {
              dates.push(dateUtil.getDateOfWeek(year, month, weekNumber, i));
            }

            week = this._getWeek(year, month, dates);

            if (this.weekStartDay && !_isFirstWeek(weekNumber, week[0].dayInMonth)) {
              weeks.push(this._getFirstWeek(year, month));
              weeksCount -= 1; // Fix for no changing height
            }

            weeks.push(week);
            weekNumber += 1;
          }

          return weeks;
        },

        /**
         * week (templating) for date-calendar
         * @param {number} currentYear
         * @param {number} currentMonth
         * @param {Array.<Date>} dates
         * @private
         */
        _getWeek: function(currentYear, currentMonth, dates) {
          var firstDateOfCurrentMonth = new Date(currentYear, currentMonth - 1, 1);
          var lastDateOfCurrentMonth = new Date(currentYear, currentMonth, 0);
          var contexts = [];
          var i = 0;
          var length = dates.length;
          var date, className;

          for (; i < length; i += 1) {
            className = 'tui-calendar-date';
            date = dates[i];

            if (date < firstDateOfCurrentMonth) {
              className += ' tui-calendar-prev-month';
            }

            if (date > lastDateOfCurrentMonth) {
              className += ' tui-calendar-next-month';
            }

            if (date.getDay() === 0) {
              className += ' tui-calendar-sun';
            } else if (date.getDay() === 6) {
              className += ' tui-calendar-sat';
            }

            contexts.push({
              dayInMonth: date.getDate(),
              className: className,
              timestamp: date.getTime()
            });
          }

          return contexts;
        },

        /**
         * Render date-layer
         * @override
         * @param {Date} date Date to render
         * @param {HTMLElement} container A container element for the rendered element
         */
        render: function(date, container) {
          var context = this._makeContext(date);

          container.innerHTML = bodyTmpl(context);
          this._element = container.firstChild;
        },

        /**
         * Return date elements
         * @override
         * @returns {HTMLElement[]}
         */
        getDateElements: function() {
          return this._element.querySelectorAll(DATE_SELECTOR);
        },

        _getFirstWeek: function(year, month) {
          var firstWeekDates = [];
          var i;

          for (i = this.weekStartDay; i < DAYS_OF_WEEK + this.weekStartDay; i += 1) {
            firstWeekDates.push(dateUtil.getDateOfWeek(year, month, -1, i));
          }

          return this._getWeek(year, month, firstWeekDates);
        }
      }
    );

    function _isFirstWeek(weekIndex, dayInMonth) {
      return weekIndex || dayInMonth === 1 || dayInMonth > DAYS_OF_WEEK;
    }

    module.exports = DateLayer;


    /***/ }),
    /* 51 */
    /***/ (function(module, exports, __webpack_require__) {


    var template = __webpack_require__(11);

    module.exports = function(context) {
      var source =
        '<table class="tui-calendar-body-inner" cellspacing="0" cellpadding="0">' +
        '  <caption><span>Dates</span></caption>' +
        '  <thead class="tui-calendar-body-header">' +
        '    <tr>' +
        '      <th class="tui-sun" scope="col">{{Sun}}</th>' +
        '      <th scope="col">{{Mon}}</th>' +
        '      <th scope="col">{{Tue}}</th>' +
        '      <th scope="col">{{Wed}}</th>' +
        '      <th scope="col">{{Thu}}</th>' +
        '      <th scope="col">{{Fri}}</th>' +
        '      <th class="tui-sat" scope="col">{{Sat}}</th>' +
        '    </tr>' +
        '  </thead>' +
        '  <tbody>' +
        '    {{each weeks}}' +
        '    <tr class="tui-calendar-week">' +
        '      {{each @this}}' +
        '      <td class="{{@this["className"]}}" data-timestamp="{{@this["timestamp"]}}">{{@this["dayInMonth"]}}</td>' +
        '      {{/each}}' +
        '    </tr>' +
        '    {{/each}}' +
        '  </tbody>' +
        '</table>';

      return template(source, context);
    };


    /***/ }),
    /* 52 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Month layer
     * @author NHN. FE Development Lab <dl_javascript@nhn.com>
     */



    var defineClass = __webpack_require__(0);

    var bodyTmpl = __webpack_require__(53);
    var LayerBase = __webpack_require__(20);
    var TYPE_MONTH = __webpack_require__(1).TYPE_MONTH;
    var dateUtil = __webpack_require__(5);

    var DATE_SELECTOR = '.tui-calendar-month';

    /**
     * @class
     * @extends LayerBase
     * @param {string} language - Initial language
     * @ignore
     */
    var MonthLayer = defineClass(
      LayerBase,
      /** @lends MonthLayer.prototype */ {
        init: function(language) {
          LayerBase.call(this, language);
        },

        /**
         * Layer type
         * @type {string}
         * @private
         */
        _type: TYPE_MONTH,

        /**
         * @override
         * @returns {object} Template context
         * @private
         */
        _makeContext: function(date) {
          var monthsShort = this._localeText.titles.MMM;

          return {
            year: date.getFullYear(),
            Jan: monthsShort[0],
            Feb: monthsShort[1],
            Mar: monthsShort[2],
            Apr: monthsShort[3],
            May: monthsShort[4],
            Jun: monthsShort[5],
            Jul: monthsShort[6],
            Aug: monthsShort[7],
            Sep: monthsShort[8],
            Oct: monthsShort[9],
            Nov: monthsShort[10],
            Dec: monthsShort[11],
            getFirstDayTimestamp: dateUtil.getFirstDayTimestamp
          };
        },

        /**
         * Render month-layer element
         * @override
         * @param {Date} date Date to render
         * @param {HTMLElement} container A container element for the rendered element
         */
        render: function(date, container) {
          var context = this._makeContext(date);

          container.innerHTML = bodyTmpl(context);
          this._element = container.firstChild;
        },

        /**
         * Returns month elements
         * @override
         * @returns {HTMLElement[]}
         */
        getDateElements: function() {
          return this._element.querySelectorAll(DATE_SELECTOR);
        }
      }
    );

    module.exports = MonthLayer;


    /***/ }),
    /* 53 */
    /***/ (function(module, exports, __webpack_require__) {


    var template = __webpack_require__(11);

    module.exports = function(context) {
      var source =
        '<table class="tui-calendar-body-inner">' +
        '  <caption><span>Months</span></caption>' +
        '  <tbody>' +
        '    <tr class="tui-calendar-month-group">' +
        '      <td class="tui-calendar-month" data-timestamp={{getFirstDayTimestamp year 0}}>{{Jan}}</td>' +
        '      <td class="tui-calendar-month" data-timestamp={{getFirstDayTimestamp year 1}}>{{Feb}}</td>' +
        '      <td class="tui-calendar-month" data-timestamp={{getFirstDayTimestamp year 2}}>{{Mar}}</td>' +
        '      <td class="tui-calendar-month" data-timestamp={{getFirstDayTimestamp year 3}}>{{Apr}}</td>' +
        '    </tr>' +
        '    <tr class="tui-calendar-month-group">' +
        '      <td class="tui-calendar-month" data-timestamp={{getFirstDayTimestamp year 4}}>{{May}}</td>' +
        '      <td class="tui-calendar-month" data-timestamp={{getFirstDayTimestamp year 5}}>{{Jun}}</td>' +
        '      <td class="tui-calendar-month" data-timestamp={{getFirstDayTimestamp year 6}}>{{Jul}}</td>' +
        '      <td class="tui-calendar-month" data-timestamp={{getFirstDayTimestamp year 7}}>{{Aug}}</td>' +
        '    </tr>' +
        '    <tr class="tui-calendar-month-group">' +
        '      <td class="tui-calendar-month" data-timestamp={{getFirstDayTimestamp year 8}}>{{Sep}}</td>' +
        '      <td class="tui-calendar-month" data-timestamp={{getFirstDayTimestamp year 9}}>{{Oct}}</td>' +
        '      <td class="tui-calendar-month" data-timestamp={{getFirstDayTimestamp year 10}}>{{Nov}}</td>' +
        '      <td class="tui-calendar-month" data-timestamp={{getFirstDayTimestamp year 11}}>{{Dec}}</td>' +
        '    </tr>' +
        '  </tbody>' +
        '</table>';

      return template(source, context);
    };


    /***/ }),
    /* 54 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Year layer
     * @author NHN. FE Development Lab <dl_javascript@nhn.com>
     */



    var defineClass = __webpack_require__(0);

    var bodyTmpl = __webpack_require__(55);
    var LayerBase = __webpack_require__(20);
    var TYPE_YEAR = __webpack_require__(1).TYPE_YEAR;
    var dateUtil = __webpack_require__(5);

    var DATE_SELECTOR = '.tui-calendar-year';

    /**
     * @class
     * @extends LayerBase
     * @param {string} language - Initial language
     * @ignore
     */
    var YearLayer = defineClass(
      LayerBase,
      /** @lends YearLayer.prototype */ {
        init: function(language) {
          LayerBase.call(this, language);
        },

        /**
         * Layer type
         * @type {string}
         * @private
         */
        _type: TYPE_YEAR,

        /**
         * @override
         * @returns {object} Template context
         * @private
         */
        _makeContext: function(date) {
          var year = date.getFullYear();

          return {
            yearGroups: [
              dateUtil.getRangeArr(year - 4, year - 2),
              dateUtil.getRangeArr(year - 1, year + 1),
              dateUtil.getRangeArr(year + 2, year + 4)
            ],
            getFirstDayTimestamp: dateUtil.getFirstDayTimestamp
          };
        },

        /**
         * Render year-layer element
         * @override
         * @param {Date} date Date to render
         * @param {HTMLElement} container A container element for the rendered element
         */
        render: function(date, container) {
          var context = this._makeContext(date);

          container.innerHTML = bodyTmpl(context);
          this._element = container.firstChild;
        },

        /**
         * Returns year elements
         * @override
         * @returns {HTMLElement[]}
         */
        getDateElements: function() {
          return this._element.querySelectorAll(DATE_SELECTOR);
        }
      }
    );

    module.exports = YearLayer;


    /***/ }),
    /* 55 */
    /***/ (function(module, exports, __webpack_require__) {


    var template = __webpack_require__(11);

    module.exports = function(context) {
      var source =
        '<table class="tui-calendar-body-inner">' +
        '  <caption><span>Years</span></caption>' +
        '  <tbody>' +
        '    {{each yearGroups}}' +
        '    <tr class="tui-calendar-year-group">' +
        '      {{each @this}}' +
        '      <td class="tui-calendar-year" data-timestamp={{getFirstDayTimestamp @this 0}}>' +
        '        {{@this}}' +
        '      </td>' +
        '      {{/each}}' +
        '    </tr>' +
        '    {{/each}}' +
        '  </tbody>' +
        '</table>';

      return template(source, context);
    };


    /***/ }),
    /* 56 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview RangeModel
     * @author NHN. FE Development Lab <dl_javascript@nhn.com>
     */



    var forEachArray = __webpack_require__(2);
    var defineClass = __webpack_require__(0);
    var isNumber = __webpack_require__(15);

    var Range = __webpack_require__(57);
    var util = __webpack_require__(4);

    /**
     * @class
     * @ignore
     * @param {Array.<Array.<number>>} ranges - Ranges
     */
    var RangeModel = defineClass(
      /** @lends RangeModel.prototype */ {
        init: function(ranges) {
          ranges = ranges || [];

          /**
           * @type {Array.<Range>}
           * @private
           */
          this._ranges = [];

          forEachArray(
            ranges,
            function(range) {
              this.add(range[0], range[1]);
            },
            this
          );
        },

        /**
         * Whether the ranges contain a time or time-range
         * @param {number} start - Start
         * @param {number} [end] - End
         * @returns {boolean}
         */
        contains: function(start, end) {
          var i = 0;
          var length = this._ranges.length;
          var range;

          for (; i < length; i += 1) {
            range = this._ranges[i];
            if (range.contains(start, end)) {
              return true;
            }
          }

          return false;
        },

        /**
         * Whether overlaps with a point or range
         * @param {number} start - Start
         * @param {number} [end] - End
         * @returns {boolean}
         */
        hasOverlap: function(start, end) {
          var i = 0;
          var length = this._ranges.length;
          var range;

          for (; i < length; i += 1) {
            range = this._ranges[i];
            if (range.isOverlapped(start, end)) {
              return true;
            }
          }

          return false;
        },

        /**
         * Add range
         * @param {number} start - Start
         * @param {number} [end] - End
         */
        add: function(start, end) {
          var overlapped = false;
          var i = 0;
          var len = this._ranges.length;
          var range;

          for (; i < len; i += 1) {
            range = this._ranges[i];
            overlapped = range.isOverlapped(start, end);

            if (overlapped) {
              range.merge(start, end);
              break;
            }

            if (start < range.start) {
              break;
            }
          }

          if (!overlapped) {
            this._ranges.splice(i, 0, new Range(start, end));
          }
        },

        /**
         * Returns minimum value in ranges
         * @returns {number}
         */
        getMinimumValue: function() {
          return this._ranges[0].start;
        },

        /**
         * Returns maximum value in ranges
         * @returns {number}
         */
        getMaximumValue: function() {
          var length = this._ranges.length;

          return this._ranges[length - 1].end;
        },

        /**
         * @param {number} start - Start
         * @param {number} [end] - End
         */
        exclude: function(start, end) {
          if (!isNumber(end)) {
            end = start;
          }

          forEachArray(
            this._ranges,
            function(range) {
              var rangeEnd;

              if (range.isOverlapped(start, end)) {
                rangeEnd = range.end; // Save before excluding
                range.exclude(start, end);

                if (end + 1 <= rangeEnd) {
                  this.add(end + 1, rangeEnd); // Add split range
                }
              }
            },
            this
          );

          // Reduce empty ranges
          this._ranges = util.filter(this._ranges, function(range) {
            return !range.isEmpty();
          });
        },

        /**
         * Returns the first overlapped range from the point or range
         * @param {number} start - Start
         * @param {number} end - End
         * @returns {Array.<number>} - [start, end]
         */
        findOverlappedRange: function(start, end) {
          var i = 0;
          var len = this._ranges.length;
          var range;

          for (; i < len; i += 1) {
            range = this._ranges[i];
            if (range.isOverlapped(start, end)) {
              return [range.start, range.end];
            }
          }

          return null;
        }
      }
    );

    module.exports = RangeModel;


    /***/ }),
    /* 57 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Range (in RangeModel)
     * @author NHN. FE Development Lab <dl_javascript@nhn.com>
     */



    var defineClass = __webpack_require__(0);
    var isNumber = __webpack_require__(15);

    /**
     * @class
     * @ignore
     * @param {number} start - Start of range
     * @param {number} [end] - End of range
     */
    var Range = defineClass(
      /** @lends Range.prototype */ {
        init: function(start, end) {
          this.setRange(start, end);
        },

        /**
         * Set range
         * @param {number} start - Start number
         * @param {number} [end] - End number
         */
        setRange: function(start, end) {
          if (!isNumber(end)) {
            end = start;
          }

          this.start = Math.min(start, end);
          this.end = Math.max(start, end);
        },

        /**
         * Merge range
         * @param {number} start - Start
         * @param {number} [end] - End
         */
        merge: function(start, end) {
          if (!isNumber(start) || !isNumber(end) || !this.isOverlapped(start, end)) {
            return;
          }

          this.start = Math.min(start, this.start);
          this.end = Math.max(end, this.end);
        },

        /**
         * Whether being empty.
         * @returns {boolean}
         */
        isEmpty: function() {
          return !isNumber(this.start) || !isNumber(this.end);
        },

        /**
         * Set empty
         */
        setEmpty: function() {
          this.start = this.end = null;
        },

        /**
         * Whether containing a range.
         * @param {number} start - Start
         * @param {number} [end] - End
         * @returns {boolean}
         */
        contains: function(start, end) {
          if (!isNumber(end)) {
            end = start;
          }

          return this.start <= start && end <= this.end;
        },

        /**
         * Whether overlaps with a range
         * @param {number} start - Start
         * @param {number} [end] - End
         * @returns {boolean}
         */
        isOverlapped: function(start, end) {
          if (!isNumber(end)) {
            end = start;
          }

          return this.start <= end && this.end >= start;
        },

        /**
         * Exclude a range
         * @param {number} start - Start
         * @param {number} end - End
         */
        exclude: function(start, end) {
          if (start <= this.start && end >= this.end) {
            // Excluding range contains this
            this.setEmpty();
          } else if (this.contains(start)) {
            this.setRange(this.start, start - 1);
          } else if (this.contains(end)) {
            this.setRange(end + 1, this.end);
          }
        }
      }
    );

    module.exports = Range;


    /***/ }),
    /* 58 */
    /***/ (function(module, exports, __webpack_require__) {


    var template = __webpack_require__(11);

    module.exports = function(context) {
      var source =
        '<div class="tui-datepicker">' +
        '  {{if timePicker}}' +
        '    {{if isTab}}' +
        '      <div class="tui-datepicker-selector">' +
        '        <button type="button" class="tui-datepicker-selector-button tui-is-checked" aria-label="selected">' +
        '          <span class="tui-ico-date"></span>{{localeText["date"]}}' +
        '        </button>' +
        '        <button type="button" class="tui-datepicker-selector-button">' +
        '          <span class="tui-ico-time"></span>{{localeText["time"]}}' +
        '        </button>' +
        '      </div>' +
        '      <div class="tui-datepicker-body">' +
        '        <div class="tui-calendar-container"></div>' +
        '        <div class="tui-timepicker-container"></div>' +
        '      </div>' +
        '    {{else}}' +
        '      <div class="tui-datepicker-body">' +
        '        <div class="tui-calendar-container"></div>' +
        '      </div>' +
        '      <div class="tui-datepicker-footer">' +
        '        <div class="tui-timepicker-container"></div>' +
        '      </div>' +
        '    {{/if}}' +
        '  {{else}}' +
        '    <div class="tui-datepicker-body">' +
        '      <div class="tui-calendar-container"></div>' +
        '    </div>' +
        '  {{/if}}' +
        '</div>';

      return template(source, context);
    };


    /***/ }),
    /* 59 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview DatePicker input(element) component
     * @author NHN. FE Development Lab <dl_javascript@nhn.com>
     */



    var defineClass = __webpack_require__(0);
    var CustomEvents = __webpack_require__(8);
    var on = __webpack_require__(31);
    var off = __webpack_require__(33);

    var DateTimeFormatter = __webpack_require__(30);
    var mouseTouchEvent = __webpack_require__(19);
    var util = __webpack_require__(4);

    var DEFAULT_FORMAT = 'yyyy-MM-dd';

    /**
     * DatePicker Input
     * @ignore
     * @class
     * @param {string|HTMLElement} inputElement - Input element or selector
     * @param {object} option - Option
     * @param {string} option.id - Id
     * @param {string} option.format - Text format
     */
    var DatePickerInput = defineClass(
      /** @lends DatePickerInput.prototype */ {
        init: function(inputElement, option) {
          option.format = option.format || DEFAULT_FORMAT;

          /**
           * Input element
           * @type {HTMLElement}
           * @private
           */
          this._input = util.getElement(inputElement);

          /**
           * Id
           * @type {string}
           * @private
           */
          this._id = option.id;

          /**
           * LocaleText titles
           * @type {Object}
           * @private
           */
          this._titles = option.localeText.titles;

          /**
           * Text<->DateTime Formatter
           * @type {DateTimeFormatter}
           * @private
           */
          this._formatter = new DateTimeFormatter(option.format, this._titles);

          this._setEvents();
        },

        /**
         * Change locale titles
         * @param {object} titles - locale text in format
         */
        changeLocaleTitles: function(titles) {
          this._titles = titles;
        },

        /**
         * Set input 'click', 'change' event
         * @private
         */
        _setEvents: function() {
          if (this._input) {
            on(this._input, 'change', this._onChangeHandler, this);
            mouseTouchEvent.on(this._input, 'click', this._onClickHandler, this);
          }
        },

        /**
         * Remove events
         * @private
         */
        _removeEvents: function() {
          this.off();

          if (this._input) {
            off(this._input, 'change', this._onChangeHandler);
            mouseTouchEvent.off(this._input, 'click', this._onClickHandler);
          }
        },

        /**
         * Onchange handler
         */
        _onChangeHandler: function() {
          this.fire('change');
        },

        /**
         * Onclick handler
         */
        _onClickHandler: function() {
          this.fire('click');
        },

        /**
         * Check element is same as the input element.
         * @param {HTMLElement} el - To check matched set of elements
         * @returns {boolean}
         */
        is: function(el) {
          return this._input === el;
        },

        /**
         * Enable input
         */
        enable: function() {
          if (this._input) {
            this._input.removeAttribute('disabled');
          }
        },

        /**
         * Disable input
         */
        disable: function() {
          if (this._input) {
            this._input.setAttribute('disabled', true);
          }
        },

        /**
         * Return format
         * @returns {string}
         */
        getFormat: function() {
          return this._formatter.getRawString();
        },

        /**
         * Set format
         * @param {string} format - Format
         */
        setFormat: function(format) {
          if (!format) {
            return;
          }

          this._formatter = new DateTimeFormatter(format, this._titles);
        },

        /**
         * Clear text
         */
        clearText: function() {
          if (this._input) {
            this._input.value = '';
          }
        },

        /**
         * Set value from date
         * @param {Date} date - Date
         */
        setDate: function(date) {
          if (this._input) {
            this._input.value = this._formatter.format(date);
          }
        },

        /**
         * Returns date from input-text
         * @returns {Date}
         * @throws {Error}
         */
        getDate: function() {
          var value = '';

          if (this._input) {
            value = this._input.value;
          }

          return this._formatter.parse(value);
        },

        /**
         * Destroy
         */
        destroy: function() {
          this._removeEvents();

          this._input = this._id = this._formatter = null;
        }
      }
    );

    CustomEvents.mixin(DatePickerInput);
    module.exports = DatePickerInput;


    /***/ }),
    /* 60 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Date-Range picker
     * @author NHN. FE Development Lab <dl_javascript@nhn.com>
     */



    var forEachArray = __webpack_require__(2);
    var defineClass = __webpack_require__(0);
    var CustomEvents = __webpack_require__(8);
    var addClass = __webpack_require__(16);
    var getData = __webpack_require__(26);
    var removeClass = __webpack_require__(18);
    var extend = __webpack_require__(7);

    var DatePicker = __webpack_require__(21);
    var dateUtil = __webpack_require__(5);
    var constants = __webpack_require__(1);
    var util = __webpack_require__(4);

    var CLASS_NAME_RANGE_PICKER = 'tui-rangepicker';
    var CLASS_NAME_SELECTED = constants.CLASS_NAME_SELECTED;
    var CLASS_NAME_SELECTED_RANGE = 'tui-is-selected-range';

    /**
     * @class
     * @description
     * Create a date-range picker by {@link DatePicker#createRangePicker DatePicker.createRangePicker()}.
     * @see {@link /tutorial-example08-daterangepicker DateRangePicker example}
     * @param {object} options - DateRangePicker options
     *     @param {object} options.startpicker - Startpicker options
     *         @param {HTMLElement|string} options.startpicker.input - Startpicker input element or selector
     *         @param {HTMLElement|string} options.startpicker.container - Startpicker container element or selector
     *         @param {Date|number} [options.startpicker.date] - Initial date of the start picker. Set by a Date instance or a number(timestamp). (default: no initial date)
     *         @param {string} [options.startpicker.weekStartDay = 'Sun'] - Start of the week. 'Sun', 'Mon', ..., 'Sat'(default: 'Sun'(start on Sunday))
     *     @param {object} options.endpicker - Endpicker options
     *         @param {HTMLElement|string} options.endpicker.input - Endpicker input element or selector
     *         @param {HTMLElement|string} options.endpicker.container - Endpicker container element or selector
     *         @param {Date|number} [options.endpicker.date] - Initial date of the end picker. Set by a Date instance or a number(timestamp). (default: no initial date)
     *         @param {string} [options.endpicker.weekStartDay = 'Sun'] - Start of the week. 'Sun', 'Mon', ..., 'Sat'(default: 'Sun'(start on Sunday))
     *     @param {('date'|'month'|'year')} [options.type = 'date'] - DatePicker type. Determine whether to choose a date, month, or year.
     *     @param {string} [options.language='en'] - Language code. English('en') and Korean('ko') are provided as default. To use the other languages, use {@link DatePicker#localeTexts DatePicker.localeTexts}.
     *     @param {object|boolean} [options.timePicker] - [TimePicker](https://nhn.github.io/tui.time-picker/latest) options. Refer to the [TimePicker instance's options](https://nhn.github.io/tui.time-picker/latest/TimePicker). To create the TimePicker without customization, set to true.
     *     @param {object} [options.calendar] - {@link Calendar} options. Refer to the {@link Calendar Calendar instance's options}.
     *     @param {string} [options.format = 'yyyy-mm-dd'] - Format of the Date string
     *     @param {Array.<Array.<Date|number>>} [options.selectableRanges] - Ranges of selectable date. Set by Date instances or numbers(timestamp).
     *     @param {boolean} [options.showAlways = false] - Show the DateRangePicker always
     *     @param {boolean} [options.autoClose = true] - Close the DateRangePicker after clicking the date
     *     @param {boolean} [options.usageStatistics = true] - Send a hostname to Google Analytics (default: true)
     * @example
     * // ES6
     * import DatePicker from 'tui-date-picker'
     *
     * // CommonJS
     * const DatePicker = require('tui-date-picker');
     *
     * // Browser
     * const DatePicker = tui.DatePicker;
     *
     * const rangePicker = DatePicker.createRangePicker({
     *     startpicker: {
     *         input: '#start-input',
     *         container: '#start-container'
     *         date: new Date(2019, 3, 1),
     *         weekStartDay: 'Mon',
     *     },
     *     endpicker: {
     *         input: '#end-input',
     *         container: '#end-container',
     *         weekStartDay: 'Mon',
     *     },
     *     type: 'date',
     *     format: 'yyyy-MM-dd'
     *     selectableRanges: [
     *         [new Date(2017, 3, 1), new Date(2017, 5, 1)],
     *         [new Date(2017, 6, 3), new Date(2017, 10, 5)]
     *     ]
     * });
     */
    var DateRangePicker = defineClass(
      /** @lends DateRangePicker.prototype */ {
        init: function(options) {
          var startpickerOpt, endpickerOpt;

          options = options || {};
          startpickerOpt = options.startpicker;
          endpickerOpt = options.endpicker;

          if (!startpickerOpt) {
            throw new Error('The "startpicker" option is required.');
          }
          if (!endpickerOpt) {
            throw new Error('The "endpicker" option is required.');
          }

          /**
           * Start picker
           * @type {DatePicker}
           * @private
           */
          this._startpicker = null;

          /**
           * End picker
           * @type {DatePicker}
           * @private
           */
          this._endpicker = null;

          this._isRangeSet = false;

          this._preEndPickerDate = new Date().getDate();

          this._initializePickers(options);
          this._syncRangesToEndpicker();
        },

        /**
         * Create picker
         * @param {Object} options - DatePicker options
         * @private
         */
        _initializePickers: function(options) {
          var startpickerContainer = util.getElement(options.startpicker.container);
          var endpickerContainer = util.getElement(options.endpicker.container);
          var startInput = util.getElement(options.startpicker.input);
          var endInput = util.getElement(options.endpicker.input);

          var startpickerOpt = extend({}, options, {
            input: {
              element: startInput,
              format: options.format
            },
            date: options.startpicker.date,
            weekStartDay: options.startpicker.weekStartDay
          });
          var endpickerOpt = extend({}, options, {
            input: {
              element: endInput,
              format: options.format
            },
            date: options.endpicker.date,
            weekStartDay: options.endpicker.weekStartDay
          });

          this._startpicker = new DatePicker(startpickerContainer, startpickerOpt);
          this._startpicker.addCssClass(CLASS_NAME_RANGE_PICKER);
          this._startpicker.on('change', this._onChangeStartpicker, this);
          this._startpicker.on('draw', this._onDrawPicker, this);

          this._endpicker = new DatePicker(endpickerContainer, endpickerOpt);
          this._endpicker.addCssClass(CLASS_NAME_RANGE_PICKER);
          this._endpicker.on('change', this._onChangeEndpicker, this);
          this._endpicker.on('draw', this._onDrawPicker, this);
        },

        /**
         * Set selection-class to elements after calendar drawing
         * @param {Object} eventData - Event data {@link DatePicker#event:draw}
         * @private
         */
        _onDrawPicker: function(eventData) {
          var calendarType = eventData.type;
          var startDate = this._startpicker.getDate();
          var endDate = this._endpicker.getDate();

          if (!startDate) {
            return;
          }

          if (!endDate) {
            // Convert null to invaild date.
            endDate = new Date(NaN);
          }

          forEachArray(
            eventData.dateElements,
            function(el) {
              var elDate = new Date(Number(getData(el, 'timestamp')));
              var isInRange = dateUtil.inRange(startDate, endDate, elDate, calendarType);
              var isSelected =
                dateUtil.isSame(startDate, elDate, calendarType) ||
                dateUtil.isSame(endDate, elDate, calendarType);

              this._setRangeClass(el, isInRange);
              this._setSelectedClass(el, isSelected);
            },
            this
          );
        },

        /**
         * Set range class to element
         * @param {HTMLElement} el - Element
         * @param {boolean} isInRange - In range
         * @private
         */
        _setRangeClass: function(el, isInRange) {
          if (isInRange) {
            addClass(el, CLASS_NAME_SELECTED_RANGE);
          } else {
            removeClass(el, CLASS_NAME_SELECTED_RANGE);
          }
        },

        /**
         * Set selected class to element
         * @param {HTMLElement} el - Element
         * @param {boolean} isSelected - Is selected
         * @private
         */
        _setSelectedClass: function(el, isSelected) {
          if (isSelected) {
            addClass(el, CLASS_NAME_SELECTED);
          } else {
            removeClass(el, CLASS_NAME_SELECTED);
          }
        },

        /**
         * Sync ranges to endpicker
         * @private
         */
        _syncRangesToEndpicker: function() {
          var startDate = this._startpicker.getDate();
          var overlappedRange;

          if (startDate) {
            overlappedRange = this._startpicker.findOverlappedRange(
              dateUtil.cloneWithStartOf(startDate).getTime(),
              dateUtil.cloneWithEndOf(startDate).getTime()
            );

            this._endpicker.enable();
            this._endpicker.setRanges([[startDate.getTime(), overlappedRange[1].getTime()]]);

            this._setTimeRangeOnEndPicker();
          } else {
            this._endpicker.setNull();
            this._endpicker.disable();
          }
        },

        /**
         * After change on start-picker
         * @private
         */
        _onChangeStartpicker: function() {
          this._syncRangesToEndpicker();
          /**
           * Occur after the start date is changed.
           * @event DateRangePicker#change:start
           * @see {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents#on rangePicker.on()} to bind event handlers.
           * @see {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents#off rangePicker.off()} to unbind event handlers.
           * @see Refer to {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents CustomEvents} for more methods. DateRangePicker mixes in the methods from CustomEvents.
           * @example
           * // bind the 'change:start' event
           * rangePicker.on('change:start', () => {
           *     console.log(`Start date: ${rangePicker.getStartDate()}`);
           * });
           *
           * // unbind the 'change:start' event
           * rangePicker.off('change:start');
           */
          this.fire('change:start');
        },

        /**
         * After change on end-picker
         * @private
         */
        _onChangeEndpicker: function() {
          /**
           * Occur after the end date is changed.
           * @event DateRangePicker#change:end
           * @see {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents#on rangePicker.on()} to bind event handlers.
           * @see {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents#off rangePicker.off()} to unbind event handlers.
           * @see Refer to {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents CustomEvents} for more methods. DateRangePicker mixes in the methods from CustomEvents.
           * @example
           * // bind the 'change:end' event
           * rangePicker.on('change:end', () => {
           *     console.log(`End date: ${rangePicker.getEndDate()}`);
           * });
           *
           * // unbind the 'change:end' event
           * rangePicker.off('change:end');
           */

          var date;
          var endPickerDate = this._endpicker.getDate();

          if (endPickerDate) {
            date = endPickerDate.getDate();
            if (this._preEndPickerDate !== date) {
              this._setTimeRangeOnEndPicker();
            }

            this._preEndPickerDate = date;
          } else {
            this._preEndPickerDate = null;
          }

          this.fire('change:end');
        },

        /**
         * Set time range on end picker
         * @private
         */
        _setTimeRangeOnEndPicker: function() {
          var pickerDate, timeRange;
          var endTimePicker = this._endpicker._timePicker;

          if (!endTimePicker) {
            return;
          }

          pickerDate = this._endpicker.getDate() || this._startpicker.getDate();
          timeRange = this._getTimeRangeFromStartPicker();

          if (pickerDate && timeRange[pickerDate.getDate()]) {
            endTimePicker.setRange(timeRange[pickerDate.getDate()]);
            this._isRangeSet = true;
          } else if (this._isRangeSet) {
            endTimePicker.setRange({ hour: 0, minute: 0 });
            endTimePicker.resetMinuteRange();
            this._isRangeSet = false;
          }
        },

        /**
         * Return object of time range from start picker.
         * @returns {object}
         * @private
         */
        _getTimeRangeFromStartPicker: function() {
          var startDate = this._startpicker.getDate();
          var timeRange = {};

          timeRange[startDate.getDate()] = {
            hour: startDate.getHours(),
            minute: startDate.getMinutes()
          };

          return timeRange;
        },

        /**
         * Return a start-datepicker.
         * @returns {DatePicker}
         */
        getStartpicker: function() {
          return this._startpicker;
        },

        /**
         * Return a end-datepicker.
         * @returns {DatePicker}
         */
        getEndpicker: function() {
          return this._endpicker;
        },

        /**
         * Set the start date.
         * @param {Date} date - Start date
         */
        setStartDate: function(date) {
          this._startpicker.setDate(date);
        },

        /**
         * Return the start date.
         * @returns {?Date}
         */
        getStartDate: function() {
          return this._startpicker.getDate();
        },

        /**
         * Return the end date.
         * @returns {?Date}
         */
        getEndDate: function() {
          return this._endpicker.getDate();
        },

        /**
         * Set the end date.
         * @param {Date} date - End date
         */
        setEndDate: function(date) {
          this._endpicker.setDate(date);
        },

        /**
         * Set selectable ranges.
         * @param {Array.<Array.<number|Date>>} ranges - Selectable ranges. Use Date instances or numbers(timestamp).
         */
        setRanges: function(ranges) {
          this._startpicker.setRanges(ranges);
          this._syncRangesToEndpicker();
        },

        /**
         * Add a selectable range. Use Date instances or numbers(timestamp).
         * @param {Date|number} start - the start date
         * @param {Date|number} end - the end date
         */
        addRange: function(start, end) {
          this._startpicker.addRange(start, end);
          this._syncRangesToEndpicker();
        },

        /**
         * Remove a range. Use Date instances or numbers(timestamp).
         * @param {Date|number} start - the start date
         * @param {Date|number} end - the end date
         * @param {null|'date'|'month'|'year'} type - Range type. If falsy, start and end values are considered as timestamp
         */
        removeRange: function(start, end, type) {
          this._startpicker.removeRange(start, end, type);
          this._syncRangesToEndpicker();
        },

        /**
         * Change language.
         * @param {string} language - Language code. English('en') and Korean('ko') are provided as default.
         * @see To set to the other languages, use {@link DatePicker#localeTexts DatePicker.localeTexts}.
         */
        changeLanguage: function(language) {
          this._startpicker.changeLanguage(language);
          this._endpicker.changeLanguage(language);
        },

        /**
         * Destroy the date-range picker.
         */
        destroy: function() {
          this.off();
          this._startpicker.destroy();
          this._endpicker.destroy();
          this._startpicker = this._endpicker = null;
        }
      }
    );

    CustomEvents.mixin(DateRangePicker);
    module.exports = DateRangePicker;


    /***/ }),
    /* 61 */
    /***/ (function(module, exports, __webpack_require__) {

    // extracted by mini-css-extract-plugin

    /***/ })
    /******/ ]);
    });
    }(tuiDatePicker));

    var tuiPagination = {exports: {}};

    /*!
     * TOAST UI Pagination
     * @version 3.4.1
     * @author NHN FE Development Team <dl_javascript@nhn.com>
     * @license MIT
     */

    (function (module, exports) {
    (function webpackUniversalModuleDefinition(root, factory) {
    	module.exports = factory();
    })(window, function() {
    return /******/ (function(modules) { // webpackBootstrap
    /******/ 	// The module cache
    /******/ 	var installedModules = {};
    /******/
    /******/ 	// The require function
    /******/ 	function __webpack_require__(moduleId) {
    /******/
    /******/ 		// Check if module is in cache
    /******/ 		if(installedModules[moduleId]) {
    /******/ 			return installedModules[moduleId].exports;
    /******/ 		}
    /******/ 		// Create a new module (and put it into the cache)
    /******/ 		var module = installedModules[moduleId] = {
    /******/ 			i: moduleId,
    /******/ 			l: false,
    /******/ 			exports: {}
    /******/ 		};
    /******/
    /******/ 		// Execute the module function
    /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    /******/
    /******/ 		// Flag the module as loaded
    /******/ 		module.l = true;
    /******/
    /******/ 		// Return the exports of the module
    /******/ 		return module.exports;
    /******/ 	}
    /******/
    /******/
    /******/ 	// expose the modules object (__webpack_modules__)
    /******/ 	__webpack_require__.m = modules;
    /******/
    /******/ 	// expose the module cache
    /******/ 	__webpack_require__.c = installedModules;
    /******/
    /******/ 	// define getter function for harmony exports
    /******/ 	__webpack_require__.d = function(exports, name, getter) {
    /******/ 		if(!__webpack_require__.o(exports, name)) {
    /******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
    /******/ 		}
    /******/ 	};
    /******/
    /******/ 	// define __esModule on exports
    /******/ 	__webpack_require__.r = function(exports) {
    /******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
    /******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
    /******/ 		}
    /******/ 		Object.defineProperty(exports, '__esModule', { value: true });
    /******/ 	};
    /******/
    /******/ 	// create a fake namespace object
    /******/ 	// mode & 1: value is a module id, require it
    /******/ 	// mode & 2: merge all properties of value into the ns
    /******/ 	// mode & 4: return value when already ns object
    /******/ 	// mode & 8|1: behave like require
    /******/ 	__webpack_require__.t = function(value, mode) {
    /******/ 		if(mode & 1) value = __webpack_require__(value);
    /******/ 		if(mode & 8) return value;
    /******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
    /******/ 		var ns = Object.create(null);
    /******/ 		__webpack_require__.r(ns);
    /******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
    /******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
    /******/ 		return ns;
    /******/ 	};
    /******/
    /******/ 	// getDefaultExport function for compatibility with non-harmony modules
    /******/ 	__webpack_require__.n = function(module) {
    /******/ 		var getter = module && module.__esModule ?
    /******/ 			function getDefault() { return module['default']; } :
    /******/ 			function getModuleExports() { return module; };
    /******/ 		__webpack_require__.d(getter, 'a', getter);
    /******/ 		return getter;
    /******/ 	};
    /******/
    /******/ 	// Object.prototype.hasOwnProperty.call
    /******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
    /******/
    /******/ 	// __webpack_public_path__
    /******/ 	__webpack_require__.p = "dist";
    /******/
    /******/
    /******/ 	// Load entry module and return exports
    /******/ 	return __webpack_require__(__webpack_require__.s = 10);
    /******/ })
    /************************************************************************/
    /******/ ([
    /* 0 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Extend the target object from other objects.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * @module object
     */

    /**
     * Extend the target object from other objects.
     * @param {object} target - Object that will be extended
     * @param {...object} objects - Objects as sources
     * @returns {object} Extended object
     * @memberof module:object
     */
    function extend(target, objects) { // eslint-disable-line no-unused-vars
      var hasOwnProp = Object.prototype.hasOwnProperty;
      var source, prop, i, len;

      for (i = 1, len = arguments.length; i < len; i += 1) {
        source = arguments[i];
        for (prop in source) {
          if (hasOwnProp.call(source, prop)) {
            target[prop] = source[prop];
          }
        }
      }

      return target;
    }

    module.exports = extend;


    /***/ }),
    /* 1 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is undefined or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Check whether the given variable is undefined or not.
     * If the given variable is undefined, returns true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is undefined?
     * @memberof module:type
     */
    function isUndefined(obj) {
      return obj === undefined; // eslint-disable-line no-undefined
    }

    module.exports = isUndefined;


    /***/ }),
    /* 2 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is an instance of Array or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Check whether the given variable is an instance of Array or not.
     * If the given variable is an instance of Array, return true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is array instance?
     * @memberof module:type
     */
    function isArray(obj) {
      return obj instanceof Array;
    }

    module.exports = isArray;


    /***/ }),
    /* 3 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Execute the provided callback once for each property of object(or element of array) which actually exist.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var isArray = __webpack_require__(2);
    var forEachArray = __webpack_require__(17);
    var forEachOwnProperties = __webpack_require__(6);

    /**
     * @module collection
     */

    /**
     * Execute the provided callback once for each property of object(or element of array) which actually exist.
     * If the object is Array-like object(ex-arguments object), It needs to transform to Array.(see 'ex2' of example).
     * If the callback function returns false, the loop will be stopped.
     * Callback function(iteratee) is invoked with three arguments:
     *  1) The value of the property(or The value of the element)
     *  2) The name of the property(or The index of the element)
     *  3) The object being traversed
     * @param {Object} obj The object that will be traversed
     * @param {function} iteratee Callback function
     * @param {Object} [context] Context(this) of callback function
     * @memberof module:collection
     * @example
     * var forEach = require('tui-code-snippet/collection/forEach'); // node, commonjs
     *
     * var sum = 0;
     *
     * forEach([1,2,3], function(value){
     *     sum += value;
     * });
     * alert(sum); // 6
     *
     * // In case of Array-like object
     * var array = Array.prototype.slice.call(arrayLike); // change to array
     * forEach(array, function(value){
     *     sum += value;
     * });
     */
    function forEach(obj, iteratee, context) {
      if (isArray(obj)) {
        forEachArray(obj, iteratee, context);
      } else {
        forEachOwnProperties(obj, iteratee, context);
      }
    }

    module.exports = forEach;


    /***/ }),
    /* 4 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is a string or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Check whether the given variable is a string or not.
     * If the given variable is a string, return true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is string?
     * @memberof module:type
     */
    function isString(obj) {
      return typeof obj === 'string' || obj instanceof String;
    }

    module.exports = isString;


    /***/ }),
    /* 5 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is a function or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Check whether the given variable is a function or not.
     * If the given variable is a function, return true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is function?
     * @memberof module:type
     */
    function isFunction(obj) {
      return obj instanceof Function;
    }

    module.exports = isFunction;


    /***/ }),
    /* 6 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Execute the provided callback once for each property of object which actually exist.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Execute the provided callback once for each property of object which actually exist.
     * If the callback function returns false, the loop will be stopped.
     * Callback function(iteratee) is invoked with three arguments:
     *  1) The value of the property
     *  2) The name of the property
     *  3) The object being traversed
     * @param {Object} obj The object that will be traversed
     * @param {function} iteratee  Callback function
     * @param {Object} [context] Context(this) of callback function
     * @memberof module:collection
     * @example
     * var forEachOwnProperties = require('tui-code-snippet/collection/forEachOwnProperties'); // node, commonjs
     *
     * var sum = 0;
     *
     * forEachOwnProperties({a:1,b:2,c:3}, function(value){
     *     sum += value;
     * });
     * alert(sum); // 6
     */
    function forEachOwnProperties(obj, iteratee, context) {
      var key;

      context = context || null;

      for (key in obj) {
        if (obj.hasOwnProperty(key)) {
          if (iteratee.call(context, obj[key], key, obj) === false) {
            break;
          }
        }
      }
    }

    module.exports = forEachOwnProperties;


    /***/ }),
    /* 7 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview
     * This module provides a function to make a constructor
     * that can inherit from the other constructors like the CLASS easily.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var inherit = __webpack_require__(18);
    var extend = __webpack_require__(0);

    /**
     * @module defineClass
     */

    /**
     * Help a constructor to be defined and to inherit from the other constructors
     * @param {*} [parent] Parent constructor
     * @param {Object} props Members of constructor
     *  @param {Function} props.init Initialization method
     *  @param {Object} [props.static] Static members of constructor
     * @returns {*} Constructor
     * @memberof module:defineClass
     * @example
     * var defineClass = require('tui-code-snippet/defineClass/defineClass'); // node, commonjs
     *
     * //-- #2. Use property --//
     * var Parent = defineClass({
     *     init: function() { // constuructor
     *         this.name = 'made by def';
     *     },
     *     method: function() {
     *         // ...
     *     },
     *     static: {
     *         staticMethod: function() {
     *              // ...
     *         }
     *     }
     * });
     *
     * var Child = defineClass(Parent, {
     *     childMethod: function() {}
     * });
     *
     * Parent.staticMethod();
     *
     * var parentInstance = new Parent();
     * console.log(parentInstance.name); //made by def
     * parentInstance.staticMethod(); // Error
     *
     * var childInstance = new Child();
     * childInstance.method();
     * childInstance.childMethod();
     */
    function defineClass(parent, props) {
      var obj;

      if (!props) {
        props = parent;
        parent = null;
      }

      obj = props.init || function() {};

      if (parent) {
        inherit(obj, parent);
      }

      if (props.hasOwnProperty('static')) {
        extend(obj, props['static']);
        delete props['static'];
      }

      extend(obj.prototype, props);

      return obj;
    }

    module.exports = defineClass;


    /***/ }),
    /* 8 */
    /***/ (function(module, exports, __webpack_require__) {
    /* eslint-disable complexity */
    /**
     * @fileoverview Returns the first index at which a given element can be found in the array.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var isArray = __webpack_require__(2);

    /**
     * @module array
     */

    /**
     * Returns the first index at which a given element can be found in the array
     * from start index(default 0), or -1 if it is not present.
     * It compares searchElement to elements of the Array using strict equality
     * (the same method used by the ===, or triple-equals, operator).
     * @param {*} searchElement Element to locate in the array
     * @param {Array} array Array that will be traversed.
     * @param {number} startIndex Start index in array for searching (default 0)
     * @returns {number} the First index at which a given element, or -1 if it is not present
     * @memberof module:array
     * @example
     * var inArray = require('tui-code-snippet/array/inArray'); // node, commonjs
     *
     * var arr = ['one', 'two', 'three', 'four'];
     * var idx1 = inArray('one', arr, 3); // -1
     * var idx2 = inArray('one', arr); // 0
     */
    function inArray(searchElement, array, startIndex) {
      var i;
      var length;
      startIndex = startIndex || 0;

      if (!isArray(array)) {
        return -1;
      }

      if (Array.prototype.indexOf) {
        return Array.prototype.indexOf.call(array, searchElement, startIndex);
      }

      length = array.length;
      for (i = startIndex; startIndex >= 0 && i < length; i += 1) {
        if (array[i] === searchElement) {
          return i;
        }
      }

      return -1;
    }

    module.exports = inArray;


    /***/ }),
    /* 9 */
    /***/ (function(module, exports, __webpack_require__) {


    var template = __webpack_require__(29);
    var sendHostname = __webpack_require__(30);
    var isFunction = __webpack_require__(5);

    var util = {
      /**
       * Capitalize first letter
       * @param {string} str - String to change
       * @returns {string} Changed string
       */
      capitalizeFirstLetter: function(str) {
        return str.substring(0, 1).toUpperCase() + str.substring(1, str.length);
      },

      /**
       * Check the element is contained
       * @param {HTMLElement} find - Target element
       * @param {HTMLElement} parent - Wrapper element
       * @returns {boolean} Whether contained or not
       */
      isContained: function(find, parent) {
        if (!parent) {
          return false;
        }

        return find === parent ? true : parent.contains(find);
      },

      /**
       * Create an new element by template literals.
       * @param {string|function} tmpl - template
       * @param {Object} context - context
       * @returns {HTMLElement}
       */
      createElementByTemplate: function(tmpl, context) {
        var parent = document.createElement('div');
        var html = isFunction(tmpl) ? tmpl(context) : template(tmpl, context);
        parent.innerHTML = html;

        return parent.firstChild;
      },

      /**
       * Create a new function that, when called, has its this keyword set to the provided value.
       * @param {function} fn A original function before binding
       * @param {*} obj context of function in arguments[0]
       * @returns {function} A new bound function with context that is in arguments[1]
       */
      bind: function(fn, obj) {
        var slice = Array.prototype.slice;
        var args;

        if (fn.bind) {
          return fn.bind.apply(fn, slice.call(arguments, 1));
        }

        args = slice.call(arguments, 2);

        return function() {
          return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
        };
      },

      /**
       * Send hostname for GA
       * @ignore
       */
      sendHostName: function() {
        sendHostname('pagination', 'UA-129987462-1');
      }
    };

    module.exports = util;


    /***/ }),
    /* 10 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview The entry file of Pagination components
     * @author NHN. FE Development Lab <dl_javascript@nhn.com>
     */



    __webpack_require__(11);

    module.exports = __webpack_require__(12);


    /***/ }),
    /* 11 */
    /***/ (function(module, exports, __webpack_require__) {

    // extracted by mini-css-extract-plugin

    /***/ }),
    /* 12 */
    /***/ (function(module, exports, __webpack_require__) {


    var CustomEvents = __webpack_require__(13);
    var defineClass = __webpack_require__(7);
    var extend = __webpack_require__(0);
    var isUndefined = __webpack_require__(1);

    var View = __webpack_require__(20);
    var util = __webpack_require__(9);

    var defaultOption = {
      totalItems: 10,
      itemsPerPage: 10,
      visiblePages: 10,
      page: 1,
      centerAlign: false,
      firstItemClassName: 'tui-first-child',
      lastItemClassName: 'tui-last-child',
      usageStatistics: true
    };

    /**
     * Pagination class
     * @class Pagination
     * @param {string|HTMLElement|jQueryObject} container - Container element or selector.
     * In case of a string, it is considered as an id selector and find the element by id.
     * If there is no element, it is considered as a selector and find the element by querySelector().
     * Passing jQueryObject and considering an id selector at first will be deprecated in v4.0.0.
     * @param {object} options - Option object
     *     @param {number} [options.totalItems=10] Total item count
     *     @param {number} [options.itemsPerPage=10] Item count per page
     *     @param {number} [options.visiblePages=10] Display page link count
     *     @param {number} [options.page=1] Display page after pagination draw.
     *     @param {boolean}[options.centerAlign=false] Whether current page keep center or not
     *     @param {string} [options.firstItemClassName='first-child'] The class name of the first item
     *     @param {string} [options.lastItemClassName='last-child'] The class name of the last item
     *     @param {object} [options.template] A markup string set to make element. Refer to {@link https://github.com/nhn/tui.pagination/blob/master/docs/getting-started.md#how-to-use-template Getting Started: How to use template}.
     *         @param {string|function} [options.template.page] HTML template
     *         @param {string|function} [options.template.currentPage] HTML template
     *         @param {string|function} [options.template.moveButton] HTML template
     *         @param {string|function} [options.template.disabledMoveButton] HTML template
     *         @param {string|function} [options.template.moreButton] HTML template
     *     @param {boolean} [options.usageStatistics=true] Send the hostname to google analytics.
     *         If you do not want to send the hostname, this option set to false.
     * @example
     * // ES6
     * import Pagination from 'tui-pagination';
     *
     * // CommonJS
     * const Pagination = require('tui-pagination');
     *
     * // Browser
     * const Pagination = tui.Pagination;
     *
     * const container = document.getElementById('pagination');
     * const options = { // below default value of options
     *      totalItems: 10,
     *      itemsPerPage: 10,
     *      visiblePages: 10,
     *      page: 1,
     *      centerAlign: false,
     *      firstItemClassName: 'tui-first-child',
     *      lastItemClassName: 'tui-last-child',
     *      template: {
     *          page: '<a href="#" class="tui-page-btn">{{page}}</a>',
     *          currentPage: '<strong class="tui-page-btn tui-is-selected">{{page}}</strong>',
     *          moveButton:
     *              '<a href="#" class="tui-page-btn tui-{{type}}">' +
     *                  '<span class="tui-ico-{{type}}">{{type}}</span>' +
     *              '</a>',
     *          disabledMoveButton:
     *              '<span class="tui-page-btn tui-is-disabled tui-{{type}}">' +
     *                  '<span class="tui-ico-{{type}}">{{type}}</span>' +
     *              '</span>',
     *          moreButton:
     *              '<a href="#" class="tui-page-btn tui-{{type}}-is-ellip">' +
     *                  '<span class="tui-ico-ellip">...</span>' +
     *              '</a>'
     *      }
     * };
     * const pagination = new Pagination(container, options);
     */
    var Pagination = defineClass(
      /** @lends Pagination.prototype */ {
        init: function(container, options) {
          /**
           * Option object
           * @type {object}
           * @private
           */
          this._options = extend({}, defaultOption, options);

          /**
           * Current page number
           * @type {number}
           * @private
           */
          this._currentPage = 0;

          /**
           * View instance
           * @type {View}
           * @private
           */
          this._view = new View(container, this._options, util.bind(this._onClickHandler, this));

          this._paginate();

          if (this._options.usageStatistics) {
            util.sendHostName();
          }
        },

        /**
         * Set current page
         * @param {number} page - Current page
         * @private
         */
        _setCurrentPage: function(page) {
          this._currentPage = page || this._options.page;
        },

        /**
         * Get last page number
         * @returns {number} Last page number
         * @private
         */
        _getLastPage: function() {
          var lastPage = Math.ceil(this._options.totalItems / this._options.itemsPerPage);

          return !lastPage ? 1 : lastPage;
        },

        /**
         * Index of list in total lists
         * @param {number} pageNumber - Page number
         * @returns {number} Page index or number
         * @private
         */
        _getPageIndex: function(pageNumber) {
          var left, pageIndex;

          if (this._options.centerAlign) {
            left = Math.floor(this._options.visiblePages / 2);
            pageIndex = pageNumber - left;
            pageIndex = Math.max(pageIndex, 1);
            pageIndex = Math.min(pageIndex, this._getLastPage() - this._options.visiblePages + 1);

            return pageIndex;
          }

          return Math.ceil(pageNumber / this._options.visiblePages);
        },

        /**
         * Get relative page
         * @param {string} moveType - Move type ('prev' or 'next')
         * @returns {number} Relative page number
         * @private
         */
        _getRelativePage: function(moveType) {
          var isPrevMove = moveType === 'prev';
          var currentPage = this.getCurrentPage();

          return isPrevMove ? currentPage - 1 : currentPage + 1;
        },

        /**
         * Get more page index
         * @param {string} moveType - Move type ('prev' or 'next')
         * @returns {number} Page index
         * @private
         */
        _getMorePageIndex: function(moveType) {
          var currentPageIndex = this._getPageIndex(this.getCurrentPage());
          var pageCount = this._options.visiblePages;
          var isPrevMove = moveType === 'prev';
          var pageIndex;

          if (this._options.centerAlign) {
            pageIndex = isPrevMove ? currentPageIndex - 1 : currentPageIndex + pageCount;
          } else {
            pageIndex = isPrevMove
              ? (currentPageIndex - 1) * pageCount
              : currentPageIndex * pageCount + 1;
          }

          return pageIndex;
        },
        /* eslint-enable complexity */

        /**
         * Get available page number from over number
         * If total page is 23, but input number is 30 => return 23
         * @param {number} page - Page number
         * @returns {number} Replaced pgae number
         * @private
         */
        _convertToValidPage: function(page) {
          var lastPageNumber = this._getLastPage();
          page = Math.max(page, 1);
          page = Math.min(page, lastPageNumber);

          return page;
        },

        /**
         * Create require view set, notify view to update
         * @param {number} page - Page number
         * @private
         */
        _paginate: function(page) {
          var viewData = this._makeViewData(page || this._options.page);
          this._setCurrentPage(page);
          this._view.update(viewData);
        },

        /**
         * Create and get view data
         * @param {number} page - Page number
         * @returns {object} view data
         * @private
         */
        _makeViewData: function(page) {
          var viewData = {};
          var lastPage = this._getLastPage();
          var currentPageIndex = this._getPageIndex(page);
          var lastPageListIndex = this._getPageIndex(lastPage);
          var edges = this._getEdge(page);

          viewData.leftPageNumber = edges.left;
          viewData.rightPageNumber = edges.right;

          viewData.prevMore = currentPageIndex > 1;
          viewData.nextMore = currentPageIndex < lastPageListIndex;

          viewData.page = page;
          viewData.currentPageIndex = page;
          viewData.lastPage = lastPage;
          viewData.lastPageListIndex = lastPage;

          return viewData;
        },

        /**
         * Get each edge page
         * @param {object} page - Page number
         * @returns {{left: number, right: number}} Edge page numbers
         * @private
         */
        _getEdge: function(page) {
          var leftPageNumber, rightPageNumber, left;
          var lastPage = this._getLastPage();
          var visiblePages = this._options.visiblePages;
          var currentPageIndex = this._getPageIndex(page);

          if (this._options.centerAlign) {
            left = Math.floor(visiblePages / 2);
            leftPageNumber = Math.max(page - left, 1);
            rightPageNumber = leftPageNumber + visiblePages - 1;

            if (rightPageNumber > lastPage) {
              leftPageNumber = Math.max(lastPage - visiblePages + 1, 1);
              rightPageNumber = lastPage;
            }
          } else {
            leftPageNumber = (currentPageIndex - 1) * visiblePages + 1;
            rightPageNumber = currentPageIndex * visiblePages;
            rightPageNumber = Math.min(rightPageNumber, lastPage);
          }

          return {
            left: leftPageNumber,
            right: rightPageNumber
          };
        },

        /**
         * Pagelist click event hadnler
         * @param {?string} buttonType - Button type
         * @param {?number} page - Page number
         * @private
         */
        /* eslint-disable complexity */
        _onClickHandler: function(buttonType, page) {
          switch (buttonType) {
            case 'first':
              page = 1;
              break;
            case 'prev':
              page = this._getRelativePage('prev');
              break;
            case 'next':
              page = this._getRelativePage('next');
              break;
            case 'prevMore':
              page = this._getMorePageIndex('prev');
              break;
            case 'nextMore':
              page = this._getMorePageIndex('next');
              break;
            case 'last':
              page = this._getLastPage();
              break;
            default:
              if (!page) {
                return;
              }
          }

          this.movePageTo(page);
        },
        /* eslint-enable complexity */

        /**
         * Reset pagination
         * @param {*} totalItems - Redraw page item count
         * @example
         * pagination.reset();
         * pagination.reset(100);
         */
        reset: function(totalItems) {
          if (isUndefined(totalItems)) {
            totalItems = this._options.totalItems;
          }

          this._options.totalItems = totalItems;
          this._paginate(1);
        },

        /**
         * Move to specific page, redraw list.
         * Before move fire beforeMove event, After move fire afterMove event.
         * @param {Number} targetPage - Target page
         * @example
         * pagination.movePageTo(10);
         */
        movePageTo: function(targetPage) {
          targetPage = this._convertToValidPage(targetPage);

          /**
           * @event Pagination#beforeMove
           * @type {object} evt - Custom event object
           * @property {number} page - Moved page
           * @example
           * paganation.on('beforeMove', (event) => {
           *     const currentPage = event.page;
           *
           *     if (currentPage === 10) {
           *         return false;
           *         // return true;
           *     }
           * });
           */
          if (!this.invoke('beforeMove', { page: targetPage })) {
            return;
          }

          this._paginate(targetPage);

          /**
           * @event Pagination#afterMove
           * @type {object} evt - Custom event object
           * @property {number} page - Moved page
           * @example
           * paganation.on('afterMove', (event) => {
           *      const currentPage = event.page;
           *      console.log(currentPage);
           * });
           */
          this.fire('afterMove', { page: targetPage });
        },

        /**
         * Set total count of items
         * @param {number} itemCount - Total item count
         */
        setTotalItems: function(itemCount) {
          this._options.totalItems = itemCount;
        },

        /**
         * Set count of items per page
         * @param {number} itemCount - Item count
         */
        setItemsPerPage: function(itemCount) {
          this._options.itemsPerPage = itemCount;
        },

        /**
         * Get current page
         * @returns {number} Current page
         */
        getCurrentPage: function() {
          return this._currentPage || this._options.page;
        }
      }
    );

    CustomEvents.mixin(Pagination);

    module.exports = Pagination;


    /***/ }),
    /* 13 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview This module provides some functions for custom events. And it is implemented in the observer design pattern.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var extend = __webpack_require__(0);
    var isExisty = __webpack_require__(14);
    var isString = __webpack_require__(4);
    var isObject = __webpack_require__(16);
    var isArray = __webpack_require__(2);
    var isFunction = __webpack_require__(5);
    var forEach = __webpack_require__(3);

    var R_EVENTNAME_SPLIT = /\s+/g;

    /**
     * @class
     * @example
     * // node, commonjs
     * var CustomEvents = require('tui-code-snippet/customEvents/customEvents');
     */
    function CustomEvents() {
      /**
         * @type {HandlerItem[]}
         */
      this.events = null;

      /**
         * only for checking specific context event was binded
         * @type {object[]}
         */
      this.contexts = null;
    }

    /**
     * Mixin custom events feature to specific constructor
     * @param {function} func - constructor
     * @example
     * var CustomEvents = require('tui-code-snippet/customEvents/customEvents'); // node, commonjs
     *
     * var model;
     * function Model() {
     *     this.name = '';
     * }
     * CustomEvents.mixin(Model);
     *
     * model = new Model();
     * model.on('change', function() { this.name = 'model'; }, this);
     * model.fire('change');
     * alert(model.name); // 'model';
     */
    CustomEvents.mixin = function(func) {
      extend(func.prototype, CustomEvents.prototype);
    };

    /**
     * Get HandlerItem object
     * @param {function} handler - handler function
     * @param {object} [context] - context for handler
     * @returns {HandlerItem} HandlerItem object
     * @private
     */
    CustomEvents.prototype._getHandlerItem = function(handler, context) {
      var item = {handler: handler};

      if (context) {
        item.context = context;
      }

      return item;
    };

    /**
     * Get event object safely
     * @param {string} [eventName] - create sub event map if not exist.
     * @returns {(object|array)} event object. if you supplied `eventName`
     *  parameter then make new array and return it
     * @private
     */
    CustomEvents.prototype._safeEvent = function(eventName) {
      var events = this.events;
      var byName;

      if (!events) {
        events = this.events = {};
      }

      if (eventName) {
        byName = events[eventName];

        if (!byName) {
          byName = [];
          events[eventName] = byName;
        }

        events = byName;
      }

      return events;
    };

    /**
     * Get context array safely
     * @returns {array} context array
     * @private
     */
    CustomEvents.prototype._safeContext = function() {
      var context = this.contexts;

      if (!context) {
        context = this.contexts = [];
      }

      return context;
    };

    /**
     * Get index of context
     * @param {object} ctx - context that used for bind custom event
     * @returns {number} index of context
     * @private
     */
    CustomEvents.prototype._indexOfContext = function(ctx) {
      var context = this._safeContext();
      var index = 0;

      while (context[index]) {
        if (ctx === context[index][0]) {
          return index;
        }

        index += 1;
      }

      return -1;
    };

    /**
     * Memorize supplied context for recognize supplied object is context or
     *  name: handler pair object when off()
     * @param {object} ctx - context object to memorize
     * @private
     */
    CustomEvents.prototype._memorizeContext = function(ctx) {
      var context, index;

      if (!isExisty(ctx)) {
        return;
      }

      context = this._safeContext();
      index = this._indexOfContext(ctx);

      if (index > -1) {
        context[index][1] += 1;
      } else {
        context.push([ctx, 1]);
      }
    };

    /**
     * Forget supplied context object
     * @param {object} ctx - context object to forget
     * @private
     */
    CustomEvents.prototype._forgetContext = function(ctx) {
      var context, contextIndex;

      if (!isExisty(ctx)) {
        return;
      }

      context = this._safeContext();
      contextIndex = this._indexOfContext(ctx);

      if (contextIndex > -1) {
        context[contextIndex][1] -= 1;

        if (context[contextIndex][1] <= 0) {
          context.splice(contextIndex, 1);
        }
      }
    };

    /**
     * Bind event handler
     * @param {(string|{name:string, handler:function})} eventName - custom
     *  event name or an object {eventName: handler}
     * @param {(function|object)} [handler] - handler function or context
     * @param {object} [context] - context for binding
     * @private
     */
    CustomEvents.prototype._bindEvent = function(eventName, handler, context) {
      var events = this._safeEvent(eventName);
      this._memorizeContext(context);
      events.push(this._getHandlerItem(handler, context));
    };

    /**
     * Bind event handlers
     * @param {(string|{name:string, handler:function})} eventName - custom
     *  event name or an object {eventName: handler}
     * @param {(function|object)} [handler] - handler function or context
     * @param {object} [context] - context for binding
     * //-- #1. Get Module --//
     * var CustomEvents = require('tui-code-snippet/customEvents/customEvents'); // node, commonjs
     *
     * //-- #2. Use method --//
     * // # 2.1 Basic Usage
     * CustomEvents.on('onload', handler);
     *
     * // # 2.2 With context
     * CustomEvents.on('onload', handler, myObj);
     *
     * // # 2.3 Bind by object that name, handler pairs
     * CustomEvents.on({
     *     'play': handler,
     *     'pause': handler2
     * });
     *
     * // # 2.4 Bind by object that name, handler pairs with context object
     * CustomEvents.on({
     *     'play': handler
     * }, myObj);
     */
    CustomEvents.prototype.on = function(eventName, handler, context) {
      var self = this;

      if (isString(eventName)) {
        // [syntax 1, 2]
        eventName = eventName.split(R_EVENTNAME_SPLIT);
        forEach(eventName, function(name) {
          self._bindEvent(name, handler, context);
        });
      } else if (isObject(eventName)) {
        // [syntax 3, 4]
        context = handler;
        forEach(eventName, function(func, name) {
          self.on(name, func, context);
        });
      }
    };

    /**
     * Bind one-shot event handlers
     * @param {(string|{name:string,handler:function})} eventName - custom
     *  event name or an object {eventName: handler}
     * @param {function|object} [handler] - handler function or context
     * @param {object} [context] - context for binding
     */
    CustomEvents.prototype.once = function(eventName, handler, context) {
      var self = this;

      if (isObject(eventName)) {
        context = handler;
        forEach(eventName, function(func, name) {
          self.once(name, func, context);
        });

        return;
      }

      function onceHandler() { // eslint-disable-line require-jsdoc
        handler.apply(context, arguments);
        self.off(eventName, onceHandler, context);
      }

      this.on(eventName, onceHandler, context);
    };

    /**
     * Splice supplied array by callback result
     * @param {array} arr - array to splice
     * @param {function} predicate - function return boolean
     * @private
     */
    CustomEvents.prototype._spliceMatches = function(arr, predicate) {
      var i = 0;
      var len;

      if (!isArray(arr)) {
        return;
      }

      for (len = arr.length; i < len; i += 1) {
        if (predicate(arr[i]) === true) {
          arr.splice(i, 1);
          len -= 1;
          i -= 1;
        }
      }
    };

    /**
     * Get matcher for unbind specific handler events
     * @param {function} handler - handler function
     * @returns {function} handler matcher
     * @private
     */
    CustomEvents.prototype._matchHandler = function(handler) {
      var self = this;

      return function(item) {
        var needRemove = handler === item.handler;

        if (needRemove) {
          self._forgetContext(item.context);
        }

        return needRemove;
      };
    };

    /**
     * Get matcher for unbind specific context events
     * @param {object} context - context
     * @returns {function} object matcher
     * @private
     */
    CustomEvents.prototype._matchContext = function(context) {
      var self = this;

      return function(item) {
        var needRemove = context === item.context;

        if (needRemove) {
          self._forgetContext(item.context);
        }

        return needRemove;
      };
    };

    /**
     * Get matcher for unbind specific hander, context pair events
     * @param {function} handler - handler function
     * @param {object} context - context
     * @returns {function} handler, context matcher
     * @private
     */
    CustomEvents.prototype._matchHandlerAndContext = function(handler, context) {
      var self = this;

      return function(item) {
        var matchHandler = (handler === item.handler);
        var matchContext = (context === item.context);
        var needRemove = (matchHandler && matchContext);

        if (needRemove) {
          self._forgetContext(item.context);
        }

        return needRemove;
      };
    };

    /**
     * Unbind event by event name
     * @param {string} eventName - custom event name to unbind
     * @param {function} [handler] - handler function
     * @private
     */
    CustomEvents.prototype._offByEventName = function(eventName, handler) {
      var self = this;
      var andByHandler = isFunction(handler);
      var matchHandler = self._matchHandler(handler);

      eventName = eventName.split(R_EVENTNAME_SPLIT);

      forEach(eventName, function(name) {
        var handlerItems = self._safeEvent(name);

        if (andByHandler) {
          self._spliceMatches(handlerItems, matchHandler);
        } else {
          forEach(handlerItems, function(item) {
            self._forgetContext(item.context);
          });

          self.events[name] = [];
        }
      });
    };

    /**
     * Unbind event by handler function
     * @param {function} handler - handler function
     * @private
     */
    CustomEvents.prototype._offByHandler = function(handler) {
      var self = this;
      var matchHandler = this._matchHandler(handler);

      forEach(this._safeEvent(), function(handlerItems) {
        self._spliceMatches(handlerItems, matchHandler);
      });
    };

    /**
     * Unbind event by object(name: handler pair object or context object)
     * @param {object} obj - context or {name: handler} pair object
     * @param {function} handler - handler function
     * @private
     */
    CustomEvents.prototype._offByObject = function(obj, handler) {
      var self = this;
      var matchFunc;

      if (this._indexOfContext(obj) < 0) {
        forEach(obj, function(func, name) {
          self.off(name, func);
        });
      } else if (isString(handler)) {
        matchFunc = this._matchContext(obj);

        self._spliceMatches(this._safeEvent(handler), matchFunc);
      } else if (isFunction(handler)) {
        matchFunc = this._matchHandlerAndContext(handler, obj);

        forEach(this._safeEvent(), function(handlerItems) {
          self._spliceMatches(handlerItems, matchFunc);
        });
      } else {
        matchFunc = this._matchContext(obj);

        forEach(this._safeEvent(), function(handlerItems) {
          self._spliceMatches(handlerItems, matchFunc);
        });
      }
    };

    /**
     * Unbind custom events
     * @param {(string|object|function)} eventName - event name or context or
     *  {name: handler} pair object or handler function
     * @param {(function)} handler - handler function
     * @example
     * //-- #1. Get Module --//
     * var CustomEvents = require('tui-code-snippet/customEvents/customEvents'); // node, commonjs
     *
     * //-- #2. Use method --//
     * // # 2.1 off by event name
     * CustomEvents.off('onload');
     *
     * // # 2.2 off by event name and handler
     * CustomEvents.off('play', handler);
     *
     * // # 2.3 off by handler
     * CustomEvents.off(handler);
     *
     * // # 2.4 off by context
     * CustomEvents.off(myObj);
     *
     * // # 2.5 off by context and handler
     * CustomEvents.off(myObj, handler);
     *
     * // # 2.6 off by context and event name
     * CustomEvents.off(myObj, 'onload');
     *
     * // # 2.7 off by an Object.<string, function> that is {eventName: handler}
     * CustomEvents.off({
     *   'play': handler,
     *   'pause': handler2
     * });
     *
     * // # 2.8 off the all events
     * CustomEvents.off();
     */
    CustomEvents.prototype.off = function(eventName, handler) {
      if (isString(eventName)) {
        // [syntax 1, 2]
        this._offByEventName(eventName, handler);
      } else if (!arguments.length) {
        // [syntax 8]
        this.events = {};
        this.contexts = [];
      } else if (isFunction(eventName)) {
        // [syntax 3]
        this._offByHandler(eventName);
      } else if (isObject(eventName)) {
        // [syntax 4, 5, 6]
        this._offByObject(eventName, handler);
      }
    };

    /**
     * Fire custom event
     * @param {string} eventName - name of custom event
     */
    CustomEvents.prototype.fire = function(eventName) {  // eslint-disable-line
      this.invoke.apply(this, arguments);
    };

    /**
     * Fire a event and returns the result of operation 'boolean AND' with all
     *  listener's results.
     *
     * So, It is different from {@link CustomEvents#fire}.
     *
     * In service code, use this as a before event in component level usually
     *  for notifying that the event is cancelable.
     * @param {string} eventName - Custom event name
     * @param {...*} data - Data for event
     * @returns {boolean} The result of operation 'boolean AND'
     * @example
     * var map = new Map();
     * map.on({
     *     'beforeZoom': function() {
     *         // It should cancel the 'zoom' event by some conditions.
     *         if (that.disabled && this.getState()) {
     *             return false;
     *         }
     *         return true;
     *     }
     * });
     *
     * if (this.invoke('beforeZoom')) {    // check the result of 'beforeZoom'
     *     // if true,
     *     // doSomething
     * }
     */
    CustomEvents.prototype.invoke = function(eventName) {
      var events, args, index, item;

      if (!this.hasListener(eventName)) {
        return true;
      }

      events = this._safeEvent(eventName);
      args = Array.prototype.slice.call(arguments, 1);
      index = 0;

      while (events[index]) {
        item = events[index];

        if (item.handler.apply(item.context, args) === false) {
          return false;
        }

        index += 1;
      }

      return true;
    };

    /**
     * Return whether at least one of the handlers is registered in the given
     *  event name.
     * @param {string} eventName - Custom event name
     * @returns {boolean} Is there at least one handler in event name?
     */
    CustomEvents.prototype.hasListener = function(eventName) {
      return this.getListenerLength(eventName) > 0;
    };

    /**
     * Return a count of events registered.
     * @param {string} eventName - Custom event name
     * @returns {number} number of event
     */
    CustomEvents.prototype.getListenerLength = function(eventName) {
      var events = this._safeEvent(eventName);

      return events.length;
    };

    module.exports = CustomEvents;


    /***/ }),
    /* 14 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is existing or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var isUndefined = __webpack_require__(1);
    var isNull = __webpack_require__(15);

    /**
     * Check whether the given variable is existing or not.
     * If the given variable is not null and not undefined, returns true.
     * @param {*} param - Target for checking
     * @returns {boolean} Is existy?
     * @memberof module:type
     * @example
     * var isExisty = require('tui-code-snippet/type/isExisty'); // node, commonjs
     *
     * isExisty(''); //true
     * isExisty(0); //true
     * isExisty([]); //true
     * isExisty({}); //true
     * isExisty(null); //false
     * isExisty(undefined); //false
    */
    function isExisty(param) {
      return !isUndefined(param) && !isNull(param);
    }

    module.exports = isExisty;


    /***/ }),
    /* 15 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is null or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Check whether the given variable is null or not.
     * If the given variable(arguments[0]) is null, returns true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is null?
     * @memberof module:type
     */
    function isNull(obj) {
      return obj === null;
    }

    module.exports = isNull;


    /***/ }),
    /* 16 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is an object or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Check whether the given variable is an object or not.
     * If the given variable is an object, return true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is object?
     * @memberof module:type
     */
    function isObject(obj) {
      return obj === Object(obj);
    }

    module.exports = isObject;


    /***/ }),
    /* 17 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Execute the provided callback once for each element present in the array(or Array-like object) in ascending order.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Execute the provided callback once for each element present
     * in the array(or Array-like object) in ascending order.
     * If the callback function returns false, the loop will be stopped.
     * Callback function(iteratee) is invoked with three arguments:
     *  1) The value of the element
     *  2) The index of the element
     *  3) The array(or Array-like object) being traversed
     * @param {Array|Arguments|NodeList} arr The array(or Array-like object) that will be traversed
     * @param {function} iteratee Callback function
     * @param {Object} [context] Context(this) of callback function
     * @memberof module:collection
     * @example
     * var forEachArray = require('tui-code-snippet/collection/forEachArray'); // node, commonjs
     *
     * var sum = 0;
     *
     * forEachArray([1,2,3], function(value){
     *     sum += value;
     * });
     * alert(sum); // 6
     */
    function forEachArray(arr, iteratee, context) {
      var index = 0;
      var len = arr.length;

      context = context || null;

      for (; index < len; index += 1) {
        if (iteratee.call(context, arr[index], index, arr) === false) {
          break;
        }
      }
    }

    module.exports = forEachArray;


    /***/ }),
    /* 18 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Provide a simple inheritance in prototype-oriented.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var createObject = __webpack_require__(19);

    /**
     * Provide a simple inheritance in prototype-oriented.
     * Caution :
     *  Don't overwrite the prototype of child constructor.
     *
     * @param {function} subType Child constructor
     * @param {function} superType Parent constructor
     * @memberof module:inheritance
     * @example
     * var inherit = require('tui-code-snippet/inheritance/inherit'); // node, commonjs
     *
     * // Parent constructor
     * function Animal(leg) {
     *     this.leg = leg;
     * }
     * Animal.prototype.growl = function() {
     *     // ...
     * };
     *
     * // Child constructor
     * function Person(name) {
     *     this.name = name;
     * }
     *
     * // Inheritance
     * inherit(Person, Animal);
     *
     * // After this inheritance, please use only the extending of property.
     * // Do not overwrite prototype.
     * Person.prototype.walk = function(direction) {
     *     // ...
     * };
     */
    function inherit(subType, superType) {
      var prototype = createObject(superType.prototype);
      prototype.constructor = subType;
      subType.prototype = prototype;
    }

    module.exports = inherit;


    /***/ }),
    /* 19 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Create a new object with the specified prototype object and properties.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * @module inheritance
     */

    /**
     * Create a new object with the specified prototype object and properties.
     * @param {Object} obj This object will be a prototype of the newly-created object.
     * @returns {Object}
     * @memberof module:inheritance
     */
    function createObject(obj) {
      function F() {} // eslint-disable-line require-jsdoc
      F.prototype = obj;

      return new F();
    }

    module.exports = createObject;


    /***/ }),
    /* 20 */
    /***/ (function(module, exports, __webpack_require__) {


    var forEach = __webpack_require__(3);
    var defineClass = __webpack_require__(7);
    var getTarget = __webpack_require__(21);
    var on = __webpack_require__(22);
    var preventDefault = __webpack_require__(24);
    var addClass = __webpack_require__(25);
    var extend = __webpack_require__(0);
    var isString = __webpack_require__(4);
    var isHTMLNode = __webpack_require__(28);

    var util = __webpack_require__(9);

    var defaultTemplate = {
      page: '<a href="#" class="tui-page-btn">{{page}}</a>',
      currentPage: '<strong class="tui-page-btn tui-is-selected">{{page}}</strong>',
      moveButton:
        '<a href="#" class="tui-page-btn tui-{{type}}">' +
        '<span class="tui-ico-{{type}}">{{type}}</span>' +
        '</a>',
      disabledMoveButton:
        '<span class="tui-page-btn tui-is-disabled tui-{{type}}">' +
        '<span class="tui-ico-{{type}}">{{type}}</span>' +
        '</span>',
      moreButton:
        '<a href="#" class="tui-page-btn tui-{{type}}-is-ellip">' +
        '<span class="tui-ico-ellip">...</span>' +
        '</a>'
    };
    var moveButtons = ['first', 'prev', 'next', 'last'];
    var moreButtons = ['prev', 'next'];

    var INVALID_CONTAINER_ELEMENT = 'The container element is invalid.';

    /**
     * Pagination view class
     * @class View
     * @param {string|HTMLElement|jQueryObject} container - Container element or id selector
     * @param {object} options - Option object
     *     @param {number} [options.totalItems=10] Total item count
     *     @param {number} [options.itemsPerPage=10] Item count per page
     *     @param {number} [options.visiblePages=10] Display page link count
     *     @param {number} [options.page=1] Display page after pagination draw.
     *     @param {boolean}[options.centerAlign=false] Whether current page keep center or not
     *     @param {string} [options.firstItemClassName='first-child'] The class name of the first item
     *     @param {string} [options.lastItemClassName='last-child'] The class name of the last item
     *     @param {object} [options.template] A markup string set to make element
     *         @param {string|function} [options.template.page] HTML template
     *         @param {string|function} [options.template.currentPage] HTML template
     *         @param {string|function} [options.template.moveButton] HTML template
     *         @param {string|function} [options.template.disabledMoveButton] HTML template
     *         @param {string|function} [options.template.moreButton] HTML template
     * @param {function} handler - Event handler
     * @ignore
     */
    var View = defineClass(
      /** @lends View.prototype */ {
        init: function(container, options, handler) {
          /**
           * Root element
           * @type {HTMLElement}
           * @private
           */
          this._containerElement = null;

          /**
           * First item's class name
           * @type {string}
           * @private
           */
          this._firstItemClassName = options.firstItemClassName;

          /**
           * Last item's class name
           * @type {string}
           * @private
           */
          this._lastItemClassName = options.lastItemClassName;

          /**
           * Default template
           * @type {object.<string, string|function>}
           * @private
           */
          this._template = extend({}, defaultTemplate, options.template);

          /**
           * Map of buttons
           * @type {object.<string, HTMLElement>}
           * @private
           */
          this._buttons = {};

          /**
           * Enabled page elements list
           * @type {array}
           * @private
           */

          this._enabledPageElements = [];

          this._setRootElement(container);
          this._setMoveButtons();
          this._setDisabledMoveButtons();
          this._setMoreButtons();
          this._attachClickEvent(handler);
        },
        /* eslint-enable complexity */

        /**
         * Set root element
         * @param {string|HTMLElement|jQueryObject} container - Container element or id selector
         * @private
         */
        _setRootElement: function(container) {
          if (isString(container)) {
            container = document.getElementById(container) || document.querySelector(container);
          } else if (container.jquery) {
            container = container[0];
          }

          if (!isHTMLNode(container)) {
            throw new Error(INVALID_CONTAINER_ELEMENT);
          }

          this._containerElement = container;
        },

        /**
         * Assign move buttons to option
         * @private
         */
        _setMoveButtons: function() {
          forEach(
            moveButtons,
            function(type) {
              this._buttons[type] = util.createElementByTemplate(this._template.moveButton, {
                type: type
              });
            },
            this
          );
        },

        /**
         * Assign disabled move buttons to option
         * @private
         */
        _setDisabledMoveButtons: function() {
          forEach(
            moveButtons,
            function(type) {
              var key = 'disabled' + util.capitalizeFirstLetter(type);
              this._buttons[key] = util.createElementByTemplate(this._template.disabledMoveButton, {
                type: type
              });
            },
            this
          );
        },

        /**
         * Assign more buttons to option
         * @private
         */
        _setMoreButtons: function() {
          forEach(
            moreButtons,
            function(type) {
              var key = type + 'More';
              this._buttons[key] = util.createElementByTemplate(this._template.moreButton, {
                type: type
              });
            },
            this
          );
        },
        /* eslint-enable camelcase */

        /**
         * Get container element
         * @returns {HTMLElement} Container element
         * @private
         */
        _getContainerElement: function() {
          return this._containerElement;
        },

        /**
         * Append first button on container element
         * @param {object} viewData - View data to render pagination
         * @private
         */
        _appendFirstButton: function(viewData) {
          var button;

          if (viewData.page > 1) {
            button = this._buttons.first;
          } else {
            button = this._buttons.disabledFirst;
          }

          this._getContainerElement().appendChild(button);
        },

        /**
         * Append previous button on container element
         * @param {object} viewData - View data to render pagination
         * @private
         */
        _appendPrevButton: function(viewData) {
          var button;

          if (viewData.currentPageIndex > 1) {
            button = this._buttons.prev;
          } else {
            button = this._buttons.disabledPrev;
          }

          this._getContainerElement().appendChild(button);
        },

        /**
         * Append next button on container element
         * @param {object} viewData - View data to render pagination
         * @private
         */
        _appendNextButton: function(viewData) {
          var button;

          if (viewData.currentPageIndex < viewData.lastPageListIndex) {
            button = this._buttons.next;
          } else {
            button = this._buttons.disabledNext;
          }

          this._getContainerElement().appendChild(button);
        },

        /**
         * Append last button on container element
         * @param {object} viewData - View data to render pagination
         * @private
         */
        _appendLastButton: function(viewData) {
          var button;

          if (viewData.page < viewData.lastPage) {
            button = this._buttons.last;
          } else {
            button = this._buttons.disabledLast;
          }

          this._getContainerElement().appendChild(button);
        },

        /**
         * Append previous more button on container element
         * @param {object} viewData - View data to render pagination
         * @private
         */
        _appendPrevMoreButton: function(viewData) {
          var button;

          if (viewData.prevMore) {
            button = this._buttons.prevMore;
            addClass(button, this._firstItemClassName);
            this._getContainerElement().appendChild(button);
          }
        },

        /**
         * Append next more button on container element
         * @param {object} viewData - View data to render pagination
         * @private
         */
        _appendNextMoreButton: function(viewData) {
          var button;

          if (viewData.nextMore) {
            button = this._buttons.nextMore;
            addClass(button, this._lastItemClassName);
            this._getContainerElement().appendChild(button);
          }
        },

        /**
         * Append page number elements on container element
         * @param {object} viewData - View data to render pagination
         * @private
         */
        // eslint-disable-next-line complexity
        _appendPages: function(viewData) {
          var firstPage = viewData.leftPageNumber;
          var lastPage = viewData.rightPageNumber;
          var pageItem, i;

          for (i = firstPage; i <= lastPage; i += 1) {
            if (i === viewData.page) {
              pageItem = util.createElementByTemplate(this._template.currentPage, { page: i });
            } else {
              pageItem = util.createElementByTemplate(this._template.page, { page: i });
              this._enabledPageElements.push(pageItem);
            }

            if (i === firstPage && !viewData.prevMore) {
              addClass(pageItem, this._firstItemClassName);
            }
            if (i === lastPage && !viewData.nextMore) {
              addClass(pageItem, this._lastItemClassName);
            }
            this._getContainerElement().appendChild(pageItem);
          }
        },

        /**
         * Attach click event
         * @param {function} callback - Callback function
         * @private
         */
        _attachClickEvent: function(callback) {
          var rootElement = this._getContainerElement();

          on(
            rootElement,
            'click',
            function(ev) {
              var target = getTarget(ev);
              var page, buttonType;

              preventDefault(ev);

              buttonType = this._getButtonType(target);

              if (!buttonType) {
                page = this._getPageNumber(target);
              }

              callback(buttonType, page);
            },
            this
          );
        },

        /**
         * Get button type to move button elements
         * @param {HTMLElement} targetElement - Each move button element
         * @returns {?string} Button type
         * @private
         */
        _getButtonType: function(targetElement) {
          var buttonType;
          var buttons = this._buttons;

          forEach(
            buttons,
            function(button, type) {
              if (util.isContained(targetElement, button)) {
                buttonType = type;

                return false;
              }

              return true;
            },
            this
          );

          return buttonType;
        },
        /* eslint-enable no-lonely-if */

        /**
         * Get number to page elements
         * @param {HTMLElement} targetElement - Each page element
         * @returns {?number} Page number
         * @private
         */
        _getPageNumber: function(targetElement) {
          var targetPage = this._findPageElement(targetElement);
          var page;

          if (targetPage) {
            page = parseInt(targetPage.innerText, 10);
          }

          return page;
        },

        /**
         * Find target element from page elements
         * @param {HTMLElement} targetElement - Each page element
         * @returns {HTMLElement} Found element
         * @ignore
         */
        _findPageElement: function(targetElement) {
          var i = 0;
          var length = this._enabledPageElements.length;
          var pickedItem;

          for (; i < length; i += 1) {
            pickedItem = this._enabledPageElements[i];

            if (util.isContained(targetElement, pickedItem)) {
              return pickedItem;
            }
          }

          return null;
        },

        /**
         * Reset container element
         * @private
         */
        _empty: function() {
          this._enabledPageElements = [];

          forEach(
            this._buttons,
            function(buttonElement, type) {
              this._buttons[type] = buttonElement.cloneNode(true);
            },
            this
          );

          this._getContainerElement().innerHTML = '';
        },

        /**
         * Update view
         * @param {object} viewData - View data to render pagination
         * @ignore
         */
        update: function(viewData) {
          this._empty();
          this._appendFirstButton(viewData);
          this._appendPrevButton(viewData);
          this._appendPrevMoreButton(viewData);
          this._appendPages(viewData);
          this._appendNextMoreButton(viewData);
          this._appendNextButton(viewData);
          this._appendLastButton(viewData);
        }
      }
    );

    module.exports = View;


    /***/ }),
    /* 21 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Get a target element from an event object.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Get a target element from an event object.
     * @param {Event} e - event object
     * @returns {HTMLElement} - target element
     * @memberof module:domEvent
     */
    function getTarget(e) {
      return e.target || e.srcElement;
    }

    module.exports = getTarget;


    /***/ }),
    /* 22 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Bind DOM events
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var isString = __webpack_require__(4);
    var forEach = __webpack_require__(3);

    var safeEvent = __webpack_require__(23);

    /**
     * Bind DOM events.
     * @param {HTMLElement} element - element to bind events
     * @param {(string|object)} types - Space splitted events names or eventName:handler object
     * @param {(function|object)} handler - handler function or context for handler method
     * @param {object} [context] context - context for handler method.
     * @memberof module:domEvent
     * @example
     * var div = document.querySelector('div');
     * 
     * // Bind one event to an element.
     * on(div, 'click', toggle);
     * 
     * // Bind multiple events with a same handler to multiple elements at once.
     * // Use event names splitted by a space.
     * on(div, 'mouseenter mouseleave', changeColor);
     * 
     * // Bind multiple events with different handlers to an element at once.
     * // Use an object which of key is an event name and value is a handler function.
     * on(div, {
     *   keydown: highlight,
     *   keyup: dehighlight
     * });
     * 
     * // Set a context for handler method.
     * var name = 'global';
     * var repository = {name: 'CodeSnippet'};
     * on(div, 'drag', function() {
     *  console.log(this.name);
     * }, repository);
     * // Result when you drag a div: "CodeSnippet"
     */
    function on(element, types, handler, context) {
      if (isString(types)) {
        forEach(types.split(/\s+/g), function(type) {
          bindEvent(element, type, handler, context);
        });

        return;
      }

      forEach(types, function(func, type) {
        bindEvent(element, type, func, handler);
      });
    }

    /**
     * Bind DOM events
     * @param {HTMLElement} element - element to bind events
     * @param {string} type - events name
     * @param {function} handler - handler function or context for handler method
     * @param {object} [context] context - context for handler method.
     * @private
     */
    function bindEvent(element, type, handler, context) {
      /**
         * Event handler
         * @param {Event} e - event object
         */
      function eventHandler(e) {
        handler.call(context || element, e || window.event);
      }

      if ('addEventListener' in element) {
        element.addEventListener(type, eventHandler);
      } else if ('attachEvent' in element) {
        element.attachEvent('on' + type, eventHandler);
      }
      memorizeHandler(element, type, handler, eventHandler);
    }

    /**
     * Memorize DOM event handler for unbinding.
     * @param {HTMLElement} element - element to bind events
     * @param {string} type - events name
     * @param {function} handler - handler function that user passed at on() use
     * @param {function} wrappedHandler - handler function that wrapped by domevent for implementing some features
     * @private
     */
    function memorizeHandler(element, type, handler, wrappedHandler) {
      var events = safeEvent(element, type);
      var existInEvents = false;

      forEach(events, function(obj) {
        if (obj.handler === handler) {
          existInEvents = true;

          return false;
        }

        return true;
      });

      if (!existInEvents) {
        events.push({
          handler: handler,
          wrappedHandler: wrappedHandler
        });
      }
    }

    module.exports = on;


    /***/ }),
    /* 23 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Get event collection for specific HTML element
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var EVENT_KEY = '_feEventKey';

    /**
     * Get event collection for specific HTML element
     * @param {HTMLElement} element - HTML element
     * @param {string} type - event type
     * @returns {array}
     * @private
     */
    function safeEvent(element, type) {
      var events = element[EVENT_KEY];
      var handlers;

      if (!events) {
        events = element[EVENT_KEY] = {};
      }

      handlers = events[type];
      if (!handlers) {
        handlers = events[type] = [];
      }

      return handlers;
    }

    module.exports = safeEvent;


    /***/ }),
    /* 24 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Prevent default action
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Prevent default action
     * @param {Event} e - event object
     * @memberof module:domEvent
     */
    function preventDefault(e) {
      if (e.preventDefault) {
        e.preventDefault();

        return;
      }

      e.returnValue = false;
    }

    module.exports = preventDefault;


    /***/ }),
    /* 25 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Add css class to element
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var forEach = __webpack_require__(3);
    var inArray = __webpack_require__(8);
    var getClass = __webpack_require__(26);
    var setClassName = __webpack_require__(27);

    /**
     * domUtil module
     * @module domUtil
     */

    /**
     * Add css class to element
     * @param {(HTMLElement|SVGElement)} element - target element
     * @param {...string} cssClass - css classes to add
     * @memberof module:domUtil
     */
    function addClass(element) {
      var cssClass = Array.prototype.slice.call(arguments, 1);
      var classList = element.classList;
      var newClass = [];
      var origin;

      if (classList) {
        forEach(cssClass, function(name) {
          element.classList.add(name);
        });

        return;
      }

      origin = getClass(element);

      if (origin) {
        cssClass = [].concat(origin.split(/\s+/), cssClass);
      }

      forEach(cssClass, function(cls) {
        if (inArray(cls, newClass) < 0) {
          newClass.push(cls);
        }
      });

      setClassName(element, newClass);
    }

    module.exports = addClass;


    /***/ }),
    /* 26 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Get HTML element's design classes.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var isUndefined = __webpack_require__(1);

    /**
     * Get HTML element's design classes.
     * @param {(HTMLElement|SVGElement)} element target element
     * @returns {string} element css class name
     * @memberof module:domUtil
     */
    function getClass(element) {
      if (!element || !element.className) {
        return '';
      }

      if (isUndefined(element.className.baseVal)) {
        return element.className;
      }

      return element.className.baseVal;
    }

    module.exports = getClass;


    /***/ }),
    /* 27 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Set className value
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var isArray = __webpack_require__(2);
    var isUndefined = __webpack_require__(1);

    /**
     * Set className value
     * @param {(HTMLElement|SVGElement)} element - target element
     * @param {(string|string[])} cssClass - class names
     * @private
     */
    function setClassName(element, cssClass) {
      cssClass = isArray(cssClass) ? cssClass.join(' ') : cssClass;

      cssClass = cssClass.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

      if (isUndefined(element.className.baseVal)) {
        element.className = cssClass;

        return;
      }

      element.className.baseVal = cssClass;
    }

    module.exports = setClassName;


    /***/ }),
    /* 28 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is a instance of HTMLNode or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Check whether the given variable is a instance of HTMLNode or not.
     * If the given variables is a instance of HTMLNode, return true.
     * @param {*} html - Target for checking
     * @returns {boolean} Is HTMLNode ?
     * @memberof module:type
     */
    function isHTMLNode(html) {
      if (typeof HTMLElement === 'object') {
        return (html && (html instanceof HTMLElement || !!html.nodeType));
      }

      return !!(html && html.nodeType);
    }

    module.exports = isHTMLNode;


    /***/ }),
    /* 29 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Convert text by binding expressions with context.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var inArray = __webpack_require__(8);
    var forEach = __webpack_require__(3);
    var isArray = __webpack_require__(2);
    var isString = __webpack_require__(4);
    var extend = __webpack_require__(0);

    // IE8 does not support capture groups.
    var EXPRESSION_REGEXP = /{{\s?|\s?}}/g;
    var BRACKET_NOTATION_REGEXP = /^[a-zA-Z0-9_@]+\[[a-zA-Z0-9_@"']+\]$/;
    var BRACKET_REGEXP = /\[\s?|\s?\]/;
    var DOT_NOTATION_REGEXP = /^[a-zA-Z_]+\.[a-zA-Z_]+$/;
    var DOT_REGEXP = /\./;
    var STRING_NOTATION_REGEXP = /^["']\w+["']$/;
    var STRING_REGEXP = /"|'/g;
    var NUMBER_REGEXP = /^-?\d+\.?\d*$/;

    var EXPRESSION_INTERVAL = 2;

    var BLOCK_HELPERS = {
      'if': handleIf,
      'each': handleEach,
      'with': handleWith
    };

    var isValidSplit = 'a'.split(/a/).length === 3;

    /**
     * Split by RegExp. (Polyfill for IE8)
     * @param {string} text - text to be splitted\
     * @param {RegExp} regexp - regular expression
     * @returns {Array.<string>}
     */
    var splitByRegExp = (function() {
      if (isValidSplit) {
        return function(text, regexp) {
          return text.split(regexp);
        };
      }

      return function(text, regexp) {
        var result = [];
        var prevIndex = 0;
        var match, index;

        if (!regexp.global) {
          regexp = new RegExp(regexp, 'g');
        }

        match = regexp.exec(text);
        while (match !== null) {
          index = match.index;
          result.push(text.slice(prevIndex, index));

          prevIndex = index + match[0].length;
          match = regexp.exec(text);
        }
        result.push(text.slice(prevIndex));

        return result;
      };
    })();

    /**
     * Find value in the context by an expression.
     * @param {string} exp - an expression
     * @param {object} context - context
     * @returns {*}
     * @private
     */
    // eslint-disable-next-line complexity
    function getValueFromContext(exp, context) {
      var splitedExps;
      var value = context[exp];

      if (exp === 'true') {
        value = true;
      } else if (exp === 'false') {
        value = false;
      } else if (STRING_NOTATION_REGEXP.test(exp)) {
        value = exp.replace(STRING_REGEXP, '');
      } else if (BRACKET_NOTATION_REGEXP.test(exp)) {
        splitedExps = exp.split(BRACKET_REGEXP);
        value = getValueFromContext(splitedExps[0], context)[getValueFromContext(splitedExps[1], context)];
      } else if (DOT_NOTATION_REGEXP.test(exp)) {
        splitedExps = exp.split(DOT_REGEXP);
        value = getValueFromContext(splitedExps[0], context)[splitedExps[1]];
      } else if (NUMBER_REGEXP.test(exp)) {
        value = parseFloat(exp);
      }

      return value;
    }

    /**
     * Extract elseif and else expressions.
     * @param {Array.<string>} ifExps - args of if expression
     * @param {Array.<string>} sourcesInsideBlock - sources inside if block
     * @returns {object} - exps: expressions of if, elseif, and else / sourcesInsideIf: sources inside if, elseif, and else block.
     * @private
     */
    function extractElseif(ifExps, sourcesInsideBlock) {
      var exps = [ifExps];
      var sourcesInsideIf = [];
      var otherIfCount = 0;
      var start = 0;

      // eslint-disable-next-line complexity
      forEach(sourcesInsideBlock, function(source, index) {
        if (source.indexOf('if') === 0) {
          otherIfCount += 1;
        } else if (source === '/if') {
          otherIfCount -= 1;
        } else if (!otherIfCount && (source.indexOf('elseif') === 0 || source === 'else')) {
          exps.push(source === 'else' ? ['true'] : source.split(' ').slice(1));
          sourcesInsideIf.push(sourcesInsideBlock.slice(start, index));
          start = index + 1;
        }
      });

      sourcesInsideIf.push(sourcesInsideBlock.slice(start));

      return {
        exps: exps,
        sourcesInsideIf: sourcesInsideIf
      };
    }

    /**
     * Helper function for "if". 
     * @param {Array.<string>} exps - array of expressions split by spaces
     * @param {Array.<string>} sourcesInsideBlock - array of sources inside the if block
     * @param {object} context - context
     * @returns {string}
     * @private
     */
    function handleIf(exps, sourcesInsideBlock, context) {
      var analyzed = extractElseif(exps, sourcesInsideBlock);
      var result = false;
      var compiledSource = '';

      forEach(analyzed.exps, function(exp, index) {
        result = handleExpression(exp, context);
        if (result) {
          compiledSource = compile(analyzed.sourcesInsideIf[index], context);
        }

        return !result;
      });

      return compiledSource;
    }

    /**
     * Helper function for "each".
     * @param {Array.<string>} exps - array of expressions split by spaces
     * @param {Array.<string>} sourcesInsideBlock - array of sources inside the each block
     * @param {object} context - context
     * @returns {string}
     * @private
     */
    function handleEach(exps, sourcesInsideBlock, context) {
      var collection = handleExpression(exps, context);
      var additionalKey = isArray(collection) ? '@index' : '@key';
      var additionalContext = {};
      var result = '';

      forEach(collection, function(item, key) {
        additionalContext[additionalKey] = key;
        additionalContext['@this'] = item;
        extend(context, additionalContext);

        result += compile(sourcesInsideBlock.slice(), context);
      });

      return result;
    }

    /**
     * Helper function for "with ... as"
     * @param {Array.<string>} exps - array of expressions split by spaces
     * @param {Array.<string>} sourcesInsideBlock - array of sources inside the with block
     * @param {object} context - context
     * @returns {string}
     * @private
     */
    function handleWith(exps, sourcesInsideBlock, context) {
      var asIndex = inArray('as', exps);
      var alias = exps[asIndex + 1];
      var result = handleExpression(exps.slice(0, asIndex), context);

      var additionalContext = {};
      additionalContext[alias] = result;

      return compile(sourcesInsideBlock, extend(context, additionalContext)) || '';
    }

    /**
     * Extract sources inside block in place.
     * @param {Array.<string>} sources - array of sources
     * @param {number} start - index of start block
     * @param {number} end - index of end block
     * @returns {Array.<string>}
     * @private
     */
    function extractSourcesInsideBlock(sources, start, end) {
      var sourcesInsideBlock = sources.splice(start + 1, end - start);
      sourcesInsideBlock.pop();

      return sourcesInsideBlock;
    }

    /**
     * Handle block helper function
     * @param {string} helperKeyword - helper keyword (ex. if, each, with)
     * @param {Array.<string>} sourcesToEnd - array of sources after the starting block
     * @param {object} context - context
     * @returns {Array.<string>}
     * @private
     */
    function handleBlockHelper(helperKeyword, sourcesToEnd, context) {
      var executeBlockHelper = BLOCK_HELPERS[helperKeyword];
      var helperCount = 1;
      var startBlockIndex = 0;
      var endBlockIndex;
      var index = startBlockIndex + EXPRESSION_INTERVAL;
      var expression = sourcesToEnd[index];

      while (helperCount && isString(expression)) {
        if (expression.indexOf(helperKeyword) === 0) {
          helperCount += 1;
        } else if (expression.indexOf('/' + helperKeyword) === 0) {
          helperCount -= 1;
          endBlockIndex = index;
        }

        index += EXPRESSION_INTERVAL;
        expression = sourcesToEnd[index];
      }

      if (helperCount) {
        throw Error(helperKeyword + ' needs {{/' + helperKeyword + '}} expression.');
      }

      sourcesToEnd[startBlockIndex] = executeBlockHelper(
        sourcesToEnd[startBlockIndex].split(' ').slice(1),
        extractSourcesInsideBlock(sourcesToEnd, startBlockIndex, endBlockIndex),
        context
      );

      return sourcesToEnd;
    }

    /**
     * Helper function for "custom helper".
     * If helper is not a function, return helper itself.
     * @param {Array.<string>} exps - array of expressions split by spaces (first element: helper)
     * @param {object} context - context
     * @returns {string}
     * @private
     */
    function handleExpression(exps, context) {
      var result = getValueFromContext(exps[0], context);

      if (result instanceof Function) {
        return executeFunction(result, exps.slice(1), context);
      }

      return result;
    }

    /**
     * Execute a helper function.
     * @param {Function} helper - helper function
     * @param {Array.<string>} argExps - expressions of arguments
     * @param {object} context - context
     * @returns {string} - result of executing the function with arguments
     * @private
     */
    function executeFunction(helper, argExps, context) {
      var args = [];
      forEach(argExps, function(exp) {
        args.push(getValueFromContext(exp, context));
      });

      return helper.apply(null, args);
    }

    /**
     * Get a result of compiling an expression with the context.
     * @param {Array.<string>} sources - array of sources split by regexp of expression.
     * @param {object} context - context
     * @returns {Array.<string>} - array of sources that bind with its context
     * @private
     */
    function compile(sources, context) {
      var index = 1;
      var expression = sources[index];
      var exps, firstExp, result;

      while (isString(expression)) {
        exps = expression.split(' ');
        firstExp = exps[0];

        if (BLOCK_HELPERS[firstExp]) {
          result = handleBlockHelper(firstExp, sources.splice(index, sources.length - index), context);
          sources = sources.concat(result);
        } else {
          sources[index] = handleExpression(exps, context);
        }

        index += EXPRESSION_INTERVAL;
        expression = sources[index];
      }

      return sources.join('');
    }

    /**
     * Convert text by binding expressions with context.
     * <br>
     * If expression exists in the context, it will be replaced.
     * ex) '{{title}}' with context {title: 'Hello!'} is converted to 'Hello!'.
     * An array or object can be accessed using bracket and dot notation.
     * ex) '{{odds\[2\]}}' with context {odds: \[1, 3, 5\]} is converted to '5'.
     * ex) '{{evens\[first\]}}' with context {evens: \[2, 4\], first: 0} is converted to '2'.
     * ex) '{{project\["name"\]}}' and '{{project.name}}' with context {project: {name: 'CodeSnippet'}} is converted to 'CodeSnippet'.
     * <br>
     * If replaced expression is a function, next expressions will be arguments of the function.
     * ex) '{{add 1 2}}' with context {add: function(a, b) {return a + b;}} is converted to '3'.
     * <br>
     * It has 3 predefined block helpers '{{helper ...}} ... {{/helper}}': 'if', 'each', 'with ... as ...'.
     * 1) 'if' evaluates conditional statements. It can use with 'elseif' and 'else'.
     * 2) 'each' iterates an array or object. It provides '@index'(array), '@key'(object), and '@this'(current element).
     * 3) 'with ... as ...' provides an alias.
     * @param {string} text - text with expressions
     * @param {object} context - context
     * @returns {string} - text that bind with its context
     * @memberof module:domUtil
     * @example
     * var template = require('tui-code-snippet/domUtil/template');
     * 
     * var source = 
     *     '<h1>'
     *   +   '{{if isValidNumber title}}'
     *   +     '{{title}}th'
     *   +   '{{elseif isValidDate title}}'
     *   +     'Date: {{title}}'
     *   +   '{{/if}}'
     *   + '</h1>'
     *   + '{{each list}}'
     *   +   '{{with addOne @index as idx}}'
     *   +     '<p>{{idx}}: {{@this}}</p>'
     *   +   '{{/with}}'
     *   + '{{/each}}';
     * 
     * var context = {
     *   isValidDate: function(text) {
     *     return /^\d{4}-(0|1)\d-(0|1|2|3)\d$/.test(text);
     *   },
     *   isValidNumber: function(text) {
     *     return /^\d+$/.test(text);
     *   }
     *   title: '2019-11-25',
     *   list: ['Clean the room', 'Wash the dishes'],
     *   addOne: function(num) {
     *     return num + 1;
     *   }
     * };
     * 
     * var result = template(source, context);
     * console.log(result); // <h1>Date: 2019-11-25</h1><p>1: Clean the room</p><p>2: Wash the dishes</p>
     */
    function template(text, context) {
      return compile(splitByRegExp(text, EXPRESSION_REGEXP), context);
    }

    module.exports = template;


    /***/ }),
    /* 30 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Send hostname on DOMContentLoaded.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var isUndefined = __webpack_require__(1);
    var imagePing = __webpack_require__(31);

    var ms7days = 7 * 24 * 60 * 60 * 1000;

    /**
     * Check if the date has passed 7 days
     * @param {number} date - milliseconds
     * @returns {boolean}
     * @private
     */
    function isExpired(date) {
      var now = new Date().getTime();

      return now - date > ms7days;
    }

    /**
     * Send hostname on DOMContentLoaded.
     * To prevent hostname set tui.usageStatistics to false.
     * @param {string} appName - application name
     * @param {string} trackingId - GA tracking ID
     * @ignore
     */
    function sendHostname(appName, trackingId) {
      var url = 'https://www.google-analytics.com/collect';
      var hostname = location.hostname;
      var hitType = 'event';
      var eventCategory = 'use';
      var applicationKeyForStorage = 'TOAST UI ' + appName + ' for ' + hostname + ': Statistics';
      var date = window.localStorage.getItem(applicationKeyForStorage);

      // skip if the flag is defined and is set to false explicitly
      if (!isUndefined(window.tui) && window.tui.usageStatistics === false) {
        return;
      }

      // skip if not pass seven days old
      if (date && !isExpired(date)) {
        return;
      }

      window.localStorage.setItem(applicationKeyForStorage, new Date().getTime());

      setTimeout(function() {
        if (document.readyState === 'interactive' || document.readyState === 'complete') {
          imagePing(url, {
            v: 1,
            t: hitType,
            tid: trackingId,
            cid: hostname,
            dp: hostname,
            dh: appName,
            el: appName,
            ec: eventCategory
          });
        }
      }, 1000);
    }

    module.exports = sendHostname;


    /***/ }),
    /* 31 */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Request image ping.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var forEachOwnProperties = __webpack_require__(6);

    /**
     * @module request
     */

    /**
     * Request image ping.
     * @param {String} url url for ping request
     * @param {Object} trackingInfo infos for make query string
     * @returns {HTMLElement}
     * @memberof module:request
     * @example
     * var imagePing = require('tui-code-snippet/request/imagePing'); // node, commonjs
     *
     * imagePing('https://www.google-analytics.com/collect', {
     *     v: 1,
     *     t: 'event',
     *     tid: 'trackingid',
     *     cid: 'cid',
     *     dp: 'dp',
     *     dh: 'dh'
     * });
     */
    function imagePing(url, trackingInfo) {
      var trackingElement = document.createElement('img');
      var queryString = '';
      forEachOwnProperties(trackingInfo, function(value, key) {
        queryString += '&' + key + '=' + value;
      });
      queryString = queryString.substring(1);

      trackingElement.src = url + '?' + queryString;

      trackingElement.style.display = 'none';
      document.body.appendChild(trackingElement);
      document.body.removeChild(trackingElement);

      return trackingElement;
    }

    module.exports = imagePing;


    /***/ })
    /******/ ]);
    });
    }(tuiPagination));

    /*!
     * TOAST UI Grid
     * @version 4.18.1 | Wed Jul 14 2021
     * @author NHN. FE Development Lab
     * @license MIT
     */

    (function (module, exports) {
    (function webpackUniversalModuleDefinition(root, factory) {
    	module.exports = factory(tuiDatePicker.exports, tuiPagination.exports);
    })(window, function(__WEBPACK_EXTERNAL_MODULE__40__, __WEBPACK_EXTERNAL_MODULE__118__) {
    return /******/ (function(modules) { // webpackBootstrap
    /******/ 	// The module cache
    /******/ 	var installedModules = {};
    /******/
    /******/ 	// The require function
    /******/ 	function __webpack_require__(moduleId) {
    /******/
    /******/ 		// Check if module is in cache
    /******/ 		if(installedModules[moduleId]) {
    /******/ 			return installedModules[moduleId].exports;
    /******/ 		}
    /******/ 		// Create a new module (and put it into the cache)
    /******/ 		var module = installedModules[moduleId] = {
    /******/ 			i: moduleId,
    /******/ 			l: false,
    /******/ 			exports: {}
    /******/ 		};
    /******/
    /******/ 		// Execute the module function
    /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    /******/
    /******/ 		// Flag the module as loaded
    /******/ 		module.l = true;
    /******/
    /******/ 		// Return the exports of the module
    /******/ 		return module.exports;
    /******/ 	}
    /******/
    /******/
    /******/ 	// expose the modules object (__webpack_modules__)
    /******/ 	__webpack_require__.m = modules;
    /******/
    /******/ 	// expose the module cache
    /******/ 	__webpack_require__.c = installedModules;
    /******/
    /******/ 	// define getter function for harmony exports
    /******/ 	__webpack_require__.d = function(exports, name, getter) {
    /******/ 		if(!__webpack_require__.o(exports, name)) {
    /******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
    /******/ 		}
    /******/ 	};
    /******/
    /******/ 	// define __esModule on exports
    /******/ 	__webpack_require__.r = function(exports) {
    /******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
    /******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
    /******/ 		}
    /******/ 		Object.defineProperty(exports, '__esModule', { value: true });
    /******/ 	};
    /******/
    /******/ 	// create a fake namespace object
    /******/ 	// mode & 1: value is a module id, require it
    /******/ 	// mode & 2: merge all properties of value into the ns
    /******/ 	// mode & 4: return value when already ns object
    /******/ 	// mode & 8|1: behave like require
    /******/ 	__webpack_require__.t = function(value, mode) {
    /******/ 		if(mode & 1) value = __webpack_require__(value);
    /******/ 		if(mode & 8) return value;
    /******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
    /******/ 		var ns = Object.create(null);
    /******/ 		__webpack_require__.r(ns);
    /******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
    /******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
    /******/ 		return ns;
    /******/ 	};
    /******/
    /******/ 	// getDefaultExport function for compatibility with non-harmony modules
    /******/ 	__webpack_require__.n = function(module) {
    /******/ 		var getter = module && module.__esModule ?
    /******/ 			function getDefault() { return module['default']; } :
    /******/ 			function getModuleExports() { return module; };
    /******/ 		__webpack_require__.d(getter, 'a', getter);
    /******/ 		return getter;
    /******/ 	};
    /******/
    /******/ 	// Object.prototype.hasOwnProperty.call
    /******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
    /******/
    /******/ 	// __webpack_public_path__
    /******/ 	__webpack_require__.p = "/dist";
    /******/
    /******/
    /******/ 	// Load entry module and return exports
    /******/ 	return __webpack_require__(__webpack_require__.s = 58);
    /******/ })
    /************************************************************************/
    /******/ ([
    /* 0 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.silentSplice = exports.convertTextToData = exports.endsWith = exports.startsWith = exports.uniqByProp = exports.uniq = exports.pick = exports.omit = exports.pruneObject = exports.debounce = exports.convertToNumber = exports.fromArray = exports.isEmpty = exports.isNil = exports.isString = exports.isNumber = exports.isBoolean = exports.isNull = exports.isUndefined = exports.isBlank = exports.last = exports.range = exports.clamp = exports.setDefaultProp = exports.encodeHTMLEntity = exports.hasOwnProp = exports.forEachObject = exports.isObject = exports.isFunction = exports.createMapFromArray = exports.removeArrayItem = exports.assign = exports.deepCopy = exports.deepCopyArray = exports.deepMergedCopy = exports.mapProp = exports.findOffsetIndex = exports.findPrevIndex = exports.findIndexes = exports.findPropIndex = exports.findIndex = exports.someProp = exports.some = exports.findProp = exports.find = exports.includes = exports.pipe = exports.sum = exports.arrayEqual = exports.shallowEqual = void 0;
    var tslib_1 = __webpack_require__(1);
    var CUSTOM_LF_SUBCHAR = '___tui_grid_lf___';
    var CUSTOM_CR_SUBCHAR = '___tui_grid_cr___';
    var LF = '\n';
    var CR = '\r';
    var CUSTOM_LF_REGEXP = new RegExp(CUSTOM_LF_SUBCHAR, 'g');
    var CUSTOM_CR_REGEXP = new RegExp(CUSTOM_CR_SUBCHAR, 'g');
    function shallowEqual(o1, o2) {
        for (var key in o1) {
            if (o1[key] !== o2[key]) {
                return false;
            }
        }
        for (var key in o2) {
            if (!(key in o1)) {
                return false;
            }
        }
        return true;
    }
    exports.shallowEqual = shallowEqual;
    function arrayEqual(a1, a2) {
        if (a1.length !== a2.length) {
            return false;
        }
        for (var i = 0, len = a1.length; i < len; i += 1) {
            if (a1[i] !== a2[i]) {
                return false;
            }
        }
        return true;
    }
    exports.arrayEqual = arrayEqual;
    function sum(nums) {
        return nums.reduce(function (acc, num) { return acc + num; }, 0);
    }
    exports.sum = sum;
    function pipe(initVal) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return args.reduce(function (acc, fn) { return fn(acc); }, initVal);
    }
    exports.pipe = pipe;
    function includes(arr, searchItem, searchIndex) {
        if (typeof searchIndex === 'number' && arr[searchIndex] !== searchItem) {
            return false;
        }
        for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {
            var item = arr_1[_i];
            if (item === searchItem) {
                return true;
            }
        }
        return false;
    }
    exports.includes = includes;
    // eslint-disable-next-line consistent-return
    function find(predicate, arr) {
        for (var _i = 0, arr_2 = arr; _i < arr_2.length; _i++) {
            var item = arr_2[_i];
            if (predicate(item)) {
                return item;
            }
        }
    }
    exports.find = find;
    function findProp(propName, value, arr) {
        return find(function (item) { return item[propName] === value; }, arr);
    }
    exports.findProp = findProp;
    function some(predicate, arr) {
        return !!find(predicate, arr);
    }
    exports.some = some;
    function someProp(propName, value, arr) {
        return !!findProp(propName, value, arr);
    }
    exports.someProp = someProp;
    function findIndex(predicate, arr) {
        for (var i = 0, len = arr.length; i < len; i += 1) {
            if (predicate(arr[i])) {
                return i;
            }
        }
        return -1;
    }
    exports.findIndex = findIndex;
    function findPropIndex(propName, value, arr) {
        return findIndex(function (item) { return item[propName] === value; }, arr);
    }
    exports.findPropIndex = findPropIndex;
    function findIndexes(predicate, arr) {
        return arr.reduce(function (acc, v, idx) { return (predicate(v) ? tslib_1.__spreadArrays(acc, [idx]) : acc); }, []);
    }
    exports.findIndexes = findIndexes;
    function findPrevIndex(arr, predicate) {
        var index = findIndex(predicate, arr);
        var positiveIndex = index <= 0 ? 0 : index - 1;
        return index >= 0 ? positiveIndex : arr.length - 1;
    }
    exports.findPrevIndex = findPrevIndex;
    function findOffsetIndex(offsets, targetOffset) {
        return findPrevIndex(offsets, function (offset) { return offset > targetOffset; });
    }
    exports.findOffsetIndex = findOffsetIndex;
    function mapProp(propName, arr) {
        return arr.map(function (item) { return item[propName]; });
    }
    exports.mapProp = mapProp;
    function deepMergedCopy(targetObj, obj) {
        var resultObj = tslib_1.__assign({}, targetObj);
        Object.keys(obj).forEach(function (prop) {
            if (isObject(resultObj[prop])) {
                if (Array.isArray(obj[prop])) {
                    resultObj[prop] = deepCopyArray(obj[prop]);
                }
                else if (resultObj.hasOwnProperty(prop)) {
                    resultObj[prop] = deepMergedCopy(resultObj[prop], obj[prop]);
                }
                else {
                    resultObj[prop] = deepCopy(obj[prop]);
                }
            }
            else {
                resultObj[prop] = obj[prop];
            }
        });
        return resultObj;
    }
    exports.deepMergedCopy = deepMergedCopy;
    function deepCopyArray(items) {
        return items.map(function (item) {
            if (isObject(item)) {
                return Array.isArray(item) ? deepCopyArray(item) : deepCopy(item);
            }
            return item;
        });
    }
    exports.deepCopyArray = deepCopyArray;
    function deepCopy(obj) {
        var resultObj = {};
        var keys = Object.keys(obj);
        if (!keys.length) {
            return obj;
        }
        keys.forEach(function (prop) {
            if (isObject(obj[prop])) {
                resultObj[prop] = Array.isArray(obj[prop]) ? deepCopyArray(obj[prop]) : deepCopy(obj[prop]);
            }
            else {
                resultObj[prop] = obj[prop];
            }
        });
        return resultObj;
    }
    exports.deepCopy = deepCopy;
    function assign(targetObj, obj) {
        Object.keys(obj).forEach(function (prop) {
            if (targetObj.hasOwnProperty(prop) && typeof targetObj[prop] === 'object') {
                if (Array.isArray(obj[prop])) {
                    targetObj[prop] = obj[prop];
                }
                else {
                    assign(targetObj[prop], obj[prop]);
                }
            }
            else {
                targetObj[prop] = obj[prop];
            }
        });
    }
    exports.assign = assign;
    function removeArrayItem(targetItem, arr) {
        var targetIdx = findIndex(function (item) { return item === targetItem; }, arr);
        if (targetIdx !== -1) {
            arr.splice(targetIdx, 1);
        }
        return arr;
    }
    exports.removeArrayItem = removeArrayItem;
    function createMapFromArray(arr, propName) {
        var resultMap = {};
        arr.forEach(function (item) {
            var key = String(item[propName]);
            resultMap[key] = item;
        });
        return resultMap;
    }
    exports.createMapFromArray = createMapFromArray;
    function isFunction(obj) {
        return typeof obj === 'function';
    }
    exports.isFunction = isFunction;
    function isObject(obj) {
        return typeof obj === 'object' && obj !== null;
    }
    exports.isObject = isObject;
    function forEachObject(fn, obj) {
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                fn(obj[key], key, obj);
            }
        }
    }
    exports.forEachObject = forEachObject;
    function hasOwnProp(obj, key) {
        return obj.hasOwnProperty(key);
    }
    exports.hasOwnProp = hasOwnProp;
    function encodeHTMLEntity(html) {
        var entities = {
            '"': 'quot',
            '&': 'amp',
            '<': 'lt',
            '>': 'gt',
            "'": '#39',
        };
        return html.replace(/[<>&"']/g, function (match) { return "&" + entities[match] + ";"; });
    }
    exports.encodeHTMLEntity = encodeHTMLEntity;
    function setDefaultProp(obj, key, defValue) {
        if (isUndefined(obj[key]) || isNull(obj[key])) {
            obj[key] = defValue;
        }
    }
    exports.setDefaultProp = setDefaultProp;
    /**
     * Returns a number whose value is limited to the given range.
     * @param value - A number to force within given min-max range
     * @param min - The lower boundary of the output range
     * @param max - The upper boundary of the output range
     * @returns A number in the range [min, max]
     * @example
     *      // limit the output of this computation to between 0 and 255
     *      value = clamp(value, 0, 255);
     */
    function clamp(value, min, max) {
        var _a;
        if (min > max) {
            _a = [min, max], max = _a[0], min = _a[1];
        }
        return Math.max(min, Math.min(value, max));
    }
    exports.clamp = clamp;
    function range(end) {
        var arr = [];
        for (var i = 0; i < end; i += 1) {
            arr.push(i);
        }
        return arr;
    }
    exports.range = range;
    function last(arr) {
        return arr[arr.length - 1];
    }
    exports.last = last;
    function isBlank(value) {
        if (typeof value === 'string') {
            return !value.length;
        }
        return typeof value === 'undefined' || value === null;
    }
    exports.isBlank = isBlank;
    function isUndefined(value) {
        return typeof value === 'undefined';
    }
    exports.isUndefined = isUndefined;
    function isNull(value) {
        return value === null;
    }
    exports.isNull = isNull;
    function isBoolean(value) {
        return typeof value === 'boolean';
    }
    exports.isBoolean = isBoolean;
    function isNumber(value) {
        return typeof value === 'number';
    }
    exports.isNumber = isNumber;
    function isString(value) {
        return typeof value === 'string';
    }
    exports.isString = isString;
    function isNil(value) {
        return isUndefined(value) || isNull(value);
    }
    exports.isNil = isNil;
    /**
     * check the emptiness(included null) of object or array. if obj parameter is null or undefind, return true
     * @param obj - target object or array
     * @returns the emptiness of obj
     */
    function isEmpty(obj) {
        return (isNull(obj) ||
            isUndefined(obj) ||
            (!isUndefined(obj.length) && obj.length === 0) ||
            Object.keys(obj).length === 0);
    }
    exports.isEmpty = isEmpty;
    function fromArray(value) {
        return Array.prototype.slice.call(value);
    }
    exports.fromArray = fromArray;
    function convertToNumber(value) {
        if (typeof value === 'number' || isNaN(value) || isBlank(value)) {
            return value;
        }
        return Number(value);
    }
    exports.convertToNumber = convertToNumber;
    function debounce(fn, wait, immediate) {
        if (immediate === void 0) { immediate = false; }
        var timeout = null;
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var later = function () {
                timeout = -1;
                if (!immediate) {
                    fn.apply(void 0, args);
                }
            };
            var callNow = immediate && !timeout;
            if (timeout) {
                clearTimeout(timeout);
            }
            timeout = window.setTimeout(later, wait);
            if (callNow) {
                fn.apply(void 0, args);
            }
        };
    }
    exports.debounce = debounce;
    function pruneObject(obj) {
        var pruned = {};
        forEachObject(function (value, key) {
            if (!isUndefined(value) && !isNull(value)) {
                pruned[key] = value;
            }
        }, obj);
        return pruned;
    }
    exports.pruneObject = pruneObject;
    function omit(obj) {
        var propNames = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            propNames[_i - 1] = arguments[_i];
        }
        var resultMap = {};
        Object.keys(obj).forEach(function (key) {
            if (!includes(propNames, key)) {
                resultMap[key] = obj[key];
            }
        });
        return resultMap;
    }
    exports.omit = omit;
    function pick(obj) {
        var propNames = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            propNames[_i - 1] = arguments[_i];
        }
        var resultMap = {};
        Object.keys(obj).forEach(function (key) {
            if (includes(propNames, key)) {
                resultMap[key] = obj[key];
            }
        });
        return resultMap;
    }
    exports.pick = pick;
    function uniq(arr) {
        return arr.filter(function (name, index) { return arr.indexOf(name) === index; });
    }
    exports.uniq = uniq;
    function uniqByProp(propName, arr) {
        return arr.filter(function (obj, index) { return findPropIndex(propName, obj[propName], arr) === index; });
    }
    exports.uniqByProp = uniqByProp;
    function startsWith(str, targetStr) {
        return targetStr.slice(0, str.length) === str;
    }
    exports.startsWith = startsWith;
    function endsWith(str, targetStr) {
        var index = targetStr.lastIndexOf(str);
        return index !== -1 && index + str.length === targetStr.length;
    }
    exports.endsWith = endsWith;
    function removeDoubleQuotes(text) {
        if (text.match(CUSTOM_LF_REGEXP)) {
            return text.substring(1, text.length - 1).replace(/""/g, '"');
        }
        return text;
    }
    function replaceNewlineToSubchar(text) {
        return text.replace(/"([^"]|"")*"/g, function (value) {
            return value.replace(LF, CUSTOM_LF_SUBCHAR).replace(CR, CUSTOM_CR_SUBCHAR);
        });
    }
    function convertTextToData(text) {
        // Each newline cell data is wrapping double quotes in the text and
        // newline characters should be replaced with substitution characters temporarily
        // before spliting the text by newline characters.
        text = replaceNewlineToSubchar(text);
        return text
            .split(/\r?\n/)
            .map(function (row) {
            return row
                .split('\t')
                .map(function (column) {
                return removeDoubleQuotes(column).replace(CUSTOM_LF_REGEXP, LF).replace(CUSTOM_CR_REGEXP, CR);
            });
        });
    }
    exports.convertTextToData = convertTextToData;
    function silentSplice(arr, start, deleteCount) {
        var _a;
        var items = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            items[_i - 3] = arguments[_i];
        }
        return (_a = Array.prototype.splice).call.apply(_a, tslib_1.__spreadArrays([arr, start, deleteCount], items));
    }
    exports.silentSplice = silentSplice;


    /***/ }),
    /* 1 */
    /***/ (function(module, __webpack_exports__, __webpack_require__) {
    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spreadArrays", function() { return __spreadArrays; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldGet", function() { return __classPrivateFieldGet; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldSet", function() { return __classPrivateFieldSet; });
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __exportStar(m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    }
    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }

    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }


    /***/ }),
    /* 2 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getComputedFontStyle = exports.getTextWidth = exports.setClipboardSelection = exports.isSupportWindowClipboardData = exports.convertTableToData = exports.getCoordinateWithOffset = exports.setCursorStyle = exports.appendStyleElement = exports.getCellAddress = exports.findParent = exports.findParentByTagName = exports.hasClass = exports.isDatePickerElement = exports.cls = exports.dataAttr = void 0;
    var common_1 = __webpack_require__(0);
    var CLS_PREFIX = 'tui-grid-';
    exports.dataAttr = {
        ROW_KEY: 'data-row-key',
        COLUMN_NAME: 'data-column-name',
        COLUMN_INDEX: 'data-column-index',
        GRID_ID: 'data-grid-id',
    };
    function cls() {
        var names = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            names[_i] = arguments[_i];
        }
        var result = [];
        for (var _a = 0, names_1 = names; _a < names_1.length; _a++) {
            var name = names_1[_a];
            var className = void 0;
            if (Array.isArray(name)) {
                className = name[0] ? name[1] : null;
            }
            else {
                className = name;
            }
            if (className) {
                result.push("" + CLS_PREFIX + className);
            }
        }
        return result.join(' ');
    }
    exports.cls = cls;
    function isSvgElement(el) {
        var _a;
        return ((_a = el.namespaceURI) === null || _a === void 0 ? void 0 : _a.indexOf('svg')) !== -1;
    }
    function isDatePickerElement(el) {
        var currentEl = el;
        if (isSvgElement(el)) {
            return false;
        }
        while (currentEl && currentEl.className.split(' ').indexOf('tui-datepicker') === -1) {
            currentEl = currentEl.parentElement;
        }
        return !!currentEl;
    }
    exports.isDatePickerElement = isDatePickerElement;
    function hasClass(el, className) {
        return !isSvgElement(el) && el.className.split(' ').indexOf(cls(className)) !== -1;
    }
    exports.hasClass = hasClass;
    function findParentByTagName(el, tagName) {
        var currentEl = el;
        while (currentEl && currentEl.tagName.toLowerCase() !== tagName) {
            currentEl = currentEl.parentElement;
        }
        return currentEl;
    }
    exports.findParentByTagName = findParentByTagName;
    function findParent(el, className) {
        var currentEl = el;
        while (currentEl && !hasClass(currentEl, className)) {
            currentEl = currentEl.parentElement;
        }
        return currentEl;
    }
    exports.findParent = findParent;
    function getCellAddress(el) {
        var cellElement = findParentByTagName(el, 'td');
        if (!cellElement) {
            return null;
        }
        var rowKey = cellElement.getAttribute(exports.dataAttr.ROW_KEY);
        var columnName = cellElement.getAttribute(exports.dataAttr.COLUMN_NAME);
        if (common_1.isNull(rowKey)) {
            return null;
        }
        return {
            rowKey: Number(rowKey),
            columnName: columnName,
        };
    }
    exports.getCellAddress = getCellAddress;
    /**
     * create style element and append it into the head element.
     * @param {String} id - element id
     * @param {String} cssString - css string
     */
    function appendStyleElement(id, cssString) {
        var style = document.createElement('style');
        style.type = 'text/css';
        style.id = id;
        style.appendChild(document.createTextNode(cssString));
        document.getElementsByTagName('head')[0].appendChild(style);
    }
    exports.appendStyleElement = appendStyleElement;
    function setCursorStyle(type) {
        document.body.style.cursor = type;
    }
    exports.setCursorStyle = setCursorStyle;
    function getCoordinateWithOffset(pageX, pageY) {
        var pageXWithOffset = pageX - window.pageXOffset;
        var pageYWithOffset = pageY - window.pageYOffset;
        return [pageXWithOffset, pageYWithOffset];
    }
    exports.getCoordinateWithOffset = getCoordinateWithOffset;
    function setDataInSpanRange(value, data, colspanRange, rowspanRange) {
        var startColspan = colspanRange[0], endColspan = colspanRange[1];
        var startRowspan = rowspanRange[0], endRowspan = rowspanRange[1];
        for (var rowIdx = startRowspan; rowIdx < endRowspan; rowIdx += 1) {
            for (var columnIdx = startColspan; columnIdx < endColspan; columnIdx += 1) {
                data[rowIdx][columnIdx] = startRowspan === rowIdx && startColspan === columnIdx ? value : ' ';
            }
        }
    }
    function convertTableToData(rows) {
        var data = [];
        var colspanRange, rowspanRange;
        for (var index = 0; index < rows.length; index += 1) {
            data[index] = [];
        }
        common_1.fromArray(rows).forEach(function (tr, rowIndex) {
            var columnIndex = 0;
            common_1.fromArray(tr.cells).forEach(function (td) {
                var text = td.textContent || td.innerText;
                while (data[rowIndex][columnIndex]) {
                    columnIndex += 1;
                }
                colspanRange = [columnIndex, columnIndex + (td.colSpan || 1)];
                rowspanRange = [rowIndex, rowIndex + (td.rowSpan || 1)];
                setDataInSpanRange(text, data, colspanRange, rowspanRange);
                columnIndex = colspanRange[1];
            });
        });
        return data;
    }
    exports.convertTableToData = convertTableToData;
    function isSupportWindowClipboardData() {
        return !!window.clipboardData;
    }
    exports.isSupportWindowClipboardData = isSupportWindowClipboardData;
    function setClipboardSelection(node) {
        if (node) {
            var range = document.createRange();
            var selection = window.getSelection();
            selection.removeAllRanges();
            range.selectNodeContents(node);
            selection.addRange(range);
        }
    }
    exports.setClipboardSelection = setClipboardSelection;
    function getTextWidth(text, font) {
        var context = document.createElement('canvas').getContext('2d');
        context.font = font;
        var width = context.measureText(String(text)).width;
        return Math.ceil(width);
    }
    exports.getTextWidth = getTextWidth;
    function getComputedFontStyle(selector) {
        var firstCellNode = document.querySelector("." + cls(selector));
        var walker = document.createTreeWalker(firstCellNode, 4);
        var node = firstCellNode;
        while (walker.nextNode()) {
            node = walker.currentNode;
            if (node.nodeType === 3) {
                node = node.parentElement;
                break;
            }
        }
        var compStyle = getComputedStyle(node);
        var fontSize = compStyle.getPropertyValue('font-size');
        var fontWeight = compStyle.getPropertyValue('font-weight');
        var fontFamily = compStyle.getPropertyValue('font-family');
        return fontWeight + " " + fontSize + " " + fontFamily;
    }
    exports.getComputedFontStyle = getComputedFontStyle;


    /***/ }),
    /* 3 */
    /***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {
    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return h; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createElement", function() { return h; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneElement", function() { return cloneElement; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createRef", function() { return createRef; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Component", function() { return Component; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rerender", function() { return rerender; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "options", function() { return options; });
    var VNode = function VNode() {};

    var options = {};

    var stack = [];

    var EMPTY_CHILDREN = [];

    function h(nodeName, attributes) {
    	var children = EMPTY_CHILDREN,
    	    lastSimple,
    	    child,
    	    simple,
    	    i;
    	for (i = arguments.length; i-- > 2;) {
    		stack.push(arguments[i]);
    	}
    	if (attributes && attributes.children != null) {
    		if (!stack.length) stack.push(attributes.children);
    		delete attributes.children;
    	}
    	while (stack.length) {
    		if ((child = stack.pop()) && child.pop !== undefined) {
    			for (i = child.length; i--;) {
    				stack.push(child[i]);
    			}
    		} else {
    			if (typeof child === 'boolean') child = null;

    			if (simple = typeof nodeName !== 'function') {
    				if (child == null) child = '';else if (typeof child === 'number') child = String(child);else if (typeof child !== 'string') simple = false;
    			}

    			if (simple && lastSimple) {
    				children[children.length - 1] += child;
    			} else if (children === EMPTY_CHILDREN) {
    				children = [child];
    			} else {
    				children.push(child);
    			}

    			lastSimple = simple;
    		}
    	}

    	var p = new VNode();
    	p.nodeName = nodeName;
    	p.children = children;
    	p.attributes = attributes == null ? undefined : attributes;
    	p.key = attributes == null ? undefined : attributes.key;

    	if (options.vnode !== undefined) options.vnode(p);

    	return p;
    }

    function extend(obj, props) {
      for (var i in props) {
        obj[i] = props[i];
      }return obj;
    }

    function applyRef(ref, value) {
      if (ref != null) {
        if (typeof ref == 'function') ref(value);else ref.current = value;
      }
    }

    var defer = typeof Promise == 'function' ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout;

    function cloneElement(vnode, props) {
      return h(vnode.nodeName, extend(extend({}, vnode.attributes), props), arguments.length > 2 ? [].slice.call(arguments, 2) : vnode.children);
    }

    var IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;

    var items = [];

    function enqueueRender(component) {
    	if (!component._dirty && (component._dirty = true) && items.push(component) == 1) {
    		(options.debounceRendering || defer)(rerender);
    	}
    }

    function rerender() {
    	var p;
    	while (p = items.pop()) {
    		if (p._dirty) renderComponent(p);
    	}
    }

    function isSameNodeType(node, vnode, hydrating) {
    	if (typeof vnode === 'string' || typeof vnode === 'number') {
    		return node.splitText !== undefined;
    	}
    	if (typeof vnode.nodeName === 'string') {
    		return !node._componentConstructor && isNamedNode(node, vnode.nodeName);
    	}
    	return hydrating || node._componentConstructor === vnode.nodeName;
    }

    function isNamedNode(node, nodeName) {
    	return node.normalizedNodeName === nodeName || node.nodeName.toLowerCase() === nodeName.toLowerCase();
    }

    function getNodeProps(vnode) {
    	var props = extend({}, vnode.attributes);
    	props.children = vnode.children;

    	var defaultProps = vnode.nodeName.defaultProps;
    	if (defaultProps !== undefined) {
    		for (var i in defaultProps) {
    			if (props[i] === undefined) {
    				props[i] = defaultProps[i];
    			}
    		}
    	}

    	return props;
    }

    function createNode(nodeName, isSvg) {
    	var node = isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName);
    	node.normalizedNodeName = nodeName;
    	return node;
    }

    function removeNode(node) {
    	var parentNode = node.parentNode;
    	if (parentNode) parentNode.removeChild(node);
    }

    function setAccessor(node, name, old, value, isSvg) {
    	if (name === 'className') name = 'class';

    	if (name === 'key') ; else if (name === 'ref') {
    		applyRef(old, null);
    		applyRef(value, node);
    	} else if (name === 'class' && !isSvg) {
    		node.className = value || '';
    	} else if (name === 'style') {
    		if (!value || typeof value === 'string' || typeof old === 'string') {
    			node.style.cssText = value || '';
    		}
    		if (value && typeof value === 'object') {
    			if (typeof old !== 'string') {
    				for (var i in old) {
    					if (!(i in value)) node.style[i] = '';
    				}
    			}
    			for (var i in value) {
    				node.style[i] = typeof value[i] === 'number' && IS_NON_DIMENSIONAL.test(i) === false ? value[i] + 'px' : value[i];
    			}
    		}
    	} else if (name === 'dangerouslySetInnerHTML') {
    		if (value) node.innerHTML = value.__html || '';
    	} else if (name[0] == 'o' && name[1] == 'n') {
    		var useCapture = name !== (name = name.replace(/Capture$/, ''));
    		name = name.toLowerCase().substring(2);
    		if (value) {
    			if (!old) node.addEventListener(name, eventProxy, useCapture);
    		} else {
    			node.removeEventListener(name, eventProxy, useCapture);
    		}
    		(node._listeners || (node._listeners = {}))[name] = value;
    	} else if (name !== 'list' && name !== 'type' && !isSvg && name in node) {
    		try {
    			node[name] = value == null ? '' : value;
    		} catch (e) {}
    		if ((value == null || value === false) && name != 'spellcheck') node.removeAttribute(name);
    	} else {
    		var ns = isSvg && name !== (name = name.replace(/^xlink:?/, ''));

    		if (value == null || value === false) {
    			if (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase());else node.removeAttribute(name);
    		} else if (typeof value !== 'function') {
    			if (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase(), value);else node.setAttribute(name, value);
    		}
    	}
    }

    function eventProxy(e) {
    	return this._listeners[e.type](options.event && options.event(e) || e);
    }

    var mounts = [];

    var diffLevel = 0;

    var isSvgMode = false;

    var hydrating = false;

    function flushMounts() {
    	var c;
    	while (c = mounts.shift()) {
    		if (options.afterMount) options.afterMount(c);
    		if (c.componentDidMount) c.componentDidMount();
    	}
    }

    function diff(dom, vnode, context, mountAll, parent, componentRoot) {
    	if (!diffLevel++) {
    		isSvgMode = parent != null && parent.ownerSVGElement !== undefined;

    		hydrating = dom != null && !('__preactattr_' in dom);
    	}

    	var ret = idiff(dom, vnode, context, mountAll, componentRoot);

    	if (parent && ret.parentNode !== parent) parent.appendChild(ret);

    	if (! --diffLevel) {
    		hydrating = false;

    		if (!componentRoot) flushMounts();
    	}

    	return ret;
    }

    function idiff(dom, vnode, context, mountAll, componentRoot) {
    	var out = dom,
    	    prevSvgMode = isSvgMode;

    	if (vnode == null || typeof vnode === 'boolean') vnode = '';

    	if (typeof vnode === 'string' || typeof vnode === 'number') {
    		if (dom && dom.splitText !== undefined && dom.parentNode && (!dom._component || componentRoot)) {
    			if (dom.nodeValue != vnode) {
    				dom.nodeValue = vnode;
    			}
    		} else {
    			out = document.createTextNode(vnode);
    			if (dom) {
    				if (dom.parentNode) dom.parentNode.replaceChild(out, dom);
    				recollectNodeTree(dom, true);
    			}
    		}

    		out['__preactattr_'] = true;

    		return out;
    	}

    	var vnodeName = vnode.nodeName;
    	if (typeof vnodeName === 'function') {
    		return buildComponentFromVNode(dom, vnode, context, mountAll);
    	}

    	isSvgMode = vnodeName === 'svg' ? true : vnodeName === 'foreignObject' ? false : isSvgMode;

    	vnodeName = String(vnodeName);
    	if (!dom || !isNamedNode(dom, vnodeName)) {
    		out = createNode(vnodeName, isSvgMode);

    		if (dom) {
    			while (dom.firstChild) {
    				out.appendChild(dom.firstChild);
    			}
    			if (dom.parentNode) dom.parentNode.replaceChild(out, dom);

    			recollectNodeTree(dom, true);
    		}
    	}

    	var fc = out.firstChild,
    	    props = out['__preactattr_'],
    	    vchildren = vnode.children;

    	if (props == null) {
    		props = out['__preactattr_'] = {};
    		for (var a = out.attributes, i = a.length; i--;) {
    			props[a[i].name] = a[i].value;
    		}
    	}

    	if (!hydrating && vchildren && vchildren.length === 1 && typeof vchildren[0] === 'string' && fc != null && fc.splitText !== undefined && fc.nextSibling == null) {
    		if (fc.nodeValue != vchildren[0]) {
    			fc.nodeValue = vchildren[0];
    		}
    	} else if (vchildren && vchildren.length || fc != null) {
    			innerDiffNode(out, vchildren, context, mountAll, hydrating || props.dangerouslySetInnerHTML != null);
    		}

    	diffAttributes(out, vnode.attributes, props);

    	isSvgMode = prevSvgMode;

    	return out;
    }

    function innerDiffNode(dom, vchildren, context, mountAll, isHydrating) {
    	var originalChildren = dom.childNodes,
    	    children = [],
    	    keyed = {},
    	    keyedLen = 0,
    	    min = 0,
    	    len = originalChildren.length,
    	    childrenLen = 0,
    	    vlen = vchildren ? vchildren.length : 0,
    	    j,
    	    c,
    	    f,
    	    vchild,
    	    child;

    	if (len !== 0) {
    		for (var i = 0; i < len; i++) {
    			var _child = originalChildren[i],
    			    props = _child['__preactattr_'],
    			    key = vlen && props ? _child._component ? _child._component.__key : props.key : null;
    			if (key != null) {
    				keyedLen++;
    				keyed[key] = _child;
    			} else if (props || (_child.splitText !== undefined ? isHydrating ? _child.nodeValue.trim() : true : isHydrating)) {
    				children[childrenLen++] = _child;
    			}
    		}
    	}

    	if (vlen !== 0) {
    		for (var i = 0; i < vlen; i++) {
    			vchild = vchildren[i];
    			child = null;

    			var key = vchild.key;
    			if (key != null) {
    				if (keyedLen && keyed[key] !== undefined) {
    					child = keyed[key];
    					keyed[key] = undefined;
    					keyedLen--;
    				}
    			} else if (min < childrenLen) {
    					for (j = min; j < childrenLen; j++) {
    						if (children[j] !== undefined && isSameNodeType(c = children[j], vchild, isHydrating)) {
    							child = c;
    							children[j] = undefined;
    							if (j === childrenLen - 1) childrenLen--;
    							if (j === min) min++;
    							break;
    						}
    					}
    				}

    			child = idiff(child, vchild, context, mountAll);

    			f = originalChildren[i];
    			if (child && child !== dom && child !== f) {
    				if (f == null) {
    					dom.appendChild(child);
    				} else if (child === f.nextSibling) {
    					removeNode(f);
    				} else {
    					dom.insertBefore(child, f);
    				}
    			}
    		}
    	}

    	if (keyedLen) {
    		for (var i in keyed) {
    			if (keyed[i] !== undefined) recollectNodeTree(keyed[i], false);
    		}
    	}

    	while (min <= childrenLen) {
    		if ((child = children[childrenLen--]) !== undefined) recollectNodeTree(child, false);
    	}
    }

    function recollectNodeTree(node, unmountOnly) {
    	var component = node._component;
    	if (component) {
    		unmountComponent(component);
    	} else {
    		if (node['__preactattr_'] != null) applyRef(node['__preactattr_'].ref, null);

    		if (unmountOnly === false || node['__preactattr_'] == null) {
    			removeNode(node);
    		}

    		removeChildren(node);
    	}
    }

    function removeChildren(node) {
    	node = node.lastChild;
    	while (node) {
    		var next = node.previousSibling;
    		recollectNodeTree(node, true);
    		node = next;
    	}
    }

    function diffAttributes(dom, attrs, old) {
    	var name;

    	for (name in old) {
    		if (!(attrs && attrs[name] != null) && old[name] != null) {
    			setAccessor(dom, name, old[name], old[name] = undefined, isSvgMode);
    		}
    	}

    	for (name in attrs) {
    		if (name !== 'children' && name !== 'innerHTML' && (!(name in old) || attrs[name] !== (name === 'value' || name === 'checked' ? dom[name] : old[name]))) {
    			setAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);
    		}
    	}
    }

    var recyclerComponents = [];

    function createComponent(Ctor, props, context) {
    	var inst,
    	    i = recyclerComponents.length;

    	if (Ctor.prototype && Ctor.prototype.render) {
    		inst = new Ctor(props, context);
    		Component.call(inst, props, context);
    	} else {
    		inst = new Component(props, context);
    		inst.constructor = Ctor;
    		inst.render = doRender;
    	}

    	while (i--) {
    		if (recyclerComponents[i].constructor === Ctor) {
    			inst.nextBase = recyclerComponents[i].nextBase;
    			recyclerComponents.splice(i, 1);
    			return inst;
    		}
    	}

    	return inst;
    }

    function doRender(props, state, context) {
    	return this.constructor(props, context);
    }

    function setComponentProps(component, props, renderMode, context, mountAll) {
    	if (component._disable) return;
    	component._disable = true;

    	component.__ref = props.ref;
    	component.__key = props.key;
    	delete props.ref;
    	delete props.key;

    	if (typeof component.constructor.getDerivedStateFromProps === 'undefined') {
    		if (!component.base || mountAll) {
    			if (component.componentWillMount) component.componentWillMount();
    		} else if (component.componentWillReceiveProps) {
    			component.componentWillReceiveProps(props, context);
    		}
    	}

    	if (context && context !== component.context) {
    		if (!component.prevContext) component.prevContext = component.context;
    		component.context = context;
    	}

    	if (!component.prevProps) component.prevProps = component.props;
    	component.props = props;

    	component._disable = false;

    	if (renderMode !== 0) {
    		if (renderMode === 1 || options.syncComponentUpdates !== false || !component.base) {
    			renderComponent(component, 1, mountAll);
    		} else {
    			enqueueRender(component);
    		}
    	}

    	applyRef(component.__ref, component);
    }

    function renderComponent(component, renderMode, mountAll, isChild) {
    	if (component._disable) return;

    	var props = component.props,
    	    state = component.state,
    	    context = component.context,
    	    previousProps = component.prevProps || props,
    	    previousState = component.prevState || state,
    	    previousContext = component.prevContext || context,
    	    isUpdate = component.base,
    	    nextBase = component.nextBase,
    	    initialBase = isUpdate || nextBase,
    	    initialChildComponent = component._component,
    	    skip = false,
    	    snapshot = previousContext,
    	    rendered,
    	    inst,
    	    cbase;

    	if (component.constructor.getDerivedStateFromProps) {
    		state = extend(extend({}, state), component.constructor.getDerivedStateFromProps(props, state));
    		component.state = state;
    	}

    	if (isUpdate) {
    		component.props = previousProps;
    		component.state = previousState;
    		component.context = previousContext;
    		if (renderMode !== 2 && component.shouldComponentUpdate && component.shouldComponentUpdate(props, state, context) === false) {
    			skip = true;
    		} else if (component.componentWillUpdate) {
    			component.componentWillUpdate(props, state, context);
    		}
    		component.props = props;
    		component.state = state;
    		component.context = context;
    	}

    	component.prevProps = component.prevState = component.prevContext = component.nextBase = null;
    	component._dirty = false;

    	if (!skip) {
    		rendered = component.render(props, state, context);

    		if (component.getChildContext) {
    			context = extend(extend({}, context), component.getChildContext());
    		}

    		if (isUpdate && component.getSnapshotBeforeUpdate) {
    			snapshot = component.getSnapshotBeforeUpdate(previousProps, previousState);
    		}

    		var childComponent = rendered && rendered.nodeName,
    		    toUnmount,
    		    base;

    		if (typeof childComponent === 'function') {

    			var childProps = getNodeProps(rendered);
    			inst = initialChildComponent;

    			if (inst && inst.constructor === childComponent && childProps.key == inst.__key) {
    				setComponentProps(inst, childProps, 1, context, false);
    			} else {
    				toUnmount = inst;

    				component._component = inst = createComponent(childComponent, childProps, context);
    				inst.nextBase = inst.nextBase || nextBase;
    				inst._parentComponent = component;
    				setComponentProps(inst, childProps, 0, context, false);
    				renderComponent(inst, 1, mountAll, true);
    			}

    			base = inst.base;
    		} else {
    			cbase = initialBase;

    			toUnmount = initialChildComponent;
    			if (toUnmount) {
    				cbase = component._component = null;
    			}

    			if (initialBase || renderMode === 1) {
    				if (cbase) cbase._component = null;
    				base = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase && initialBase.parentNode, true);
    			}
    		}

    		if (initialBase && base !== initialBase && inst !== initialChildComponent) {
    			var baseParent = initialBase.parentNode;
    			if (baseParent && base !== baseParent) {
    				baseParent.replaceChild(base, initialBase);

    				if (!toUnmount) {
    					initialBase._component = null;
    					recollectNodeTree(initialBase, false);
    				}
    			}
    		}

    		if (toUnmount) {
    			unmountComponent(toUnmount);
    		}

    		component.base = base;
    		if (base && !isChild) {
    			var componentRef = component,
    			    t = component;
    			while (t = t._parentComponent) {
    				(componentRef = t).base = base;
    			}
    			base._component = componentRef;
    			base._componentConstructor = componentRef.constructor;
    		}
    	}

    	if (!isUpdate || mountAll) {
    		mounts.push(component);
    	} else if (!skip) {

    		if (component.componentDidUpdate) {
    			component.componentDidUpdate(previousProps, previousState, snapshot);
    		}
    		if (options.afterUpdate) options.afterUpdate(component);
    	}

    	while (component._renderCallbacks.length) {
    		component._renderCallbacks.pop().call(component);
    	}if (!diffLevel && !isChild) flushMounts();
    }

    function buildComponentFromVNode(dom, vnode, context, mountAll) {
    	var c = dom && dom._component,
    	    originalComponent = c,
    	    oldDom = dom,
    	    isDirectOwner = c && dom._componentConstructor === vnode.nodeName,
    	    isOwner = isDirectOwner,
    	    props = getNodeProps(vnode);
    	while (c && !isOwner && (c = c._parentComponent)) {
    		isOwner = c.constructor === vnode.nodeName;
    	}

    	if (c && isOwner && (!mountAll || c._component)) {
    		setComponentProps(c, props, 3, context, mountAll);
    		dom = c.base;
    	} else {
    		if (originalComponent && !isDirectOwner) {
    			unmountComponent(originalComponent);
    			dom = oldDom = null;
    		}

    		c = createComponent(vnode.nodeName, props, context);
    		if (dom && !c.nextBase) {
    			c.nextBase = dom;

    			oldDom = null;
    		}
    		setComponentProps(c, props, 1, context, mountAll);
    		dom = c.base;

    		if (oldDom && dom !== oldDom) {
    			oldDom._component = null;
    			recollectNodeTree(oldDom, false);
    		}
    	}

    	return dom;
    }

    function unmountComponent(component) {
    	if (options.beforeUnmount) options.beforeUnmount(component);

    	var base = component.base;

    	component._disable = true;

    	if (component.componentWillUnmount) component.componentWillUnmount();

    	component.base = null;

    	var inner = component._component;
    	if (inner) {
    		unmountComponent(inner);
    	} else if (base) {
    		if (base['__preactattr_'] != null) applyRef(base['__preactattr_'].ref, null);

    		component.nextBase = base;

    		removeNode(base);
    		recyclerComponents.push(component);

    		removeChildren(base);
    	}

    	applyRef(component.__ref, null);
    }

    function Component(props, context) {
    	this._dirty = true;

    	this.context = context;

    	this.props = props;

    	this.state = this.state || {};

    	this._renderCallbacks = [];
    }

    extend(Component.prototype, {
    	setState: function setState(state, callback) {
    		if (!this.prevState) this.prevState = this.state;
    		this.state = extend(extend({}, this.state), typeof state === 'function' ? state(this.state, this.props) : state);
    		if (callback) this._renderCallbacks.push(callback);
    		enqueueRender(this);
    	},
    	forceUpdate: function forceUpdate(callback) {
    		if (callback) this._renderCallbacks.push(callback);
    		renderComponent(this, 2);
    	},
    	render: function render() {}
    });

    function render(vnode, parent, merge) {
      return diff(merge, vnode, {}, false, parent, false);
    }

    function createRef() {
    	return {};
    }

    var preact = {
    	h: h,
    	createElement: h,
    	cloneElement: cloneElement,
    	createRef: createRef,
    	Component: Component,
    	render: render,
    	rerender: rerender,
    	options: options
    };

    /* harmony default export */ __webpack_exports__["default"] = (preact);




    /***/ }),
    /* 4 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.connect = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var observable_1 = __webpack_require__(5);
    function connect(selector, forceUpdate) {
        return function (WrappedComponent) {
            var _a;
            return _a = /** @class */ (function (_super) {
                    tslib_1.__extends(class_1, _super);
                    function class_1() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    class_1.prototype.setStateUsingSelector = function (ownProps) {
                        if (selector) {
                            this.setState(selector(this.context.store, ownProps));
                            if (forceUpdate) {
                                this.forceUpdate();
                            }
                        }
                    };
                    class_1.prototype.componentWillMount = function () {
                        var _this = this;
                        if (selector) {
                            this.unobserve = observable_1.observe(function () {
                                _this.setStateUsingSelector(_this.props);
                            });
                        }
                    };
                    class_1.prototype.componentWillReceiveProps = function (nextProps) {
                        this.setStateUsingSelector(nextProps);
                    };
                    class_1.prototype.componentWillUnmount = function () {
                        if (this.unobserve) {
                            this.unobserve();
                        }
                    };
                    class_1.prototype.render = function () {
                        var _a = this, props = _a.props, state = _a.state;
                        var dispatch = this.context.dispatch;
                        return preact_1.h(WrappedComponent, tslib_1.__assign({}, props, state, { dispatch: dispatch }));
                    };
                    return class_1;
                }(preact_1.Component)),
                _a.displayName = "Connect:" + WrappedComponent.name,
                _a;
        };
    }
    exports.connect = connect;


    /***/ }),
    /* 5 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.asyncInvokeObserver = exports.batchObserver = exports.unobservedInvoke = exports.getOriginObject = exports.notify = exports.observable = exports.partialObservable = exports.observe = exports.isObservable = exports.getRunningObservers = exports.observerInfoMap = void 0;
    var common_1 = __webpack_require__(0);
    var array_1 = __webpack_require__(61);
    var generateObserverId = (function () {
        var lastId = 0;
        return function () {
            lastId += 1;
            return "@observer" + lastId;
        };
    })();
    // store all observer info
    exports.observerInfoMap = {};
    // observerId stack for managing recursive observing calls
    var observerIdStack = [];
    var queue = [];
    var observerIdMap = {};
    var pending = false;
    var paused = false;
    function batchUpdate(observerId) {
        if (!observerIdMap[observerId]) {
            observerIdMap[observerId] = true;
            queue.push(observerId);
        }
        if (!pending) {
            flush();
        }
    }
    function clearQueue() {
        queue = [];
        observerIdMap = {};
        pending = false;
    }
    function getRunningObservers() {
        return queue.map(function (id) { return exports.observerInfoMap[id].name; }).filter(function (name) { return name; });
    }
    exports.getRunningObservers = getRunningObservers;
    function callObserver(observerId) {
        observerIdStack.push(observerId);
        exports.observerInfoMap[observerId].fn();
        observerIdStack.pop();
    }
    function flush() {
        pending = true;
        for (var index = 0; index < queue.length; index += 1) {
            var observerId = queue[index];
            observerIdMap[observerId] = false;
            callObserver(observerId);
        }
        clearQueue();
    }
    function run(observerId) {
        var sync = exports.observerInfoMap[observerId].sync;
        if (sync) {
            callObserver(observerId);
        }
        else {
            batchUpdate(observerId);
        }
    }
    function setValue(storage, resultObj, observerIdSet, key, value) {
        if (storage[key] !== value) {
            if (Array.isArray(value)) {
                array_1.patchArrayMethods(value, resultObj, key);
            }
            storage[key] = value;
            Object.keys(observerIdSet).forEach(function (observerId) {
                run(observerId);
            });
        }
    }
    function isObservable(resultObj) {
        return common_1.isObject(resultObj) && common_1.hasOwnProp(resultObj, '__storage__');
    }
    exports.isObservable = isObservable;
    function observe(fn, sync, name) {
        if (sync === void 0) { sync = false; }
        if (name === void 0) { name = ''; }
        var observerId = generateObserverId();
        exports.observerInfoMap[observerId] = { fn: fn, targetObserverIdSets: [], sync: sync, name: name };
        run(observerId);
        // return unobserve function
        return function () {
            exports.observerInfoMap[observerId].targetObserverIdSets.forEach(function (idSet) {
                delete idSet[observerId];
            });
            delete exports.observerInfoMap[observerId];
        };
    }
    exports.observe = observe;
    // eslint-disable-next-line max-params
    function makeObservableData(obj, resultObj, key, storage, propObserverIdSetMap, sync) {
        var getter = (Object.getOwnPropertyDescriptor(obj, key) || {}).get;
        var observerIdSet = (propObserverIdSetMap[key] = {});
        Object.defineProperty(resultObj, key, {
            configurable: true,
            enumerable: true,
            get: function () {
                var observerId = common_1.last(observerIdStack);
                if (!paused && observerId && !observerIdSet[observerId]) {
                    observerIdSet[observerId] = true;
                    exports.observerInfoMap[observerId].targetObserverIdSets.push(observerIdSet);
                }
                return storage[key];
            },
        });
        if (common_1.isFunction(getter)) {
            observe(function () {
                var value = getter.call(resultObj);
                setValue(storage, resultObj, observerIdSet, key, value);
            }, sync);
        }
        else {
            // has to add 'as' type assertion and refer the below typescript issue
            // In general, the constraint Record<string, XXX> doesn't actually ensure that an argument has a string index signature,
            // it merely ensures that the properties of the argument are assignable to type XXX.
            // So, in the example above you could effectively pass any object and the function could write to any property without any checks.
            // https://github.com/microsoft/TypeScript/issues/31661
            storage[key] = obj[key];
            if (Array.isArray(storage[key])) {
                array_1.patchArrayMethods(storage[key], resultObj, key);
            }
            Object.defineProperty(resultObj, key, {
                set: function (value) {
                    setValue(storage, resultObj, observerIdSet, key, value);
                },
            });
        }
    }
    function partialObservable(obj, key) {
        var storage = obj.__storage__;
        var propObserverIdSetMap = obj.__propObserverIdSetMap__;
        makeObservableData(obj, obj, key, storage, propObserverIdSetMap);
    }
    exports.partialObservable = partialObservable;
    function observable(obj, sync) {
        if (sync === void 0) { sync = false; }
        if (Array.isArray(obj)) {
            throw new Error('Array object cannot be Reactive');
        }
        if (isObservable(obj)) {
            return obj;
        }
        var storage = {};
        var propObserverIdSetMap = {};
        var resultObj = {};
        Object.defineProperties(resultObj, {
            __storage__: { value: storage },
            __propObserverIdSetMap__: { value: propObserverIdSetMap },
        });
        Object.keys(obj).forEach(function (key) {
            makeObservableData(obj, resultObj, key, storage, propObserverIdSetMap, sync);
        });
        return resultObj;
    }
    exports.observable = observable;
    function notifyUnit(obj, key) {
        Object.keys(obj.__propObserverIdSetMap__[key]).forEach(function (observerId) {
            run(observerId);
        });
    }
    function notify(obj) {
        var keys = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            keys[_i - 1] = arguments[_i];
        }
        if (isObservable(obj)) {
            keys.forEach(function (key) { return notifyUnit(obj, key); });
        }
    }
    exports.notify = notify;
    function getOriginObject(obj) {
        var result = {};
        common_1.forEachObject(function (value, key) {
            result[key] = isObservable(value) ? getOriginObject(value) : value;
        }, obj.__storage__);
        return common_1.isEmpty(result) ? obj : result;
    }
    exports.getOriginObject = getOriginObject;
    function unobservedInvoke(fn) {
        paused = true;
        fn();
        paused = false;
    }
    exports.unobservedInvoke = unobservedInvoke;
    function batchObserver(fn) {
        pending = true;
        fn();
        pending = false;
    }
    exports.batchObserver = batchObserver;
    var asyncTimer = null;
    function asyncInvokeObserver(fn) {
        if (common_1.isNull(asyncTimer)) {
            asyncTimer = setTimeout(function () {
                fn();
                asyncTimer = null;
            });
        }
    }
    exports.asyncInvokeObserver = asyncInvokeObserver;


    /***/ }),
    /* 6 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.changeRawDataToOriginDataForTree = exports.getOmittedInternalProp = exports.createChangeInfo = exports.getFormattedValue = exports.getRowKeyByIndexWithPageRange = exports.getRowIndexPerPage = exports.isClientPagination = exports.isScrollPagination = exports.getMaxRowKey = exports.isFiltered = exports.isSorted = exports.getCreatedRowInfo = exports.getRemovedClassName = exports.getAddedClassName = exports.getLoadingState = exports.getRowHeight = exports.isInitialSortState = exports.isSortable = exports.getUniqColumnData = exports.findRowByRowKey = exports.findIndexByRowKey = exports.getConditionalRows = exports.getCheckedRowInfoList = exports.isEditableCell = exports.getCellAddressByIndex = void 0;
    var tslib_1 = __webpack_require__(1);
    var common_1 = __webpack_require__(0);
    var instance_1 = __webpack_require__(7);
    var rowSpan_1 = __webpack_require__(11);
    var column_1 = __webpack_require__(12);
    var data_1 = __webpack_require__(15);
    var data_2 = __webpack_require__(26);
    var data_3 = __webpack_require__(13);
    var validation_1 = __webpack_require__(25);
    var observable_1 = __webpack_require__(5);
    function getCellAddressByIndex(_a, rowIndex, columnIndex) {
        var data = _a.data, column = _a.column;
        return {
            rowKey: data.filteredViewData[rowIndex].rowKey,
            columnName: column.visibleColumns[columnIndex].name,
        };
    }
    exports.getCellAddressByIndex = getCellAddressByIndex;
    function isEditableCell(store, rowIndex, columnName) {
        var data = store.data, column = store.column;
        var filteredIndex = data.filteredIndex, filteredViewData = data.filteredViewData;
        if (filteredIndex && common_1.isNil(filteredIndex[rowIndex])) {
            return false;
        }
        // get index based on whole data(not filtered data)
        var index = filteredIndex ? filteredIndex[rowIndex] : rowIndex;
        data_3.makeObservable(store, index, true);
        var _a = filteredViewData[rowIndex].valueMap[columnName], disabled = _a.disabled, editable = _a.editable;
        return !column_1.isHiddenColumn(column, columnName) && editable && !disabled;
    }
    exports.isEditableCell = isEditableCell;
    function getCheckedRowInfoList(_a) {
        var data = _a.data;
        var targetRows = {
            rowIndexes: [],
            rows: [],
            nextRows: [],
        };
        data.rawData.reduce(function (acc, row, index) {
            if (row._attributes.checked) {
                acc.rowIndexes.push(index);
                acc.rows.push(row);
                acc.nextRows.push(data.rawData[index + 1]);
            }
            return acc;
        }, targetRows);
        return targetRows;
    }
    exports.getCheckedRowInfoList = getCheckedRowInfoList;
    function getConditionalRows(_a, conditions) {
        var data = _a.data;
        var rawData = data.rawData;
        if (common_1.isFunction(conditions)) {
            return rawData.filter(conditions);
        }
        var result = rawData;
        Object.keys(conditions).forEach(function (key) {
            result = result.filter(function (row) { return row[key] === conditions[key]; });
        });
        return result;
    }
    exports.getConditionalRows = getConditionalRows;
    function findIndexByRowKey(data, column, id, rowKey, filtered) {
        if (filtered === void 0) { filtered = true; }
        if (common_1.isNil(rowKey)) {
            return -1;
        }
        var filteredRawData = data.filteredRawData, rawData = data.rawData, sortState = data.sortState;
        var targetData = filtered ? filteredRawData : rawData;
        var dataManager = instance_1.getDataManager(id);
        var modified = dataManager ? dataManager.isMixedOrder() : false;
        if (!rowSpan_1.isRowSpanEnabled(sortState) || column.keyColumnName || modified) {
            return common_1.findPropIndex('rowKey', rowKey, targetData);
        }
        var start = 0;
        var end = targetData.length - 1;
        while (start <= end) {
            var mid = Math.floor((start + end) / 2);
            var comparedRowKey = targetData[mid].rowKey;
            if (rowKey > comparedRowKey) {
                start = mid + 1;
            }
            else if (rowKey < comparedRowKey) {
                end = mid - 1;
            }
            else {
                return mid;
            }
        }
        return -1;
    }
    exports.findIndexByRowKey = findIndexByRowKey;
    function findRowByRowKey(data, column, id, rowKey, filtered) {
        if (filtered === void 0) { filtered = true; }
        var targetData = filtered ? data.filteredRawData : data.rawData;
        return targetData[findIndexByRowKey(data, column, id, rowKey, filtered)];
    }
    exports.findRowByRowKey = findRowByRowKey;
    function getUniqColumnData(targetData, column, columnName) {
        var columnInfo = column.allColumnMap[columnName];
        var uniqColumnData = common_1.uniqByProp(columnName, targetData.map(function (data) {
            var _a;
            return (tslib_1.__assign(tslib_1.__assign({}, data), (_a = {}, _a[columnName] = common_1.isNil(data[columnName]) ? '' : data[columnName], _a)));
        }));
        return uniqColumnData.map(function (row) {
            var value = row[columnName];
            var formatterProps = {
                row: row,
                value: value,
                column: columnInfo,
            };
            var relationListItems = row._relationListItemMap[columnName];
            return data_2.getFormattedValue(formatterProps, columnInfo.formatter, value, relationListItems);
        });
    }
    exports.getUniqColumnData = getUniqColumnData;
    function isSortable(sortState, column, columnName) {
        if (columnName === 'sortKey') {
            return true;
        }
        var _a = column.allColumnMap[columnName], sortable = _a.sortable, hidden = _a.hidden;
        return sortState.useClient && !hidden && sortable;
    }
    exports.isSortable = isSortable;
    function isInitialSortState(_a) {
        var columns = _a.columns;
        return columns.length === 1 && columns[0].columnName === 'sortKey';
    }
    exports.isInitialSortState = isInitialSortState;
    function getRowHeight(row, defaultRowHeight) {
        var _a = row._attributes, height = _a.height, tree = _a.tree;
        var rowHeight = tree && tree.hidden ? 0 : height;
        return common_1.isNumber(rowHeight) ? rowHeight : defaultRowHeight;
    }
    exports.getRowHeight = getRowHeight;
    function getLoadingState(rawData) {
        return rawData.length ? 'DONE' : 'EMPTY';
    }
    exports.getLoadingState = getLoadingState;
    function getAddedClassName(className, prevClassNames) {
        var classNames = className.split(' ');
        var columnClassNames = prevClassNames ? prevClassNames : [];
        return common_1.uniq(tslib_1.__spreadArrays(classNames, columnClassNames));
    }
    exports.getAddedClassName = getAddedClassName;
    function getRemovedClassName(className, prevClassNames) {
        var classNames = className.split(' ');
        var removedClassNames = prevClassNames;
        classNames.forEach(function (clsName) {
            common_1.removeArrayItem(clsName, removedClassNames);
        });
        return removedClassNames;
    }
    exports.getRemovedClassName = getRemovedClassName;
    function getCreatedRowInfo(store, rowIndex, row, rowKey) {
        data_1.generateDataCreationKey();
        var data = store.data, column = store.column, id = store.id;
        var rawData = data.rawData;
        var prevRow = rawData[rowIndex - 1];
        var options = { prevRow: prevRow, lazyObservable: true };
        if (!common_1.isUndefined(rowKey)) {
            row.rowKey = rowKey;
        }
        var index = getMaxRowKey(data);
        var rawRow = data_1.createRawRow(id, tslib_1.__assign(tslib_1.__assign({}, column.emptyRow), row), index, column, options);
        var viewRow = { rowKey: row.rowKey, sortKey: row.sortKey, uniqueKey: row.uniqueKey };
        return { rawRow: rawRow, viewRow: viewRow, prevRow: prevRow };
    }
    exports.getCreatedRowInfo = getCreatedRowInfo;
    function isSorted(data) {
        return data.sortState.columns[0].columnName !== 'sortKey';
    }
    exports.isSorted = isSorted;
    function isFiltered(data) {
        return !common_1.isNull(data.filters);
    }
    exports.isFiltered = isFiltered;
    function getMaxRowKey(data) {
        return Math.max.apply(Math, tslib_1.__spreadArrays([-1], common_1.mapProp('rowKey', data.rawData))) + 1;
    }
    exports.getMaxRowKey = getMaxRowKey;
    function isScrollPagination(_a, useClient) {
        var pageOptions = _a.pageOptions;
        if (common_1.isUndefined(useClient)) {
            return pageOptions.type === 'scroll';
        }
        return useClient && pageOptions.type === 'scroll';
    }
    exports.isScrollPagination = isScrollPagination;
    function isClientPagination(_a) {
        var pageOptions = _a.pageOptions;
        return !common_1.isEmpty(pageOptions) && pageOptions.useClient && pageOptions.type === 'pagination';
    }
    exports.isClientPagination = isClientPagination;
    function getRowIndexPerPage(data, rowIndex) {
        return isClientPagination(data) ? rowIndex % data.pageOptions.perPage : rowIndex;
    }
    exports.getRowIndexPerPage = getRowIndexPerPage;
    function getRowKeyByIndexWithPageRange(data, rowIndex) {
        if (isClientPagination(data)) {
            rowIndex += data.pageRowRange[0];
        }
        return data.filteredRawData[rowIndex].rowKey;
    }
    exports.getRowKeyByIndexWithPageRange = getRowKeyByIndexWithPageRange;
    function getFormattedValue(store, rowKey, columnName) {
        var data = store.data, column = store.column, id = store.id;
        var rowIndex = findIndexByRowKey(data, column, id, rowKey, false);
        var viewData = data.viewData;
        if (rowIndex !== -1) {
            data_3.makeObservable(store, rowIndex);
            var viewCell = viewData[rowIndex].valueMap[columnName];
            return viewCell ? viewCell.formattedValue : null;
        }
        return null;
    }
    exports.getFormattedValue = getFormattedValue;
    function createChangeInfo(store, row, columnName, pastingValue, index) {
        var id = store.id, column = store.column;
        var rowKey = row.rowKey;
        var prevChange = { rowKey: rowKey, columnName: columnName, value: row[columnName], nextValue: pastingValue };
        var nextChange = { rowKey: rowKey, columnName: columnName, prevValue: row[columnName], value: pastingValue };
        var changeValue = function () {
            var value = prevChange.value, nextValue = prevChange.nextValue;
            validation_1.replaceColumnUniqueInfoMap(id, column, {
                rowKey: rowKey,
                columnName: columnName,
                prevValue: value,
                value: nextValue,
            });
            nextChange.value = nextValue;
            row[columnName] = nextValue;
            return index;
        };
        return { prevChange: prevChange, nextChange: nextChange, changeValue: changeValue };
    }
    exports.createChangeInfo = createChangeInfo;
    function getOmittedInternalProp(row) {
        var additaional = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            additaional[_i - 1] = arguments[_i];
        }
        return common_1.omit.apply(void 0, tslib_1.__spreadArrays([observable_1.getOriginObject(row), 'sortKey',
            'uniqueKey',
            'rowSpanMap',
            '_relationListItemMap',
            '_disabledPriority'], additaional));
    }
    exports.getOmittedInternalProp = getOmittedInternalProp;
    function changeRowToOriginRowForTree(row) {
        var originRow = getOmittedInternalProp(row, 'rowKey', '_attributes');
        if (originRow._children) {
            originRow._children = originRow._children.map(function (childRow) {
                return changeRowToOriginRowForTree(childRow);
            });
        }
        return originRow;
    }
    function changeRawDataToOriginDataForTree(rawData) {
        return rawData
            .filter(function (row) { var _a, _b; return common_1.isNil((_b = (_a = row._attributes) === null || _a === void 0 ? void 0 : _a.tree) === null || _b === void 0 ? void 0 : _b.parentRowKey); })
            .map(function (row) { return changeRowToOriginRowForTree(row); });
    }
    exports.changeRawDataToOriginDataForTree = changeRawDataToOriginDataForTree;


    /***/ }),
    /* 7 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getPaginationManager = exports.getDataManager = exports.getDataProvider = exports.getInstance = exports.registerDataSources = exports.register = void 0;
    var common_1 = __webpack_require__(0);
    var currentId = 0;
    var instanceMap = {};
    function generateId() {
        currentId += 1;
        return currentId;
    }
    function register(instance) {
        var id = generateId();
        if (!common_1.isObject(instanceMap[id])) {
            instanceMap[id] = {};
        }
        instanceMap[id].grid = instance;
        return id;
    }
    exports.register = register;
    function registerDataSources(id, dataProvider, dataManager, paginationManager) {
        instanceMap[id].dataProvider = dataProvider;
        instanceMap[id].dataManager = dataManager;
        instanceMap[id].paginationManager = paginationManager;
    }
    exports.registerDataSources = registerDataSources;
    function getInstance(id) {
        return instanceMap[id].grid;
    }
    exports.getInstance = getInstance;
    function getDataProvider(id) {
        return instanceMap[id].dataProvider;
    }
    exports.getDataProvider = getDataProvider;
    function getDataManager(id) {
        return instanceMap[id].dataManager;
    }
    exports.getDataManager = getDataManager;
    function getPaginationManager(id) {
        return instanceMap[id].paginationManager;
    }
    exports.getPaginationManager = getPaginationManager;


    /***/ }),
    /* 8 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEventBus = exports.createEventBus = void 0;
    var tslib_1 = __webpack_require__(1);
    var common_1 = __webpack_require__(0);
    var instance_1 = __webpack_require__(7);
    var eventBusMap = {};
    function createEventBus(id) {
        var listenersMap = {};
        eventBusMap[id] = {
            on: function (eventName, func) {
                var listeners = listenersMap[eventName];
                listenersMap[eventName] = listeners ? tslib_1.__spreadArrays(listeners, [func]) : [func];
            },
            off: function (eventName, func) {
                var listeners = listenersMap[eventName];
                if (listeners) {
                    if (func) {
                        listenersMap[eventName] = common_1.removeArrayItem(func, listeners);
                    }
                    else {
                        delete listenersMap[eventName];
                    }
                }
            },
            trigger: function (eventName, gridEvent) {
                if (listenersMap[eventName]) {
                    var instance = instance_1.getInstance(id);
                    gridEvent.setInstance(instance);
                    listenersMap[eventName].forEach(function (func) {
                        func(gridEvent);
                    });
                }
            },
        };
        return eventBusMap[id];
    }
    exports.createEventBus = createEventBus;
    function getEventBus(id) {
        return eventBusMap[id];
    }
    exports.getEventBus = getEventBus;


    /***/ }),
    /* 9 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(1);
    var dom_1 = __webpack_require__(2);
    var common_1 = __webpack_require__(0);
    var column_1 = __webpack_require__(10);
    function getTargetInfo(nativeEvent) {
        var targetType = 'etc';
        var target = nativeEvent.target;
        var cell = dom_1.findParentByTagName(target, 'td');
        var rowKey, columnName;
        if (cell) {
            var address = dom_1.getCellAddress(cell);
            if (address) {
                rowKey = address.rowKey;
                columnName = address.columnName;
                targetType = column_1.isRowHeader(address.columnName) ? 'rowHeader' : 'cell';
            }
            else {
                targetType = 'dummy';
            }
        }
        else {
            cell = dom_1.findParentByTagName(target, 'th');
            if (cell) {
                columnName = cell.getAttribute(dom_1.dataAttr.COLUMN_NAME);
                targetType = 'columnHeader';
            }
        }
        return common_1.pruneObject({
            nativeEvent: nativeEvent,
            targetType: targetType,
            rowKey: rowKey,
            columnName: columnName,
        });
    }
    /**
     * Event class for public event of Grid
     * @module event/gridEvent
     * @param {Object} data - Event data for handler
     */
    var GridEvent = /** @class */ (function () {
        function GridEvent(_a) {
            if (_a === void 0) { _a = {}; }
            var event = _a.event, props = tslib_1.__rest(_a, ["event"]);
            this.stopped = false;
            if (event) {
                this.assignData(getTargetInfo(event));
            }
            if (props) {
                this.assignData(props);
            }
        }
        /**
         * Stops propogation of this event.
         * @memberof event/gridEvent
         */
        GridEvent.prototype.stop = function () {
            this.stopped = true;
        };
        GridEvent.prototype.isStopped = function () {
            return this.stopped;
        };
        GridEvent.prototype.assignData = function (data) {
            common_1.assign(this, data);
        };
        GridEvent.prototype.setInstance = function (instance) {
            common_1.assign(this, { instance: instance });
        };
        return GridEvent;
    }());
    exports.default = GridEvent;


    /***/ }),
    /* 10 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isCheckboxColumn = exports.isRowNumColumn = exports.isRowHeader = void 0;
    var common_1 = __webpack_require__(0);
    function isRowHeader(columnName) {
        return common_1.includes(['_number', '_checked', '_draggable'], columnName);
    }
    exports.isRowHeader = isRowHeader;
    function isRowNumColumn(columnName) {
        return columnName === '_number';
    }
    exports.isRowNumColumn = isRowNumColumn;
    function isCheckboxColumn(columnName) {
        return columnName === '_checked';
    }
    exports.isCheckboxColumn = isCheckboxColumn;


    /***/ }),
    /* 11 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isRowSpanEnabled = exports.getMaxRowSpanCount = exports.getRowSpanByRowKey = exports.getRowSpanBottomIndex = exports.getRowSpanTopIndex = exports.getRowSpan = exports.getVerticalPosWithRowSpan = exports.getRowRangeWithRowSpan = exports.getMaxRowSpanRange = void 0;
    var common_1 = __webpack_require__(0);
    var selection_1 = __webpack_require__(20);
    function getMainRowSpan(columnName, rowSpan, data) {
        var mainRow = rowSpan.mainRow, mainRowKey = rowSpan.mainRowKey;
        if (mainRow) {
            return rowSpan;
        }
        var mainRowIndex = common_1.findPropIndex('rowKey', mainRowKey, data);
        return data[mainRowIndex].rowSpanMap[columnName];
    }
    function getRowSpanRange(rowRange, colRange, visibleColumns, data) {
        var startColumnIndex = colRange[0], endColumnIndex = colRange[1];
        var startRowIndex = rowRange[0], endRowIndex = rowRange[1];
        for (var index = startColumnIndex; index <= endColumnIndex; index += 1) {
            var rawData = data.rawData;
            var startRowSpanMap = rawData[startRowIndex].rowSpanMap;
            var endRowSpanMap = rawData[endRowIndex].rowSpanMap;
            var columnName = visibleColumns[index].name;
            // get top row index of topmost rowSpan
            if (startRowSpanMap[columnName]) {
                var mainRowKey = startRowSpanMap[columnName].mainRowKey;
                var topRowSpanIndex = common_1.findPropIndex('rowKey', mainRowKey, rawData);
                startRowIndex = startRowIndex > topRowSpanIndex ? topRowSpanIndex : startRowIndex;
            }
            // get bottom row index of bottommost rowSpan
            if (endRowSpanMap[columnName]) {
                var _a = endRowSpanMap[columnName], mainRowKey = _a.mainRowKey, spanCount = _a.spanCount;
                var bottomRowSpanIndex = common_1.findPropIndex('rowKey', mainRowKey, rawData) + spanCount - 1;
                endRowIndex = endRowIndex < bottomRowSpanIndex ? bottomRowSpanIndex : endRowIndex;
            }
        }
        return startRowIndex !== rowRange[0] || endRowIndex !== rowRange[1]
            ? getRowSpanRange([startRowIndex, endRowIndex], colRange, visibleColumns, data)
            : [startRowIndex, endRowIndex];
    }
    function getMaxRowSpanRange(rowRange, colRange, visibleColumns, focusRowIndex, data) {
        var sortedColRange = selection_1.getSortedRange(colRange);
        var endRowIndex = rowRange[1];
        var startRowIndex = rowRange[0];
        // if start row index is different from focused index,
        // change start row index to focused row index for getting proper row range
        startRowIndex =
            !common_1.isNull(focusRowIndex) && startRowIndex !== focusRowIndex ? focusRowIndex : startRowIndex;
        var sortedRowRange = selection_1.getSortedRange([startRowIndex, endRowIndex]);
        var _a = getRowSpanRange(sortedRowRange, sortedColRange, visibleColumns, data), startRowSpanIndex = _a[0], endRowSpanIndex = _a[1];
        return startRowIndex > endRowIndex
            ? [endRowSpanIndex, startRowSpanIndex]
            : [startRowSpanIndex, endRowSpanIndex];
    }
    exports.getMaxRowSpanRange = getMaxRowSpanRange;
    function getRowRangeWithRowSpan(rowRange, colRange, visibleColumnsWithRowHeader, rowIndex, data) {
        if (isRowSpanEnabled(data.sortState)) {
            return getMaxRowSpanRange(rowRange, colRange, visibleColumnsWithRowHeader, rowIndex, data);
        }
        return rowRange;
    }
    exports.getRowRangeWithRowSpan = getRowRangeWithRowSpan;
    function getVerticalPosWithRowSpan(columnName, rowSpan, rowCoords, data) {
        var mainRowSpan = getMainRowSpan(columnName, rowSpan, data);
        var mainRowIndex = common_1.findPropIndex('rowKey', mainRowSpan.mainRowKey, data);
        var spanCount = mainRowSpan.spanCount;
        var top = rowCoords.offsets[mainRowIndex];
        var bottom = top;
        for (var count = 0; count < spanCount; count += 1) {
            bottom += rowCoords.heights[mainRowIndex + count];
        }
        return [top, bottom];
    }
    exports.getVerticalPosWithRowSpan = getVerticalPosWithRowSpan;
    function getRowSpan(rowIndex, columnName, data) {
        var rowSpanMap = data[rowIndex].rowSpanMap;
        return rowSpanMap[columnName];
    }
    exports.getRowSpan = getRowSpan;
    /*
     * get top row index of specific rowSpan cell
     */
    function getRowSpanTopIndex(rowIndex, columnName, data) {
        var rowSpan = getRowSpan(rowIndex, columnName, data);
        if (!rowSpan) {
            return rowIndex;
        }
        return common_1.findPropIndex('rowKey', rowSpan.mainRowKey, data);
    }
    exports.getRowSpanTopIndex = getRowSpanTopIndex;
    /*
     * get bottom row index of specific rowSpan cell
     */
    function getRowSpanBottomIndex(rowIndex, columnName, data) {
        var rowSpan = getRowSpan(rowIndex, columnName, data);
        if (!rowSpan) {
            return rowIndex;
        }
        var mainRowIndex = common_1.findPropIndex('rowKey', rowSpan.mainRowKey, data);
        return mainRowIndex + rowSpan.spanCount - 1;
    }
    exports.getRowSpanBottomIndex = getRowSpanBottomIndex;
    function getRowSpanByRowKey(rowKey, columnName, data) {
        var rowIndex = common_1.findPropIndex('rowKey', rowKey, data);
        if (rowIndex === -1) {
            return null;
        }
        return getRowSpan(rowIndex, columnName, data) || null;
    }
    exports.getRowSpanByRowKey = getRowSpanByRowKey;
    /*
     * get max rowSpan count in all columns that have rowSpan
     */
    function getMaxRowSpanCount(rowIndex, data) {
        var _a;
        var rowSpanMap = (_a = data[rowIndex]) === null || _a === void 0 ? void 0 : _a.rowSpanMap;
        if (common_1.isEmpty(rowSpanMap)) {
            return 0;
        }
        return Object.keys(rowSpanMap).reduce(function (acc, columnName) { return Math.max(acc, rowSpanMap[columnName].spanCount); }, 0);
    }
    exports.getMaxRowSpanCount = getMaxRowSpanCount;
    function isRowSpanEnabled(sortState) {
        return sortState.columns[0].columnName === 'sortKey';
    }
    exports.isRowSpanEnabled = isRowSpanEnabled;


    /***/ }),
    /* 12 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getColumnSide = exports.getChildHeaderCount = exports.getHierarchyMaxRowCount = exports.getComplexColumnsHierarchy = exports.getRemovedHiddenChildColumns = exports.getColumnHierarchy = exports.isComplexHeader = exports.isHiddenColumn = exports.isParentColumnHeader = void 0;
    var tslib_1 = __webpack_require__(1);
    var common_1 = __webpack_require__(0);
    function isParentColumnHeader(complexColumnHeaders, name) {
        return !!complexColumnHeaders.length && common_1.some(function (item) { return item.name === name; }, complexColumnHeaders);
    }
    exports.isParentColumnHeader = isParentColumnHeader;
    function isHiddenColumn(column, columnName) {
        return column.allColumnMap[columnName].hidden;
    }
    exports.isHiddenColumn = isHiddenColumn;
    function isComplexHeader(column, columnName) {
        return common_1.some(function (_a) {
            var name = _a.name, hideChildHeaders = _a.hideChildHeaders, childNames = _a.childNames;
            return !!(name === columnName || (hideChildHeaders && common_1.includes(childNames, columnName)));
        }, column.complexColumnHeaders);
    }
    exports.isComplexHeader = isComplexHeader;
    function getColumnHierarchy(column, complexColumnHeaders, mergedComplexColumns) {
        var complexColumns = mergedComplexColumns || [];
        if (column) {
            complexColumns.push(column);
            if (complexColumnHeaders) {
                complexColumnHeaders.forEach(function (complexColumnHeader) {
                    if (common_1.includes(complexColumnHeader.childNames, column.name)) {
                        getColumnHierarchy(complexColumnHeader, complexColumnHeaders, complexColumns);
                    }
                });
            }
        }
        return complexColumns;
    }
    exports.getColumnHierarchy = getColumnHierarchy;
    function getRemovedHiddenChildColumns(hierarchies) {
        return hierarchies.map(function (columns) {
            if (columns.length > 1) {
                // The hideChildHeaders option always exists in the second column to last.
                var hideChildHeaders = columns[columns.length - 2].hideChildHeaders;
                if (hideChildHeaders) {
                    columns.pop();
                }
            }
            return columns;
        });
    }
    exports.getRemovedHiddenChildColumns = getRemovedHiddenChildColumns;
    function getComplexColumnsHierarchy(columns, complexColumnHeaders) {
        return getRemovedHiddenChildColumns(columns.map(function (column) { return getColumnHierarchy(column, complexColumnHeaders).reverse(); }));
    }
    exports.getComplexColumnsHierarchy = getComplexColumnsHierarchy;
    function getHierarchyMaxRowCount(hierarchies) {
        return Math.max.apply(Math, tslib_1.__spreadArrays([0], common_1.mapProp('length', hierarchies)));
    }
    exports.getHierarchyMaxRowCount = getHierarchyMaxRowCount;
    function getChildHeaderCount(columns, complexColumns, name) {
        var count = 0;
        var leafColumn = common_1.someProp('name', name, columns);
        if (!leafColumn) {
            var complexColumn = common_1.findProp('name', name, complexColumns);
            if (complexColumn) {
                complexColumn.childNames.forEach(function (childName) {
                    var leafChildColumn = common_1.someProp('name', childName, columns);
                    count += leafChildColumn ? 1 : getChildHeaderCount(columns, complexColumns, childName);
                });
            }
        }
        return count;
    }
    exports.getChildHeaderCount = getChildHeaderCount;
    function getColumnSide(column, columnName) {
        return common_1.someProp('name', columnName, column.visibleColumnsBySideWithRowHeader.R) ? 'R' : 'L';
    }
    exports.getColumnSide = getColumnSide;


    /***/ }),
    /* 13 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.removeRows = exports.appendRows = exports.scrollToNext = exports.moveRow = exports.setRow = exports.updateRowNumber = exports.setCheckedAllRows = exports.setLoadingState = exports.removeColumnClassName = exports.addColumnClassName = exports.removeCellClassName = exports.addCellClassName = exports.removeRowClassName = exports.addRowClassName = exports.resetData = exports.clearData = exports.removeRow = exports.appendRow = exports.setRowCheckDisabled = exports.setColumnDisabled = exports.setRowDisabled = exports.setDisabled = exports.setDisabledAllCheckbox = exports.uncheckAll = exports.checkAll = exports.uncheck = exports.check = exports.setColumnValues = exports.setAllRowAttribute = exports.setRowAttribute = exports.isUpdatableRowAttr = exports.setValue = exports.makeObservable = exports.updateHeights = void 0;
    var tslib_1 = __webpack_require__(1);
    var common_1 = __webpack_require__(0);
    var data_1 = __webpack_require__(15);
    var observable_1 = __webpack_require__(5);
    var selection_1 = __webpack_require__(16);
    var eventBus_1 = __webpack_require__(8);
    var gridEvent_1 = tslib_1.__importDefault(__webpack_require__(9));
    var instance_1 = __webpack_require__(7);
    var tree_1 = __webpack_require__(30);
    var rowSpan_1 = __webpack_require__(11);
    var focus_1 = __webpack_require__(18);
    var tree_2 = __webpack_require__(21);
    var sort_1 = __webpack_require__(28);
    var data_2 = __webpack_require__(6);
    var summary_1 = __webpack_require__(24);
    var filter_1 = __webpack_require__(34);
    var viewport_1 = __webpack_require__(23);
    var column_1 = __webpack_require__(10);
    var pagination_1 = __webpack_require__(35);
    var rowSpan_2 = __webpack_require__(75);
    var lazyObservable_1 = __webpack_require__(27);
    var validation_1 = __webpack_require__(25);
    var column_2 = __webpack_require__(31);
    function updateHeightsWithFilteredData(store) {
        if (store.data.filters) {
            focus_1.initFocus(store);
        }
        updateHeights(store);
    }
    function updateHeights(store) {
        var data = store.data, rowCoords = store.rowCoords, dimension = store.dimension;
        var pageOptions = data.pageOptions, pageRowRange = data.pageRowRange, filteredRawData = data.filteredRawData;
        var rowHeight = dimension.rowHeight;
        rowCoords.heights = pageOptions.useClient
            ? filteredRawData.slice.apply(filteredRawData, pageRowRange).map(function (row) { return data_2.getRowHeight(row, rowHeight); })
            : filteredRawData.map(function (row) { return data_2.getRowHeight(row, rowHeight); });
    }
    exports.updateHeights = updateHeights;
    function makeObservable(store, rowIndex, silent) {
        if (silent === void 0) { silent = false; }
        var data = store.data, column = store.column, id = store.id;
        var rawData = data.rawData, viewData = data.viewData;
        var treeColumnName = column.treeColumnName;
        var rawRow = rawData[rowIndex];
        if (observable_1.isObservable(rawRow)) {
            return;
        }
        if (treeColumnName) {
            var parentRow = data_2.findRowByRowKey(data, column, id, rawRow._attributes.tree.parentRowKey);
            rawData[rowIndex] = tree_2.createTreeRawRow(id, rawRow, parentRow || null, column);
        }
        else {
            rawData[rowIndex] = data_1.createRawRow(id, rawRow, rowIndex, column);
        }
        viewData[rowIndex] = data_1.createViewRow(id, rawData[rowIndex], rawData, column);
        if (!silent) {
            observable_1.notify(data, 'rawData', 'filteredRawData', 'viewData', 'filteredViewData');
        }
    }
    exports.makeObservable = makeObservable;
    function setValue(store, rowKey, columnName, value, checkCellState) {
        if (checkCellState === void 0) { checkCellState = false; }
        var gridEvent;
        var column = store.column, data = store.data, id = store.id;
        var eventBus = eventBus_1.getEventBus(id);
        var rawData = data.rawData, viewData = data.viewData, sortState = data.sortState;
        var allColumnMap = column.allColumnMap, columnsWithoutRowHeader = column.columnsWithoutRowHeader;
        var rowIndex = data_2.findIndexByRowKey(data, column, id, rowKey, false);
        var targetRow = rawData[rowIndex];
        if (!targetRow || targetRow[columnName] === value) {
            return;
        }
        if (checkCellState) {
            makeObservable(store, rowIndex);
            var _a = viewData[rowIndex].valueMap[columnName], disabled = _a.disabled, editable = _a.editable;
            if (disabled || !editable) {
                return;
            }
        }
        var targetColumn = common_1.findProp('name', columnName, columnsWithoutRowHeader);
        var orgValue = targetRow[columnName];
        // @TODO: 'onBeforeChange' event is deprecated. This event will be replaced with 'beforeChange' event
        if (targetColumn && targetColumn.onBeforeChange) {
            gridEvent = new gridEvent_1.default({ rowKey: rowKey, columnName: columnName, value: orgValue, nextValue: value });
            targetColumn.onBeforeChange(gridEvent);
            if (gridEvent.isStopped()) {
                return;
            }
        }
        var change = { rowKey: rowKey, columnName: columnName, value: orgValue, nextValue: value };
        gridEvent = new gridEvent_1.default({ origin: 'cell', changes: [change] });
        /**
         * Occurs before one or more cells is changed
         * @event Grid#beforeChange
         * @property {string} origin - The type of change('paste', 'delete', 'cell')
         * @property {Array.<object>} changes - rowKey, column name, original values and next values before changing the values
         * @property {Grid} instance - Current grid instance
         */
        eventBus.trigger('beforeChange', gridEvent);
        if (gridEvent.isStopped()) {
            return;
        }
        value = change.nextValue;
        var rowSpanMap = targetRow.rowSpanMap;
        var columns = sortState.columns;
        var index = common_1.findPropIndex('columnName', columnName, columns);
        validation_1.replaceColumnUniqueInfoMap(id, column, { rowKey: rowKey, columnName: columnName, prevValue: orgValue, value: value });
        targetRow[columnName] = value;
        data_1.setRowRelationListItems(targetRow, allColumnMap);
        if (index !== -1) {
            sort_1.sort(store, columnName, columns[index].ascending, true, false);
        }
        updateHeightsWithFilteredData(store);
        summary_1.updateSummaryValueByCell(store, columnName, { orgValue: orgValue, value: value });
        instance_1.getDataManager(id).push('UPDATE', targetRow);
        if (!common_1.isEmpty(rowSpanMap) && rowSpanMap[columnName] && rowSpan_1.isRowSpanEnabled(sortState)) {
            var spanCount = rowSpanMap[columnName].spanCount;
            // update sub rows value
            for (var count = 1; count < spanCount; count += 1) {
                rawData[rowIndex + count][columnName] = value;
                summary_1.updateSummaryValueByCell(store, columnName, { orgValue: orgValue, value: value });
                instance_1.getDataManager(id).push('UPDATE', rawData[rowIndex + count]);
            }
        }
        column_2.setAutoResizingColumnWidths(store);
        // @TODO: 'onAfterChange' event is deprecated. This event will be replaced with 'afterChange' event
        if (targetColumn && targetColumn.onAfterChange) {
            gridEvent = new gridEvent_1.default({ rowKey: rowKey, columnName: columnName, value: value, prevValue: orgValue });
            targetColumn.onAfterChange(gridEvent);
        }
        gridEvent = new gridEvent_1.default({
            origin: 'cell',
            changes: [{ rowKey: rowKey, columnName: columnName, value: value, prevValue: orgValue }],
        });
        /**
         * Occurs after one or more cells is changed
         * @event Grid#afterChange
         * @property {string} origin - The type of change('paste', 'delete', 'cell')
         * @property {Array.<object>} changes - rowKey, column name, previous values and changed values after changing the values
         * @property {Grid} instance - Current grid instance
         */
        eventBus.trigger('afterChange', gridEvent);
    }
    exports.setValue = setValue;
    function isUpdatableRowAttr(name, checkDisabled) {
        return !(name === 'checked' && checkDisabled);
    }
    exports.isUpdatableRowAttr = isUpdatableRowAttr;
    function setRowAttribute(_a, rowKey, attrName, value) {
        var data = _a.data, column = _a.column, id = _a.id;
        var targetRow = data_2.findRowByRowKey(data, column, id, rowKey, false);
        // https://github.com/microsoft/TypeScript/issues/34293
        if (targetRow && isUpdatableRowAttr(attrName, targetRow._attributes.checkDisabled)) {
            targetRow._attributes[attrName] = value;
        }
    }
    exports.setRowAttribute = setRowAttribute;
    function setAllRowAttribute(_a, attrName, value, allPage) {
        var data = _a.data;
        if (allPage === void 0) { allPage = true; }
        var filteredRawData = data.filteredRawData;
        var range = allPage ? [0, filteredRawData.length] : data.pageRowRange;
        filteredRawData.slice.apply(filteredRawData, range).forEach(function (row) {
            if (isUpdatableRowAttr(attrName, row._attributes.checkDisabled)) {
                // https://github.com/microsoft/TypeScript/issues/34293
                row._attributes[attrName] = value;
            }
        });
    }
    exports.setAllRowAttribute = setAllRowAttribute;
    function setColumnValues(store, columnName, value, checkCellState) {
        if (checkCellState === void 0) { checkCellState = false; }
        if (checkCellState) {
            // @TODO: find more practical way to make observable
            lazyObservable_1.createObservableData(store, true);
        }
        var id = store.id, data = store.data, column = store.column;
        data.rawData.forEach(function (targetRow, index) {
            var valid = true;
            if (checkCellState) {
                var _a = data.viewData[index].valueMap[columnName], disabled = _a.disabled, editable = _a.editable;
                valid = !disabled && editable;
            }
            if (targetRow[columnName] !== value && valid) {
                validation_1.replaceColumnUniqueInfoMap(id, column, {
                    rowKey: targetRow.rowKey,
                    columnName: columnName,
                    prevValue: targetRow[columnName],
                    value: value,
                });
                targetRow[columnName] = value;
                instance_1.getDataManager(id).push('UPDATE', targetRow);
            }
        });
        summary_1.updateSummaryValueByColumn(store, columnName, { value: value });
        validation_1.forceValidateUniquenessOfColumn(data.rawData, column, columnName);
        column_2.setAutoResizingColumnWidths(store);
    }
    exports.setColumnValues = setColumnValues;
    function check(store, rowKey) {
        var id = store.id, column = store.column;
        var allColumnMap = column.allColumnMap, _a = column.treeColumnName, treeColumnName = _a === void 0 ? '' : _a;
        var eventBus = eventBus_1.getEventBus(id);
        var gridEvent = new gridEvent_1.default({ rowKey: rowKey });
        setRowAttribute(store, rowKey, 'checked', true);
        if (allColumnMap[treeColumnName]) {
            tree_1.changeTreeRowsCheckedState(store, rowKey, true);
        }
        observable_1.asyncInvokeObserver(function () {
            setCheckedAllRows(store);
        });
        /**
         * Occurs when a checkbox in row header is checked
         * @event Grid#check
         * @property {number | string} rowKey - rowKey of the checked row
         * @property {Grid} instance - Current grid instance
         */
        eventBus.trigger('check', gridEvent);
    }
    exports.check = check;
    function uncheck(store, rowKey) {
        var id = store.id, column = store.column;
        var allColumnMap = column.allColumnMap, _a = column.treeColumnName, treeColumnName = _a === void 0 ? '' : _a;
        var eventBus = eventBus_1.getEventBus(id);
        var gridEvent = new gridEvent_1.default({ rowKey: rowKey });
        setRowAttribute(store, rowKey, 'checked', false);
        if (allColumnMap[treeColumnName]) {
            tree_1.changeTreeRowsCheckedState(store, rowKey, false);
        }
        observable_1.asyncInvokeObserver(function () {
            setCheckedAllRows(store);
        });
        /**
         * Occurs when a checkbox in row header is unchecked
         * @event Grid#uncheck
         * @property {number | string} rowKey - rowKey of the unchecked row
         * @property {Grid} instance - Current grid instance
         */
        eventBus.trigger('uncheck', gridEvent);
    }
    exports.uncheck = uncheck;
    function checkAll(store, allPage) {
        var id = store.id;
        setAllRowAttribute(store, 'checked', true, allPage);
        setCheckedAllRows(store);
        var eventBus = eventBus_1.getEventBus(id);
        var gridEvent = new gridEvent_1.default();
        /**
         * Occurs when a checkbox in header is checked(checked all checkbox in row header)
         * @event Grid#checkAll
         * @property {Grid} instance - Current grid instance
         */
        eventBus.trigger('checkAll', gridEvent);
    }
    exports.checkAll = checkAll;
    function uncheckAll(store, allPage) {
        var id = store.id;
        setAllRowAttribute(store, 'checked', false, allPage);
        setCheckedAllRows(store);
        var eventBus = eventBus_1.getEventBus(id);
        var gridEvent = new gridEvent_1.default();
        /**
         * Occurs when a checkbox in header is unchecked(unchecked all checkbox in row header)
         * @event Grid#uncheckAll
         * @property {Grid} instance - Current grid instance
         */
        eventBus.trigger('uncheckAll', gridEvent);
    }
    exports.uncheckAll = uncheckAll;
    function setDisabledAllCheckbox(_a) {
        var data = _a.data;
        var rawData = data.rawData;
        data.disabledAllCheckbox =
            !!rawData.length && rawData.every(function (row) { return row._attributes.checkDisabled; });
    }
    exports.setDisabledAllCheckbox = setDisabledAllCheckbox;
    function setRowOrColumnDisabled(target, disabled) {
        if (target.disabled === disabled) {
            observable_1.notify(target, 'disabled');
        }
        else {
            target.disabled = disabled;
        }
    }
    // @TODO consider the client pagination with disabled
    function setDisabled(store, disabled) {
        var data = store.data, column = store.column;
        data.rawData.forEach(function (row) {
            row._disabledPriority = {};
            setAllRowAttribute(store, 'disabled', disabled);
            setAllRowAttribute(store, 'checkDisabled', disabled);
        });
        column.columnsWithoutRowHeader.forEach(function (columnInfo) {
            columnInfo.disabled = disabled;
        });
        data.disabledAllCheckbox = disabled;
    }
    exports.setDisabled = setDisabled;
    function setRowDisabled(store, disabled, rowKey, withCheckbox) {
        var data = store.data, column = store.column, id = store.id;
        var row = data_2.findRowByRowKey(data, column, id, rowKey, false);
        if (row) {
            var _attributes = row._attributes, _disabledPriority_1 = row._disabledPriority;
            column.allColumns.forEach(function (columnInfo) {
                _disabledPriority_1[columnInfo.name] = 'ROW';
            });
            if (withCheckbox) {
                _attributes.checkDisabled = disabled;
                setDisabledAllCheckbox(store);
            }
            setRowOrColumnDisabled(_attributes, disabled);
        }
    }
    exports.setRowDisabled = setRowDisabled;
    function setColumnDisabled(_a, disabled, columnName) {
        var data = _a.data, column = _a.column;
        if (column_1.isRowHeader(columnName)) {
            return;
        }
        data.rawData.forEach(function (row) {
            row._disabledPriority[columnName] = 'COLUMN';
        });
        setRowOrColumnDisabled(column.allColumnMap[columnName], disabled);
    }
    exports.setColumnDisabled = setColumnDisabled;
    function setRowCheckDisabled(store, disabled, rowKey) {
        var data = store.data, column = store.column, id = store.id;
        var row = data_2.findRowByRowKey(data, column, id, rowKey, false);
        if (row) {
            row._attributes.checkDisabled = disabled;
            setDisabledAllCheckbox(store);
        }
    }
    exports.setRowCheckDisabled = setRowCheckDisabled;
    function appendRow(store, row, options) {
        var data = store.data, id = store.id;
        var rawData = data.rawData, viewData = data.viewData, sortState = data.sortState, pageOptions = data.pageOptions;
        var _a = options.at, at = _a === void 0 ? rawData.length : _a;
        var _b = data_2.getCreatedRowInfo(store, at, row), rawRow = _b.rawRow, viewRow = _b.viewRow, prevRow = _b.prevRow;
        var inserted = at !== rawData.length;
        common_1.silentSplice(rawData, at, 0, rawRow);
        common_1.silentSplice(viewData, at, 0, viewRow);
        makeObservable(store, at);
        pagination_1.updatePageOptions(store, { totalCount: pageOptions.totalCount + 1 });
        updateHeights(store);
        if (inserted) {
            sort_1.updateSortKey(data, at);
        }
        sort_1.sortByCurrentState(store);
        if (prevRow && rowSpan_1.isRowSpanEnabled(sortState)) {
            rowSpan_2.updateRowSpanWhenAppending(rawData, prevRow, options.extendPrevRowSpan || false);
        }
        instance_1.getDataManager(id).push('CREATE', rawRow, inserted);
        summary_1.updateSummaryValueByRow(store, rawRow, { type: 'APPEND' });
        postUpdateAfterManipulation(store, at, 'DONE', [rawRow]);
    }
    exports.appendRow = appendRow;
    function removeRow(store, rowKey, options) {
        var data = store.data, id = store.id, focus = store.focus, column = store.column;
        var rawData = data.rawData, viewData = data.viewData, sortState = data.sortState;
        var rowIndex = data_2.findIndexByRowKey(data, column, id, rowKey, false);
        if (rowIndex === -1) {
            return;
        }
        var removedRow = {};
        var nextRow = rawData[rowIndex + 1];
        pagination_1.updatePageWhenRemovingRow(store, 1);
        validation_1.removeUniqueInfoMap(id, rawData[rowIndex], column);
        observable_1.batchObserver(function () {
            removedRow = rawData.splice(rowIndex, 1)[0];
        });
        viewData.splice(rowIndex, 1);
        updateHeights(store);
        if (!common_1.someProp('rowKey', focus.rowKey, rawData)) {
            focus_1.initFocus(store);
        }
        selection_1.initSelection(store);
        if (nextRow && rowSpan_1.isRowSpanEnabled(sortState)) {
            rowSpan_2.updateRowSpanWhenRemoving(rawData, removedRow, nextRow, options.keepRowSpanData || false);
        }
        if (rowIndex !== rawData.length) {
            sort_1.updateSortKey(data, removedRow.sortKey + 1, false);
        }
        instance_1.getDataManager(id).push('DELETE', removedRow);
        summary_1.updateSummaryValueByRow(store, removedRow, { type: 'REMOVE' });
        postUpdateAfterManipulation(store, rowIndex, data_2.getLoadingState(rawData));
    }
    exports.removeRow = removeRow;
    function clearData(store) {
        var data = store.data, id = store.id, rowCoords = store.rowCoords;
        validation_1.createNewValidationMap(id);
        viewport_1.initScrollPosition(store);
        focus_1.initFocus(store);
        selection_1.initSelection(store);
        sort_1.initSortState(data);
        filter_1.initFilter(store);
        rowCoords.heights = [];
        data.rawData = [];
        data.viewData = [];
        pagination_1.updatePageOptions(store, { totalCount: 0, page: 1 }, true);
        summary_1.updateAllSummaryValues(store);
        setLoadingState(store, 'EMPTY');
        setCheckedAllRows(store);
        instance_1.getDataManager(id).clearAll();
    }
    exports.clearData = clearData;
    function resetData(store, inputData, options) {
        var data = store.data, column = store.column, id = store.id;
        var sortState = options.sortState, filterState = options.filterState, pageState = options.pageState;
        validation_1.createNewValidationMap(id);
        var _a = data_1.createData(id, inputData, column, { lazyObservable: true }), rawData = _a.rawData, viewData = _a.viewData;
        var eventBus = eventBus_1.getEventBus(id);
        var gridEvent = new gridEvent_1.default();
        viewport_1.initScrollPosition(store);
        focus_1.initFocus(store);
        selection_1.initSelection(store);
        sort_1.resetSortState(store, sortState);
        filter_1.resetFilterState(store, filterState);
        pagination_1.resetPageState(store, rawData.length, pageState);
        data.rawData = rawData;
        data.viewData = viewData;
        updateHeights(store);
        summary_1.updateAllSummaryValues(store);
        setLoadingState(store, data_2.getLoadingState(rawData));
        setCheckedAllRows(store);
        instance_1.getDataManager(id).setOriginData(inputData);
        instance_1.getDataManager(id).clearAll();
        column_2.setColumnWidthsByText(store);
        setTimeout(function () {
            /**
             * Occurs when the grid data is updated and the grid is rendered onto the DOM
             * The event occurs only in the following API as below.
             * 'resetData', 'restore', 'reloadData', 'readData', 'setPerPage' with 'dataSource', using 'dataSource'
             * @event Grid#onGridUpdated
             * @property {Grid} instance - Current grid instance
             */
            eventBus.trigger('onGridUpdated', gridEvent);
        });
    }
    exports.resetData = resetData;
    function addRowClassName(store, rowKey, className) {
        var data = store.data, column = store.column, id = store.id;
        var row = data_2.findRowByRowKey(data, column, id, rowKey, false);
        if (row) {
            var rowClassMap = row._attributes.className.row;
            var isExist = common_1.includes(rowClassMap, className);
            if (!isExist) {
                rowClassMap.push(className);
                observable_1.notify(row._attributes, 'className');
            }
        }
    }
    exports.addRowClassName = addRowClassName;
    function removeRowClassName(store, rowKey, className) {
        var data = store.data, column = store.column, id = store.id;
        var row = data_2.findRowByRowKey(data, column, id, rowKey, false);
        if (row) {
            common_1.removeArrayItem(className, row._attributes.className.row);
            observable_1.notify(row._attributes, 'className');
        }
    }
    exports.removeRowClassName = removeRowClassName;
    function addClassNameToAttribute(row, columnName, className) {
        var columnClassNames = row._attributes.className.column[columnName];
        row._attributes.className.column[columnName] = data_2.getAddedClassName(className, columnClassNames);
        observable_1.notify(row._attributes, 'className');
    }
    function removeClassNameToAttribute(row, columnName, className) {
        var columnClassNames = row._attributes.className.column[columnName];
        if (columnClassNames) {
            row._attributes.className.column[columnName] = data_2.getRemovedClassName(className, columnClassNames);
        }
        observable_1.notify(row._attributes, 'className');
    }
    function addCellClassName(store, rowKey, columnName, className) {
        var data = store.data, column = store.column, id = store.id;
        var row = data_2.findRowByRowKey(data, column, id, rowKey, false);
        if (row) {
            addClassNameToAttribute(row, columnName, className);
        }
    }
    exports.addCellClassName = addCellClassName;
    function removeCellClassName(store, rowKey, columnName, className) {
        var data = store.data, column = store.column, id = store.id;
        var row = data_2.findRowByRowKey(data, column, id, rowKey);
        if (row) {
            removeClassNameToAttribute(row, columnName, className);
        }
    }
    exports.removeCellClassName = removeCellClassName;
    function addColumnClassName(_a, columnName, className) {
        var data = _a.data;
        var rawData = data.rawData;
        rawData.forEach(function (row) {
            addClassNameToAttribute(row, columnName, className);
        });
    }
    exports.addColumnClassName = addColumnClassName;
    function removeColumnClassName(_a, columnName, className) {
        var data = _a.data;
        var rawData = data.rawData;
        rawData.forEach(function (row) {
            removeClassNameToAttribute(row, columnName, className);
        });
    }
    exports.removeColumnClassName = removeColumnClassName;
    function setLoadingState(_a, state) {
        var data = _a.data;
        data.loadingState = state;
    }
    exports.setLoadingState = setLoadingState;
    function setCheckedAllRows(_a) {
        var data = _a.data;
        var filteredRawData = data.filteredRawData, pageRowRange = data.pageRowRange;
        var result = false;
        if (filteredRawData.length) {
            var enableCheckRows = filteredRawData
                .slice.apply(filteredRawData, pageRowRange).filter(function (row) { return !row._attributes.checkDisabled; });
            result = !!enableCheckRows.length && enableCheckRows.every(function (row) { return row._attributes.checked; });
        }
        data.checkedAllRows = result;
    }
    exports.setCheckedAllRows = setCheckedAllRows;
    function updateRowNumber(_a, startIndex) {
        var data = _a.data;
        var rawData = data.rawData;
        for (var idx = startIndex; idx < rawData.length; idx += 1) {
            rawData[idx]._attributes.rowNum = idx + 1;
        }
    }
    exports.updateRowNumber = updateRowNumber;
    function setRow(store, rowIndex, row) {
        var data = store.data, id = store.id, column = store.column;
        var rawData = data.rawData, viewData = data.viewData, sortState = data.sortState;
        var orgRow = rawData[rowIndex];
        if (!orgRow) {
            return;
        }
        validation_1.removeUniqueInfoMap(id, orgRow, column);
        row.sortKey = orgRow.sortKey;
        var _a = data_2.getCreatedRowInfo(store, rowIndex, row, orgRow.rowKey), rawRow = _a.rawRow, viewRow = _a.viewRow, prevRow = _a.prevRow;
        common_1.silentSplice(rawData, rowIndex, 1, rawRow);
        common_1.silentSplice(viewData, rowIndex, 1, viewRow);
        makeObservable(store, rowIndex);
        sort_1.sortByCurrentState(store);
        if (prevRow && rowSpan_1.isRowSpanEnabled(sortState)) {
            rowSpan_2.updateRowSpanWhenAppending(rawData, prevRow, false);
        }
        instance_1.getDataManager(id).push('UPDATE', rawRow);
        updateHeightsWithFilteredData(store);
        summary_1.updateSummaryValueByRow(store, rawRow, { type: 'SET', orgRow: orgRow });
        postUpdateAfterManipulation(store, rowIndex, 'DONE');
    }
    exports.setRow = setRow;
    function moveRow(store, rowKey, targetIndex) {
        var data = store.data, column = store.column, id = store.id;
        var rawData = data.rawData, viewData = data.viewData;
        if (!rawData[targetIndex] || data_2.isSorted(data) || data_2.isFiltered(data)) {
            return;
        }
        var currentIndex = data_2.findIndexByRowKey(data, column, id, rowKey, false);
        if (currentIndex === -1) {
            return;
        }
        var minIndex = Math.min(currentIndex, targetIndex);
        var rawRow = common_1.silentSplice(rawData, currentIndex, 1)[0];
        var viewRow = common_1.silentSplice(viewData, currentIndex, 1)[0];
        observable_1.batchObserver(function () {
            rawData.splice(targetIndex, 0, rawRow);
        });
        viewData.splice(targetIndex, 0, viewRow);
        sort_1.resetSortKey(data, minIndex);
        updateRowNumber(store, minIndex);
        instance_1.getDataManager(id).push('UPDATE', rawRow, true);
    }
    exports.moveRow = moveRow;
    function scrollToNext(store) {
        var data = store.data, id = store.id;
        var _a = data.pageOptions, page = _a.page, totalCount = _a.totalCount, perPage = _a.perPage, useClient = _a.useClient;
        if (data_2.isScrollPagination(data)) {
            if (useClient) {
                data.pageOptions.page += 1;
                observable_1.notify(data, 'pageOptions');
                sort_1.sortByCurrentState(store);
                updateHeights(store);
                setCheckedAllRows(store);
            }
            else if (page * perPage < totalCount) {
                data.pageOptions.page += 1;
                instance_1.getDataProvider(id).readData(data.pageOptions.page);
            }
        }
    }
    exports.scrollToNext = scrollToNext;
    function appendRows(store, inputData) {
        var data = store.data, column = store.column, id = store.id;
        if (!column.keyColumnName) {
            var rowKey_1 = data_2.getMaxRowKey(data);
            inputData.forEach(function (row, index) {
                row.rowKey = rowKey_1 + index;
            });
        }
        var startIndex = data.rawData.length;
        var _a = data_1.createData(id, inputData, column, { lazyObservable: true }), rawData = _a.rawData, viewData = _a.viewData;
        data.rawData = data.rawData.concat(rawData);
        data.viewData = data.viewData.concat(viewData);
        sort_1.resetSortKey(data, startIndex);
        sort_1.sortByCurrentState(store);
        updateHeights(store);
        postUpdateAfterManipulation(store, startIndex, 'DONE', rawData);
    }
    exports.appendRows = appendRows;
    function removeRows(store, targetRows) {
        var data = store.data, id = store.id, focus = store.focus, column = store.column;
        var sortState = data.sortState, viewData = data.viewData, rawData = data.rawData;
        var rowIndexes = targetRows.rowIndexes, rows = targetRows.rows, nextRows = targetRows.nextRows;
        var deletedCount = rowIndexes.length;
        pagination_1.updatePageWhenRemovingRow(store, deletedCount);
        rowIndexes.forEach(function (rowIndex, i) {
            var nextRow = nextRows[i];
            var removedRow = common_1.silentSplice(rawData, rowIndex - i, 1)[0];
            common_1.silentSplice(viewData, rowIndex - i, 1);
            validation_1.removeUniqueInfoMap(id, removedRow, column);
            if (nextRow) {
                if (rowSpan_1.isRowSpanEnabled(sortState)) {
                    rowSpan_2.updateRowSpanWhenRemoving(rawData, removedRow, nextRow, false);
                }
            }
            instance_1.getDataManager(id).push('DELETE', removedRow);
            sort_1.updateSortKey(data, removedRow.sortKey + 1, false);
        });
        observable_1.notify(data, 'rawData', 'filteredRawData', 'viewData', 'filteredViewData');
        updateHeights(store);
        if (common_1.someProp('rowKey', focus.rowKey, rows)) {
            focus_1.initFocus(store);
        }
        selection_1.initSelection(store);
        summary_1.updateAllSummaryValues(store);
        postUpdateAfterManipulation(store, rowIndexes[0], data_2.getLoadingState(rawData));
    }
    exports.removeRows = removeRows;
    function postUpdateAfterManipulation(store, rowIndex, state, rows) {
        setLoadingState(store, state);
        updateRowNumber(store, rowIndex);
        setDisabledAllCheckbox(store);
        setCheckedAllRows(store);
        validation_1.forceValidateUniquenessOfColumns(store.data.rawData, store.column);
        column_2.setAutoResizingColumnWidths(store, rows);
    }


    /***/ }),
    /* 14 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RIGHT_MOUSE_BUTTON = exports.TREE_CELL_HORIZONTAL_PADDING = exports.TREE_INDENT_WIDTH = exports.FILTER_DEBOUNCE_TIME = void 0;
    exports.FILTER_DEBOUNCE_TIME = 50;
    exports.TREE_INDENT_WIDTH = 22;
    exports.TREE_CELL_HORIZONTAL_PADDING = 19;
    exports.RIGHT_MOUSE_BUTTON = 2;


    /***/ }),
    /* 15 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.create = exports.createData = exports.createRawRow = exports.setRowRelationListItems = exports.createViewRow = exports.createRowSpan = exports.generateDataCreationKey = void 0;
    var tslib_1 = __webpack_require__(1);
    var observable_1 = __webpack_require__(5);
    var column_1 = __webpack_require__(10);
    var common_1 = __webpack_require__(0);
    var tree_1 = __webpack_require__(21);
    var validation_1 = __webpack_require__(25);
    var data_1 = __webpack_require__(6);
    var data_2 = __webpack_require__(26);
    var dataCreationKey = '';
    function generateDataCreationKey() {
        dataCreationKey = "@dataKey" + Date.now();
        return dataCreationKey;
    }
    exports.generateDataCreationKey = generateDataCreationKey;
    function getRelationCbResult(fn, relationParams) {
        var result = common_1.isFunction(fn) ? fn(relationParams) : null;
        return common_1.isUndefined(result) ? null : result;
    }
    function getEditable(fn, relationParams) {
        var result = getRelationCbResult(fn, relationParams);
        return result === null ? true : result;
    }
    function getDisabled(fn, relationParams) {
        var result = getRelationCbResult(fn, relationParams);
        return result === null ? false : result;
    }
    function getListItems(fn, relationParams) {
        return getRelationCbResult(fn, relationParams) || [];
    }
    function getRowHeaderValue(row, columnName) {
        if (column_1.isRowNumColumn(columnName)) {
            return row._attributes.rowNum;
        }
        if (column_1.isCheckboxColumn(columnName)) {
            return row._attributes.checked;
        }
        return '';
    }
    function createRowSpan(mainRow, rowKey, count, spanCount) {
        return { mainRow: mainRow, mainRowKey: rowKey, count: count, spanCount: spanCount };
    }
    exports.createRowSpan = createRowSpan;
    function createViewCell(id, row, column, relationInfo) {
        if (relationInfo === void 0) { relationInfo = {}; }
        var _a = relationInfo.relationMatched, relationMatched = _a === void 0 ? true : _a, relationListItems = relationInfo.relationListItems;
        var name = column.name, formatter = column.formatter, editor = column.editor, validation = column.validation, defaultValue = column.defaultValue;
        var value = column_1.isRowHeader(name) ? getRowHeaderValue(row, name) : row[name];
        if (common_1.isNil(value) && !common_1.isNil(defaultValue)) {
            value = defaultValue;
        }
        if (!relationMatched) {
            value = '';
        }
        var formatterProps = { row: row, column: column, value: value };
        var _b = row._attributes, disabled = _b.disabled, checkDisabled = _b.checkDisabled, classNameAttr = _b.className;
        var columnDisabled = !!column.disabled;
        var rowDisabled = column_1.isCheckboxColumn(name) ? checkDisabled : disabled;
        var columnClassName = common_1.isUndefined(classNameAttr.column[name]) ? [] : classNameAttr.column[name];
        var className = tslib_1.__spreadArrays(classNameAttr.row, columnClassName).join(' ');
        var cellDisabled = rowDisabled || columnDisabled;
        if (!common_1.isUndefined(row._disabledPriority[name])) {
            cellDisabled = row._disabledPriority[name] === 'COLUMN' ? columnDisabled : rowDisabled;
        }
        return {
            editable: !!editor,
            className: className,
            disabled: cellDisabled,
            invalidStates: validation_1.getValidationCode({ id: id, value: row[name], row: row, validation: validation, columnName: name }),
            formattedValue: data_2.getFormattedValue(formatterProps, formatter, value, relationListItems),
            value: value,
        };
    }
    function createRelationViewCell(id, name, row, _a) {
        var columnMap = _a.columnMap, valueMap = _a.valueMap;
        var _b = valueMap[name], editable = _b.editable, disabled = _b.disabled, value = _b.value;
        var _c = columnMap[name].relationMap, relationMap = _c === void 0 ? {} : _c;
        Object.keys(relationMap).forEach(function (targetName) {
            var _a = relationMap[targetName], editableCallback = _a.editable, disabledCallback = _a.disabled, listItemsCallback = _a.listItems;
            var relationCbParams = { value: value, editable: editable, disabled: disabled, row: row };
            var targetEditable = getEditable(editableCallback, relationCbParams);
            var targetDisabled = getDisabled(disabledCallback, relationCbParams);
            var targetListItems = getListItems(listItemsCallback, relationCbParams);
            var targetValue = row[targetName];
            var targetEditor = columnMap[targetName].editor;
            var targetEditorOptions = targetEditor === null || targetEditor === void 0 ? void 0 : targetEditor.options;
            var relationMatched = common_1.isFunction(listItemsCallback)
                ? common_1.someProp('value', targetValue, targetListItems)
                : true;
            var cellData = createViewCell(id, row, columnMap[targetName], {
                relationMatched: relationMatched,
                relationListItems: targetListItems,
            });
            if (!targetEditable) {
                cellData.editable = false;
            }
            if (targetDisabled) {
                cellData.disabled = true;
            }
            // should set the relation list to relationListItemMap for preventing to share relation list in other rows
            if (targetEditorOptions) {
                targetEditorOptions.relationListItemMap = targetEditorOptions.relationListItemMap || {};
                targetEditorOptions.relationListItemMap[row.rowKey] = targetListItems;
            }
            valueMap[targetName] = cellData;
        });
    }
    function createViewRow(id, row, rawData, column) {
        var rowKey = row.rowKey, sortKey = row.sortKey, rowSpanMap = row.rowSpanMap, uniqueKey = row.uniqueKey;
        var columnMap = column.columnMapWithRelation;
        var _a = column.treeColumnName, treeColumnName = _a === void 0 ? '' : _a, _b = column.treeIcon, treeIcon = _b === void 0 ? true : _b;
        var initValueMap = {};
        Object.keys(columnMap).forEach(function (name) {
            initValueMap[name] = null;
        });
        var valueMap = observable_1.observable(initValueMap);
        var __unobserveFns__ = [];
        Object.keys(columnMap).forEach(function (name) {
            var _a = columnMap[name], related = _a.related, relationMap = _a.relationMap, className = _a.className;
            if (className) {
                row._attributes.className.column[name] = className.split(' ');
            }
            // add condition expression to prevent to call watch function recursively
            if (!related) {
                __unobserveFns__.push(observable_1.observe(function () {
                    valueMap[name] = createViewCell(id, row, columnMap[name]);
                }));
            }
            if (relationMap && Object.keys(relationMap).length) {
                __unobserveFns__.push(observable_1.observe(function () {
                    createRelationViewCell(id, name, row, { columnMap: columnMap, valueMap: valueMap });
                }));
            }
        });
        return tslib_1.__assign({ rowKey: rowKey,
            sortKey: sortKey,
            uniqueKey: uniqueKey,
            rowSpanMap: rowSpanMap,
            valueMap: valueMap,
            __unobserveFns__: __unobserveFns__ }, (treeColumnName && { treeInfo: tree_1.createTreeCellInfo(rawData, row, treeIcon) }));
    }
    exports.createViewRow = createViewRow;
    function getAttributes(row, index, lazyObservable, disabled) {
        var defaultAttr = {
            rowNum: index + 1,
            checked: false,
            disabled: disabled,
            checkDisabled: disabled,
            className: {
                row: [],
                column: {},
            },
        };
        if (row._attributes) {
            if (common_1.isBoolean(row._attributes.disabled) && common_1.isUndefined(row._attributes.checkDisabled)) {
                row._attributes.checkDisabled = row._attributes.disabled;
            }
            if (!common_1.isUndefined(row._attributes.className)) {
                row._attributes.className = tslib_1.__assign({ row: [], column: {} }, row._attributes.className);
            }
        }
        var attributes = tslib_1.__assign(tslib_1.__assign({}, defaultAttr), row._attributes);
        return lazyObservable ? attributes : observable_1.observable(attributes);
    }
    function createRelationListItems(name, row, columnMap) {
        var _a = columnMap[name], _b = _a.relationMap, relationMap = _b === void 0 ? {} : _b, editor = _a.editor;
        var _c = row._attributes, checkDisabled = _c.checkDisabled, rowDisabled = _c.disabled;
        var editable = !!editor;
        var disabled = column_1.isCheckboxColumn(name) ? checkDisabled : rowDisabled;
        var value = row[name];
        var relationCbParams = { value: value, editable: editable, disabled: disabled, row: row };
        var relationListItemMap = {};
        Object.keys(relationMap).forEach(function (targetName) {
            relationListItemMap[targetName] = getListItems(relationMap[targetName].listItems, relationCbParams);
        });
        return relationListItemMap;
    }
    function setRowRelationListItems(row, columnMap) {
        var relationListItemMap = tslib_1.__assign({}, row._relationListItemMap);
        Object.keys(columnMap).forEach(function (name) {
            common_1.assign(relationListItemMap, createRelationListItems(name, row, columnMap));
        });
        row._relationListItemMap = relationListItemMap;
    }
    exports.setRowRelationListItems = setRowRelationListItems;
    function createMainRowSpanMap(rowSpan, rowKey) {
        var mainRowSpanMap = {};
        if (!rowSpan) {
            return mainRowSpanMap;
        }
        Object.keys(rowSpan).forEach(function (columnName) {
            var spanCount = rowSpan[columnName];
            mainRowSpanMap[columnName] = createRowSpan(true, rowKey, spanCount, spanCount);
        });
        return mainRowSpanMap;
    }
    function createSubRowSpan(prevRowSpanMap) {
        var subRowSpanMap = {};
        Object.keys(prevRowSpanMap).forEach(function (columnName) {
            var prevRowSpan = prevRowSpanMap[columnName];
            var mainRowKey = prevRowSpan.mainRowKey, count = prevRowSpan.count, spanCount = prevRowSpan.spanCount;
            if (spanCount > 1 - count) {
                var subRowCount = count >= 0 ? -1 : count - 1;
                subRowSpanMap[columnName] = createRowSpan(false, mainRowKey, subRowCount, spanCount);
            }
        });
        return subRowSpanMap;
    }
    function createRowSpanMap(row, rowSpan, prevRow) {
        var rowKey = row.rowKey;
        var mainRowSpanMap = {};
        var subRowSpanMap = {};
        if (!common_1.isEmpty(rowSpan)) {
            mainRowSpanMap = createMainRowSpanMap(rowSpan, rowKey);
        }
        if (prevRow) {
            var prevRowSpanMap = prevRow.rowSpanMap;
            if (!common_1.isEmpty(prevRowSpanMap)) {
                subRowSpanMap = createSubRowSpan(prevRowSpanMap);
            }
        }
        return tslib_1.__assign(tslib_1.__assign({}, mainRowSpanMap), subRowSpanMap);
    }
    function createRawRow(id, row, index, column, options) {
        if (options === void 0) { options = {}; }
        // this rowSpan variable is attribute option before creating rowSpanDataMap
        var rowSpan;
        var keyColumnName = options.keyColumnName, prevRow = options.prevRow, _a = options.lazyObservable, lazyObservable = _a === void 0 ? false : _a, _b = options.disabled, disabled = _b === void 0 ? false : _b;
        if (row._attributes) {
            rowSpan = row._attributes.rowSpan;
        }
        if (keyColumnName) {
            row.rowKey = row[keyColumnName];
        }
        else if (common_1.isUndefined(row.rowKey)) {
            row.rowKey = index;
        }
        row.sortKey = common_1.isNumber(row.sortKey) ? row.sortKey : index;
        row.uniqueKey = dataCreationKey + "-" + row.rowKey;
        row._attributes = getAttributes(row, index, lazyObservable, disabled);
        row._attributes.rowSpan = rowSpan;
        row._disabledPriority = row._disabledPriority || {};
        row.rowSpanMap = createRowSpanMap(row, rowSpan, prevRow);
        setRowRelationListItems(row, column.columnMapWithRelation);
        if (column.autoResizingColumn.length) {
            data_2.setMaxTextMap(column, row);
        }
        if (lazyObservable) {
            validation_1.addUniqueInfoMap(id, row, column);
        }
        return (lazyObservable ? row : observable_1.observable(row));
    }
    exports.createRawRow = createRawRow;
    function createData(id, data, column, _a) {
        var _b = _a.lazyObservable, lazyObservable = _b === void 0 ? false : _b, prevRows = _a.prevRows, _c = _a.disabled, disabled = _c === void 0 ? false : _c;
        generateDataCreationKey();
        var keyColumnName = column.keyColumnName, _d = column.treeColumnName, treeColumnName = _d === void 0 ? '' : _d;
        var rawData;
        if (treeColumnName) {
            rawData = tree_1.createTreeRawData({
                id: id,
                data: data,
                column: column,
                keyColumnName: keyColumnName,
                lazyObservable: lazyObservable,
                disabled: disabled,
            });
        }
        else {
            rawData = data.map(function (row, index, rows) {
                return createRawRow(id, row, index, column, {
                    keyColumnName: keyColumnName,
                    prevRow: prevRows ? prevRows[index] : rows[index - 1],
                    lazyObservable: lazyObservable,
                    disabled: disabled,
                });
            });
        }
        var viewData = rawData.map(function (row) {
            return lazyObservable
                ? { rowKey: row.rowKey, sortKey: row.sortKey, uniqueKey: row.uniqueKey }
                : createViewRow(id, row, rawData, column);
        });
        return { rawData: rawData, viewData: viewData };
    }
    exports.createData = createData;
    var cachedFilteredIndex = {};
    function applyFilterToRawData(rawData, filters, columnMap) {
        var data = rawData;
        cachedFilteredIndex = {};
        if (filters) {
            data = filters.reduce(function (acc, filter) {
                var conditionFn = filter.conditionFn, columnName = filter.columnName;
                var formatter = columnMap[columnName].formatter;
                return acc.filter(function (row, index) {
                    var value = row[columnName];
                    var relationListItems = row._relationListItemMap[columnName];
                    var formatterProps = { row: row, column: columnMap[columnName], value: value };
                    var filtered = conditionFn(data_2.getFormattedValue(formatterProps, formatter, value, relationListItems));
                    // cache the filtered index for performance
                    if (acc === rawData && filtered) {
                        cachedFilteredIndex[row.rowKey] = index;
                    }
                    else if (!filtered) {
                        cachedFilteredIndex[row.rowKey] = null;
                    }
                    return filtered;
                });
            }, rawData);
        }
        return data;
    }
    function createPageOptions(userPageOptions, rawData) {
        var pageOptions = (common_1.isEmpty(userPageOptions)
            ? {}
            : tslib_1.__assign(tslib_1.__assign({ useClient: false, page: 1, perPage: 20, type: 'pagination' }, userPageOptions), { totalCount: userPageOptions.useClient ? rawData.length : userPageOptions.totalCount }));
        if (pageOptions.type === 'pagination') {
            pageOptions.position = pageOptions.position || 'bottom';
            pageOptions.visiblePages = pageOptions.visiblePages || 10;
        }
        return pageOptions;
    }
    function create(_a) {
        var data = _a.data, column = _a.column, userPageOptions = _a.pageOptions, useClientSort = _a.useClientSort, disabled = _a.disabled, id = _a.id;
        var _b = createData(id, data, column, { lazyObservable: true, disabled: disabled }), rawData = _b.rawData, viewData = _b.viewData;
        var sortState = {
            useClient: useClientSort,
            columns: [
                {
                    columnName: 'sortKey',
                    ascending: true,
                },
            ],
        };
        var pageOptions = createPageOptions(userPageOptions, rawData);
        return observable_1.observable({
            rawData: rawData,
            viewData: viewData,
            sortState: sortState,
            pageOptions: pageOptions,
            checkedAllRows: rawData.length ? !rawData.some(function (row) { return !row._attributes.checked; }) : false,
            disabledAllCheckbox: disabled,
            filters: null,
            loadingState: rawData.length ? 'DONE' : 'EMPTY',
            get filteredRawData() {
                var _a;
                if (this.filters) {
                    // should filter the sliced data which is displayed in viewport in case of client infinite scrolling
                    var targetData = data_1.isScrollPagination(this, true)
                        ? (_a = this.rawData).slice.apply(_a, this.pageRowRange) : this.rawData;
                    return applyFilterToRawData(targetData, this.filters, column.allColumnMap);
                }
                return this.rawData;
            },
            get filteredIndex() {
                var _a = this, filteredRawData = _a.filteredRawData, filters = _a.filters;
                return filters
                    ? filteredRawData
                        .filter(function (row) { return !common_1.isNull(cachedFilteredIndex[row.rowKey]); })
                        .map(function (row) { return cachedFilteredIndex[row.rowKey]; })
                    : null;
            },
            get filteredViewData() {
                var _this = this;
                return this.filters
                    ? this.filteredIndex.map(function (index) { return _this.viewData[index]; })
                    : this.viewData;
            },
            get pageRowRange() {
                var _a = this.pageOptions, useClient = _a.useClient, type = _a.type, page = _a.page, perPage = _a.perPage;
                var start = 0;
                // should calculate the range through all rawData in case of client infinite scrolling
                var end = data_1.isScrollPagination(this, true) ? this.rawData.length : this.filteredViewData.length;
                if (useClient) {
                    var pageRowLastIndex = page * perPage;
                    if (type === 'pagination') {
                        start = (page - 1) * perPage;
                    }
                    end = pageRowLastIndex > 0 && pageRowLastIndex < end ? pageRowLastIndex : end;
                }
                return [start, end];
            },
        });
    }
    exports.create = create;


    /***/ }),
    /* 16 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.initSelection = exports.setSelection = exports.changeSelectionRange = void 0;
    var tslib_1 = __webpack_require__(1);
    var common_1 = __webpack_require__(0);
    var eventBus_1 = __webpack_require__(8);
    var selection_1 = __webpack_require__(20);
    var gridEvent_1 = tslib_1.__importDefault(__webpack_require__(9));
    var rowSpan_1 = __webpack_require__(11);
    function changeSelectionRange(selection, inputRange, id) {
        if (!selection_1.isSameInputRange(selection.inputRange, inputRange)) {
            selection.inputRange = inputRange;
            var eventBus = eventBus_1.getEventBus(id);
            var gridEvent = new gridEvent_1.default({ range: selection.rangeWithRowHeader });
            /**
             * Occurs when selecting cells
             * @event Grid#selection
             * @property {Object} range - Range of selection
             * @property {Array} range.start - Info of start cell (ex: [rowKey, columnName])
             * @property {Array} range.end - Info of end cell (ex: [rowKey, columnName])
             * @property {Grid} instance - Current grid instance
             */
            eventBus.trigger('selection', gridEvent);
        }
    }
    exports.changeSelectionRange = changeSelectionRange;
    function setSelection(store, range) {
        var _a;
        var selection = store.selection, data = store.data, _b = store.column, visibleColumnsWithRowHeader = _b.visibleColumnsWithRowHeader, rowHeaderCount = _b.rowHeaderCount, id = store.id;
        var viewData = data.viewData;
        var rowLength = viewData.length;
        var columnLength = visibleColumnsWithRowHeader.length;
        var startRowIndex = common_1.clamp(range.start[0], 0, rowLength - 1);
        var endRowIndex = common_1.clamp(range.end[0], 0, rowLength - 1);
        var startColumnIndex = common_1.clamp(range.start[1] + rowHeaderCount, rowHeaderCount, columnLength - 1);
        var endColumnIndex = common_1.clamp(range.end[1] + rowHeaderCount, rowHeaderCount, columnLength - 1);
        _a = rowSpan_1.getRowRangeWithRowSpan([startRowIndex, endRowIndex], [startColumnIndex, endColumnIndex], visibleColumnsWithRowHeader, null, data), startRowIndex = _a[0], endRowIndex = _a[1];
        var inputRange = {
            row: [startRowIndex, endRowIndex],
            column: [startColumnIndex, endColumnIndex],
        };
        changeSelectionRange(selection, inputRange, id);
    }
    exports.setSelection = setSelection;
    function initSelection(store) {
        store.selection.inputRange = null;
    }
    exports.initSelection = initSelection;


    /***/ }),
    /* 17 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isArrowKey = exports.isNonPrintableKey = exports.keyEventGenerate = exports.getKeyStrokeString = exports.keyStrokeCommandMap = exports.keyboardEventCommandMap = exports.keyboardEventTypeMap = exports.keyNameMap = void 0;
    var common_1 = __webpack_require__(0);
    exports.keyNameMap = {
        8: 'backspace',
        9: 'tab',
        13: 'enter',
        16: 'shift',
        17: 'ctrl',
        27: 'esc',
        37: 'left',
        38: 'up',
        39: 'right',
        40: 'down',
        65: 'a',
        67: 'c',
        86: 'v',
        32: 'space',
        33: 'pageUp',
        34: 'pageDown',
        36: 'home',
        35: 'end',
        46: 'del',
    };
    exports.keyboardEventTypeMap = {
        move: 'move',
        edit: 'edit',
        remove: 'remove',
        select: 'select',
        clipboard: 'clipboard',
    };
    exports.keyboardEventCommandMap = {
        up: 'up',
        down: 'down',
        left: 'left',
        right: 'right',
        pageUp: 'pageUp',
        pageDown: 'pageDown',
        firstColumn: 'firstColumn',
        lastColumn: 'lastColumn',
        currentCell: 'currentCell',
        nextCell: 'nextCell',
        prevCell: 'prevCell',
        firstCell: 'firstCell',
        lastCell: 'lastCell',
        all: 'all',
        copy: 'copy',
        paste: 'paste',
    };
    /**
     * K-V object for matching keystroke and event command
     * K: keystroke (order : ctrl -> shift -> keyName)
     * V: [key event type, command]
     * @type {Object}
     * @ignore
     */
    exports.keyStrokeCommandMap = {
        up: ['move', 'up'],
        down: ['move', 'down'],
        left: ['move', 'left'],
        right: ['move', 'right'],
        pageUp: ['move', 'pageUp'],
        pageDown: ['move', 'pageDown'],
        home: ['move', 'firstColumn'],
        end: ['move', 'lastColumn'],
        enter: ['edit', 'currentCell'],
        space: ['edit', 'currentCell'],
        tab: ['edit', 'nextCell'],
        backspace: ['remove'],
        del: ['remove'],
        'shift-tab': ['edit', 'prevCell'],
        'shift-up': ['select', 'up'],
        'shift-down': ['select', 'down'],
        'shift-left': ['select', 'left'],
        'shift-right': ['select', 'right'],
        'shift-pageUp': ['select', 'pageUp'],
        'shift-pageDown': ['select', 'pageDown'],
        'shift-home': ['select', 'firstColumn'],
        'shift-end': ['select', 'lastColumn'],
        'ctrl-a': ['select', 'all'],
        'ctrl-c': ['clipboard', 'copy'],
        'ctrl-v': ['clipboard', 'paste'],
        'ctrl-home': ['move', 'firstCell'],
        'ctrl-end': ['move', 'lastCell'],
        'ctrl-shift-home': ['select', 'firstCell'],
        'ctrl-shift-end': ['select', 'lastCell'],
    };
    /**
     * Returns the keyStroke string
     * @param {Event} ev - Keyboard event
     * @returns {String}
     * @ignore
     */
    function getKeyStrokeString(ev) {
        var keys = [];
        var keyCode = ev.keyCode, ctrlKey = ev.ctrlKey, metaKey = ev.metaKey, shiftKey = ev.shiftKey;
        if (ctrlKey || metaKey) {
            keys.push('ctrl');
        }
        if (shiftKey) {
            keys.push('shift');
        }
        if (keyCode in exports.keyNameMap) {
            keys.push(exports.keyNameMap[keyCode]);
        }
        return keys.join('-');
    }
    exports.getKeyStrokeString = getKeyStrokeString;
    function keyEventGenerate(ev) {
        var keyStroke = getKeyStrokeString(ev);
        var commandInfo = exports.keyStrokeCommandMap[keyStroke];
        return commandInfo
            ? {
                type: commandInfo[0],
                command: commandInfo[1],
            }
            : {};
    }
    exports.keyEventGenerate = keyEventGenerate;
    function isNonPrintableKey(keyCode) {
        var keys = [
            'shift',
            'ctrl',
            'esc',
            'left',
            'up',
            'right',
            'down',
            'pageUp',
            'pageDown',
            'end',
            'home',
        ];
        var key = exports.keyNameMap[keyCode];
        return common_1.includes(keys, key);
    }
    exports.isNonPrintableKey = isNonPrintableKey;
    function isArrowKey(keyName) {
        return common_1.includes(['up', 'down', 'left', 'right'], keyName);
    }
    exports.isArrowKey = isArrowKey;


    /***/ }),
    /* 18 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setFocusInfo = exports.saveAndFinishEditing = exports.initFocus = exports.changeFocus = exports.finishEditing = exports.startEditing = void 0;
    var tslib_1 = __webpack_require__(1);
    var gridEvent_1 = tslib_1.__importDefault(__webpack_require__(9));
    var eventBus_1 = __webpack_require__(8);
    var data_1 = __webpack_require__(6);
    var focus_1 = __webpack_require__(41);
    var rowSpan_1 = __webpack_require__(11);
    var data_2 = __webpack_require__(13);
    var common_1 = __webpack_require__(0);
    var column_1 = __webpack_require__(12);
    function startEditing(store, rowKey, columnName) {
        var data = store.data, focus = store.focus, column = store.column, id = store.id;
        var filteredRawData = data.filteredRawData;
        var foundIndex = data_1.findIndexByRowKey(data, column, id, rowKey);
        if (foundIndex === -1) {
            return;
        }
        // makes the data observable to judge editable, disable of the cell
        data_2.makeObservable(store, data_1.findIndexByRowKey(data, column, id, rowKey, false));
        if (!data_1.isEditableCell(store, foundIndex, columnName)) {
            return;
        }
        var eventBus = eventBus_1.getEventBus(id);
        var gridEvent = new gridEvent_1.default({
            rowKey: rowKey,
            columnName: columnName,
            value: filteredRawData[foundIndex][columnName],
        });
        /**
         * Occurs when editing the cell is started
         * @event Grid#editingStart
         * @property {number} rowKey - rowKey of the target cell
         * @property {number} columnName - columnName of the target cell
         * @property {number | string | boolean | null | undefined} value - value of the editing cell
         * @property {Grid} instance - Current grid instance
         */
        eventBus.trigger('editingStart', gridEvent);
        if (!gridEvent.isStopped()) {
            focus.forcedDestroyEditing = false;
            focus.navigating = false;
            focus.editingAddress = { rowKey: rowKey, columnName: columnName };
        }
    }
    exports.startEditing = startEditing;
    // @TODO: Events should be separated(ex.'editingFinish', 'editingCanceled')
    function finishEditing(_a, rowKey, columnName, value, editingInfo) {
        var focus = _a.focus, id = _a.id;
        if (focus_1.isEditingCell(focus, rowKey, columnName)) {
            focus.editingAddress = null;
            focus.navigating = true;
        }
        var eventBus = eventBus_1.getEventBus(id);
        var gridEvent = new gridEvent_1.default(tslib_1.__assign({ rowKey: rowKey, columnName: columnName, value: value }, editingInfo));
        /**
         * Occurs when editing the cell is finished
         * @event Grid#editingFinish
         * @property {number} rowKey - rowKey of the target cell
         * @property {number} columnName - columnName of the target cell
         * @property {number | string | boolean | null | undefined} value - value of the editing cell
         * @property {Grid} instance - Current grid instance
         * @property {boolean} save - Whether to save the value
         * @property {boolean} triggeredByKey - Whether to trigger the event by key
         */
        eventBus.trigger('editingFinish', gridEvent);
    }
    exports.finishEditing = finishEditing;
    function changeFocus(store, rowKey, columnName, id) {
        var data = store.data, focus = store.focus, column = store.column;
        if (focus_1.isFocusedCell(focus, rowKey, columnName) ||
            (columnName && column_1.isHiddenColumn(column, columnName))) {
            return;
        }
        var rawData = data.rawData, sortState = data.sortState;
        var eventBus = eventBus_1.getEventBus(id);
        var gridEvent = new gridEvent_1.default({
            rowKey: rowKey,
            columnName: columnName,
            prevColumnName: focus.columnName,
            prevRowKey: focus.rowKey,
        });
        /**
         * Occurs when focused cell is about to change
         * @event Grid#focusChange
         * @property {number} rowKey - rowKey of the target cell
         * @property {number} columnName - columnName of the target cell
         * @property {number} prevRowKey - rowKey of the currently focused cell
         * @property {number} prevColumnName - columnName of the currently focused cell
         * @property {Grid} instance - Current grid instance
         */
        eventBus.trigger('focusChange', gridEvent);
        if (!gridEvent.isStopped()) {
            var focusRowKey = rowKey;
            if (rowKey && columnName && rowSpan_1.isRowSpanEnabled(sortState)) {
                var rowSpan = rowSpan_1.getRowSpanByRowKey(rowKey, columnName, rawData);
                if (rowSpan) {
                    focusRowKey = rowSpan.mainRowKey;
                }
            }
            focus.prevColumnName = focus.columnName;
            focus.prevRowKey = focus.rowKey;
            focus.columnName = columnName;
            focus.rowKey = focusRowKey;
        }
    }
    exports.changeFocus = changeFocus;
    function initFocus(_a) {
        var focus = _a.focus;
        focus.editingAddress = null;
        focus.navigating = false;
        focus.rowKey = null;
        focus.columnName = null;
        focus.prevRowKey = null;
        focus.prevColumnName = null;
    }
    exports.initFocus = initFocus;
    function saveAndFinishEditing(store, value) {
        // @TODO: remove 'value' paramter
        // saveAndFinishEditing(store: Store)
        var focus = store.focus, data = store.data, column = store.column, id = store.id;
        var editingAddress = focus.editingAddress;
        if (!editingAddress) {
            return;
        }
        var rowKey = editingAddress.rowKey, columnName = editingAddress.columnName;
        // makes the data observable to judge editable, disable of the cell.
        data_2.makeObservable(store, data_1.findIndexByRowKey(data, column, id, rowKey, false));
        // if value is 'undefined', editing result is saved and finished.
        if (common_1.isUndefined(value)) {
            focus.forcedDestroyEditing = true;
            focus.editingAddress = null;
            focus.navigating = true;
            return;
        }
        data_2.setValue(store, rowKey, columnName, value);
        finishEditing(store, rowKey, columnName, value, { save: true });
    }
    exports.saveAndFinishEditing = saveAndFinishEditing;
    function setFocusInfo(store, rowKey, columnName, navigating) {
        var focus = store.focus, id = store.id;
        focus.navigating = navigating;
        changeFocus(store, rowKey, columnName, id);
    }
    exports.setFocusInfo = setFocusInfo;


    /***/ }),
    /* 19 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(1);
    var messages = {
        en: {
            display: {
                noData: 'No data.',
                loadingData: 'Loading data.',
                resizeHandleGuide: 'You can change the width of the column by mouse drag, and initialize the width by double-clicking.',
            },
            net: {
                confirmCreate: 'Are you sure you want to create {{count}} data?',
                confirmUpdate: 'Are you sure you want to update {{count}} data?',
                confirmDelete: 'Are you sure you want to delete {{count}} data?',
                confirmModify: 'Are you sure you want to modify {{count}} data?',
                noDataToCreate: 'No data to create.',
                noDataToUpdate: 'No data to update.',
                noDataToDelete: 'No data to delete.',
                noDataToModify: 'No data to modify.',
                failResponse: 'An error occurred while requesting data.\nPlease try again.',
            },
            filter: {
                contains: 'Contains',
                eq: 'Equals',
                ne: 'Not equals',
                start: 'Starts with',
                end: 'Ends with',
                after: 'After',
                afterEq: 'After or Equal',
                before: 'Before',
                beforeEq: 'Before or Equal',
                apply: 'Apply',
                clear: 'Clear',
                selectAll: 'Select All',
                emptyValue: 'Empty Value',
            },
            contextMenu: {
                copy: 'Copy',
                copyColumns: 'Copy Columns',
                copyRows: 'Copy Rows',
            },
        },
        es: {
            display: {
                noData: 'No hay informacin.',
                loadingData: 'Cargando informacin.',
                resizeHandleGuide: 'Puedes cambiar el ancho de la columna arrastrando el ratn e inicializar el ancho haciendo doble clic.',
            },
            net: {
                confirmCreate: 'Ests seguro que quieres crear {{count}} filas?',
                confirmUpdate: 'Ests seguro que quieres actualizar {{count}} filas?',
                confirmDelete: 'Ests seguro que quieres eliminar {{count}} filas?',
                confirmModify: 'Ests seguro que quieres modificar {{count}} filas?',
                noDataToCreate: 'No hay informacin para crear.',
                noDataToUpdate: 'No hay informacin para actualizar.',
                noDataToDelete: 'No hay informacin para eliminar.',
                noDataToModify: 'No hay informacin para modificar.',
                failResponse: 'Se produjo un error al solicitar datos. \nVuelve a intentarlo.',
            },
            filter: {
                contains: 'Contiene',
                eq: 'Igual',
                ne: 'Distinto',
                start: 'Empieza con',
                end: 'Termina en',
                after: 'Despus',
                afterEq: 'Despus o Igual',
                before: 'Antes',
                beforeEq: 'Antes o Igual',
                apply: 'Aplicar',
                clear: 'Limpiar',
                selectAll: 'Seleccionar Todo',
                emptyValue: 'Vaciar Valor',
            },
            contextMenu: {
                copy: 'Copiar',
                copyColumns: 'Copiar Columnas',
                copyRows: 'Copiar Filas',
            },
        },
        ko: {
            display: {
                noData: '  .',
                loadingData: '  .',
                resizeHandleGuide: '      ,       .',
            },
            net: {
                confirmCreate: '{{count}}  ?',
                confirmUpdate: '{{count}}  ?',
                confirmDelete: '{{count}}  ?',
                confirmModify: '{{count}}  ?',
                noDataToCreate: '  .',
                noDataToUpdate: '  .',
                noDataToDelete: '  .',
                noDataToModify: '  .',
                failResponse: '    .\n   .',
            },
            filter: {
                contains: 'Contains',
                eq: 'Equals',
                ne: 'Not equals',
                start: 'Starts with',
                end: 'Ends with',
                after: 'After',
                afterEq: 'After or Equal',
                before: 'Before',
                beforeEq: 'Before or Equal',
                apply: 'Apply',
                clear: 'Clear',
                selectAll: 'Select All',
                emptyValue: 'Empty Value',
            },
            contextMenu: {
                copy: '',
                copyColumns: ' ',
                copyRows: ' ',
            },
        },
    };
    var messageMap = {};
    /**
     * Flatten message map
     * @param {object} data - Messages
     * @returns {object} Flatten message object (key format is 'key.subKey')
     * @ignore
     */
    function flattenMessageMap(data) {
        if (data === void 0) { data = {}; }
        var obj = {};
        var newKey;
        Object.keys(data).forEach(function (key) {
            var keyWithType = key;
            var groupMessages = data[keyWithType];
            Object.keys(groupMessages).forEach(function (subKey) {
                newKey = key + "." + subKey;
                obj[newKey] = groupMessages[subKey];
            });
        });
        return obj;
    }
    /**
     * Replace text
     * @param {string} text - Text including handlebar expression
     * @param {Object} values - Replaced values
     * @returns {string} Replaced text
     */
    function replaceText(text, values) {
        return text
            ? text.replace(/\{\{(\w*)\}\}/g, function (_, prop) { return (values.hasOwnProperty(prop) ? values[prop] : ''); })
            : '';
    }
    exports.default = {
        /**
         * Set messages
         * @param {string} localeCode - Code to set locale messages and
         *     this is the language or language-region combination. (ex: en-US)
         * @param {object} [data] - Messages using in Grid
         */
        setLanguage: function (localeCode, data) {
            var localeMessages = messages[localeCode];
            if (!localeMessages && !data) {
                throw new Error('You should set messages to map the locale code.');
            }
            var newData = flattenMessageMap(data);
            if (localeMessages) {
                var originData = flattenMessageMap(localeMessages);
                messageMap = tslib_1.__assign(tslib_1.__assign({}, originData), newData);
            }
            else {
                messageMap = newData;
            }
        },
        /**
         * Get message
         * @param {string} key - Key to find message (ex: 'net.confirmCreate')
         * @param {object} [replacements] - Values to replace string
         * @returns {string} Message
         */
        get: function (key, replacements) {
            if (replacements === void 0) { replacements = {}; }
            var message = messageMap[key];
            return replaceText(message, replacements);
        },
    };


    /***/ }),
    /* 20 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSelectionRange = exports.isSameInputRange = exports.getSortedRange = exports.getChildColumnRange = exports.getLeafChildColumnNames = void 0;
    var tslib_1 = __webpack_require__(1);
    var common_1 = __webpack_require__(0);
    var column_1 = __webpack_require__(12);
    function sortByVisibleColumns(visibleColumnsWithRowHeader, childNames) {
        var result = [];
        visibleColumnsWithRowHeader.forEach(function (column) {
            if (common_1.includes(childNames, column.name)) {
                result.push(column.name);
            }
        });
        return result;
    }
    function getLeafChildColumnNames(complexColumnHeaders, name) {
        var column = common_1.findProp('name', name, complexColumnHeaders);
        if (!column) {
            return [name];
        }
        var result = [];
        column.childNames.forEach(function (childName) {
            if (column_1.isParentColumnHeader(complexColumnHeaders, childName)) {
                result = tslib_1.__spreadArrays(result, getLeafChildColumnNames(complexColumnHeaders, childName));
            }
            else {
                result = tslib_1.__spreadArrays(result, [childName]);
            }
        });
        return result;
    }
    exports.getLeafChildColumnNames = getLeafChildColumnNames;
    function getChildColumnRange(visibleColumnsWithRowHeader, complexColumnHeaders, name) {
        var unsortedChildNames = getLeafChildColumnNames(complexColumnHeaders, name);
        var childNames = sortByVisibleColumns(visibleColumnsWithRowHeader, unsortedChildNames);
        var startIndex = common_1.findPropIndex('name', childNames[0], visibleColumnsWithRowHeader);
        var endIndex = common_1.findPropIndex('name', childNames[childNames.length - 1], visibleColumnsWithRowHeader);
        return [startIndex, endIndex];
    }
    exports.getChildColumnRange = getChildColumnRange;
    function getSortedRange(range) {
        return range[0] > range[1] ? [range[1], range[0]] : range;
    }
    exports.getSortedRange = getSortedRange;
    function isSameInputRange(inp1, inp2) {
        if (common_1.isNull(inp1) || common_1.isNull(inp2)) {
            return inp1 === inp2;
        }
        return (inp1.column[0] === inp2.column[0] &&
            inp1.column[1] === inp2.column[1] &&
            inp1.row[0] === inp2.row[0] &&
            inp1.row[1] === inp2.row[1]);
    }
    exports.isSameInputRange = isSameInputRange;
    function getSelectionRange(range, pageOptions) {
        if (!common_1.isEmpty(pageOptions)) {
            var row = range.row, column = range.column;
            var perPage = pageOptions.perPage, page = pageOptions.page;
            var prevPageRowCount = (page - 1) * perPage;
            return {
                row: [row[0] - prevPageRowCount, row[1] - prevPageRowCount],
                column: column,
            };
        }
        return range;
    }
    exports.getSelectionRange = getSelectionRange;


    /***/ }),
    /* 21 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTreeIndentWidth = exports.createTreeCellInfo = exports.createTreeRawData = exports.flattenTreeData = exports.createTreeRawRow = void 0;
    var tslib_1 = __webpack_require__(1);
    var data_1 = __webpack_require__(15);
    var tree_1 = __webpack_require__(22);
    var observable_1 = __webpack_require__(5);
    var common_1 = __webpack_require__(0);
    var constant_1 = __webpack_require__(14);
    var treeRowKey = -1;
    function generateTreeRowKey() {
        treeRowKey += 1;
        return treeRowKey;
    }
    function addChildRowKey(row, childRow) {
        var tree = row._attributes.tree;
        var rowKey = childRow.rowKey;
        if (tree && !common_1.includes(tree.childRowKeys, rowKey)) {
            tree.childRowKeys.push(rowKey);
        }
        if (!common_1.someProp('rowKey', rowKey, row._children)) {
            row._children.push(childRow);
        }
        row._leaf = false;
    }
    function insertChildRowKey(row, childRow, offset) {
        var tree = row._attributes.tree;
        var rowKey = childRow.rowKey;
        if (tree && !common_1.includes(tree.childRowKeys, rowKey)) {
            tree.childRowKeys.splice(offset, 0, rowKey);
        }
        if (!common_1.someProp('rowKey', rowKey, row._children)) {
            row._children.splice(offset, 0, childRow);
        }
        row._leaf = false;
    }
    function getTreeCellInfo(rawData, row, useIcon) {
        var depth = tree_1.getDepth(rawData, row);
        var indentWidth = getTreeIndentWidth(depth, useIcon);
        return {
            depth: depth,
            indentWidth: indentWidth,
            leaf: tree_1.isLeaf(row),
            expanded: tree_1.isExpanded(row),
        };
    }
    function createTreeRawRow(id, row, parentRow, column, options) {
        if (options === void 0) { options = {}; }
        var childRowKeys = [];
        if (row._attributes && row._attributes.tree) {
            childRowKeys = row._attributes.tree.childRowKeys;
        }
        var keyColumnName = options.keyColumnName, offset = options.offset, _a = options.lazyObservable, lazyObservable = _a === void 0 ? false : _a, _b = options.disabled, disabled = _b === void 0 ? false : _b;
        if (!row._children) {
            row._children = [];
            row._leaf = true;
        }
        // generate new tree rowKey when row doesn't have rowKey
        var targetTreeRowKey = common_1.isUndefined(row.rowKey) ? generateTreeRowKey() : Number(row.rowKey);
        var rawRow = data_1.createRawRow(id, row, targetTreeRowKey, column, {
            keyColumnName: keyColumnName,
            lazyObservable: lazyObservable,
            disabled: disabled,
        });
        var defaultAttributes = {
            parentRowKey: parentRow ? parentRow.rowKey : null,
            childRowKeys: childRowKeys,
            hidden: parentRow ? !tree_1.isExpanded(parentRow) || tree_1.isHidden(parentRow) : false,
        };
        if (parentRow) {
            if (!common_1.isUndefined(offset)) {
                insertChildRowKey(parentRow, rawRow, offset);
            }
            else {
                addChildRowKey(parentRow, rawRow);
            }
        }
        var tree = tslib_1.__assign(tslib_1.__assign({}, defaultAttributes), { expanded: row._attributes.expanded });
        rawRow._attributes.tree = lazyObservable ? tree : observable_1.observable(tree);
        return rawRow;
    }
    exports.createTreeRawRow = createTreeRawRow;
    function flattenTreeData(id, data, parentRow, column, options) {
        var flattenedRows = [];
        data.forEach(function (row) {
            var rawRow = createTreeRawRow(id, row, parentRow, column, options);
            flattenedRows.push(rawRow);
            if (Array.isArray(row._children)) {
                if (row._children.length) {
                    flattenedRows.push.apply(flattenedRows, flattenTreeData(id, row._children, rawRow, column, options));
                }
            }
        });
        return flattenedRows;
    }
    exports.flattenTreeData = flattenTreeData;
    function createTreeRawData(_a) {
        var id = _a.id, data = _a.data, column = _a.column, keyColumnName = _a.keyColumnName, _b = _a.lazyObservable, lazyObservable = _b === void 0 ? false : _b, _c = _a.disabled, disabled = _c === void 0 ? false : _c;
        // only reset the rowKey on lazy observable data
        if (lazyObservable) {
            treeRowKey = -1;
        }
        return flattenTreeData(id, data, null, column, {
            keyColumnName: keyColumnName,
            lazyObservable: lazyObservable,
            disabled: disabled,
        });
    }
    exports.createTreeRawData = createTreeRawData;
    function createTreeCellInfo(rawData, row, useIcon, lazyObservable) {
        if (lazyObservable === void 0) { lazyObservable = false; }
        var treeCellInfo = getTreeCellInfo(rawData, row, useIcon);
        var treeInfo = lazyObservable ? treeCellInfo : observable_1.observable(treeCellInfo);
        if (!lazyObservable) {
            observable_1.observe(function () {
                treeInfo.expanded = tree_1.isExpanded(row);
                treeInfo.leaf = tree_1.isLeaf(row);
            });
        }
        return treeInfo;
    }
    exports.createTreeCellInfo = createTreeCellInfo;
    function getTreeIndentWidth(depth, showIcon) {
        return depth * constant_1.TREE_INDENT_WIDTH + (showIcon ? constant_1.TREE_INDENT_WIDTH : 0);
    }
    exports.getTreeIndentWidth = getTreeIndentWidth;


    /***/ }),
    /* 22 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRootParentRow = exports.traverseDescendantRows = exports.traverseAncestorRows = exports.getDepth = exports.isRootChildRow = exports.isExpanded = exports.isLeaf = exports.isHidden = exports.getChildRowKeys = exports.getParentRowKey = exports.getStartIndexToAppendRow = exports.getDescendantRows = exports.getAncestorRows = exports.getChildRows = exports.getParentRow = void 0;
    var observable_1 = __webpack_require__(5);
    var data_1 = __webpack_require__(6);
    var common_1 = __webpack_require__(0);
    function getParentRow(store, rowKey, plainObj) {
        var data = store.data, column = store.column, id = store.id;
        var row = data_1.findRowByRowKey(data, column, id, rowKey);
        if (row) {
            var parentRowKey = getParentRowKey(row);
            var parentRow = data_1.findRowByRowKey(data, column, id, parentRowKey);
            if (parentRow) {
                return plainObj ? observable_1.getOriginObject(parentRow) : parentRow;
            }
        }
        return null;
    }
    exports.getParentRow = getParentRow;
    function getChildRows(store, rowKey, plainObj) {
        var data = store.data, column = store.column, id = store.id;
        var row = data_1.findRowByRowKey(data, column, id, rowKey);
        if (row) {
            var childRowKeys = getChildRowKeys(row);
            return childRowKeys.map(function (childRowKey) {
                var childRow = data_1.findRowByRowKey(data, column, id, childRowKey);
                return plainObj ? observable_1.getOriginObject(childRow) : childRow;
            });
        }
        return [];
    }
    exports.getChildRows = getChildRows;
    function getAncestorRows(store, rowKey) {
        var data = store.data, column = store.column, id = store.id;
        var rawData = data.rawData;
        var row = data_1.findRowByRowKey(data, column, id, rowKey);
        var ancestorRows = [];
        if (row) {
            traverseAncestorRows(rawData, row, function (parentRow) {
                ancestorRows.unshift(observable_1.getOriginObject(parentRow));
            });
        }
        return ancestorRows;
    }
    exports.getAncestorRows = getAncestorRows;
    function getDescendantRows(store, rowKey) {
        var data = store.data, column = store.column, id = store.id;
        var rawData = data.rawData;
        var row = data_1.findRowByRowKey(data, column, id, rowKey);
        var childRows = [];
        if (row) {
            traverseDescendantRows(rawData, row, function (childRow) {
                childRows.push(observable_1.getOriginObject(childRow));
            });
        }
        return childRows;
    }
    exports.getDescendantRows = getDescendantRows;
    function getStartIndexToAppendRow(store, parentRow, offset) {
        var data = store.data, column = store.column, id = store.id;
        var rawData = data.rawData;
        var startIdx;
        if (parentRow) {
            if (offset) {
                var childRowKeys = getChildRowKeys(parentRow);
                var prevChildRowKey = childRowKeys[offset - 1];
                var prevChildRowIdx = data_1.findIndexByRowKey(data, column, id, prevChildRowKey);
                var descendantRowsCount = getDescendantRows(store, prevChildRowKey).length;
                startIdx = prevChildRowIdx + descendantRowsCount + 1;
            }
            else {
                startIdx = data_1.findIndexByRowKey(data, column, id, parentRow.rowKey) + 1;
                if (common_1.isUndefined(offset)) {
                    startIdx += getDescendantRows(store, parentRow.rowKey).length;
                }
            }
        }
        else {
            startIdx = common_1.isUndefined(offset) ? rawData.length : offset;
        }
        return startIdx;
    }
    exports.getStartIndexToAppendRow = getStartIndexToAppendRow;
    function getParentRowKey(row) {
        var tree = row._attributes.tree;
        return tree && tree.parentRowKey !== row.rowKey ? tree.parentRowKey : null;
    }
    exports.getParentRowKey = getParentRowKey;
    function getChildRowKeys(row) {
        var tree = row._attributes.tree;
        return tree ? tree.childRowKeys.slice() : [];
    }
    exports.getChildRowKeys = getChildRowKeys;
    function isHidden(_a) {
        var _attributes = _a._attributes;
        var tree = _attributes.tree;
        return !!(tree && tree.hidden);
    }
    exports.isHidden = isHidden;
    function isLeaf(_a) {
        var _attributes = _a._attributes, _leaf = _a._leaf;
        var tree = _attributes.tree;
        return !!tree && !tree.childRowKeys.length && !!_leaf;
    }
    exports.isLeaf = isLeaf;
    function isExpanded(row) {
        var tree = row._attributes.tree;
        return !!(tree && tree.expanded);
    }
    exports.isExpanded = isExpanded;
    function isRootChildRow(row) {
        var tree = row._attributes.tree;
        return !!tree && common_1.isNull(tree.parentRowKey);
    }
    exports.isRootChildRow = isRootChildRow;
    function getDepth(rawData, row) {
        var parentRow = row;
        var depth = 0;
        do {
            depth += 1;
            parentRow = common_1.findProp('rowKey', getParentRowKey(parentRow), rawData);
        } while (parentRow);
        return depth;
    }
    exports.getDepth = getDepth;
    function traverseAncestorRows(rawData, row, iteratee) {
        var parentRowKey = getParentRowKey(row);
        var parentRow;
        while (!common_1.isNull(parentRowKey)) {
            parentRow = common_1.findProp('rowKey', parentRowKey, rawData);
            iteratee(parentRow);
            parentRowKey = parentRow ? getParentRowKey(parentRow) : null;
        }
    }
    exports.traverseAncestorRows = traverseAncestorRows;
    function traverseDescendantRows(rawData, row, iteratee) {
        var childRowKeys = getChildRowKeys(row);
        var rowKey, childRow;
        while (childRowKeys.length) {
            rowKey = childRowKeys.shift();
            childRow = common_1.findProp('rowKey', rowKey, rawData);
            iteratee(childRow);
            if (childRow) {
                childRowKeys = childRowKeys.concat(getChildRowKeys(childRow));
            }
        }
    }
    exports.traverseDescendantRows = traverseDescendantRows;
    function getRootParentRow(rawData, row) {
        var rootParentRow = row;
        do {
            var parentRow = common_1.findProp('rowKey', getParentRowKey(rootParentRow), rawData);
            if (!parentRow) {
                break;
            }
            rootParentRow = parentRow;
        } while (rootParentRow);
        return rootParentRow;
    }
    exports.getRootParentRow = getRootParentRow;


    /***/ }),
    /* 23 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.initScrollPosition = exports.setScrollTop = exports.setScrollLeft = exports.setScrollToSelection = exports.setScrollToFocus = void 0;
    var viewport_1 = __webpack_require__(74);
    function setScrollPosition(viewport, changedScrollTop, changedScrollLeft) {
        if (changedScrollLeft !== null) {
            viewport.scrollLeft = changedScrollLeft;
        }
        if (changedScrollTop !== null) {
            viewport.scrollTop = changedScrollTop;
        }
    }
    function setScrollToFocus(store) {
        var _a = store.focus, cellPosRect = _a.cellPosRect, side = _a.side, viewport = store.viewport;
        if (cellPosRect === null || side === null) {
            return;
        }
        var _b = viewport_1.getChangedScrollPosition(store, side), changedScrollLeft = _b[0], changedScrollTop = _b[1];
        setScrollPosition(viewport, changedScrollTop, changedScrollLeft);
    }
    exports.setScrollToFocus = setScrollToFocus;
    function setScrollToSelection(store) {
        var _a = store.columnCoords, widths = _a.widths, columnOffsets = _a.offsets, _b = store.rowCoords, heights = _b.heights, rowOffsets = _b.offsets, inputRange = store.selection.inputRange, viewport = store.viewport;
        if (!inputRange) {
            return;
        }
        var rowIndex = inputRange.row[1];
        var columnIndex = inputRange.column[1];
        var cellSide = columnIndex > widths.L.length - 1 ? 'R' : 'L';
        var rightSideColumnIndex = columnIndex < widths.L.length ? widths.L.length : columnIndex - widths.L.length;
        var left = columnOffsets[cellSide][rightSideColumnIndex];
        var right = left + widths[cellSide][rightSideColumnIndex];
        var top = rowOffsets[rowIndex];
        var bottom = top + heights[rowIndex];
        var cellPosRect = { left: left, right: right, top: top, bottom: bottom };
        var _c = viewport_1.getChangedScrollPosition(store, cellSide, cellPosRect), changedScrollLeft = _c[0], changedScrollTop = _c[1];
        setScrollPosition(viewport, changedScrollTop, changedScrollLeft);
    }
    exports.setScrollToSelection = setScrollToSelection;
    function setScrollLeft(_a, scrollLeft) {
        var viewport = _a.viewport;
        viewport.scrollLeft = scrollLeft;
    }
    exports.setScrollLeft = setScrollLeft;
    function setScrollTop(_a, scrollTop) {
        var viewport = _a.viewport;
        viewport.scrollTop = scrollTop;
    }
    exports.setScrollTop = setScrollTop;
    function initScrollPosition(_a) {
        var viewport = _a.viewport;
        viewport.scrollLeft = 0;
        viewport.scrollTop = 0;
    }
    exports.initScrollPosition = initScrollPosition;


    /***/ }),
    /* 24 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.updateAllSummaryValues = exports.updateSummaryValueByRow = exports.updateSummaryValueByColumn = exports.updateSummaryValueByCell = exports.setSummaryColumnContent = void 0;
    var summary_1 = __webpack_require__(43);
    var common_1 = __webpack_require__(0);
    var summary_2 = __webpack_require__(44);
    var observable_1 = __webpack_require__(5);
    function setSummaryColumnContent(_a, columnName, columnContent) {
        var summary = _a.summary, data = _a.data;
        var castedColumnContent = summary_1.castToSummaryColumnContent(columnContent);
        var content = summary_1.extractSummaryColumnContent(castedColumnContent, null);
        summary.summaryColumnContents[columnName] = content;
        summary.summaryValues[columnName] = summary_2.createSummaryValue(content, columnName, data);
        observable_1.notify(summary, 'summaryValues');
    }
    exports.setSummaryColumnContent = setSummaryColumnContent;
    function updateSummaryValue(_a, columnName, type, options) {
        var summary = _a.summary, data = _a.data;
        var content = summary.summaryColumnContents[columnName];
        if (!content || !content.useAutoSummary) {
            return;
        }
        var summaryValue = summary.summaryValues[columnName];
        var orgValue = Number(options.orgValue) || 0;
        var value = Number(options.value) || 0;
        var cntVariation = options.type === 'APPEND' ? 1 : -1;
        var columnFilter = common_1.findProp('columnName', columnName, data.filters || []);
        var hasColumnFilter = !!(columnFilter && common_1.isFunction(columnFilter.conditionFn));
        var included = hasColumnFilter && columnFilter.conditionFn(value);
        var sum = summaryValue.sum, min = summaryValue.min, max = summaryValue.max, cnt = summaryValue.cnt;
        var _b = summaryValue.filtered, filteredSum = _b.sum, filteredMin = _b.min, filteredMax = _b.max, filteredCnt = _b.cnt;
        switch (type) {
            case 'UPDATE_COLUMN':
                sum = value * cnt;
                min = value;
                max = value;
                if (hasColumnFilter) {
                    filteredCnt = included ? filteredCnt : 0;
                    filteredSum = included ? value * filteredCnt : 0;
                    filteredMin = included ? value : 0;
                    filteredMax = included ? value : 0;
                }
                break;
            case 'UPDATE_CELL':
                sum = sum - orgValue + value;
                if (hasColumnFilter) {
                    var orgIncluded = columnFilter.conditionFn(orgValue);
                    if (!orgIncluded && included) {
                        filteredSum = filteredSum + value;
                        filteredCnt += 1;
                    }
                    else if (orgIncluded && !included) {
                        filteredSum = filteredSum - orgValue;
                        filteredCnt -= 1;
                    }
                    else if (orgIncluded && included) {
                        filteredSum = filteredSum - orgValue + value;
                    }
                }
                break;
            case 'UPDATE_ROW':
                cnt += cntVariation;
                sum = sum + cntVariation * value;
                if (hasColumnFilter && included) {
                    filteredSum = filteredSum + cntVariation * value;
                    filteredCnt += cntVariation;
                }
                break;
            // do nothing;
        }
        var avg = sum / cnt;
        var filteredAvg = filteredSum / filteredCnt;
        min = Math.min(value, min);
        max = Math.max(value, max);
        filteredMin = Math.min(value, filteredMin);
        filteredMax = Math.max(value, filteredMax);
        summary.summaryValues[columnName] = {
            sum: sum,
            min: min,
            max: max,
            avg: avg,
            cnt: cnt,
            filtered: {
                sum: filteredSum,
                min: filteredMin,
                max: filteredMax,
                avg: filteredAvg,
                cnt: filteredCnt,
            },
        };
        observable_1.notify(summary, 'summaryValues');
    }
    function updateSummaryValueByCell(store, columnName, options) {
        updateSummaryValue(store, columnName, 'UPDATE_CELL', options);
    }
    exports.updateSummaryValueByCell = updateSummaryValueByCell;
    function updateSummaryValueByColumn(store, columnName, options) {
        updateSummaryValue(store, columnName, 'UPDATE_COLUMN', options);
    }
    exports.updateSummaryValueByColumn = updateSummaryValueByColumn;
    function updateSummaryValueByRow(store, row, options) {
        var summary = store.summary, column = store.column;
        var type = options.type, orgRow = options.orgRow;
        var summaryColumns = column.allColumns.filter(function (_a) {
            var name = _a.name;
            return !!summary.summaryColumnContents[name];
        });
        summaryColumns.forEach(function (_a) {
            var name = _a.name;
            if (type === 'SET') {
                updateSummaryValue(store, name, 'UPDATE_CELL', { orgValue: orgRow[name], value: row[name] });
            }
            else {
                updateSummaryValue(store, name, 'UPDATE_ROW', { type: type, value: row[name] });
            }
        });
    }
    exports.updateSummaryValueByRow = updateSummaryValueByRow;
    function updateAllSummaryValues(_a) {
        var summary = _a.summary, data = _a.data, column = _a.column;
        var summaryColumns = column.allColumns.filter(function (_a) {
            var name = _a.name;
            return !!summary.summaryColumnContents[name];
        });
        summaryColumns.forEach(function (_a) {
            var name = _a.name;
            var content = summary.summaryColumnContents[name];
            summary.summaryValues[name] = summary_2.createSummaryValue(content, name, data);
        });
        observable_1.notify(summary, 'summaryValues');
    }
    exports.updateAllSummaryValues = updateAllSummaryValues;


    /***/ }),
    /* 25 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getValidationCode = exports.forceValidateUniquenessOfColumn = exports.forceValidateUniquenessOfColumns = exports.replaceColumnUniqueInfoMap = exports.removeUniqueInfoMap = exports.addUniqueInfoMap = exports.invokeWithUniqueValidationColumn = exports.createNewValidationMap = void 0;
    var tslib_1 = __webpack_require__(1);
    var common_1 = __webpack_require__(0);
    var observable_1 = __webpack_require__(5);
    var instance_1 = __webpack_require__(7);
    var data_1 = __webpack_require__(6);
    var instanceValidationMap = {};
    var isValidatingUniquenessMap = {};
    function createNewValidationMap(id) {
        instanceValidationMap[id] = {};
    }
    exports.createNewValidationMap = createNewValidationMap;
    function invokeWithUniqueValidationColumn(column, fn) {
        column.validationColumns.forEach(function (_a) {
            var name = _a.name, validation = _a.validation;
            if (validation.unique) {
                fn(name);
            }
        });
    }
    exports.invokeWithUniqueValidationColumn = invokeWithUniqueValidationColumn;
    function addUniqueInfoMap(id, row, column) {
        invokeWithUniqueValidationColumn(column, function (name) {
            return addColumnUniqueInfoMap(id, row.rowKey, name, row[name]);
        });
    }
    exports.addUniqueInfoMap = addUniqueInfoMap;
    function removeUniqueInfoMap(id, row, column) {
        invokeWithUniqueValidationColumn(column, function (name) {
            return removeColumnUniqueInfoMap(id, row.rowKey, name, row[name]);
        });
    }
    exports.removeUniqueInfoMap = removeUniqueInfoMap;
    function removeColumnUniqueInfoMap(id, rowKey, columnName, cellValue) {
        var value = String(cellValue);
        var uniqueInfoMap = instanceValidationMap[id];
        if (uniqueInfoMap && uniqueInfoMap[value] && uniqueInfoMap[value][columnName]) {
            uniqueInfoMap[value][columnName] = uniqueInfoMap[value][columnName].filter(function (targetRowKey) { return targetRowKey !== rowKey; });
        }
    }
    function addColumnUniqueInfoMap(id, rowKey, columnName, cellValue) {
        var value = String(cellValue);
        var uniqueInfoMap = instanceValidationMap[id];
        uniqueInfoMap[value] = uniqueInfoMap[value] || {};
        uniqueInfoMap[value][columnName] = uniqueInfoMap[value][columnName] || [];
        uniqueInfoMap[value][columnName].push(rowKey);
    }
    function replaceColumnUniqueInfoMap(id, column, _a) {
        var rowKey = _a.rowKey, columnName = _a.columnName, prevValue = _a.prevValue, value = _a.value;
        if (common_1.some(function (_a) {
            var name = _a.name;
            return name === columnName;
        }, column.validationColumns)) {
            removeColumnUniqueInfoMap(id, rowKey, columnName, prevValue);
            addColumnUniqueInfoMap(id, rowKey, columnName, value);
        }
    }
    exports.replaceColumnUniqueInfoMap = replaceColumnUniqueInfoMap;
    function forceValidateUniquenessOfColumns(rawData, column) {
        if (rawData.length) {
            // trick for forcing to validate the uniqueness
            invokeWithUniqueValidationColumn(column, function (name) { return observable_1.notify(rawData[0], name); });
        }
    }
    exports.forceValidateUniquenessOfColumns = forceValidateUniquenessOfColumns;
    function forceValidateUniquenessOfColumn(rawData, column, columnName) {
        if (common_1.some(function (_a) {
            var name = _a.name;
            return name === columnName;
        }, column.validationColumns) && rawData.length) {
            // trick for forcing to validate the uniqueness
            observable_1.notify(rawData[0], columnName);
        }
    }
    exports.forceValidateUniquenessOfColumn = forceValidateUniquenessOfColumn;
    function hasDuplicateValue(id, columnName, cellValue) {
        var _a;
        var value = String(cellValue);
        var uniqueInfoMap = instanceValidationMap[id];
        return !!(uniqueInfoMap && uniqueInfoMap[value] && ((_a = uniqueInfoMap[value][columnName]) === null || _a === void 0 ? void 0 : _a.length) > 1);
    }
    function validateDataUniqueness(id, value, columnName, invalidStates) {
        if (hasDuplicateValue(id, columnName, value)) {
            invalidStates.push({ code: 'UNIQUE' });
        }
        // prevent recursive call of 'validateDataUniqueness' when scrolling or manipulating the data
        if (!isValidatingUniquenessMap[columnName] &&
            !common_1.includes(observable_1.getRunningObservers(), 'lazyObservable')) {
            var rawData_1 = [];
            observable_1.unobservedInvoke(function () {
                // @TODO: should get the latest rawData through function(not private field of the grid instance)
                // @ts-ignore
                rawData_1 = instance_1.getInstance(id).store.data.rawData;
            });
            isValidatingUniquenessMap[columnName] = true;
            rawData_1.forEach(function (row) {
                if (observable_1.isObservable(row)) {
                    observable_1.notify(row, columnName);
                }
            });
            setTimeout(function () {
                isValidatingUniquenessMap[columnName] = false;
            });
        }
    }
    function validateCustomValidator(row, value, columnName, validatorFn, invalidStates) {
        var originRow = data_1.getOmittedInternalProp(row);
        observable_1.unobservedInvoke(function () {
            var result = validatorFn(value, originRow, columnName);
            var _a = (common_1.isBoolean(result)
                ? { valid: result }
                : result), valid = _a.valid, meta = _a.meta;
            if (!valid) {
                invalidStates.push(tslib_1.__assign({ code: 'VALIDATOR_FN' }, meta));
            }
        });
    }
    function getValidationCode(_a) {
        var id = _a.id, value = _a.value, row = _a.row, columnName = _a.columnName, validation = _a.validation;
        var invalidStates = [];
        if (!validation) {
            return invalidStates;
        }
        var required = validation.required, dataType = validation.dataType, min = validation.min, max = validation.max, regExp = validation.regExp, unique = validation.unique, validatorFn = validation.validatorFn;
        if (required && common_1.isBlank(value)) {
            invalidStates.push({ code: 'REQUIRED' });
        }
        if (unique) {
            validateDataUniqueness(id, value, columnName, invalidStates);
        }
        if (common_1.isFunction(validatorFn)) {
            validateCustomValidator(row, value, columnName, validatorFn, invalidStates);
        }
        if (dataType === 'string' && !common_1.isString(value)) {
            invalidStates.push({ code: 'TYPE_STRING' });
        }
        if (regExp && common_1.isString(value) && !regExp.test(value)) {
            invalidStates.push({ code: 'REGEXP', regExp: regExp });
        }
        var numberValue = common_1.convertToNumber(value);
        if (dataType === 'number' && !common_1.isNumber(numberValue)) {
            invalidStates.push({ code: 'TYPE_NUMBER' });
        }
        if (common_1.isNumber(min) && common_1.isNumber(numberValue) && numberValue < min) {
            invalidStates.push({ code: 'MIN', min: min });
        }
        if (common_1.isNumber(max) && common_1.isNumber(numberValue) && numberValue > max) {
            invalidStates.push({ code: 'MAX', max: max });
        }
        return invalidStates;
    }
    exports.getValidationCode = getValidationCode;


    /***/ }),
    /* 26 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFormattedValue = exports.createFormattedValue = exports.getMaxTextMap = exports.setMaxColumnTextMap = exports.setMaxTextMap = exports.initMaxTextMap = void 0;
    var listItemText_1 = __webpack_require__(62);
    var common_1 = __webpack_require__(0);
    var maxTextMap = {};
    function initMaxTextMap() {
        maxTextMap = {};
    }
    exports.initMaxTextMap = initMaxTextMap;
    function setMaxTextMap(column, row) {
        column.autoResizingColumn.forEach(function (columnInfo) {
            var name = columnInfo.name;
            var formattedValue = createFormattedValue(row, columnInfo);
            if (!maxTextMap[name] || maxTextMap[name].formattedValue.length < formattedValue.length) {
                setMaxColumnTextMap(name, formattedValue, row);
            }
        });
    }
    exports.setMaxTextMap = setMaxTextMap;
    function setMaxColumnTextMap(columnName, formattedValue, row) {
        maxTextMap[columnName] = { formattedValue: formattedValue, row: row };
    }
    exports.setMaxColumnTextMap = setMaxColumnTextMap;
    function getMaxTextMap() {
        return maxTextMap;
    }
    exports.getMaxTextMap = getMaxTextMap;
    function createFormattedValue(row, columnInfo) {
        var name = columnInfo.name, formatter = columnInfo.formatter, defaultValue = columnInfo.defaultValue;
        var formatterProps = { row: row, column: columnInfo, value: row[name] };
        return getFormattedValue(formatterProps, formatter, row[name] || defaultValue, row._relationListItemMap[name]);
    }
    exports.createFormattedValue = createFormattedValue;
    function getFormattedValue(props, formatter, defaultValue, relationListItems) {
        var value;
        if (formatter === 'listItemText') {
            value = listItemText_1.listItemText(props, relationListItems);
        }
        else if (common_1.isFunction(formatter)) {
            value = formatter(props);
        }
        else if (common_1.isString(formatter)) {
            value = formatter;
        }
        else {
            value = defaultValue;
        }
        var strValue = getCellDisplayValue(value);
        if (strValue && props.column.escapeHTML) {
            return common_1.encodeHTMLEntity(strValue);
        }
        return strValue;
    }
    exports.getFormattedValue = getFormattedValue;
    function getCellDisplayValue(value) {
        if (common_1.isNil(value)) {
            return '';
        }
        return String(value);
    }


    /***/ }),
    /* 27 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createObservableData = exports.fillMissingColumnData = void 0;
    var tslib_1 = __webpack_require__(1);
    var observable_1 = __webpack_require__(5);
    var data_1 = __webpack_require__(15);
    var data_2 = __webpack_require__(6);
    var tree_1 = __webpack_require__(21);
    var common_1 = __webpack_require__(0);
    function getDataToBeObservable(acc, row, viewRow, index, treeColumnName) {
        if (treeColumnName && row._attributes.tree.hidden) {
            return acc;
        }
        if (!observable_1.isObservable(row) ||
            (viewRow && row.rowKey === viewRow.rowKey && !observable_1.isObservable(viewRow.valueMap))) {
            acc.rows.push(row);
            acc.targetIndexes.push(index);
        }
        return acc;
    }
    function createOriginData(data, rowRange, treeColumnName) {
        var start = rowRange[0], end = rowRange[1];
        var viewData = data.viewData.slice(start, end);
        return data.rawData
            .slice(start, end)
            .reduce(function (acc, row, index) {
            return getDataToBeObservable(acc, row, viewData[index], index + start, treeColumnName);
        }, {
            rows: [],
            targetIndexes: [],
        });
    }
    function createFilteredOriginData(data, rowRange, treeColumnName) {
        var start = rowRange[0], end = rowRange[1];
        var rawData = data.rawData, viewData = data.viewData;
        return data
            .filteredIndex.slice(start, end)
            .reduce(function (acc, rowIndex) {
            return getDataToBeObservable(acc, rawData[rowIndex], viewData[rowIndex], rowIndex, treeColumnName);
        }, { rows: [], targetIndexes: [] });
    }
    function changeToObservableData(id, column, data, originData) {
        var targetIndexes = originData.targetIndexes, rows = originData.rows;
        var rawData = data.rawData;
        fillMissingColumnData(column, rows);
        // prevRows is needed to create rowSpan
        var prevRows = targetIndexes.map(function (targetIndex) { return data.rawData[targetIndex - 1]; });
        for (var index = 0, end = rows.length; index < end; index += 1) {
            var targetIndex = targetIndexes[index];
            var rawRow = data_1.createRawRow(id, rows[index], index, column, {
                lazyObservable: false,
                prevRow: prevRows[index],
                keyColumnName: column.keyColumnName,
            });
            var viewRow = data_1.createViewRow(id, rawRow, rawData, column);
            common_1.silentSplice(data.rawData, targetIndex, 1, rawRow);
            common_1.silentSplice(data.viewData, targetIndex, 1, viewRow);
        }
        observable_1.notify(data, 'rawData', 'filteredRawData', 'viewData', 'filteredViewData');
    }
    function changeToObservableTreeData(id, column, data, originData) {
        var rows = originData.rows;
        var rawData = data.rawData, viewData = data.viewData;
        fillMissingColumnData(column, rows);
        // create new creation key for updating the observe function of hoc component
        data_1.generateDataCreationKey();
        rows.forEach(function (row) {
            var parentRow = data_2.findRowByRowKey(data, column, id, row._attributes.tree.parentRowKey);
            var rawRow = tree_1.createTreeRawRow(id, row, parentRow || null, column);
            var viewRow = data_1.createViewRow(id, rawRow, rawData, column);
            var foundIndex = data_2.findIndexByRowKey(data, column, id, rawRow.rowKey);
            common_1.silentSplice(rawData, foundIndex, 1, rawRow);
            common_1.silentSplice(viewData, foundIndex, 1, viewRow);
        });
        observable_1.notify(data, 'rawData', 'filteredRawData', 'viewData', 'filteredViewData');
    }
    function fillMissingColumnData(column, rawData) {
        for (var i = 0; i < rawData.length; i += 1) {
            rawData[i] = tslib_1.__assign(tslib_1.__assign({}, column.emptyRow), rawData[i]);
        }
    }
    exports.fillMissingColumnData = fillMissingColumnData;
    function createObservableData(_a, allRowRange) {
        var column = _a.column, data = _a.data, viewport = _a.viewport, id = _a.id;
        if (allRowRange === void 0) { allRowRange = false; }
        var rowRange = allRowRange ? [0, data.rawData.length] : viewport.rowRange;
        var treeColumnName = column.treeColumnName;
        var originData = data.filters && !allRowRange
            ? createFilteredOriginData(data, rowRange, treeColumnName)
            : createOriginData(data, rowRange, treeColumnName);
        if (!originData.rows.length) {
            return;
        }
        if (treeColumnName) {
            changeToObservableTreeData(id, column, data, originData);
        }
        else {
            changeToObservableData(id, column, data, originData);
        }
    }
    exports.createObservableData = createObservableData;


    /***/ }),
    /* 28 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resetSortState = exports.sortByCurrentState = exports.resetSortKey = exports.updateSortKey = exports.emitAfterSort = exports.emitBeforeSort = exports.initSortState = exports.unsort = exports.sort = exports.changeSortState = void 0;
    var tslib_1 = __webpack_require__(1);
    var common_1 = __webpack_require__(0);
    var observable_1 = __webpack_require__(5);
    var sort_1 = __webpack_require__(73);
    var eventBus_1 = __webpack_require__(8);
    var data_1 = __webpack_require__(13);
    var data_2 = __webpack_require__(6);
    var column_1 = __webpack_require__(12);
    var sort_2 = __webpack_require__(42);
    function createSoretedViewData(rawData) {
        return rawData.map(function (_a) {
            var rowKey = _a.rowKey, sortKey = _a.sortKey, uniqueKey = _a.uniqueKey;
            return ({ rowKey: rowKey, sortKey: sortKey, uniqueKey: uniqueKey });
        });
    }
    function sortData(store) {
        var data = store.data, column = store.column;
        var sortState = data.sortState, rawData = data.rawData, viewData = data.viewData, pageRowRange = data.pageRowRange;
        var columns = sortState.columns;
        var sortedColumns = columns.map(function (sortedColumn) {
            var _a;
            return (tslib_1.__assign(tslib_1.__assign({}, sortedColumn), { comparator: (_a = column.allColumnMap[sortedColumn.columnName]) === null || _a === void 0 ? void 0 : _a.comparator }));
        });
        if (data_2.isScrollPagination(data, true)) {
            // should sort the sliced data which is displayed in viewport in case of client infinite scrolling
            var targetRawData = rawData.slice.apply(rawData, pageRowRange);
            targetRawData.sort(sort_1.sortRawData(sortedColumns));
            var targetViewData = createSoretedViewData(targetRawData);
            data.rawData = targetRawData.concat(rawData.slice(pageRowRange[1]));
            data.viewData = targetViewData.concat(viewData.slice(pageRowRange[1]));
        }
        else {
            rawData.sort(sort_1.sortRawData(sortedColumns));
            data.viewData = createSoretedViewData(rawData);
        }
    }
    function setInitialSortState(data) {
        data.sortState.columns = [{ columnName: 'sortKey', ascending: true }];
    }
    function setSortStateForEmptyState(data) {
        if (!data.sortState.columns.length) {
            setInitialSortState(data);
        }
    }
    function toggleSortAscending(data, index, ascending, sortingType, cancelable) {
        var defaultAscending = sortingType === 'asc';
        if (defaultAscending === ascending && cancelable) {
            data.sortState.columns.splice(index, 1);
        }
        else {
            data.sortState.columns[index].ascending = ascending;
        }
    }
    function changeSingleSortState(data, columnName, ascending, sortingType, cancelable) {
        var sortState = data.sortState;
        var columns = sortState.columns;
        var sortedColumn = { columnName: columnName, ascending: ascending };
        if (columns.length === 1 && columns[0].columnName === columnName) {
            var columnIndex = common_1.findPropIndex('columnName', columnName, sortState.columns);
            toggleSortAscending(data, columnIndex, ascending, sortingType, cancelable);
        }
        else {
            data.sortState.columns = [sortedColumn];
        }
    }
    function changeMultiSortState(data, columnName, ascending, sortingType, cancelable) {
        var sortedColumn = { columnName: columnName, ascending: ascending };
        var sortState = data.sortState;
        var columns = sortState.columns;
        var columnIndex = common_1.findPropIndex('columnName', columnName, columns);
        if (columnIndex === -1) {
            data.sortState.columns = data_2.isInitialSortState(sortState)
                ? [sortedColumn]
                : tslib_1.__spreadArrays(columns, [sortedColumn]);
        }
        else {
            toggleSortAscending(data, columnIndex, ascending, sortingType, cancelable);
        }
    }
    function changeSortState(_a, columnName, ascending, multiple, cancelable) {
        var data = _a.data, column = _a.column;
        if (cancelable === void 0) { cancelable = true; }
        if (columnName === 'sortKey') {
            setInitialSortState(data);
        }
        else {
            var sortingType = column.allColumnMap[columnName].sortingType;
            if (multiple) {
                changeMultiSortState(data, columnName, ascending, sortingType, cancelable);
            }
            else {
                changeSingleSortState(data, columnName, ascending, sortingType, cancelable);
            }
            setSortStateForEmptyState(data);
        }
        if (!data.sortState.useClient) {
            observable_1.notify(data, 'sortState');
        }
    }
    exports.changeSortState = changeSortState;
    function applySortedData(store) {
        sortData(store);
        observable_1.notify(store.data, 'sortState');
        data_1.updateRowNumber(store, 0);
        data_1.setCheckedAllRows(store);
    }
    function sort(store, columnName, ascending, multiple, cancelable) {
        if (multiple === void 0) { multiple = false; }
        if (cancelable === void 0) { cancelable = true; }
        var data = store.data, column = store.column;
        var sortState = data.sortState;
        if (column_1.isComplexHeader(column, columnName) || !data_2.isSortable(sortState, column, columnName)) {
            return;
        }
        var cancelSort = sort_2.isCancelSort(store, columnName, ascending, cancelable);
        var gridEvent = emitBeforeSort(store, cancelSort, { columnName: columnName, ascending: ascending, multiple: multiple });
        if (gridEvent.isStopped()) {
            return;
        }
        changeSortState(store, columnName, ascending, multiple, cancelable);
        applySortedData(store);
        emitAfterSort(store, cancelSort, columnName);
    }
    exports.sort = sort;
    function unsort(store, columnName) {
        if (columnName === void 0) { columnName = 'sortKey'; }
        var data = store.data, column = store.column;
        var sortState = data.sortState;
        if (column_1.isComplexHeader(column, columnName) || !data_2.isSortable(sortState, column, columnName)) {
            return;
        }
        emitBeforeSort(store, true, { columnName: columnName, multiple: true });
        if (columnName === 'sortKey') {
            setInitialSortState(data);
        }
        else {
            var index = common_1.findPropIndex('columnName', columnName, data.sortState.columns);
            if (index !== -1) {
                data.sortState.columns.splice(index, 1);
                setSortStateForEmptyState(data);
            }
        }
        applySortedData(store);
        emitAfterSort(store, true, columnName);
    }
    exports.unsort = unsort;
    function initSortState(data) {
        setInitialSortState(data);
        observable_1.notify(data, 'sortState');
    }
    exports.initSortState = initSortState;
    function emitBeforeSort(store, cancelSort, eventParams) {
        var id = store.id, data = store.data;
        var eventBus = eventBus_1.getEventBus(id);
        var eventType = cancelSort ? 'beforeUnsort' : 'beforeSort';
        var gridEvent = sort_2.createSortEvent(eventType, tslib_1.__assign(tslib_1.__assign({}, eventParams), { sortState: data.sortState }));
        eventBus.trigger(eventType, gridEvent);
        return gridEvent;
    }
    exports.emitBeforeSort = emitBeforeSort;
    function emitAfterSort(store, cancelSort, columnName) {
        var id = store.id, data = store.data;
        var eventBus = eventBus_1.getEventBus(id);
        // @TODO: `sort` event will be deprecated. This event is replaced with `afterSort` event
        var eventTypes = (cancelSort ? ['afterUnsort'] : ['afterSort', 'sort']);
        eventTypes.forEach(function (eventType) {
            var gridEvent = sort_2.createSortEvent(eventType, { columnName: columnName, sortState: data.sortState });
            eventBus.trigger(eventType, gridEvent);
        });
    }
    exports.emitAfterSort = emitAfterSort;
    function updateSortKey(data, sortKey, appended) {
        if (appended === void 0) { appended = true; }
        var incremental = appended ? 1 : -1;
        var rawData = data.rawData, viewData = data.viewData;
        for (var idx = 0; idx < rawData.length; idx += 1) {
            if (rawData[idx].sortKey >= sortKey) {
                rawData[idx].sortKey += incremental;
                viewData[idx].sortKey += incremental;
            }
        }
        if (appended) {
            rawData[sortKey].sortKey = sortKey;
            viewData[sortKey].sortKey = sortKey;
        }
    }
    exports.updateSortKey = updateSortKey;
    function resetSortKey(data, start) {
        var rawData = data.rawData, viewData = data.viewData;
        for (var idx = start; idx < rawData.length; idx += 1) {
            rawData[idx].sortKey = idx;
            viewData[idx].sortKey = idx;
        }
    }
    exports.resetSortKey = resetSortKey;
    function sortByCurrentState(store) {
        var data = store.data;
        if (data_2.isSorted(data)) {
            var _a = data.sortState.columns[0], columnName = _a.columnName, ascending = _a.ascending;
            sort(store, columnName, ascending, true, false);
        }
    }
    exports.sortByCurrentState = sortByCurrentState;
    function resetSortState(store, sortState) {
        var data = store.data, column = store.column;
        if (sortState) {
            var columnName = sortState.columnName, ascending = sortState.ascending, multiple = sortState.multiple;
            var _a = column.allColumnMap[columnName], sortingType = _a.sortingType, sortable = _a.sortable;
            if (sortable) {
                var cancelable = common_1.isUndefined(ascending);
                var nextAscending = cancelable ? sortingType === 'asc' : ascending;
                changeSortState(store, columnName, nextAscending, multiple, cancelable);
                observable_1.notify(data, 'sortState');
            }
        }
        else {
            initSortState(data);
        }
    }
    exports.resetSortState = resetSortState;


    /***/ }),
    /* 29 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.composeConditionFn = exports.getFilterConditionFn = exports.getUnixTime = exports.createFilterSelectOption = void 0;
    var tslib_1 = __webpack_require__(1);
    var common_1 = __webpack_require__(0);
    var i18n_1 = tslib_1.__importDefault(__webpack_require__(19));
    var filterSelectOption;
    function createFilterSelectOption() {
        if (!filterSelectOption) {
            filterSelectOption = {
                number: {
                    eq: '=',
                    lt: '<',
                    gt: '>',
                    lte: '<=',
                    gte: '>=',
                    ne: '!=',
                },
                text: {
                    contain: i18n_1.default.get('filter.contains'),
                    eq: i18n_1.default.get('filter.eq'),
                    ne: i18n_1.default.get('filter.ne'),
                    start: i18n_1.default.get('filter.start'),
                    end: i18n_1.default.get('filter.end'),
                },
                date: {
                    eq: i18n_1.default.get('filter.eq'),
                    ne: i18n_1.default.get('filter.ne'),
                    after: i18n_1.default.get('filter.after'),
                    afterEq: i18n_1.default.get('filter.afterEq'),
                    before: i18n_1.default.get('filter.before'),
                    beforeEq: i18n_1.default.get('filter.beforeEq'),
                },
            };
        }
        return filterSelectOption;
    }
    exports.createFilterSelectOption = createFilterSelectOption;
    function getUnixTime(value) {
        return parseInt((new Date(String(value)).getTime() / 1000).toFixed(0), 10);
    }
    exports.getUnixTime = getUnixTime;
    function getPredicateWithType(code, type, inputValue) {
        var convertFn = {
            number: Number,
            text: String,
            select: String,
            date: getUnixTime,
        }[type];
        return code === 'eq'
            ? function (cellValue) { return convertFn(cellValue) === convertFn(inputValue); }
            : function (cellValue) { return convertFn(cellValue) !== convertFn(inputValue); };
    }
    function getFilterConditionFn(code, inputValue, type) {
        switch (code) {
            case 'eq':
            case 'ne':
                return getPredicateWithType(code, type, inputValue);
            case 'lt':
                return function (cellValue) { return Number(cellValue) < Number(inputValue); };
            case 'gt':
                return function (cellValue) { return Number(cellValue) > Number(inputValue); };
            case 'lte':
                return function (cellValue) { return Number(cellValue) <= Number(inputValue); };
            case 'gte':
                return function (cellValue) { return Number(cellValue) >= Number(inputValue); };
            case 'contain':
                return function (cellValue) {
                    return common_1.isString(cellValue) && common_1.isString(inputValue) && cellValue.indexOf(inputValue) !== -1;
                };
            case 'start':
                return function (cellValue) {
                    return common_1.isString(cellValue) && common_1.isString(inputValue) && common_1.startsWith(inputValue, cellValue);
                };
            case 'end':
                return function (cellValue) {
                    return common_1.isString(cellValue) && common_1.isString(inputValue) && common_1.endsWith(inputValue, cellValue);
                };
            case 'after':
                return function (cellValue) { return getUnixTime(cellValue) > getUnixTime(inputValue); };
            case 'afterEq':
                return function (cellValue) { return getUnixTime(cellValue) >= getUnixTime(inputValue); };
            case 'before':
                return function (cellValue) { return getUnixTime(cellValue) < getUnixTime(inputValue); };
            case 'beforeEq':
                return function (cellValue) { return getUnixTime(cellValue) <= getUnixTime(inputValue); };
            default:
                throw new Error('code not available.');
        }
    }
    exports.getFilterConditionFn = getFilterConditionFn;
    function composeConditionFn(fns, operator) {
        return function (value) {
            return fns.reduce(function (acc, fn) {
                return operator === 'OR' ? acc || fn(value) : acc && fn(value);
            }, operator !== 'OR');
        };
    }
    exports.composeConditionFn = composeConditionFn;


    /***/ }),
    /* 30 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.moveTreeRow = exports.removeTreeRow = exports.appendTreeRow = exports.changeTreeRowsCheckedState = exports.collapseAll = exports.collapseByRowKey = exports.expandAll = exports.expandByRowKey = exports.removeExpandedAttr = void 0;
    var tslib_1 = __webpack_require__(1);
    var data_1 = __webpack_require__(15);
    var data_2 = __webpack_require__(6);
    var observable_1 = __webpack_require__(5);
    var instance_1 = __webpack_require__(7);
    var data_3 = __webpack_require__(13);
    var tree_1 = __webpack_require__(22);
    var eventBus_1 = __webpack_require__(8);
    var gridEvent_1 = tslib_1.__importDefault(__webpack_require__(9));
    var tree_2 = __webpack_require__(21);
    var common_1 = __webpack_require__(0);
    var dom_1 = __webpack_require__(2);
    var lazyObservable_1 = __webpack_require__(27);
    var column_1 = __webpack_require__(12);
    var data_4 = __webpack_require__(26);
    var constant_1 = __webpack_require__(14);
    var column_2 = __webpack_require__(31);
    var computedFontStyle = '';
    function changeExpandedAttr(row, expanded) {
        var tree = row._attributes.tree;
        if (tree) {
            row._attributes.expanded = expanded;
            tree.expanded = expanded;
        }
    }
    function changeHiddenAttr(row, hidden) {
        var tree = row._attributes.tree;
        if (tree) {
            tree.hidden = hidden;
        }
    }
    function expand(store, row, recursive) {
        var rowKey = row.rowKey;
        var eventBus = eventBus_1.getEventBus(store.id);
        var gridEvent = new gridEvent_1.default({ rowKey: rowKey });
        /**
         * Occurs when the row having child rows is expanded
         * @event Grid#expand
         * @type {module:event/gridEvent}
         * @property {number|string} rowKey - rowKey of the expanded row
         * @property {Grid} instance - Current grid instance
         */
        eventBus.trigger('expand', gridEvent);
        if (gridEvent.isStopped()) {
            return;
        }
        var data = store.data, rowCoords = store.rowCoords, dimension = store.dimension, column = store.column, id = store.id, viewport = store.viewport, columnCoords = store.columnCoords;
        var heights = rowCoords.heights;
        changeExpandedAttr(row, true);
        var childRowKeys = tree_1.getChildRowKeys(row);
        updateTreeColumnWidth(childRowKeys, column, columnCoords, dimension, data.rawData);
        childRowKeys.forEach(function (childRowKey) {
            var childRow = data_2.findRowByRowKey(data, column, id, childRowKey);
            if (!childRow) {
                return;
            }
            changeHiddenAttr(childRow, false);
            if (!tree_1.isLeaf(childRow) && (tree_1.isExpanded(childRow) || recursive)) {
                expand(store, childRow, recursive);
            }
            var index = data_2.findIndexByRowKey(data, column, id, childRowKey);
            heights[index] = data_2.getRowHeight(childRow, dimension.rowHeight);
        });
        if (childRowKeys.length) {
            observable_1.notify(rowCoords, 'heights');
            observable_1.notify(viewport, 'rowRange');
        }
    }
    function updateTreeColumnWidth(childRowKeys, column, columnCoords, dimension, rawData) {
        var visibleColumnsBySideWithRowHeader = column.visibleColumnsBySideWithRowHeader, treeIcon = column.treeIcon, allColumnMap = column.allColumnMap;
        var treeColumnName = column.treeColumnName;
        var treeColumnSide = column_1.getColumnSide(column, treeColumnName);
        var treeColumnIndex = common_1.findPropIndex('name', treeColumnName, column.visibleColumnsBySide[treeColumnSide]);
        var columnInfo = visibleColumnsBySideWithRowHeader[treeColumnSide][treeColumnIndex];
        // @TODO: auto resizing is operated with 'autoResizing' option
        // 'resizable' condition should be deprecated in next version
        if (columnInfo.resizable || columnInfo.autoResizing) {
            var maxWidth = getChildTreeNodeMaxWidth(childRowKeys, rawData, columnInfo, treeIcon);
            var prevWidth = columnCoords.widths[treeColumnSide][treeColumnIndex] + dimension.cellBorderWidth;
            allColumnMap[treeColumnName].baseWidth = Math.max(prevWidth, maxWidth);
            allColumnMap[treeColumnName].fixedWidth = true;
        }
    }
    function getChildTreeNodeMaxWidth(childRowKeys, rawData, column, useIcon) {
        var maxLength = 0;
        computedFontStyle = computedFontStyle || dom_1.getComputedFontStyle('tree-wrapper-relative');
        var getMaxWidth = childRowKeys.reduce(function (acc, rowKey) {
            var row = common_1.findProp('rowKey', rowKey, rawData);
            var formattedValue = data_4.createFormattedValue(row, column);
            if (formattedValue.length > maxLength) {
                maxLength = formattedValue.length;
                acc = function () {
                    return dom_1.getTextWidth(formattedValue, computedFontStyle) +
                        tree_2.getTreeIndentWidth(tree_1.getDepth(rawData, row), useIcon) +
                        constant_1.TREE_CELL_HORIZONTAL_PADDING;
                };
            }
            return acc;
        }, function () { return 0; });
        return getMaxWidth();
    }
    function collapse(store, row, recursive) {
        var rowKey = row.rowKey;
        var eventBus = eventBus_1.getEventBus(store.id);
        var gridEvent = new gridEvent_1.default({ rowKey: rowKey });
        /**
         * Occurs when the row having child rows is collapsed
         * @event Grid#collapse
         * @type {module:event/gridEvent}
         * @property {number|string} rowKey - rowKey of the collapsed row
         * @property {Grid} instance - Current grid instance
         */
        eventBus.trigger('collapse', gridEvent);
        if (gridEvent.isStopped()) {
            return;
        }
        var data = store.data, rowCoords = store.rowCoords, column = store.column, id = store.id;
        var heights = rowCoords.heights;
        changeExpandedAttr(row, false);
        var childRowKeys = tree_1.getChildRowKeys(row);
        childRowKeys.forEach(function (childRowKey) {
            var childRow = data_2.findRowByRowKey(data, column, id, childRowKey);
            if (!childRow) {
                return;
            }
            changeHiddenAttr(childRow, true);
            if (!tree_1.isLeaf(childRow)) {
                if (recursive) {
                    collapse(store, childRow, recursive);
                }
                else {
                    tree_1.getDescendantRows(store, childRowKey).forEach(function (_a) {
                        var descendantRowKey = _a.rowKey;
                        var index = data_2.findIndexByRowKey(data, column, id, descendantRowKey);
                        changeHiddenAttr(data.filteredRawData[index], true);
                        heights[index] = 0;
                    });
                }
            }
            var index = data_2.findIndexByRowKey(data, column, id, childRowKey);
            heights[index] = 0;
        });
        observable_1.notify(rowCoords, 'heights');
    }
    function setCheckedState(row, state) {
        if (row && data_3.isUpdatableRowAttr('checked', row._attributes.checkDisabled)) {
            row._attributes.checked = state;
        }
    }
    function changeAncestorRowsCheckedState(store, rowKey) {
        var data = store.data, column = store.column, id = store.id;
        var rawData = data.rawData;
        var row = data_2.findRowByRowKey(data, column, id, rowKey);
        if (row) {
            tree_1.traverseAncestorRows(rawData, row, function (parentRow) {
                var childRowKeys = tree_1.getChildRowKeys(parentRow);
                var checkedChildRows = childRowKeys.filter(function (childRowKey) {
                    var childRow = data_2.findRowByRowKey(data, column, id, childRowKey);
                    return !!childRow && childRow._attributes.checked;
                });
                var checked = childRowKeys.length === checkedChildRows.length;
                setCheckedState(parentRow, checked);
            });
        }
    }
    function changeDescendantRowsCheckedState(store, rowKey, state) {
        var data = store.data, column = store.column, id = store.id;
        var rawData = data.rawData;
        var row = data_2.findRowByRowKey(data, column, id, rowKey);
        if (row) {
            tree_1.traverseDescendantRows(rawData, row, function (childRow) {
                setCheckedState(childRow, state);
            });
        }
    }
    function removeChildRowKey(row, rowKey) {
        var tree = row._attributes.tree;
        if (tree) {
            common_1.removeArrayItem(rowKey, tree.childRowKeys);
            if (row._children) {
                var index = common_1.findPropIndex('rowKey', rowKey, row._children);
                if (index !== -1) {
                    row._children.splice(index, 1);
                }
            }
            if (!tree.childRowKeys.length) {
                row._leaf = true;
            }
            observable_1.notify(tree, 'childRowKeys');
        }
    }
    function removeExpandedAttr(row) {
        var tree = row._attributes.tree;
        if (tree) {
            tree.expanded = false;
        }
    }
    exports.removeExpandedAttr = removeExpandedAttr;
    function expandByRowKey(store, rowKey, recursive) {
        var data = store.data, column = store.column, id = store.id;
        var row = data_2.findRowByRowKey(data, column, id, rowKey);
        if (row) {
            expand(store, row, recursive);
        }
    }
    exports.expandByRowKey = expandByRowKey;
    function expandAll(store) {
        store.data.rawData.forEach(function (row) {
            if (tree_1.isRootChildRow(row) && !tree_1.isLeaf(row)) {
                expand(store, row, true);
            }
        });
    }
    exports.expandAll = expandAll;
    function collapseByRowKey(store, rowKey, recursive) {
        var data = store.data, column = store.column, id = store.id;
        var row = data_2.findRowByRowKey(data, column, id, rowKey);
        if (row) {
            collapse(store, row, recursive);
        }
    }
    exports.collapseByRowKey = collapseByRowKey;
    function collapseAll(store) {
        store.data.rawData.forEach(function (row) {
            if (tree_1.isRootChildRow(row) && !tree_1.isLeaf(row)) {
                collapse(store, row, true);
            }
        });
    }
    exports.collapseAll = collapseAll;
    function changeTreeRowsCheckedState(store, rowKey, state) {
        var _a = store.column, treeColumnName = _a.treeColumnName, treeCascadingCheckbox = _a.treeCascadingCheckbox;
        if (treeColumnName && treeCascadingCheckbox) {
            changeDescendantRowsCheckedState(store, rowKey, state);
            changeAncestorRowsCheckedState(store, rowKey);
        }
    }
    exports.changeTreeRowsCheckedState = changeTreeRowsCheckedState;
    // @TODO: consider tree disabled state with cascading
    function appendTreeRow(store, row, options) {
        var data = store.data, column = store.column, rowCoords = store.rowCoords, dimension = store.dimension, id = store.id;
        var rawData = data.rawData, viewData = data.viewData;
        var heights = rowCoords.heights;
        var parentRowKey = options.parentRowKey, offset = options.offset, movingRow = options.movingRow;
        var parentRow = data_2.findRowByRowKey(data, column, id, parentRowKey);
        var startIdx = tree_1.getStartIndexToAppendRow(store, parentRow, offset);
        var rawRows = tree_2.flattenTreeData(id, [row], parentRow, column, {
            keyColumnName: column.keyColumnName,
            offset: offset,
        });
        var modificationType = movingRow ? 'UPDATE' : 'CREATE';
        lazyObservable_1.fillMissingColumnData(column, rawRows);
        var viewRows = rawRows.map(function (rawRow) { return data_1.createViewRow(id, rawRow, rawData, column); });
        common_1.silentSplice.apply(void 0, tslib_1.__spreadArrays([rawData, startIdx, 0], rawRows));
        common_1.silentSplice.apply(void 0, tslib_1.__spreadArrays([viewData, startIdx, 0], viewRows));
        var rowHeights = rawRows.map(function (rawRow) {
            changeTreeRowsCheckedState(store, rawRow.rowKey, rawRow._attributes.checked);
            instance_1.getDataManager(id).push(modificationType, rawRow, true);
            return data_2.getRowHeight(rawRow, dimension.rowHeight);
        });
        observable_1.notify(data, 'rawData', 'filteredRawData', 'viewData', 'filteredViewData');
        heights.splice.apply(heights, tslib_1.__spreadArrays([startIdx, 0], rowHeights));
        postUpdateAfterManipulation(store, startIdx, rawRows);
    }
    exports.appendTreeRow = appendTreeRow;
    // @TODO: consider tree disabled state with cascading
    function removeTreeRow(store, rowKey, movingRow) {
        var data = store.data, rowCoords = store.rowCoords, id = store.id, column = store.column;
        var rawData = data.rawData, viewData = data.viewData;
        var heights = rowCoords.heights;
        var parentRow = tree_1.getParentRow(store, rowKey);
        var modificationType = movingRow ? 'UPDATE' : 'DELETE';
        data_3.uncheck(store, rowKey);
        if (parentRow) {
            removeChildRowKey(parentRow, rowKey);
            if (!tree_1.getChildRowKeys(parentRow).length) {
                removeExpandedAttr(parentRow);
            }
        }
        var startIdx = data_2.findIndexByRowKey(data, column, id, rowKey);
        var deleteCount = tree_1.getDescendantRows(store, rowKey).length + 1;
        var removedRows = [];
        observable_1.batchObserver(function () {
            removedRows = rawData.splice(startIdx, deleteCount);
        });
        viewData.splice(startIdx, deleteCount);
        heights.splice(startIdx, deleteCount);
        for (var i = removedRows.length - 1; i >= 0; i -= 1) {
            instance_1.getDataManager(id).push(modificationType, removedRows[i]);
        }
        postUpdateAfterManipulation(store, startIdx, rawData);
    }
    exports.removeTreeRow = removeTreeRow;
    function postUpdateAfterManipulation(store, rowIndex, rows) {
        data_3.setLoadingState(store, data_2.getLoadingState(store.data.rawData));
        data_3.updateRowNumber(store, rowIndex);
        data_3.setCheckedAllRows(store);
        column_2.setAutoResizingColumnWidths(store, rows);
    }
    function moveTreeRow(store, rowKey, targetIndex, options) {
        var data = store.data, column = store.column, id = store.id;
        var rawData = data.rawData;
        var targetRow = rawData[targetIndex];
        if (!targetRow || data_2.isSorted(data) || data_2.isFiltered(data)) {
            return;
        }
        var currentIndex = data_2.findIndexByRowKey(data, column, id, rowKey, false);
        var row = rawData[currentIndex];
        if (currentIndex === -1 ||
            currentIndex === targetIndex ||
            row._attributes.disabled ||
            (targetRow._attributes.disabled && options.appended)) {
            return;
        }
        var childRows = tree_1.getDescendantRows(store, rowKey);
        var minIndex = Math.min(currentIndex, targetIndex);
        var moveToChild = common_1.some(function (childRow) { return childRow.rowKey === targetRow.rowKey; }, childRows);
        if (!moveToChild) {
            removeTreeRow(store, rowKey, true);
            var originRow = observable_1.getOriginObject(row);
            instance_1.getDataManager(id).push('UPDATE', targetRow, true);
            instance_1.getDataManager(id).push('UPDATE', row, true);
            if (options.appended) {
                appendTreeRow(store, originRow, { parentRowKey: targetRow.rowKey, movingRow: true });
            }
            else {
                var parentRowKey = targetRow._attributes.tree.parentRowKey;
                var parentIndex = data_2.findIndexByRowKey(data, column, id, parentRowKey);
                var offset = targetIndex > currentIndex ? targetIndex - (childRows.length + 1) : targetIndex;
                // calculate the offset based on parent row
                if (parentIndex !== -1) {
                    var parentRow = rawData[parentIndex];
                    offset = parentRow._attributes.tree.childRowKeys.indexOf(targetRow.rowKey);
                }
                // to resolve the index for moving last index
                if (options.moveToLast) {
                    parentRowKey = null;
                    offset = rawData.length;
                }
                appendTreeRow(store, originRow, { parentRowKey: parentRowKey, offset: offset, movingRow: true });
            }
            postUpdateAfterManipulation(store, minIndex);
        }
    }
    exports.moveTreeRow = moveTreeRow;


    /***/ }),
    /* 31 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setColumnWidthsByText = exports.setAutoResizingColumnWidths = exports.changeColumnHeadersByName = exports.setComplexColumnHeaders = exports.showColumn = exports.hideColumn = exports.resetColumnWidths = exports.setColumns = exports.setColumnWidth = exports.setFrozenColumnCount = void 0;
    var tslib_1 = __webpack_require__(1);
    var column_1 = __webpack_require__(32);
    var data_1 = __webpack_require__(15);
    var gridEvent_1 = tslib_1.__importDefault(__webpack_require__(9));
    var eventBus_1 = __webpack_require__(8);
    var focus_1 = __webpack_require__(18);
    var observable_1 = __webpack_require__(5);
    var sort_1 = __webpack_require__(28);
    var filter_1 = __webpack_require__(34);
    var selection_1 = __webpack_require__(16);
    var common_1 = __webpack_require__(0);
    var viewport_1 = __webpack_require__(23);
    var dom_1 = __webpack_require__(2);
    var data_2 = __webpack_require__(26);
    var tree_1 = __webpack_require__(21);
    var tree_2 = __webpack_require__(22);
    var constant_1 = __webpack_require__(14);
    function setFrozenColumnCount(_a, count) {
        var column = _a.column;
        column.frozenCount = count;
    }
    exports.setFrozenColumnCount = setFrozenColumnCount;
    function getCellWidthToBeResized(columns, range, resizeAmount, startWidths) {
        var widths = [];
        var startIdx = range[0], endIdx = range[1];
        var rangeLength = endIdx - startIdx + 1;
        var delta = resizeAmount / rangeLength;
        for (var idx = 0; idx < rangeLength; idx += 1) {
            var columnIdx = startIdx + idx;
            var minWidth = columns[columnIdx].minWidth;
            var width = Math.max(startWidths[idx] + delta, minWidth);
            widths.push(width);
        }
        return widths;
    }
    function setColumnWidth(_a, side, range, resizeAmount, startWidths) {
        var column = _a.column, id = _a.id;
        var eventBus = eventBus_1.getEventBus(id);
        var columns = column.visibleColumnsBySideWithRowHeader[side];
        var startIdx = range[0], endIdx = range[1];
        var resizedColumns = [];
        var widths = getCellWidthToBeResized(columns, range, resizeAmount, startWidths);
        for (var idx = startIdx; idx <= endIdx; idx += 1) {
            resizedColumns.push({
                columnName: columns[idx].name,
                width: widths[idx - startIdx],
            });
        }
        var gridEvent = new gridEvent_1.default({ resizedColumns: resizedColumns });
        /**
         * Occurs when column is resized
         * @event Grid#columnResize
         * @property {Array} resizedColumns - state about resized columns
         * @property {number} resizedColumns.columnName - columnName of the target cell
         * @property {number} resizedColumns.width - width of the resized column
         * @property {Grid} instance - Current grid instance
         */
        eventBus.trigger('columnResize', gridEvent);
        if (!gridEvent.isStopped()) {
            widths.forEach(function (width, idx) {
                var columnIdx = startIdx + idx;
                var item = columns[columnIdx];
                item.baseWidth = width;
                item.fixedWidth = true;
            });
        }
    }
    exports.setColumnWidth = setColumnWidth;
    function setColumns(store, optColumns) {
        var column = store.column, data = store.data, id = store.id;
        var _a = column.dataForColumnCreation, columnOptions = _a.columnOptions, copyOptions = _a.copyOptions, treeColumnOptions = _a.treeColumnOptions, rowHeaders = _a.rowHeaders;
        var relationColumns = optColumns.reduce(function (acc, _a) {
            var _b = _a.relations, relations = _b === void 0 ? [] : _b;
            return acc.concat(column_1.createRelationColumns(relations)).filter(function (columnName, index) {
                var foundIndex = acc.indexOf(columnName);
                return foundIndex === -1 || foundIndex === index;
            });
        }, []);
        var columnInfos = optColumns.map(function (optColumn) {
            return column_1.createColumn(optColumn, columnOptions, relationColumns, copyOptions, treeColumnOptions, column.columnHeaderInfo, !!optColumn.disabled);
        });
        var dataCreationKey = data_1.generateDataCreationKey();
        viewport_1.initScrollPosition(store);
        focus_1.initFocus(store);
        selection_1.initSelection(store);
        column.allColumns = tslib_1.__spreadArrays(rowHeaders, columnInfos);
        data.viewData.forEach(function (viewRow) {
            if (Array.isArray(viewRow.__unobserveFns__)) {
                viewRow.__unobserveFns__.forEach(function (fn) { return fn(); });
            }
        });
        data.rawData = data.rawData.map(function (row) {
            var newRow = tslib_1.__assign(tslib_1.__assign({}, column.emptyRow), row);
            newRow.uniqueKey = dataCreationKey + "-" + row.rowKey;
            return newRow;
        });
        data.viewData = data.rawData.map(function (row) {
            return observable_1.isObservable(row)
                ? data_1.createViewRow(id, row, data.rawData, column)
                : { rowKey: row.rowKey, sortKey: row.sortKey, uniqueKey: row.uniqueKey };
        });
        filter_1.initFilter(store);
        sort_1.unsort(store);
        setColumnWidthsByText(store);
    }
    exports.setColumns = setColumns;
    function resetColumnWidths(_a, widths) {
        var column = _a.column;
        column.visibleColumns.forEach(function (columnInfo, idx) {
            columnInfo.baseWidth = widths[idx];
            columnInfo.autoResizing = false;
        });
    }
    exports.resetColumnWidths = resetColumnWidths;
    function setColumnsHiddenValue(column, columnName, hidden) {
        var allColumnMap = column.allColumnMap, complexColumnHeaders = column.complexColumnHeaders;
        if (complexColumnHeaders.length) {
            var complexColumn = common_1.findProp('name', columnName, complexColumnHeaders);
            if (complexColumn) {
                complexColumn.childNames.forEach(function (childName) {
                    allColumnMap[childName].hidden = hidden;
                });
                return;
            }
        }
        allColumnMap[columnName].hidden = hidden;
    }
    function hideColumn(store, columnName) {
        var column = store.column, focus = store.focus;
        if (focus.columnName === columnName) {
            focus_1.initFocus(store);
        }
        selection_1.initSelection(store);
        filter_1.unfilter(store, columnName);
        sort_1.unsort(store, columnName);
        setColumnsHiddenValue(column, columnName, true);
    }
    exports.hideColumn = hideColumn;
    function showColumn(_a, columnName) {
        var column = _a.column;
        setColumnsHiddenValue(column, columnName, false);
    }
    exports.showColumn = showColumn;
    function setComplexColumnHeaders(store, complexColumnHeaders) {
        store.column.complexColumnHeaders = complexColumnHeaders;
    }
    exports.setComplexColumnHeaders = setComplexColumnHeaders;
    function changeColumnHeadersByName(_a, columnsMap) {
        var column = _a.column;
        var complexColumnHeaders = column.complexColumnHeaders, allColumnMap = column.allColumnMap;
        Object.keys(columnsMap).forEach(function (columnName) {
            var col = allColumnMap[columnName];
            if (col) {
                col.header = columnsMap[columnName];
            }
            if (complexColumnHeaders.length) {
                var complexCol = common_1.findProp('name', columnName, complexColumnHeaders);
                if (complexCol) {
                    complexCol.header = columnsMap[columnName];
                }
            }
        });
        observable_1.notify(column, 'allColumns');
    }
    exports.changeColumnHeadersByName = changeColumnHeadersByName;
    function setAutoResizingColumnWidths(store, targetData) {
        var autoResizingColumn = store.column.autoResizingColumn;
        var rawData = targetData || store.data.rawData;
        if (!rawData.length || !autoResizingColumn.length) {
            return;
        }
        data_2.initMaxTextMap();
        var maxTextMap = data_2.getMaxTextMap();
        rawData.forEach(function (row) {
            autoResizingColumn.forEach(function (columnInfo) {
                var name = columnInfo.name;
                var formattedValue = data_2.createFormattedValue(row, columnInfo);
                if (!maxTextMap[name] || maxTextMap[name].formattedValue.length < formattedValue.length) {
                    data_2.setMaxColumnTextMap(name, formattedValue, row);
                }
            });
        });
        setColumnWidthsByText(store);
    }
    exports.setAutoResizingColumnWidths = setAutoResizingColumnWidths;
    function setColumnWidthsByText(store) {
        var autoResizingColumn = store.column.autoResizingColumn;
        if (store.data.rawData.length && autoResizingColumn.length) {
            autoResizingColumn.forEach(function (_a) {
                var name = _a.name;
                setColumnWidthByText(store, name);
            });
        }
    }
    exports.setColumnWidthsByText = setColumnWidthsByText;
    function setColumnWidthByText(_a, columnName) {
        var data = _a.data, column = _a.column;
        var allColumnMap = column.allColumnMap, treeColumnName = column.treeColumnName, treeIcon = column.treeIcon;
        var maxTextMap = data_2.getMaxTextMap();
        var _b = maxTextMap[columnName], formattedValue = _b.formattedValue, row = _b.row;
        var width = dom_1.getTextWidth(formattedValue, dom_1.getComputedFontStyle(treeColumnName ? 'tree-wrapper-relative' : 'cell'));
        if (treeColumnName) {
            width +=
                tree_1.getTreeIndentWidth(tree_2.getDepth(data.rawData, row), treeIcon) + constant_1.TREE_CELL_HORIZONTAL_PADDING;
        }
        allColumnMap[columnName].baseWidth = Math.max(allColumnMap[columnName].minWidth, width);
        allColumnMap[columnName].fixedWidth = true;
    }


    /***/ }),
    /* 32 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.create = exports.createColumn = exports.createRelationColumns = exports.createColumnFilterOption = exports.validateRelationColumn = void 0;
    var tslib_1 = __webpack_require__(1);
    var observable_1 = __webpack_require__(5);
    var column_1 = __webpack_require__(10);
    var common_1 = __webpack_require__(0);
    var default_1 = __webpack_require__(63);
    var manager_1 = __webpack_require__(64);
    var rowHeaderInput_1 = __webpack_require__(71);
    var rowHeaderDraggable_1 = __webpack_require__(72);
    var DEF_ROW_HEADER_INPUT = '<input type="checkbox" name="_checked" />';
    var ROW_HEADER = 40;
    var COLUMN = 50;
    var rowHeadersMap = {
        rowNum: '_number',
        checkbox: '_checked',
        draggable: '_draggable',
    };
    function validateRelationColumn(columnInfos) {
        var checked = {};
        function checkCircularRelation(column, relations) {
            var name = column.name, relationMap = column.relationMap;
            relations.push(name);
            checked[name] = true;
            if (common_1.uniq(relations).length !== relations.length) {
                throw new Error('Cannot create circular reference between relation columns');
            }
            if (!common_1.isUndefined(relationMap)) {
                Object.keys(relationMap).forEach(function (targetName) {
                    var targetColumn = common_1.findProp('name', targetName, columnInfos);
                    // copy the 'relation' array to prevent to push all relation column into same array
                    checkCircularRelation(targetColumn, tslib_1.__spreadArrays(relations));
                });
            }
        }
        columnInfos.forEach(function (column) {
            if (!checked[column.name]) {
                checkCircularRelation(column, []);
            }
        });
    }
    exports.validateRelationColumn = validateRelationColumn;
    function createBuiltInEditorOptions(editorType, options) {
        var editInfo = manager_1.editorMap[editorType];
        return {
            type: editInfo[0],
            options: tslib_1.__assign(tslib_1.__assign({}, editInfo[1]), options),
        };
    }
    function createEditorOptions(editor) {
        if (common_1.isFunction(editor)) {
            return { type: editor };
        }
        if (common_1.isString(editor)) {
            return createBuiltInEditorOptions(editor);
        }
        if (common_1.isObject(editor)) {
            return common_1.isString(editor.type)
                ? createBuiltInEditorOptions(editor.type, editor.options)
                : editor;
        }
        return null;
    }
    function createRendererOptions(renderer) {
        if (common_1.isFunction(renderer)) {
            return { type: renderer };
        }
        if (common_1.isObject(renderer) && !common_1.isFunction(renderer) && common_1.isFunction(renderer.type)) {
            return renderer;
        }
        var defaultRenderer = { type: default_1.DefaultRenderer };
        return common_1.isObject(renderer)
            ? tslib_1.__assign(tslib_1.__assign({}, defaultRenderer), renderer)
            : defaultRenderer;
    }
    function createTreeInfo(treeColumnOptions, name) {
        if (treeColumnOptions && treeColumnOptions.name === name) {
            var _a = treeColumnOptions.useIcon, useIcon = _a === void 0 ? true : _a;
            return { tree: { useIcon: useIcon } };
        }
        return null;
    }
    function createRelationMap(relations) {
        var relationMap = {};
        relations.forEach(function (relation) {
            var editable = relation.editable, disabled = relation.disabled, listItems = relation.listItems, _a = relation.targetNames, targetNames = _a === void 0 ? [] : _a;
            targetNames.forEach(function (targetName) {
                relationMap[targetName] = {
                    editable: editable,
                    disabled: disabled,
                    listItems: listItems,
                };
            });
        });
        return relationMap;
    }
    function createColumnHeaderInfo(name, columnHeaderInfo) {
        var columnHeaders = columnHeaderInfo.columnHeaders, defaultAlign = columnHeaderInfo.align, defaultVAlign = columnHeaderInfo.valign;
        var columnOption = common_1.findProp('name', name, columnHeaders);
        var headerAlign = columnOption && columnOption.align ? columnOption.align : defaultAlign;
        var headerVAlign = columnOption && columnOption.valign ? columnOption.valign : defaultVAlign;
        var headerRenderer = columnOption && columnOption.renderer ? columnOption.renderer : null;
        return {
            headerAlign: headerAlign,
            headerVAlign: headerVAlign,
            headerRenderer: headerRenderer,
        };
    }
    function createColumnFilterOption(filter) {
        var defaultOption = {
            type: common_1.isObject(filter) ? filter.type : filter,
            showApplyBtn: false,
            showClearBtn: false,
        };
        if (common_1.isString(filter)) {
            if (filter === 'select') {
                return tslib_1.__assign(tslib_1.__assign({}, defaultOption), { operator: 'OR' });
            }
        }
        if (common_1.isObject(filter)) {
            return tslib_1.__assign(tslib_1.__assign({}, defaultOption), (filter.type === 'select'
                ? common_1.omit(filter, 'showApplyBtn', 'showClearBtn', 'operator', 'options')
                : filter));
        }
        return defaultOption;
    }
    exports.createColumnFilterOption = createColumnFilterOption;
    function createRelationColumns(relations) {
        var relationColumns = [];
        relations.forEach(function (relation) {
            var _a = relation.targetNames, targetNames = _a === void 0 ? [] : _a;
            targetNames.forEach(function (targetName) {
                relationColumns.push(targetName);
            });
        });
        return relationColumns;
    }
    exports.createRelationColumns = createRelationColumns;
    // eslint-disable-next-line max-params
    function createColumn(column, columnOptions, relationColumns, gridCopyOptions, treeColumnOptions, columnHeaderInfo, disabled) {
        var name = column.name, header = column.header, width = column.width, minWidth = column.minWidth, align = column.align, hidden = column.hidden, resizable = column.resizable, editor = column.editor, renderer = column.renderer, relations = column.relations, sortable = column.sortable, sortingType = column.sortingType, copyOptions = column.copyOptions, validation = column.validation, formatter = column.formatter, onBeforeChange = column.onBeforeChange, onAfterChange = column.onAfterChange, whiteSpace = column.whiteSpace, ellipsis = column.ellipsis, valign = column.valign, defaultValue = column.defaultValue, escapeHTML = column.escapeHTML, ignored = column.ignored, filter = column.filter, className = column.className, comparator = column.comparator;
        var editorOptions = createEditorOptions(editor);
        var rendererOptions = createRendererOptions(renderer);
        var filterOptions = filter ? createColumnFilterOption(filter) : null;
        var _a = createColumnHeaderInfo(name, columnHeaderInfo), headerAlign = _a.headerAlign, headerVAlign = _a.headerVAlign, headerRenderer = _a.headerRenderer;
        return observable_1.observable(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({ name: name,
            escapeHTML: escapeHTML, header: header || name, hidden: Boolean(hidden), resizable: common_1.isUndefined(resizable) ? Boolean(columnOptions.resizable) : Boolean(resizable), align: align || 'left', fixedWidth: typeof width === 'number', copyOptions: tslib_1.__assign(tslib_1.__assign({}, gridCopyOptions), copyOptions), baseWidth: (width === 'auto' ? 0 : width) || 0, minWidth: minWidth || columnOptions.minWidth || COLUMN, relationMap: createRelationMap(relations || []), related: common_1.includes(relationColumns, name), sortable: sortable, sortingType: sortingType || 'asc', validation: validation ? tslib_1.__assign({}, validation) : {}, renderer: rendererOptions, formatter: formatter,
            onBeforeChange: onBeforeChange,
            onAfterChange: onAfterChange,
            whiteSpace: whiteSpace,
            ellipsis: ellipsis, valign: valign || 'middle', defaultValue: defaultValue,
            ignored: ignored }, (!!editorOptions && { editor: editorOptions })), createTreeInfo(treeColumnOptions, name)), { headerAlign: headerAlign,
            headerVAlign: headerVAlign, filter: filterOptions, headerRenderer: headerRenderer,
            className: className,
            disabled: disabled,
            comparator: comparator, autoResizing: width === 'auto' }));
    }
    exports.createColumn = createColumn;
    function createRowHeader(data, columnHeaderInfo) {
        var rowHeader = common_1.isString(data)
            ? { name: rowHeadersMap[data] }
            : tslib_1.__assign({ name: rowHeadersMap[data.type] }, common_1.omit(data, 'type'));
        var name = rowHeader.name, header = rowHeader.header, align = rowHeader.align, valign = rowHeader.valign, renderer = rowHeader.renderer, width = rowHeader.width, minWidth = rowHeader.minWidth;
        var baseMinWith = common_1.isNumber(minWidth) ? minWidth : ROW_HEADER;
        var baseWidth = (width === 'auto' ? baseMinWith : width) || baseMinWith;
        var rowNumColumn = column_1.isRowNumColumn(name);
        var defaultHeader = rowNumColumn ? 'No. ' : DEF_ROW_HEADER_INPUT;
        var rendererOptions = renderer || {
            type: rowNumColumn ? default_1.DefaultRenderer : rowHeaderInput_1.RowHeaderInputRenderer,
        };
        var _a = createColumnHeaderInfo(name, columnHeaderInfo), headerAlign = _a.headerAlign, headerVAlign = _a.headerVAlign, headerRenderer = _a.headerRenderer;
        return observable_1.observable({
            name: name,
            header: header || defaultHeader,
            hidden: false,
            resizable: false,
            align: align || 'center',
            valign: valign || 'middle',
            renderer: createRendererOptions(rendererOptions),
            fixedWidth: true,
            baseWidth: baseWidth,
            escapeHTML: false,
            minWidth: baseMinWith,
            headerAlign: headerAlign,
            headerVAlign: headerVAlign,
            headerRenderer: headerRenderer,
            autoResizing: false,
        });
    }
    function createComplexColumnHeaders(column, columnHeaderInfo) {
        var header = column.header, name = column.name, childNames = column.childNames, renderer = column.renderer, hideChildHeaders = column.hideChildHeaders, _a = column.resizable, resizable = _a === void 0 ? false : _a;
        var headerAlign = column.headerAlign || columnHeaderInfo.align;
        var headerVAlign = column.headerVAlign || columnHeaderInfo.valign;
        return observable_1.observable({
            header: header,
            name: name,
            childNames: childNames,
            headerAlign: headerAlign,
            headerVAlign: headerVAlign,
            headerRenderer: renderer || null,
            hideChildHeaders: hideChildHeaders,
            resizable: resizable,
        });
    }
    function createDraggableRowHeader(rowHeaderColumn) {
        var renderer = common_1.isObject(rowHeaderColumn)
            ? rowHeaderColumn.renderer
            : { type: rowHeaderDraggable_1.RowHeaderDraggableRenderer };
        var draggableColumn = {
            name: '_draggable',
            header: '',
            hidden: false,
            resizable: false,
            align: 'center',
            valign: 'middle',
            renderer: createRendererOptions(renderer),
            baseWidth: ROW_HEADER,
            minWidth: ROW_HEADER,
            fixedWidth: true,
            autoResizing: false,
            escapeHTML: false,
            headerAlign: 'center',
            headerVAlign: 'middle',
        };
        return draggableColumn;
    }
    function create(_a) {
        var columns = _a.columns, columnOptions = _a.columnOptions, rowHeaders = _a.rowHeaders, copyOptions = _a.copyOptions, keyColumnName = _a.keyColumnName, treeColumnOptions = _a.treeColumnOptions, complexColumns = _a.complexColumns, align = _a.align, valign = _a.valign, columnHeaders = _a.columnHeaders, disabled = _a.disabled, draggable = _a.draggable;
        var relationColumns = columns.reduce(function (acc, _a) {
            var relations = _a.relations;
            acc = acc.concat(createRelationColumns(relations || []));
            return acc.filter(function (columnName, idx) { return acc.indexOf(columnName) === idx; });
        }, []);
        var columnHeaderInfo = { columnHeaders: columnHeaders, align: align, valign: valign };
        var rowHeaderInfos = [];
        if (draggable) {
            var rowHeaderColumn = null;
            var index = common_1.findIndex(function (rowHeader) {
                return (common_1.isString(rowHeader) && rowHeader === 'draggable') ||
                    rowHeader.type === 'draggable';
            }, rowHeaders);
            if (index !== -1) {
                rowHeaderColumn = rowHeaders.splice(index, 1)[0];
            }
            rowHeaderInfos.push(createDraggableRowHeader(rowHeaderColumn));
        }
        rowHeaders.forEach(function (rowHeader) {
            return rowHeaderInfos.push(createRowHeader(rowHeader, columnHeaderInfo));
        });
        var columnInfos = columns.map(function (column) {
            return createColumn(column, columnOptions, relationColumns, copyOptions, treeColumnOptions, columnHeaderInfo, !!(disabled || column.disabled));
        });
        validateRelationColumn(columnInfos);
        var allColumns = rowHeaderInfos.concat(columnInfos);
        var treeColumnName = treeColumnOptions.name, _b = treeColumnOptions.useIcon, treeIcon = _b === void 0 ? true : _b, _c = treeColumnOptions.useCascadingCheckbox, treeCascadingCheckbox = _c === void 0 ? true : _c;
        var complexColumnHeaders = complexColumns.map(function (column) {
            return createComplexColumnHeaders(column, columnHeaderInfo);
        });
        return observable_1.observable(tslib_1.__assign({ keyColumnName: keyColumnName,
            allColumns: allColumns,
            complexColumnHeaders: complexColumnHeaders,
            columnHeaderInfo: columnHeaderInfo, frozenCount: columnOptions.frozenCount || 0, dataForColumnCreation: {
                copyOptions: copyOptions,
                columnOptions: columnOptions,
                treeColumnOptions: treeColumnOptions,
                relationColumns: relationColumns,
                rowHeaders: rowHeaderInfos,
            }, get allColumnMap() {
                return common_1.createMapFromArray(this.allColumns, 'name');
            }, get rowHeaderCount() {
                return rowHeaderInfos.length;
            }, get visibleColumns() {
                return this.allColumns.slice(this.rowHeaderCount).filter(function (_a) {
                    var hidden = _a.hidden;
                    return !hidden;
                });
            },
            get visibleColumnsWithRowHeader() {
                return this.allColumns.filter(function (_a) {
                    var hidden = _a.hidden;
                    return !hidden;
                });
            }, get visibleColumnsBySide() {
                return {
                    L: this.visibleColumns.slice(0, this.frozenCount),
                    R: this.visibleColumns.slice(this.frozenCount),
                };
            }, get visibleColumnsBySideWithRowHeader() {
                var frozenLastIndex = this.rowHeaderCount + this.frozenCount;
                return {
                    L: this.visibleColumnsWithRowHeader.slice(0, frozenLastIndex),
                    R: this.visibleColumnsWithRowHeader.slice(frozenLastIndex),
                };
            },
            get defaultValues() {
                return this.allColumns
                    .filter(function (_a) {
                    var defaultValue = _a.defaultValue;
                    return Boolean(defaultValue);
                })
                    .map(function (_a) {
                    var name = _a.name, defaultValue = _a.defaultValue;
                    return ({ name: name, value: defaultValue });
                });
            }, get visibleFrozenCount() {
                return this.visibleColumnsBySideWithRowHeader.L.length;
            }, get validationColumns() {
                return this.allColumns.filter(function (_a) {
                    var validation = _a.validation;
                    return !common_1.isEmpty(validation);
                });
            },
            get ignoredColumns() {
                return this.allColumns.filter(function (_a) {
                    var ignored = _a.ignored;
                    return ignored;
                }).map(function (_a) {
                    var name = _a.name;
                    return name;
                });
            },
            get columnMapWithRelation() {
                // copy the array to prevent to affect allColumns property
                var copiedColumns = tslib_1.__spreadArrays(this.allColumns);
                copiedColumns.sort(function (columnA, columnB) {
                    var _a, _b;
                    var hasRelationMapA = !common_1.isEmpty(columnA.relationMap);
                    var hasRelationMapB = !common_1.isEmpty(columnB.relationMap);
                    if (hasRelationMapA && hasRelationMapB) {
                        if ((_a = columnA.relationMap) === null || _a === void 0 ? void 0 : _a[columnB.name]) {
                            return -1;
                        }
                        return ((_b = columnB.relationMap) === null || _b === void 0 ? void 0 : _b[columnA.name]) ? 1 : 0;
                    }
                    if (hasRelationMapA) {
                        return -1;
                    }
                    return hasRelationMapB ? 1 : 0;
                });
                return common_1.createMapFromArray(copiedColumns, 'name');
            }, get columnsWithoutRowHeader() {
                return this.allColumns.slice(this.rowHeaderCount);
            }, get emptyRow() {
                return this.columnsWithoutRowHeader.reduce(function (acc, _a) {
                    var _b;
                    var name = _a.name;
                    return (tslib_1.__assign(tslib_1.__assign({}, acc), (_b = {}, _b[name] = null, _b)));
                }, {});
            },
            get autoResizingColumn() {
                return this.columnsWithoutRowHeader.filter(function (_a) {
                    var autoResizing = _a.autoResizing;
                    return autoResizing;
                });
            } }, (treeColumnName && { treeColumnName: treeColumnName, treeIcon: treeIcon, treeCascadingCheckbox: treeCascadingCheckbox })));
    }
    exports.create = create;


    /***/ }),
    /* 33 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setLayerPosition = exports.getContainerElement = exports.setOpacity = void 0;
    var dom_1 = __webpack_require__(2);
    var INDENT = 5;
    var SCROLL_BAR_WIDTH = 17;
    var SCROLL_BAR_HEIGHT = 17;
    function setOpacity(el, opacity) {
        el.style.opacity = String(opacity);
    }
    exports.setOpacity = setOpacity;
    function getContainerElement(el) {
        return dom_1.findParent(el, 'container');
    }
    exports.getContainerElement = getContainerElement;
    function setLayerPosition(innerEl, layerEl, childEl, startBottom) {
        if (startBottom === void 0) { startBottom = false; }
        var containerRect = getContainerElement(innerEl).getBoundingClientRect();
        var innerHeight = window.innerHeight, innerWidth = window.innerWidth;
        var _a = innerEl.getBoundingClientRect(), left = _a.left, top = _a.top, bottom = _a.bottom;
        var _b = layerEl.getBoundingClientRect(), layerHeight = _b.height, layerWidth = _b.width;
        var layerTop = startBottom ? bottom : top + INDENT;
        var childElHeight = 0;
        var childElWidth = 0;
        if (childEl) {
            var _c = childEl.getBoundingClientRect(), height = _c.height, width = _c.width;
            childElHeight = height;
            childElWidth = width;
        }
        var totalHeight = layerHeight + childElHeight;
        var totalWidth = layerWidth || childElWidth;
        layerEl.style.top = (layerTop + totalHeight > innerHeight - SCROLL_BAR_WIDTH
            ? innerHeight - totalHeight - INDENT - SCROLL_BAR_WIDTH
            : layerTop) - containerRect.top + "px";
        layerEl.style.left = (left + totalWidth > innerWidth - SCROLL_BAR_HEIGHT
            ? innerWidth - totalWidth - INDENT - SCROLL_BAR_HEIGHT
            : left) - containerRect.left + "px";
    }
    exports.setLayerPosition = setLayerPosition;


    /***/ }),
    /* 34 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resetFilterState = exports.emitAfterFilter = exports.initFilter = exports.setFilter = exports.unfilter = exports.clearFilter = exports.updateFilters = exports.filter = exports.setActiveFilterState = exports.clearActiveFilterState = exports.applyActiveFilterState = exports.setActiveColumnAddress = exports.setActiveSelectFilterState = exports.toggleSelectAllCheckbox = exports.setActiveFilterOperator = void 0;
    var observable_1 = __webpack_require__(5);
    var common_1 = __webpack_require__(0);
    var filter_1 = __webpack_require__(29);
    var data_1 = __webpack_require__(6);
    var column_1 = __webpack_require__(32);
    var viewport_1 = __webpack_require__(23);
    var selection_1 = __webpack_require__(16);
    var focus_1 = __webpack_require__(18);
    var eventBus_1 = __webpack_require__(8);
    var column_2 = __webpack_require__(12);
    var data_2 = __webpack_require__(13);
    var summary_1 = __webpack_require__(24);
    var filter_2 = __webpack_require__(45);
    var pagination_1 = __webpack_require__(35);
    function initLayerAndScrollAfterFiltering(store) {
        var data = store.data;
        viewport_1.initScrollPosition(store);
        selection_1.initSelection(store);
        focus_1.initFocus(store);
        pagination_1.updatePageOptions(store, { totalCount: data.filteredRawData.length, page: 1 });
        data_2.updateHeights(store);
        data_2.setCheckedAllRows(store);
    }
    function setActiveFilterOperator(store, operator) {
        var column = store.column, filterLayerState = store.filterLayerState;
        var activeFilterState = filterLayerState.activeFilterState;
        var columnInfo = column.allColumnMap[activeFilterState.columnName];
        var columnFilterOption = columnInfo.filter;
        activeFilterState.operator = operator;
        if (!columnFilterOption.showApplyBtn) {
            columnFilterOption.operator = operator;
            applyActiveFilterState(store);
        }
    }
    exports.setActiveFilterOperator = setActiveFilterOperator;
    function toggleSelectAllCheckbox(store, checked) {
        var column = store.column, filterLayerState = store.filterLayerState, data = store.data;
        var activeFilterState = filterLayerState.activeFilterState;
        var columnName = activeFilterState.columnName;
        var columnInfo = column.allColumnMap[columnName];
        if (checked) {
            var columnData = data_1.getUniqColumnData(data.rawData, column, columnName);
            activeFilterState.state = columnData.map(function (value) { return ({ code: 'eq', value: value }); });
        }
        else {
            activeFilterState.state = [];
        }
        if (!columnInfo.filter.showApplyBtn) {
            applyActiveFilterState(store);
        }
    }
    exports.toggleSelectAllCheckbox = toggleSelectAllCheckbox;
    function setActiveSelectFilterState(store, value, checked) {
        var column = store.column, filterLayerState = store.filterLayerState;
        var activeFilterState = filterLayerState.activeFilterState;
        var columnName = filterLayerState.activeColumnAddress.name;
        var columnInfo = column.allColumnMap[columnName];
        if (checked) {
            activeFilterState.state.push({ value: value, code: 'eq' });
        }
        else {
            var index = common_1.findPropIndex('value', value, activeFilterState.state);
            activeFilterState.state.splice(index, 1);
        }
        if (!columnInfo.filter.showApplyBtn) {
            applyActiveFilterState(store);
        }
        else {
            observable_1.notify(filterLayerState, 'activeFilterState');
        }
    }
    exports.setActiveSelectFilterState = setActiveSelectFilterState;
    function setActiveColumnAddress(store, address) {
        var data = store.data, column = store.column, filterLayerState = store.filterLayerState;
        var filters = data.filters, filteredRawData = data.filteredRawData;
        filterLayerState.activeColumnAddress = address;
        if (!address) {
            filterLayerState.activeFilterState = null;
            return;
        }
        var columnName = address.name;
        var _a = column.allColumnMap[columnName].filter, type = _a.type, operator = _a.operator;
        var initialState = [];
        if (filters) {
            var prevFilter = common_1.findProp('columnName', columnName, filters);
            if (prevFilter) {
                initialState = prevFilter.state;
            }
        }
        if (type === 'select' && !initialState.length) {
            var columnData = data_1.getUniqColumnData(filteredRawData, column, columnName);
            initialState = columnData.map(function (value) { return ({ code: 'eq', value: value }); });
        }
        filterLayerState.activeFilterState = {
            columnName: columnName,
            type: type,
            operator: operator,
            state: initialState,
        };
    }
    exports.setActiveColumnAddress = setActiveColumnAddress;
    function applyActiveFilterState(store) {
        var filterLayerState = store.filterLayerState, data = store.data, column = store.column;
        var columnName = filterLayerState.activeColumnAddress.name;
        var _a = filterLayerState.activeFilterState, state = _a.state, type = _a.type, operator = _a.operator;
        var validState = state.filter(function (item) { return String(item.value).length; });
        if (type !== 'select' && !validState.length) {
            unfilter(store, columnName);
            return;
        }
        filterLayerState.activeFilterState.state = state;
        if (type === 'select') {
            var columnData = data_1.getUniqColumnData(data.rawData, column, columnName);
            if (columnData.length === state.length) {
                unfilter(store, columnName);
                return;
            }
        }
        var fns = state.map(function (_a) {
            var code = _a.code, value = _a.value;
            return filter_1.getFilterConditionFn(code, value, type);
        });
        filter(store, columnName, filter_1.composeConditionFn(fns, operator), state);
    }
    exports.applyActiveFilterState = applyActiveFilterState;
    function clearActiveFilterState(store) {
        var filterLayerState = store.filterLayerState;
        var activeFilterState = filterLayerState.activeFilterState;
        activeFilterState.state = [];
        unfilter(store, activeFilterState.columnName);
    }
    exports.clearActiveFilterState = clearActiveFilterState;
    function setActiveFilterState(store, state, filterIndex) {
        var column = store.column, filterLayerState = store.filterLayerState;
        var columnName = filterLayerState.activeColumnAddress.name;
        var columnInfo = column.allColumnMap[columnName];
        filterLayerState.activeFilterState.state[filterIndex] = state;
        if (!columnInfo.filter.showApplyBtn) {
            applyActiveFilterState(store);
        }
        else {
            observable_1.notify(filterLayerState, 'activeFilterState');
        }
    }
    exports.setActiveFilterState = setActiveFilterState;
    function filter(store, columnName, conditionFn, state) {
        var column = store.column;
        var columnFilterInfo = column.allColumnMap[columnName].filter;
        if (column_2.isComplexHeader(column, columnName) ||
            !columnFilterInfo ||
            column_2.isHiddenColumn(column, columnName)) {
            return;
        }
        var type = columnFilterInfo.type, operator = columnFilterInfo.operator;
        var nextColumnFilterState = { columnName: columnName, type: type, conditionFn: conditionFn, state: state, operator: operator };
        var gridEvent = emitBeforeFilter(store, 'beforeFilter', nextColumnFilterState);
        if (gridEvent.isStopped()) {
            return;
        }
        pagination_1.updatePageOptions(store, { page: 1 });
        updateFilters(store, columnName, nextColumnFilterState);
        initLayerAndScrollAfterFiltering(store);
        summary_1.updateAllSummaryValues(store);
        emitAfterFilter(store, 'afterFilter', columnName);
    }
    exports.filter = filter;
    function updateFilters(_a, columnName, nextColumnFilterState) {
        var data = _a.data;
        var filters = data.filters || [];
        var filterIndex = common_1.findPropIndex('columnName', columnName, filters);
        if (filterIndex >= 0) {
            filters.splice(filterIndex, 1, nextColumnFilterState);
        }
        else {
            data.filters = filters.concat(nextColumnFilterState);
        }
    }
    exports.updateFilters = updateFilters;
    function clearFilter(_a, columnName) {
        var data = _a.data;
        var filters = data.filters || [];
        var filterIndex = common_1.findPropIndex('columnName', columnName, filters);
        if (filterIndex >= 0) {
            if (filters.length === 1) {
                data.filters = null;
            }
            else {
                filters.splice(filterIndex, 1);
            }
        }
    }
    exports.clearFilter = clearFilter;
    function clearAll(store) {
        var gridEvent = emitBeforeFilter(store, 'beforeUnfilter', { columnName: null });
        if (gridEvent.isStopped()) {
            return;
        }
        initFilter(store);
        initLayerAndScrollAfterFiltering(store);
        summary_1.updateAllSummaryValues(store);
        emitAfterFilter(store, 'afterUnfilter', null);
    }
    function unfilter(store, columnName) {
        var data = store.data, column = store.column;
        var filters = data.filters;
        if (!columnName) {
            clearAll(store);
            return;
        }
        if (column_2.isComplexHeader(column, columnName) || column_2.isHiddenColumn(column, columnName)) {
            return;
        }
        if (filters) {
            var gridEvent = emitBeforeFilter(store, 'beforeUnfilter', { columnName: columnName });
            if (gridEvent.isStopped()) {
                return;
            }
            clearFilter(store, columnName);
            initLayerAndScrollAfterFiltering(store);
            summary_1.updateAllSummaryValues(store);
            emitAfterFilter(store, 'afterUnfilter', columnName);
        }
    }
    exports.unfilter = unfilter;
    function setFilter(store, columnName, filterOpt) {
        var column = store.column;
        var filterOptions = column_1.createColumnFilterOption(filterOpt);
        var index = common_1.findPropIndex('name', columnName, column.allColumns);
        if (index !== -1) {
            if (column.allColumns[index].filter) {
                unfilter(store, columnName);
            }
            column.allColumns[index].filter = filterOptions;
            observable_1.notify(column, 'allColumns');
        }
    }
    exports.setFilter = setFilter;
    function initFilter(store) {
        var filterLayerState = store.filterLayerState, data = store.data;
        filterLayerState.activeFilterState = null;
        filterLayerState.activeColumnAddress = null;
        data.filters = null;
    }
    exports.initFilter = initFilter;
    function emitBeforeFilter(store, eventType, eventParams) {
        var eventBus = eventBus_1.getEventBus(store.id);
        var gridEvent = filter_2.createFilterEvent(store, eventType, eventParams);
        eventBus.trigger(eventType, gridEvent);
        return gridEvent;
    }
    function emitAfterFilter(store, eventType, columnName) {
        var id = store.id;
        var eventBus = eventBus_1.getEventBus(id);
        // @TODO: `filter` event will be deprecated. This event is replaced with `afterFilter` event
        var eventTypes = (eventType === 'afterFilter'
            ? ['afterFilter', 'filter']
            : ['afterUnfilter']);
        eventTypes.forEach(function (type) {
            var gridEvent = filter_2.createFilterEvent(store, type, { columnName: columnName });
            eventBus.trigger(type, gridEvent);
        });
    }
    exports.emitAfterFilter = emitAfterFilter;
    function resetFilterState(store, filterState) {
        if (filterState) {
            var columnFilterState = filterState.columnFilterState, columnName = filterState.columnName;
            var columnFilterOption = store.column.allColumnMap[columnName].filter;
            if (columnFilterOption) {
                if (columnFilterState) {
                    var nextState = {
                        conditionFn: function () { return true; },
                        type: columnFilterOption.type,
                        state: columnFilterState,
                        columnName: columnName,
                        operator: columnFilterOption.operator,
                    };
                    updateFilters(store, columnName, nextState);
                }
                else {
                    clearFilter(store, columnName);
                }
            }
        }
        else {
            initFilter(store);
        }
    }
    exports.resetFilterState = resetFilterState;


    /***/ }),
    /* 35 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resetPageState = exports.updatePageWhenRemovingRow = exports.movePage = exports.updatePageOptions = void 0;
    var tslib_1 = __webpack_require__(1);
    var common_1 = __webpack_require__(0);
    var data_1 = __webpack_require__(6);
    var viewport_1 = __webpack_require__(23);
    var selection_1 = __webpack_require__(16);
    var focus_1 = __webpack_require__(18);
    var data_2 = __webpack_require__(13);
    var summary_1 = __webpack_require__(24);
    var observable_1 = __webpack_require__(5);
    function updatePageOptions(_a, pageOptions, forceUpdatePage) {
        var data = _a.data;
        if (forceUpdatePage === void 0) { forceUpdatePage = false; }
        var orgPageOptions = data.pageOptions;
        if (!common_1.isEmpty(orgPageOptions)) {
            // if infinite scrolling is applied, page number should be not reset to know the last loaded page
            if (!forceUpdatePage && data_1.isScrollPagination(data)) {
                delete pageOptions.page;
            }
            var newPageOptions = tslib_1.__assign(tslib_1.__assign({}, orgPageOptions), pageOptions);
            if (!common_1.shallowEqual(newPageOptions, orgPageOptions)) {
                data.pageOptions = newPageOptions;
            }
        }
    }
    exports.updatePageOptions = updatePageOptions;
    function movePage(store, page) {
        var data = store.data;
        viewport_1.initScrollPosition(store);
        data.pageOptions.page = page;
        observable_1.notify(data, 'pageOptions');
        data_2.updateHeights(store);
        selection_1.initSelection(store);
        focus_1.initFocus(store);
        data_2.setCheckedAllRows(store);
        summary_1.updateAllSummaryValues(store);
    }
    exports.movePage = movePage;
    function updatePageWhenRemovingRow(store, deletedCount) {
        var pageOptions = store.data.pageOptions;
        if (!common_1.isEmpty(pageOptions)) {
            var perPage = pageOptions.perPage, totalCount = pageOptions.totalCount, page = pageOptions.page;
            var modifiedLastPage = Math.floor((totalCount - deletedCount) / perPage);
            if ((totalCount - deletedCount) % perPage) {
                modifiedLastPage += 1;
            }
            updatePageOptions(store, {
                totalCount: totalCount - deletedCount,
                page: (modifiedLastPage < page ? modifiedLastPage : page) || 1,
            }, true);
        }
    }
    exports.updatePageWhenRemovingRow = updatePageWhenRemovingRow;
    function resetPageState(store, totalCount, pageState) {
        var pageOptions = pageState ? common_1.pruneObject(pageState) : { page: 1, totalCount: totalCount };
        updatePageOptions(store, pageOptions, true);
    }
    exports.resetPageState = resetPageState;


    /***/ }),
    /* 36 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ColGroup = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var hoc_1 = __webpack_require__(4);
    var dom_1 = __webpack_require__(2);
    var ColGroupComp = /** @class */ (function (_super) {
        tslib_1.__extends(ColGroupComp, _super);
        function ColGroupComp() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ColGroupComp.prototype.render = function (_a) {
            var _b;
            var columns = _a.columns, widths = _a.widths, borderWidth = _a.borderWidth;
            var attrs = (_b = {}, _b[dom_1.dataAttr.COLUMN_NAME] = name, _b);
            return (preact_1.h("colgroup", null, columns.map(function (_a, idx) {
                var name = _a.name;
                return (preact_1.h("col", tslib_1.__assign({ key: name }, attrs, { style: { width: widths[idx] + borderWidth } })));
            })));
        };
        return ColGroupComp;
    }(preact_1.Component));
    exports.ColGroup = hoc_1.connect(function (_a, _b) {
        var _c;
        var columnCoords = _a.columnCoords, viewport = _a.viewport, dimension = _a.dimension, column = _a.column;
        var side = _b.side, useViewport = _b.useViewport;
        return ({
            widths: useViewport && side === 'R'
                ? (_c = columnCoords.widths[side]).slice.apply(_c, viewport.colRange) : columnCoords.widths[side],
            columns: useViewport && side === 'R'
                ? viewport.columns
                : column.visibleColumnsBySideWithRowHeader[side],
            borderWidth: dimension.cellBorderWidth,
        });
    })(ColGroupComp);


    /***/ }),
    /* 37 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getText = exports.copyDataToRange = exports.getRangeToPaste = void 0;
    var tslib_1 = __webpack_require__(1);
    var common_1 = __webpack_require__(0);
    var data_1 = __webpack_require__(13);
    var observable_1 = __webpack_require__(5);
    function getCustomValue(customValue, value, rowAttrs, column) {
        return typeof customValue === 'function' ? customValue(value, rowAttrs, column) : customValue;
    }
    function getTextWithCopyOptionsApplied(valueMap, rawData, column) {
        var text = valueMap.value;
        var copyOptions = column.copyOptions, editor = column.editor;
        var editorOptions = editor && editor.options;
        // priority: customValue > useListItemText > useFormattedValue > original Data
        if (copyOptions) {
            if (copyOptions.customValue) {
                text = getCustomValue(copyOptions.customValue, valueMap.value, rawData, column);
            }
            else if (copyOptions.useListItemText && (editorOptions === null || editorOptions === void 0 ? void 0 : editorOptions.listItems)) {
                var listItems_1 = editorOptions.listItems;
                var value = valueMap.value;
                var valueList = [value];
                var result_1 = [];
                if (typeof value === 'string') {
                    valueList = value.split(',');
                }
                valueList.forEach(function (val) {
                    var listItem = common_1.find(function (item) { return item.value === val; }, listItems_1);
                    result_1.push(listItem ? listItem.text : val);
                });
                text = result_1.join(',');
            }
            else if (copyOptions.useFormattedValue) {
                text = "" + valueMap.formattedValue;
            }
        }
        if (typeof text === 'undefined' || text === null) {
            return '';
        }
        return String(text);
    }
    function getObservableList(store, filteredViewData, start, end) {
        var rowList = [];
        for (var i = start; i <= end; i += 1) {
            if (!observable_1.isObservable(filteredViewData[i].valueMap)) {
                data_1.makeObservable(store, i, true);
                if (i === end) {
                    observable_1.notify(store.data, 'rawData', 'filteredRawData', 'viewData', 'filteredViewData');
                }
            }
            rowList.push(filteredViewData[i]);
        }
        return rowList;
    }
    function getValuesToString(store, ranges) {
        var visibleColumnsWithRowHeader = store.column.visibleColumnsWithRowHeader, _a = store.data, filteredViewData = _a.filteredViewData, filteredRawData = _a.filteredRawData;
        var rowRange = ranges.rowRange, columnRange = ranges.columnRange;
        if (!rowRange || !columnRange) {
            return '';
        }
        var rowList = getObservableList.apply(void 0, tslib_1.__spreadArrays([store, filteredViewData], rowRange));
        var columnInRange = visibleColumnsWithRowHeader.slice(columnRange[0], columnRange[1] + 1);
        return rowList
            .map(function (_a) {
            var valueMap = _a.valueMap;
            return columnInRange
                .map(function (targetColumn) {
                return getTextWithCopyOptionsApplied(valueMap[targetColumn.name], filteredRawData, targetColumn);
            })
                .join('\t');
        })
            .join('\n');
    }
    function getRangeToPaste(store, pasteData) {
        var originalRange = store.selection.originalRange, _a = store.focus, totalColumnIndex = _a.totalColumnIndex, originalRowIndex = _a.originalRowIndex, visibleColumnsWithRowHeader = store.column.visibleColumnsWithRowHeader, viewData = store.data.viewData;
        var startRowIndex, startColumnIndex;
        if (originalRange) {
            startRowIndex = originalRange.row[0];
            startColumnIndex = originalRange.column[0];
        }
        else {
            startRowIndex = originalRowIndex;
            startColumnIndex = totalColumnIndex;
        }
        var endRowIndex = Math.min(pasteData.length + startRowIndex, viewData.length) - 1;
        var endColumnIndex = Math.min(pasteData[0].length + startColumnIndex, visibleColumnsWithRowHeader.length) - 1;
        return {
            row: [startRowIndex, endRowIndex],
            column: [startColumnIndex, endColumnIndex],
        };
    }
    exports.getRangeToPaste = getRangeToPaste;
    function copyDataToRange(range, pasteData) {
        var rowLength = range.row[1] - range.row[0] + 1;
        var colLength = range.column[1] - range.column[0] + 1;
        var dataRowLength = pasteData.length;
        var dataColLength = pasteData[0].length;
        var rowDupCount = Math.floor(rowLength / dataRowLength) - 1;
        var colDupCount = Math.floor(colLength / dataColLength) - 1;
        var result = tslib_1.__spreadArrays(pasteData);
        for (var i = 0; i < rowDupCount; i += 1) {
            pasteData.forEach(function (row) {
                result.push(row.slice(0));
            });
        }
        result.forEach(function (row) {
            var rowData = row.slice(0);
            for (var i = 0; i < colDupCount; i += 1) {
                row.push.apply(row, rowData);
            }
        });
        return result;
    }
    exports.copyDataToRange = copyDataToRange;
    function getText(store, ranges) {
        var _a, _b;
        var originalRange = store.selection.originalRange, _c = store.focus, originalRowIndex = _c.originalRowIndex, totalColumnIndex = _c.totalColumnIndex;
        var rowRange = (_a = ranges === null || ranges === void 0 ? void 0 : ranges.rowRange) !== null && _a !== void 0 ? _a : originalRange === null || originalRange === void 0 ? void 0 : originalRange.row;
        var columnRange = (_b = ranges === null || ranges === void 0 ? void 0 : ranges.columnRange) !== null && _b !== void 0 ? _b : originalRange === null || originalRange === void 0 ? void 0 : originalRange.column;
        // set focus index when there is no selection area
        if (common_1.isNil(rowRange) && !common_1.isNull(originalRowIndex)) {
            rowRange = [originalRowIndex, originalRowIndex];
        }
        if (common_1.isNil(columnRange) && !common_1.isNull(totalColumnIndex)) {
            columnRange = [totalColumnIndex, totalColumnIndex];
        }
        return getValuesToString(store, { rowRange: rowRange, columnRange: columnRange });
    }
    exports.getText = getText;


    /***/ }),
    /* 38 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createAjaxConfig = void 0;
    var tslib_1 = __webpack_require__(1);
    var common_1 = __webpack_require__(0);
    function createAjaxConfig(target) {
        var configKeys = [
            'contentType',
            'withCredentials',
            'mimeType',
            'headers',
            'serializer',
        ];
        return common_1.pick.apply(void 0, tslib_1.__spreadArrays([target], configKeys));
    }
    exports.createAjaxConfig = createAjaxConfig;


    /***/ }),
    /* 39 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getListItems = void 0;
    var common_1 = __webpack_require__(0);
    function getListItems(props) {
        var _a = props.columnInfo.editor.options, listItems = _a.listItems, relationListItemMap = _a.relationListItemMap;
        if (!common_1.isEmpty(relationListItemMap) && Array.isArray(relationListItemMap[props.rowKey])) {
            return relationListItemMap[props.rowKey];
        }
        return listItems;
    }
    exports.getListItems = getListItems;


    /***/ }),
    /* 40 */
    /***/ (function(module, exports) {

    module.exports = __WEBPACK_EXTERNAL_MODULE__40__;

    /***/ }),
    /* 41 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEditingCell = exports.isFocusedCell = void 0;
    function isFocusedCell(focus, rowKey, columnName) {
        return rowKey === focus.rowKey && columnName === focus.columnName;
    }
    exports.isFocusedCell = isFocusedCell;
    function isEditingCell(focus, rowKey, columnName) {
        var editingAddress = focus.editingAddress;
        return !!(editingAddress &&
            editingAddress.rowKey === rowKey &&
            editingAddress.columnName === columnName);
    }
    exports.isEditingCell = isEditingCell;


    /***/ }),
    /* 42 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createSortEvent = exports.isCancelSort = void 0;
    var tslib_1 = __webpack_require__(1);
    var gridEvent_1 = tslib_1.__importDefault(__webpack_require__(9));
    var common_1 = __webpack_require__(0);
    function isCancelSort(_a, columnName, ascending, cancelable) {
        var data = _a.data, column = _a.column;
        var index = common_1.findPropIndex('columnName', columnName, data.sortState.columns);
        var defaultAscending = column.allColumnMap[columnName].sortingType === 'asc';
        return cancelable && ascending === defaultAscending && index !== -1;
    }
    exports.isCancelSort = isCancelSort;
    function createSortEvent(eventType, eventParams) {
        var columnName = eventParams.columnName, multiple = eventParams.multiple, ascending = eventParams.ascending;
        var sortState = common_1.deepCopy(eventParams.sortState);
        var props = {};
        /* eslint-disable no-fallthrough */
        switch (eventType) {
            /**
             * Occurs before sorting.
             * @event Grid#beforeSort
             * @property {Object} sortState - Current sort state
             * @property {string} columnName - Target column name
             * @property {boolean} ascending - Next ascending state of a column.
             * If the event is not stopped this ascending state will be applied to grid.
             * @property {boolean} multiple - Whether to use multiple sort
             * @property {Grid} instance - Current grid instance
             */
            case 'beforeSort':
                props = {
                    sortState: sortState,
                    columnName: columnName,
                    ascending: ascending,
                    multiple: multiple,
                };
                break;
            /**
             * Occurs before unsorting.
             * @event Grid#beforeUnsort
             * @property {Object} sortState - Current sort state of the grid
             * @property {string} columnName - Target column name
             * @property {boolean} multiple - Whether to use multiple sort
             * @property {Grid} instance - Current grid instance
             */
            case 'beforeUnsort':
                props = {
                    sortState: sortState,
                    columnName: columnName,
                    multiple: multiple,
                };
                break;
            /**
             * Occurs after sorting.
             * @deprecated
             * @event Grid#sort
             * @property {Object} sortState - sort state
             * @property {string} columnName - Target column name
             * @property {Grid} instance - Current grid instance
             */
            case 'sort':
            /**
             * Occurs after sorting.
             * @event Grid#afterSort
             * @property {Object} sortState - sort state
             * @property {string} columnName - Target column name
             * @property {Grid} instance - Current grid instance
             */
            case 'afterSort':
            /**
             * Occurs after unsorting.
             * @event Grid#afterUnsort
             * @property {Object} sortState - sort state
             * @property {string} columnName - Target column name
             * @property {Grid} instance - Current grid instance
             */
            case 'afterUnsort':
                props = {
                    sortState: sortState,
                    columnName: columnName,
                };
                break;
        }
        /* eslint-disable no-fallthrough */
        return new gridEvent_1.default(props);
    }
    exports.createSortEvent = createSortEvent;


    /***/ }),
    /* 43 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extractSummaryColumnContent = exports.castToSummaryColumnContent = exports.calculate = exports.getSummaryValue = void 0;
    var tslib_1 = __webpack_require__(1);
    function assignFilteredSummaryValue(summaryValue) {
        var sum = summaryValue.sum, min = summaryValue.min, max = summaryValue.max, avg = summaryValue.avg, cnt = summaryValue.cnt;
        return {
            filtered: {
                sum: sum,
                min: min,
                max: max,
                avg: avg,
                cnt: cnt,
            },
        };
    }
    function getSummaryValue(columnName, rawData, filteredRawData) {
        var columnValues = rawData.map(function (row) { return row[columnName]; });
        var summaryValue = calculate(columnValues);
        if (rawData.length === filteredRawData.length) {
            return tslib_1.__assign(tslib_1.__assign({}, summaryValue), assignFilteredSummaryValue(summaryValue));
        }
        var filteredColumnValues = filteredRawData.map(function (row) { return row[columnName]; });
        return tslib_1.__assign(tslib_1.__assign({}, summaryValue), assignFilteredSummaryValue(calculate(filteredColumnValues)));
    }
    exports.getSummaryValue = getSummaryValue;
    function calculate(values) {
        var cnt = values.length;
        var min = Number.MAX_VALUE;
        var max = Number.MIN_VALUE;
        var sum = 0;
        var avg = 0;
        for (var i = 0; i < cnt; i += 1) {
            var value = Number(values[i]);
            if (isNaN(value)) {
                value = 0;
            }
            sum += value;
            if (min > value) {
                min = value;
            }
            if (max < value) {
                max = value;
            }
        }
        if (!cnt) {
            max = min = avg = 0;
        }
        else {
            avg = sum / cnt;
        }
        return { sum: sum, min: min, max: max, avg: avg, cnt: cnt };
    }
    exports.calculate = calculate;
    function castToSummaryColumnContent(content) {
        if (!content) {
            return null;
        }
        return typeof content === 'string'
            ? { template: content, useAutoSummary: false }
            : {
                template: content.template,
                useAutoSummary: typeof content.useAutoSummary === 'undefined' ? true : content.useAutoSummary,
            };
    }
    exports.castToSummaryColumnContent = castToSummaryColumnContent;
    function extractSummaryColumnContent(content, defaultContent) {
        var summaryColumnContent = null;
        if (content) {
            summaryColumnContent = content;
        }
        else if (!content && defaultContent) {
            summaryColumnContent = defaultContent;
        }
        return summaryColumnContent;
    }
    exports.extractSummaryColumnContent = extractSummaryColumnContent;


    /***/ }),
    /* 44 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.create = exports.createSummaryValue = void 0;
    var observable_1 = __webpack_require__(5);
    var summary_1 = __webpack_require__(43);
    var common_1 = __webpack_require__(0);
    function createSummaryValue(content, columnName, data) {
        if (content && content.useAutoSummary) {
            return summary_1.getSummaryValue(columnName, data.rawData, data.filteredRawData);
        }
        return {
            sum: 0,
            min: 0,
            max: 0,
            avg: 0,
            cnt: 0,
            filtered: {
                sum: 0,
                min: 0,
                max: 0,
                avg: 0,
                cnt: 0,
            },
        };
    }
    exports.createSummaryValue = createSummaryValue;
    function create(_a) {
        var column = _a.column, data = _a.data, summary = _a.summary;
        var summaryColumnContents = {};
        var summaryValues = {};
        var orgColumnContent = summary.columnContent, defaultContent = summary.defaultContent;
        if (Object.keys(summary).length) {
            var castedDefaultContent_1 = summary_1.castToSummaryColumnContent(defaultContent || '');
            var columnContent_1 = orgColumnContent || {};
            var summaryColumns = Object.keys(columnContent_1);
            var filteredSummaryColumns = summaryColumns.filter(function (columnName) { return !common_1.someProp('name', columnName, column.allColumns); });
            var targetColumns = castedDefaultContent_1
                ? column.allColumns.map(function (_a) {
                    var name = _a.name;
                    return name;
                }).concat(filteredSummaryColumns)
                : summaryColumns;
            targetColumns.forEach(function (columnName) {
                var castedColumnContent = summary_1.castToSummaryColumnContent(columnContent_1[columnName]);
                var content = summary_1.extractSummaryColumnContent(castedColumnContent, castedDefaultContent_1);
                summaryColumnContents[columnName] = content;
                summaryValues[columnName] = createSummaryValue(content, columnName, data);
            });
        }
        return observable_1.observable({ summaryColumnContents: summaryColumnContents, summaryValues: summaryValues, defaultContent: defaultContent });
    }
    exports.create = create;


    /***/ }),
    /* 45 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFilterEvent = exports.getFilterState = void 0;
    var tslib_1 = __webpack_require__(1);
    var common_1 = __webpack_require__(0);
    var gridEvent_1 = tslib_1.__importDefault(__webpack_require__(9));
    function getFilterState(store) {
        var filters = store.data.filters;
        if (filters) {
            common_1.deepCopyArray(filters);
        }
        return filters;
    }
    exports.getFilterState = getFilterState;
    function createFilterEvent(_a, eventType, eventParams) {
        var data = _a.data;
        var columnName = eventParams.columnName, type = eventParams.type, conditionFn = eventParams.conditionFn, state = eventParams.state, operator = eventParams.operator;
        var filterState = data.filters ? common_1.deepCopyArray(data.filters) : null;
        var props = {};
        /* eslint-disable no-fallthrough */
        switch (eventType) {
            /**
             * Occurs before filtering.
             * @event Grid#beforeFilter
             * @property {Grid} instance - Current grid instance
             * @property {Object} filterState - Current filter state
             * @property {string} columnName - Target column name
             * @property {string} type - Column Filter type
             * @property {string} operator - Column filter Operator('AND' | 'OR')
             * @property {function} conditionFn - Original function to filter the data in grid.
             * @property {Array} columnFilterState - Next filter state of column which triggers the event.
             * If the event is not stopped this state will be applied to grid.
             */
            case 'beforeFilter':
                props = {
                    filterState: filterState,
                    columnFilterState: common_1.deepCopyArray(state),
                    conditionFn: conditionFn,
                    type: type,
                    columnName: columnName,
                    operator: operator,
                };
                break;
            /**
             *Occursbeforeunfiltering
             *@eventGrid#beforeUnfilter
             *@property{Grid}instance-Currentgridinstance
             *@property{string} columnName - Target column name
             *@property{Object} filterState -Current filter state
             */
            case 'beforeUnfilter':
            /**
             *Occursafterfiltering
             * @deprecated
             *@eventGrid#filter
             *@property{Grid}instance-Currentgridinstance
             *@property{string} columnName - Target column name
             *@property{Object} filterState -Current filter state
             */
            case 'filter':
            /**
             *Occursafterfiltering
             *@eventGrid#afterFilter
             *@property{Grid}instance-Currentgridinstance
             *@property{string} columnName - Target column name
             *@property{Object} filterState -Current filter state
             */
            case 'afterFilter':
            /**
             *Occursafterunfiltering
             *@eventGrid#afterUnfilter
             *@property{Grid}instance-Currentgridinstance
             *@property{string} columnName - Target column name
             *@property{Object} filterState -Current filter state
             */
            case 'afterUnfilter':
                props = {
                    filterState: filterState,
                    columnName: columnName,
                };
                break;
        }
        /* eslint-disable no-fallthrough */
        return new gridEvent_1.default(props);
    }
    exports.createFilterEvent = createFilterEvent;


    /***/ }),
    /* 46 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setAutoBodyHeight = exports.refreshLayout = exports.setHeaderHeight = exports.setOffsetLeft = exports.setOffsetTop = exports.setBodyHeight = exports.setHeight = exports.setWidth = void 0;
    function setWidth(_a, width, autoWidth) {
        var dimension = _a.dimension;
        dimension.autoWidth = autoWidth;
        dimension.width = width;
    }
    exports.setWidth = setWidth;
    function setHeight(_a, height) {
        var dimension = _a.dimension;
        var headerHeight = dimension.headerHeight, summaryHeight = dimension.summaryHeight, tableBorderWidth = dimension.tableBorderWidth;
        dimension.bodyHeight = height - headerHeight - summaryHeight - tableBorderWidth;
    }
    exports.setHeight = setHeight;
    function setBodyHeight(_a, bodyHeight) {
        var dimension = _a.dimension;
        dimension.autoHeight = false;
        dimension.bodyHeight = Math.max(bodyHeight, dimension.minBodyHeight);
    }
    exports.setBodyHeight = setBodyHeight;
    function setOffsetTop(store, offsetTop) {
        store.dimension.offsetTop = offsetTop;
    }
    exports.setOffsetTop = setOffsetTop;
    function setOffsetLeft(store, offsetLeft) {
        store.dimension.offsetLeft = offsetLeft;
    }
    exports.setOffsetLeft = setOffsetLeft;
    function setHeaderHeight(store, height) {
        store.dimension.headerHeight = height;
    }
    exports.setHeaderHeight = setHeaderHeight;
    function refreshLayout(store, containerEl, parentEl) {
        var dimension = store.dimension;
        var autoWidth = dimension.autoWidth, fitToParentHeight = dimension.fitToParentHeight;
        var clientHeight = containerEl.clientHeight, clientWidth = containerEl.clientWidth, scrollTop = containerEl.scrollTop, scrollLeft = containerEl.scrollLeft;
        var _a = containerEl.getBoundingClientRect(), top = _a.top, left = _a.left;
        setOffsetTop(store, top + scrollTop);
        setOffsetLeft(store, left + scrollLeft);
        setWidth(store, clientWidth, autoWidth);
        if (fitToParentHeight && parentEl && parentEl.clientHeight !== clientHeight) {
            setHeight(store, parentEl.clientHeight);
        }
    }
    exports.refreshLayout = refreshLayout;
    function setAutoBodyHeight(_a) {
        var dimension = _a.dimension, rowCoords = _a.rowCoords;
        var totalRowHeight = rowCoords.totalRowHeight;
        var autoHeight = dimension.autoHeight, scrollXHeight = dimension.scrollXHeight, minBodyHeight = dimension.minBodyHeight;
        if (autoHeight) {
            dimension.bodyHeight = Math.max(totalRowHeight + scrollXHeight, minBodyHeight);
        }
    }
    exports.setAutoBodyHeight = setAutoBodyHeight;


    /***/ }),
    /* 47 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HeaderArea = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var colGroup_1 = __webpack_require__(36);
    var dom_1 = __webpack_require__(2);
    var hoc_1 = __webpack_require__(4);
    var columnResizer_1 = __webpack_require__(88);
    var instance_1 = __webpack_require__(7);
    var column_1 = __webpack_require__(12);
    var complexHeader_1 = __webpack_require__(89);
    var columnHeader_1 = __webpack_require__(48);
    var constant_1 = __webpack_require__(14);
    var HeaderAreaComp = /** @class */ (function (_super) {
        tslib_1.__extends(HeaderAreaComp, _super);
        function HeaderAreaComp() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.startSelectedName = null;
            _this.handleDblClick = function (ev) {
                ev.stopPropagation();
            };
            _this.handleMouseMove = function (ev) {
                var _a = dom_1.getCoordinateWithOffset(ev.pageX, ev.pageY), pageX = _a[0], pageY = _a[1];
                _this.props.dispatch('dragMoveHeader', { pageX: pageX, pageY: pageY }, _this.startSelectedName);
            };
            _this.handleMouseDown = function (ev) {
                var _a = _this.props, dispatch = _a.dispatch, complexColumnHeaders = _a.complexColumnHeaders;
                var target = ev.target;
                if (dom_1.findParent(target, 'cell-row-header') ||
                    dom_1.hasClass(target, 'btn-sorting') ||
                    dom_1.hasClass(target, 'btn-filter') ||
                    ev.button === constant_1.RIGHT_MOUSE_BUTTON) {
                    return;
                }
                var name = target.getAttribute('data-column-name');
                if (!name) {
                    var parent = dom_1.findParent(target, 'cell-header');
                    if (parent) {
                        name = parent.getAttribute('data-column-name');
                    }
                }
                var parentHeader = column_1.isParentColumnHeader(complexColumnHeaders, name);
                _this.startSelectedName = name;
                dispatch('mouseDownHeader', name, parentHeader);
                document.addEventListener('mousemove', _this.handleMouseMove);
                document.addEventListener('mouseup', _this.clearDocumentEvents);
                document.addEventListener('selectstart', _this.handleSelectStart);
            };
            _this.clearDocumentEvents = function () {
                _this.props.dispatch('dragEnd');
                dom_1.setCursorStyle('');
                document.removeEventListener('mousemove', _this.handleMouseMove);
                document.removeEventListener('mouseup', _this.clearDocumentEvents);
                document.removeEventListener('selectstart', _this.handleSelectStart);
            };
            _this.handleSelectStart = function (ev) {
                ev.preventDefault();
            };
            return _this;
        }
        HeaderAreaComp.prototype.isSelected = function (index) {
            var columnSelectionRange = this.props.columnSelectionRange;
            if (!columnSelectionRange) {
                return false;
            }
            var start = columnSelectionRange[0], end = columnSelectionRange[1];
            return index >= start && index <= end;
        };
        HeaderAreaComp.prototype.componentDidUpdate = function () {
            this.el.scrollLeft = this.props.scrollLeft;
        };
        HeaderAreaComp.prototype.render = function () {
            var _this = this;
            var _a = this.props, columns = _a.columns, headerHeight = _a.headerHeight, side = _a.side, complexColumnHeaders = _a.complexColumnHeaders, grid = _a.grid;
            var headerHeightStyle = { height: headerHeight };
            return (preact_1.h("div", { class: dom_1.cls('header-area'), style: headerHeightStyle, ref: function (el) {
                    _this.el = el;
                } },
                preact_1.h("table", { class: dom_1.cls('table'), onMouseDown: this.handleMouseDown },
                    preact_1.h(colGroup_1.ColGroup, { side: side, useViewport: false }),
                    complexColumnHeaders.length ? (preact_1.h(complexHeader_1.ComplexHeader, { side: side, grid: grid })) : (preact_1.h("tbody", null,
                        preact_1.h("tr", { style: headerHeightStyle, onDblClick: this.handleDblClick }, columns.map(function (columnInfo, index) { return (preact_1.h(columnHeader_1.ColumnHeader, { key: columnInfo.name, columnInfo: columnInfo, selected: _this.isSelected(index), grid: grid })); }))))),
                preact_1.h(columnResizer_1.ColumnResizer, { side: side })));
        };
        return HeaderAreaComp;
    }(preact_1.Component));
    exports.HeaderArea = hoc_1.connect(function (store, _a) {
        var side = _a.side;
        var _b = store.column, visibleColumnsBySideWithRowHeader = _b.visibleColumnsBySideWithRowHeader, complexColumnHeaders = _b.complexColumnHeaders, _c = store.dimension, headerHeight = _c.headerHeight, cellBorderWidth = _c.cellBorderWidth, rangeBySide = store.selection.rangeBySide, viewport = store.viewport, id = store.id;
        return {
            headerHeight: headerHeight,
            cellBorderWidth: cellBorderWidth,
            columns: visibleColumnsBySideWithRowHeader[side],
            scrollLeft: side === 'L' ? 0 : viewport.scrollLeft,
            grid: instance_1.getInstance(id),
            columnSelectionRange: rangeBySide && rangeBySide[side].column ? rangeBySide[side].column : null,
            complexColumnHeaders: complexColumnHeaders,
        };
    })(HeaderAreaComp);


    /***/ }),
    /* 48 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ColumnHeader = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var dom_1 = __webpack_require__(2);
    var headerCheckbox_1 = __webpack_require__(90);
    var sortingButton_1 = __webpack_require__(91);
    var sortingOrder_1 = __webpack_require__(92);
    var filterButton_1 = __webpack_require__(93);
    var column_1 = __webpack_require__(10);
    var common_1 = __webpack_require__(0);
    var ColumnHeader = /** @class */ (function (_super) {
        tslib_1.__extends(ColumnHeader, _super);
        function ColumnHeader() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ColumnHeader.prototype.getElement = function (type) {
            var columnInfo = this.props.columnInfo;
            var name = columnInfo.name, sortable = columnInfo.sortable, sortingType = columnInfo.sortingType, filter = columnInfo.filter, headerRenderer = columnInfo.headerRenderer, header = columnInfo.header;
            if (headerRenderer) {
                return null;
            }
            switch (type) {
                case 'checkbox':
                    return column_1.isCheckboxColumn(name) ? preact_1.h(headerCheckbox_1.HeaderCheckbox, null) : header;
                case 'sortingBtn':
                    return sortable && preact_1.h(sortingButton_1.SortingButton, { columnName: name, sortingType: sortingType });
                case 'sortingOrder':
                    return sortable && preact_1.h(sortingOrder_1.SortingOrder, { columnName: name });
                case 'filter':
                    return filter && preact_1.h(filterButton_1.FilterButton, { columnName: name });
                default:
                    return null;
            }
        };
        ColumnHeader.prototype.componentDidMount = function () {
            var _a = this.props, columnInfo = _a.columnInfo, grid = _a.grid;
            var headerRenderer = columnInfo.headerRenderer;
            if (!headerRenderer || !this.el) {
                return;
            }
            var HeaderRendererClass = headerRenderer;
            var renderer = new HeaderRendererClass({ grid: grid, columnInfo: columnInfo });
            var rendererEl = renderer.getElement();
            this.el.appendChild(rendererEl);
            this.renderer = renderer;
            if (common_1.isFunction(renderer.mounted)) {
                renderer.mounted(this.el);
            }
        };
        ColumnHeader.prototype.componentWillReceiveProps = function (nextProps) {
            if (this.renderer) {
                this.renderer.render({ columnInfo: nextProps.columnInfo, grid: nextProps.grid });
            }
        };
        ColumnHeader.prototype.componentWillUnmount = function () {
            if (this.renderer && common_1.isFunction(this.renderer.beforeDestroy)) {
                this.renderer.beforeDestroy();
            }
        };
        ColumnHeader.prototype.render = function () {
            var _this = this;
            var _a = this.props, columnInfo = _a.columnInfo, colspan = _a.colspan, rowspan = _a.rowspan, selected = _a.selected, _b = _a.height, height = _b === void 0 ? null : _b;
            var name = columnInfo.name, textAlign = columnInfo.headerAlign, verticalAlign = columnInfo.headerVAlign, headerRenderer = columnInfo.headerRenderer;
            return (preact_1.h("th", tslib_1.__assign({ ref: function (el) {
                    _this.el = el;
                }, "data-column-name": name, style: { textAlign: textAlign, verticalAlign: verticalAlign, padding: headerRenderer ? 0 : null, height: height }, class: dom_1.cls('cell', 'cell-header', [!column_1.isRowHeader(name) && selected, 'cell-selected'], [column_1.isRowHeader(name), 'cell-row-header']) }, (!!colspan && { colspan: colspan }), (!!rowspan && { rowspan: rowspan })), ['checkbox', 'sortingBtn', 'sortingOrder', 'filter'].map(function (type) { return _this.getElement(type); })));
        };
        return ColumnHeader;
    }(preact_1.Component));
    exports.ColumnHeader = ColumnHeader;


    /***/ }),
    /* 49 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BodyArea = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var draggable_1 = __webpack_require__(94);
    var bodyRows_1 = __webpack_require__(95);
    var colGroup_1 = __webpack_require__(36);
    var dom_1 = __webpack_require__(2);
    var hoc_1 = __webpack_require__(4);
    var focusLayer_1 = __webpack_require__(101);
    var selectionLayer_1 = __webpack_require__(102);
    var common_1 = __webpack_require__(0);
    var editingLayer_1 = __webpack_require__(103);
    var gridEvent_1 = tslib_1.__importDefault(__webpack_require__(9));
    var eventBus_1 = __webpack_require__(8);
    var constant_1 = __webpack_require__(14);
    var focus_1 = __webpack_require__(41);
    // only updates when these props are changed
    // for preventing unnecessary rendering when scroll changes
    var PROPS_FOR_UPDATE = [
        'bodyHeight',
        'totalRowHeight',
        'offsetLeft',
        'offsetTop',
        'totalColumnWidth',
    ];
    // Minimum distance (pixel) to detect if user wants to drag when moving mouse with button pressed.
    var MIN_DISTANCE_FOR_DRAG = 10;
    var ADDITIONAL_RANGE = 3;
    var DRAGGING_CLASS = 'dragging';
    var PARENT_CELL_CLASS = 'parent-cell';
    var DRAGGABLE_COLUMN_NAME = '_draggable';
    var BodyAreaComp = /** @class */ (function (_super) {
        tslib_1.__extends(BodyAreaComp, _super);
        function BodyAreaComp() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.dragStartData = {
                pageX: null,
                pageY: null,
            };
            _this.prevScrollLeft = 0;
            // draggable info when start to move the row
            _this.draggableInfo = null;
            // floating row width and height for dragging
            _this.floatingRowSize = null;
            // the index info to move row through drag
            _this.movedIndexInfo = null;
            _this.scrollToNextDebounced = common_1.debounce(function () {
                _this.props.dispatch('scrollToNext');
            }, 200);
            _this.handleScroll = function (ev) {
                var _a = ev.target, scrollLeft = _a.scrollLeft, scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
                var _b = _this.props, dispatch = _b.dispatch, eventBus = _b.eventBus, side = _b.side;
                dispatch('setScrollTop', scrollTop);
                if (side === 'R') {
                    dispatch('setScrollLeft', scrollLeft);
                    if (scrollTop > 0 &&
                        scrollHeight - scrollTop === clientHeight &&
                        _this.prevScrollLeft === scrollLeft) {
                        var gridEvent = new gridEvent_1.default();
                        /**
                         * Occurs when scroll at the bottommost
                         * @event Grid#scrollEnd
                         * @property {Grid} instance - Current grid instance
                         */
                        eventBus.trigger('scrollEnd', gridEvent);
                        _this.scrollToNextDebounced();
                    }
                    _this.prevScrollLeft = scrollLeft;
                }
            };
            _this.dragRow = function (ev) {
                var _a = dom_1.getCoordinateWithOffset(ev.pageX, ev.pageY), pageX = _a[0], pageY = _a[1];
                if (_this.moveEnoughToTriggerDragEvent({ pageX: pageX, pageY: pageY })) {
                    var _b = _this, el = _b.el, boundingRect = _b.boundingRect, props = _b.props;
                    var _c = el, scrollTop = _c.scrollTop, scrollLeft = _c.scrollLeft;
                    var movedPosAndIndex = draggable_1.getMovedPosAndIndex(_this.context.store, {
                        scrollLeft: scrollLeft,
                        scrollTop: scrollTop,
                        left: boundingRect.left,
                        top: boundingRect.top,
                        pageX: pageX,
                        pageY: pageY,
                    });
                    var index = movedPosAndIndex.index, targetRow = movedPosAndIndex.targetRow;
                    var rowKeyToMove = targetRow.rowKey;
                    var _d = _this.draggableInfo, row = _d.row, rowKey = _d.rowKey;
                    var _e = draggable_1.getResolvedOffsets(_this.context.store, movedPosAndIndex, _this.floatingRowSize), offsetLeft = _e.offsetLeft, offsetTop = _e.offsetTop;
                    row.style.left = offsetLeft + "px";
                    row.style.top = offsetTop + "px";
                    if (props.hasTreeColumn) {
                        _this.setTreeMovedIndexInfo(movedPosAndIndex);
                    }
                    else {
                        // move the row to next index
                        _this.movedIndexInfo = { index: index, rowKey: rowKeyToMove, appended: false };
                        _this.props.dispatch('moveRow', rowKey, index);
                    }
                    var gridEvent = new gridEvent_1.default({
                        rowKey: rowKey,
                        targetRowKey: _this.movedIndexInfo.rowKey,
                        appended: _this.movedIndexInfo.appended,
                    });
                    /**
                     * Occurs when dragging the row
                     * @event Grid#drag
                     * @property {Grid} instance - Current grid instance
                     * @property {RowKey} rowKey - The rowKey of the dragging row
                     * @property {RowKey} targetRowKey - The rowKey of the row at current dragging position
                     * @property {boolean} appended - Whether the row is appended to other row as the child in tree data.
                     */
                    _this.props.eventBus.trigger('drag', gridEvent);
                }
            };
            _this.startToDragRow = function (posInfo) {
                var container = _this.el.parentElement.parentElement;
                posInfo.container = container;
                var draggableInfo = draggable_1.createDraggableInfo(_this.context.store, posInfo);
                if (draggableInfo) {
                    var row = draggableInfo.row, rowKey = draggableInfo.rowKey, line = draggableInfo.line;
                    var gridEvent = new gridEvent_1.default({ rowKey: rowKey, floatingRow: row });
                    /**
                     * Occurs when starting to drag the row
                     * @event Grid#dragStart
                     * @property {Grid} instance - Current grid instance
                     * @property {RowKey} rowKey - The rowKey of the row to drag
                     * @property {HTMLElement} floatingRow - The floating row DOM element
                     */
                    _this.props.eventBus.trigger('dragStart', gridEvent);
                    if (!gridEvent.isStopped()) {
                        container.appendChild(row);
                        var clientWidth = row.clientWidth, clientHeight = row.clientHeight;
                        _this.floatingRowSize = { width: clientWidth, height: clientHeight };
                        _this.draggableInfo = draggableInfo;
                        if (_this.props.hasTreeColumn) {
                            container.appendChild(line);
                        }
                        _this.props.dispatch('addRowClassName', rowKey, DRAGGING_CLASS);
                        _this.props.dispatch('setFocusInfo', null, null, false);
                        document.addEventListener('mousemove', _this.dragRow);
                        document.addEventListener('mouseup', _this.dropRow);
                        document.addEventListener('selectstart', _this.handleSelectStart);
                    }
                }
            };
            _this.handleMouseDown = function (ev) {
                var _a;
                var targetElement = ev.target;
                if (!_this.el ||
                    targetElement === _this.el ||
                    (ev.button === constant_1.RIGHT_MOUSE_BUTTON && _this.isSelectedCell(targetElement))) {
                    return;
                }
                var _b = _this.props, side = _b.side, dispatch = _b.dispatch;
                if (dom_1.hasClass(targetElement, 'cell-dummy')) {
                    dispatch('saveAndFinishEditing');
                    dispatch('initFocus');
                    dispatch('initSelection');
                    return;
                }
                var el = _this.el;
                var shiftKey = ev.shiftKey;
                var _c = dom_1.getCoordinateWithOffset(ev.pageX, ev.pageY), pageX = _c[0], pageY = _c[1];
                var scrollTop = el.scrollTop, scrollLeft = el.scrollLeft;
                var _d = el.getBoundingClientRect(), top = _d.top, left = _d.left;
                _this.boundingRect = { top: top, left: left };
                if (((_a = dom_1.getCellAddress(targetElement)) === null || _a === void 0 ? void 0 : _a.columnName) === DRAGGABLE_COLUMN_NAME) {
                    _this.startToDragRow({ pageX: pageX, pageY: pageY, left: left, top: top, scrollLeft: scrollLeft, scrollTop: scrollTop });
                    return;
                }
                if (!dom_1.isDatePickerElement(targetElement) && !dom_1.findParent(targetElement, 'layer-editing')) {
                    dispatch('mouseDownBody', tslib_1.__assign({ scrollTop: scrollTop, scrollLeft: scrollLeft, side: side }, _this.boundingRect), { pageX: pageX, pageY: pageY, shiftKey: shiftKey });
                }
                _this.dragStartData = { pageX: pageX, pageY: pageY };
                dom_1.setCursorStyle('default');
                document.addEventListener('mousemove', _this.handleMouseMove);
                document.addEventListener('mouseup', _this.clearDocumentEvents);
                document.addEventListener('selectstart', _this.handleSelectStart);
            };
            _this.moveEnoughToTriggerDragEvent = function (current) {
                var dx = Math.abs(_this.dragStartData.pageX - current.pageX);
                var dy = Math.abs(_this.dragStartData.pageY - current.pageY);
                var movedDistance = Math.round(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)));
                return movedDistance >= MIN_DISTANCE_FOR_DRAG;
            };
            _this.handleSelectStart = function (ev) {
                ev.preventDefault();
            };
            _this.handleMouseMove = function (ev) {
                var _a = dom_1.getCoordinateWithOffset(ev.pageX, ev.pageY), pageX = _a[0], pageY = _a[1];
                if (_this.moveEnoughToTriggerDragEvent({ pageX: pageX, pageY: pageY })) {
                    var _b = _this, el = _b.el, boundingRect = _b.boundingRect, props = _b.props;
                    var _c = el, scrollTop = _c.scrollTop, scrollLeft = _c.scrollLeft;
                    var side = props.side, dispatch = props.dispatch;
                    dispatch('dragMoveBody', _this.dragStartData, { pageX: pageX, pageY: pageY }, tslib_1.__assign({ scrollTop: scrollTop, scrollLeft: scrollLeft, side: side }, boundingRect));
                }
            };
            _this.dropRow = function () {
                var _a;
                var hasTreeColumn = _this.props.hasTreeColumn;
                var rowKey = _this.draggableInfo.rowKey;
                if (_this.movedIndexInfo) {
                    var _b = _this.movedIndexInfo, index = _b.index, targetRowKey = _b.rowKey, appended = _b.appended, _c = _b.moveToLast, moveToLast = _c === void 0 ? false : _c;
                    var gridEvent = new gridEvent_1.default({ rowKey: rowKey, targetRowKey: targetRowKey, appended: appended });
                    /**
                     * Occurs when dropping the row
                     * @event Grid#drop
                     * @property {Grid} instance - Current grid instance
                     * @property {RowKey} rowKey - The rowKey of the dragging row
                     * @property {RowKey} targetRowKey - The rowKey of the row at current dragging position
                     * @property {boolean} appended - Whether the row is appended to other row as the child in tree data.
                     */
                    _this.props.eventBus.trigger('drop', gridEvent);
                    if (!gridEvent.isStopped()) {
                        if (hasTreeColumn) {
                            _this.props.dispatch('moveTreeRow', rowKey, index, { appended: appended, moveToLast: moveToLast });
                        }
                        else {
                            _this.props.dispatch('moveRow', rowKey, index);
                        }
                    }
                }
                _this.props.dispatch('removeRowClassName', rowKey, DRAGGING_CLASS);
                if (!common_1.isNil((_a = _this.movedIndexInfo) === null || _a === void 0 ? void 0 : _a.rowKey)) {
                    _this.props.dispatch('removeRowClassName', _this.movedIndexInfo.rowKey, PARENT_CELL_CLASS);
                }
                // clear floating element and draggable info
                _this.clearDraggableInfo();
            };
            _this.clearDocumentEvents = function () {
                _this.dragStartData = { pageX: null, pageY: null };
                _this.props.dispatch('dragEnd');
                dom_1.setCursorStyle('');
                document.removeEventListener('mousemove', _this.handleMouseMove);
                document.removeEventListener('mouseup', _this.clearDocumentEvents);
                document.removeEventListener('selectstart', _this.handleSelectStart);
            };
            return _this;
        }
        BodyAreaComp.prototype.setTreeMovedIndexInfo = function (movedPosAndIndex) {
            var _a;
            var line = this.draggableInfo.line;
            var index = movedPosAndIndex.index, offsetTop = movedPosAndIndex.offsetTop, height = movedPosAndIndex.height, targetRow = movedPosAndIndex.targetRow, moveToLast = movedPosAndIndex.moveToLast;
            var rowKey = targetRow.rowKey;
            if (!common_1.isNil((_a = this.movedIndexInfo) === null || _a === void 0 ? void 0 : _a.rowKey)) {
                this.props.dispatch('removeRowClassName', this.movedIndexInfo.rowKey, PARENT_CELL_CLASS);
            }
            var targetRowKey = moveToLast ? null : rowKey;
            // display line border to mark the index to move
            if (Math.abs(height - offsetTop) < ADDITIONAL_RANGE || moveToLast) {
                line.style.top = height + "px";
                line.style.display = 'block';
                this.movedIndexInfo = { index: index, rowKey: targetRowKey, moveToLast: moveToLast, appended: false };
                // show the background color to mark parent row
            }
            else {
                line.style.display = 'none';
                this.movedIndexInfo = { index: index, rowKey: targetRowKey, appended: true };
                this.props.dispatch('addRowClassName', rowKey, PARENT_CELL_CLASS);
            }
        };
        BodyAreaComp.prototype.isSelectedCell = function (element) {
            var cellAddress = dom_1.getCellAddress(element);
            if (cellAddress) {
                var rowKey = cellAddress.rowKey, columnName = cellAddress.columnName;
                return focus_1.isFocusedCell(this.context.store.focus, rowKey, columnName);
            }
            return !!dom_1.findParent(element, 'layer-selection');
        };
        BodyAreaComp.prototype.clearDraggableInfo = function () {
            var _a = this.draggableInfo, row = _a.row, line = _a.line;
            row.parentElement.removeChild(row);
            if (this.props.hasTreeColumn) {
                line.parentElement.removeChild(line);
            }
            this.draggableInfo = null;
            this.movedIndexInfo = null;
            document.removeEventListener('mousemove', this.dragRow);
            document.removeEventListener('mouseup', this.dropRow);
            document.removeEventListener('selectstart', this.handleSelectStart);
        };
        BodyAreaComp.prototype.shouldComponentUpdate = function (nextProps) {
            var currProps = this.props;
            return common_1.some(function (propName) { return nextProps[propName] !== currProps[propName]; }, PROPS_FOR_UPDATE);
        };
        BodyAreaComp.prototype.componentWillReceiveProps = function (nextProps) {
            var scrollTop = nextProps.scrollTop, scrollLeft = nextProps.scrollLeft;
            this.el.scrollTop = scrollTop;
            this.el.scrollLeft = scrollLeft;
        };
        BodyAreaComp.prototype.render = function (_a) {
            var _this = this;
            var side = _a.side, bodyHeight = _a.bodyHeight, totalRowHeight = _a.totalRowHeight, totalColumnWidth = _a.totalColumnWidth, scrollXHeight = _a.scrollXHeight, offsetTop = _a.offsetTop, offsetLeft = _a.offsetLeft, dummyRowCount = _a.dummyRowCount, scrollX = _a.scrollX, scrollY = _a.scrollY, cellBorderWidth = _a.cellBorderWidth;
            var areaStyle = { height: bodyHeight };
            if (!scrollX) {
                areaStyle.overflowX = 'hidden';
            }
            if (!scrollY && side === 'R') {
                areaStyle.overflowY = 'hidden';
            }
            var tableContainerStyle = {
                top: offsetTop,
                left: offsetLeft,
                height: dummyRowCount ? bodyHeight - scrollXHeight : '',
                overflow: dummyRowCount ? 'hidden' : 'visible',
            };
            var containerStyle = {
                width: totalColumnWidth + (side === 'R' ? 0 : cellBorderWidth),
                height: totalRowHeight ? totalRowHeight + cellBorderWidth : '100%',
            };
            return (preact_1.h("div", { class: dom_1.cls('body-area'), style: areaStyle, onScroll: this.handleScroll, onMouseDown: this.handleMouseDown, ref: function (el) {
                    _this.el = el;
                } },
                preact_1.h("div", { class: dom_1.cls('body-container'), style: containerStyle },
                    preact_1.h("div", { class: dom_1.cls('table-container'), style: tableContainerStyle },
                        preact_1.h("table", { class: dom_1.cls('table') },
                            preact_1.h(colGroup_1.ColGroup, { side: side, useViewport: true }),
                            preact_1.h(bodyRows_1.BodyRows, { side: side }))),
                    preact_1.h(focusLayer_1.FocusLayer, { side: side }),
                    preact_1.h(selectionLayer_1.SelectionLayer, { side: side }),
                    preact_1.h(editingLayer_1.EditingLayer, { side: side }))));
        };
        return BodyAreaComp;
    }(preact_1.Component));
    exports.BodyArea = hoc_1.connect(function (store, _a) {
        var side = _a.side;
        var columnCoords = store.columnCoords, rowCoords = store.rowCoords, dimension = store.dimension, viewport = store.viewport, id = store.id, column = store.column;
        var totalRowHeight = rowCoords.totalRowHeight;
        var totalColumnWidth = columnCoords.totalColumnWidth;
        var bodyHeight = dimension.bodyHeight, scrollXHeight = dimension.scrollXHeight, scrollX = dimension.scrollX, scrollY = dimension.scrollY, cellBorderWidth = dimension.cellBorderWidth;
        var offsetLeft = viewport.offsetLeft, offsetTop = viewport.offsetTop, scrollTop = viewport.scrollTop, scrollLeft = viewport.scrollLeft, dummyRowCount = viewport.dummyRowCount;
        return {
            bodyHeight: bodyHeight,
            totalRowHeight: totalRowHeight,
            offsetTop: offsetTop,
            scrollTop: scrollTop,
            totalColumnWidth: totalColumnWidth[side],
            offsetLeft: side === 'L' ? 0 : offsetLeft,
            scrollLeft: side === 'L' ? 0 : scrollLeft,
            scrollXHeight: scrollXHeight,
            dummyRowCount: dummyRowCount,
            scrollX: scrollX,
            scrollY: scrollY,
            cellBorderWidth: cellBorderWidth,
            eventBus: eventBus_1.getEventBus(id),
            hasTreeColumn: !!column.treeColumnName,
        };
    })(BodyAreaComp);


    /***/ }),
    /* 50 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SummaryArea = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var colGroup_1 = __webpack_require__(36);
    var summaryBodyRow_1 = __webpack_require__(104);
    var dom_1 = __webpack_require__(2);
    var hoc_1 = __webpack_require__(4);
    var SummaryAreaComp = /** @class */ (function (_super) {
        tslib_1.__extends(SummaryAreaComp, _super);
        function SummaryAreaComp() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.handleScroll = function (ev) {
                var scrollLeft = ev.target.scrollLeft;
                var _a = _this.props, dispatch = _a.dispatch, side = _a.side;
                if (side === 'R') {
                    dispatch('setScrollLeft', scrollLeft);
                }
            };
            return _this;
        }
        SummaryAreaComp.prototype.componentWillReceiveProps = function (nextProps) {
            if (this.el) {
                this.el.scrollLeft = nextProps.scrollLeft;
            }
        };
        SummaryAreaComp.prototype.render = function (_a) {
            var _this = this;
            var height = _a.height, columns = _a.columns, side = _a.side;
            var tableStyle = { height: height };
            return (height > 0 && (preact_1.h("div", { class: dom_1.cls('summary-area'), onScroll: this.handleScroll, ref: function (el) {
                    _this.el = el;
                } },
                preact_1.h("table", { class: dom_1.cls('table'), style: tableStyle },
                    preact_1.h(colGroup_1.ColGroup, { side: side, useViewport: false }),
                    preact_1.h(summaryBodyRow_1.SummaryBodyRow, { columns: columns })))));
        };
        return SummaryAreaComp;
    }(preact_1.Component));
    exports.SummaryArea = hoc_1.connect(function (store, _a) {
        var side = _a.side;
        var column = store.column, dimension = store.dimension, viewport = store.viewport;
        var summaryHeight = dimension.summaryHeight;
        var scrollLeft = viewport.scrollLeft;
        return {
            height: summaryHeight,
            columns: column.visibleColumnsBySideWithRowHeader[side],
            scrollLeft: scrollLeft,
        };
    })(SummaryAreaComp);


    /***/ }),
    /* 51 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContextMenu = exports.ContextMenuComp = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var hoc_1 = __webpack_require__(4);
    var dom_1 = __webpack_require__(2);
    var contextMenuItem_1 = __webpack_require__(114);
    var ContextMenuComp = /** @class */ (function (_super) {
        tslib_1.__extends(ContextMenuComp, _super);
        function ContextMenuComp() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ContextMenuComp.prototype.render = function () {
            var _a = this.props, pos = _a.pos, menuItems = _a.menuItems;
            if (pos) {
                return (preact_1.h("ul", { class: dom_1.cls('context-menu'), style: pos }, menuItems.map(function (menuItem) { return (preact_1.h(contextMenuItem_1.ContextMenuItem, { key: menuItem.name, menuItem: menuItem })); })));
            }
            return null;
        };
        return ContextMenuComp;
    }(preact_1.Component));
    exports.ContextMenuComp = ContextMenuComp;
    exports.ContextMenu = hoc_1.connect(function (_a, _b) {
        var _c, _d;
        var contextMenu = _a.contextMenu;
        var menuItems = _b.menuItems, pos = _b.pos;
        return ({
            pos: pos || ((_d = (_c = contextMenu.posInfo) === null || _c === void 0 ? void 0 : _c.pos) !== null && _d !== void 0 ? _d : null),
            menuItems: menuItems || contextMenu.flattenTopMenuItems,
        });
    })(ContextMenuComp);


    /***/ }),
    /* 52 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isMobile = exports.isEdge = void 0;
    function isEdge() {
        var rEdge = /Edge\/(\d+)\./;
        return rEdge.exec(window.navigator.userAgent);
    }
    exports.isEdge = isEdge;
    function isMobile() {
        return /Android|BlackBerry|iPhone|iPad|iPod|Opera Mini|IEMobile|WPDesktop/i.test(navigator.userAgent);
    }
    exports.isMobile = isMobile;


    /***/ }),
    /* 53 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findRowIndexByPosition = exports.findColumnIndexByPosition = exports.getColumnNameRange = exports.getOverflowFromMousePosition = void 0;
    var tslib_1 = __webpack_require__(1);
    var common_1 = __webpack_require__(0);
    function getTotalColumnOffsets(widths, cellBorderWidth) {
        var totalWidths = tslib_1.__spreadArrays(widths.L, widths.R);
        var offsets = [0];
        for (var i = 1, len = totalWidths.length; i < len; i += 1) {
            offsets.push(offsets[i - 1] + totalWidths[i - 1] + cellBorderWidth);
        }
        return offsets;
    }
    function getScrolledPosition(_a, dimension, leftSideWidth) {
        var pageX = _a.pageX, pageY = _a.pageY, scrollLeft = _a.scrollLeft, scrollTop = _a.scrollTop;
        var _b = getPositionFromBodyArea(pageX, pageY, dimension), bodyPositionX = _b.x, bodyPositionY = _b.y;
        var scrollX = bodyPositionX > leftSideWidth ? scrollLeft : 0;
        var scrolledPositionX = bodyPositionX + scrollX;
        var scrolledPositionY = bodyPositionY + scrollTop;
        return {
            x: scrolledPositionX,
            y: scrolledPositionY,
        };
    }
    function judgeOverflow(_a, _b) {
        var containerX = _a.x, containerY = _a.y;
        var bodyHeight = _b.bodyHeight, bodyWidth = _b.bodyWidth;
        var overflowY = 0;
        var overflowX = 0;
        if (containerY < 0) {
            overflowY = -1;
        }
        else if (containerY > bodyHeight) {
            overflowY = 1;
        }
        if (containerX < 0) {
            overflowX = -1;
        }
        else if (containerX > bodyWidth) {
            overflowX = 1;
        }
        return {
            x: overflowX,
            y: overflowY,
        };
    }
    function getPositionFromBodyArea(pageX, pageY, dimension) {
        var offsetLeft = dimension.offsetLeft, offsetTop = dimension.offsetTop, tableBorderWidth = dimension.tableBorderWidth, cellBorderWidth = dimension.cellBorderWidth, headerHeight = dimension.headerHeight, summaryHeight = dimension.summaryHeight, summaryPosition = dimension.summaryPosition;
        var adjustedSummaryHeight = summaryPosition === 'top' ? summaryHeight : 0;
        return {
            x: pageX - offsetLeft,
            y: pageY -
                (offsetTop + headerHeight + adjustedSummaryHeight + cellBorderWidth + tableBorderWidth),
        };
    }
    function getOverflowFromMousePosition(pageX, pageY, bodyWidth, dimension) {
        var bodyHeight = dimension.bodyHeight;
        var _a = getPositionFromBodyArea(pageX, pageY, dimension), x = _a.x, y = _a.y;
        return judgeOverflow({ x: x, y: y }, { bodyWidth: bodyWidth, bodyHeight: bodyHeight });
    }
    exports.getOverflowFromMousePosition = getOverflowFromMousePosition;
    function getColumnNameRange(store, dragStartData, dragData, elementInfo) {
        var allColumns = store.column.allColumns;
        var scrollTop = elementInfo.scrollTop, scrollLeft = elementInfo.scrollLeft;
        var startPageX = dragStartData.pageX, startPageY = dragStartData.pageY;
        var endPageX = dragData.pageX, endPageY = dragData.pageY;
        var startViewInfo = { pageX: startPageX, pageY: startPageY, scrollTop: scrollTop, scrollLeft: scrollLeft };
        var endViewInfo = { pageX: endPageX, pageY: endPageY, scrollTop: scrollTop, scrollLeft: scrollLeft };
        var startColumnIndex = findColumnIndexByPosition(store, startViewInfo);
        var endColumnIndex = findColumnIndexByPosition(store, endViewInfo);
        var startColumnName = allColumns[startColumnIndex].name;
        var endColumnName = allColumns[endColumnIndex].name;
        return [startColumnName, endColumnName];
    }
    exports.getColumnNameRange = getColumnNameRange;
    function findColumnIndexByPosition(store, viewInfo) {
        var dimension = store.dimension, columnCoords = store.columnCoords;
        var widths = columnCoords.widths, areaWidth = columnCoords.areaWidth;
        var totalColumnOffsets = getTotalColumnOffsets(widths, dimension.cellBorderWidth);
        var scrolledPosition = getScrolledPosition(viewInfo, dimension, areaWidth.L);
        return common_1.findOffsetIndex(totalColumnOffsets, scrolledPosition.x);
    }
    exports.findColumnIndexByPosition = findColumnIndexByPosition;
    function findRowIndexByPosition(store, viewInfo) {
        var dimension = store.dimension, columnCoords = store.columnCoords, rowCoords = store.rowCoords;
        var areaWidth = columnCoords.areaWidth;
        var scrolledPosition = getScrolledPosition(viewInfo, dimension, areaWidth.L);
        return common_1.findOffsetIndex(rowCoords.offsets, scrolledPosition.y);
    }
    exports.findRowIndexByPosition = findRowIndexByPosition;


    /***/ }),
    /* 54 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.execCopy = void 0;
    var dom_1 = __webpack_require__(2);
    var clipboard_1 = __webpack_require__(37);
    var instance_1 = __webpack_require__(7);
    function execCopy(store, ranges) {
        var el = instance_1.getInstance(store.id).el;
        var targetText = clipboard_1.getText(store, ranges);
        var clipboard = el.querySelector("." + dom_1.cls('clipboard'));
        clipboard.innerHTML = targetText;
        if (dom_1.isSupportWindowClipboardData()) {
            dom_1.setClipboardSelection(clipboard.childNodes[0]);
        }
        // Accessing the clipboard is a security concern on chrome
        document.execCommand('copy');
    }
    exports.execCopy = execCopy;


    /***/ }),
    /* 55 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.gridAjax = void 0;
    var tslib_1 = __webpack_require__(1);
    var serializer_1 = __webpack_require__(132);
    var gridEvent_1 = tslib_1.__importDefault(__webpack_require__(9));
    var common_1 = __webpack_require__(0);
    var ENCODED_SPACE_REGEXP = /%20/g;
    var QS_DELIM_REGEXP = /\?/;
    function hasRequestBody(method) {
        return /^(?:POST|PUT|PATCH)$/.test(method.toUpperCase());
    }
    function getSerialized(params, serializer) {
        return common_1.isFunction(serializer) ? serializer(params) : serializer_1.serialize(params);
    }
    function handleReadyStateChange(xhr, options) {
        var eventBus = options.eventBus, success = options.success, preCallback = options.preCallback, postCallback = options.postCallback;
        // eslint-disable-next-line eqeqeq
        if (xhr.readyState != XMLHttpRequest.DONE) {
            return;
        }
        preCallback();
        var gridEvent = new gridEvent_1.default({ xhr: xhr });
        /**
         * Occurs when the response is received from the server
         * @event Grid#response
         * @type {module:event/gridEvent}
         * @property {XmlHttpRequest} xhr - XmlHttpRequest
         * @property {Grid} instance - Current grid instance
         */
        eventBus.trigger('response', gridEvent);
        if (gridEvent.isStopped()) {
            return;
        }
        if (xhr.status === 200) {
            var response = JSON.parse(xhr.responseText);
            if (response.result) {
                /**
                 * Occurs after the response event, if the result is true
                 * @event Grid#successResponse
                 * @type {module:event/gridEvent}
                 * @property {XmlHttpRequest} xhr - XmlHttpRequest
                 * @property {Grid} instance - Current grid instance
                 */
                eventBus.trigger('successResponse', gridEvent);
                if (gridEvent.isStopped()) {
                    return;
                }
                success(response);
            }
            else if (!response.result) {
                /**
                 * Occurs after the response event, if the result is false
                 * @event Grid#failResponse
                 * @type {module:event/gridEvent}
                 * @property {XmlHttpRequest} xhr - XmlHttpRequest
                 * @property {Grid} instance - Current grid instance
                 */
                eventBus.trigger('failResponse', gridEvent);
                if (gridEvent.isStopped()) {
                    return;
                }
            }
        }
        else {
            /**
             * Occurs after the response event, if the response is Error
             * @event Grid#errorResponse
             * @type {module:event/gridEvent}
             * @property {XmlHttpRequest} xhr - XmlHttpRequest
             * @property {Grid} instance - Current grid instance
             */
            eventBus.trigger('errorResponse', gridEvent);
            if (gridEvent.isStopped()) {
                return;
            }
        }
        postCallback();
    }
    function open(xhr, options) {
        var url = options.url, method = options.method, serializer = options.serializer, _a = options.params, params = _a === void 0 ? {} : _a;
        var requestUrl = url;
        if (!hasRequestBody(method)) {
            // serialize query string
            var qs = (QS_DELIM_REGEXP.test(url) ? '&' : '?') + getSerialized(params, serializer);
            requestUrl = "" + url + qs;
        }
        xhr.open(method, requestUrl);
    }
    function applyConfig(xhr, options) {
        var method = options.method, contentType = options.contentType, mimeType = options.mimeType, headers = options.headers, _a = options.withCredentials, withCredentials = _a === void 0 ? false : _a;
        // set withCredentials
        xhr.withCredentials = withCredentials;
        // overide MIME type
        if (mimeType) {
            xhr.overrideMimeType(mimeType);
        }
        // set user defined request headers
        if (common_1.isObject(headers)) {
            Object.keys(headers).forEach(function (name) {
                if (headers[name]) {
                    xhr.setRequestHeader(name, headers[name]);
                }
            });
        }
        // set 'Content-Type' when request has body
        if (hasRequestBody(method)) {
            xhr.setRequestHeader('Content-Type', contentType + "; charset=UTF-8");
        }
        // set 'x-requested-with' header to prevent CSRF in old browser
        xhr.setRequestHeader('x-requested-with', 'XMLHttpRequest');
    }
    function send(xhr, options) {
        var method = options.method, eventBus = options.eventBus, serializer = options.serializer, preCallback = options.preCallback, _a = options.params, params = _a === void 0 ? {} : _a, _b = options.contentType, contentType = _b === void 0 ? 'application/x-www-form-urlencoded' : _b;
        var body = null;
        if (hasRequestBody(method)) {
            // The space character '%20' is replaced to '+', because application/x-www-form-urlencoded follows rfc-1866
            body =
                contentType.indexOf('application/x-www-form-urlencoded') !== -1
                    ? getSerialized(params, serializer).replace(ENCODED_SPACE_REGEXP, '+')
                    : JSON.stringify(params);
        }
        xhr.onreadystatechange = function () { return handleReadyStateChange(xhr, options); };
        var gridEvent = new gridEvent_1.default({ xhr: xhr });
        /**
         * Occurs before the http request is sent
         * @event Grid#beforeRequest
         * @type {module:event/gridEvent}
         * @property {XMLHttpRequest} xhr - Current XMLHttpRequest instance
         * @property {Grid} instance - Current grid instance
         */
        eventBus.trigger('beforeRequest', gridEvent);
        if (gridEvent.isStopped()) {
            preCallback();
            return;
        }
        xhr.send(body);
    }
    function gridAjax(options) {
        var xhr = new XMLHttpRequest();
        [open, applyConfig, send].forEach(function (fn) { return fn(xhr, options); });
    }
    exports.gridAjax = gridAjax;


    /***/ }),
    /* 56 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createManager = exports.getDataWithOptions = void 0;
    var tslib_1 = __webpack_require__(1);
    var common_1 = __webpack_require__(0);
    var observable_1 = __webpack_require__(5);
    var data_1 = __webpack_require__(6);
    var paramNameMap = {
        CREATE: 'createdRows',
        UPDATE: 'updatedRows',
        DELETE: 'deletedRows',
    };
    // @TODO: fix 'Row' type with record(Dictionary) type to use negate type or other type utility
    function getDataWithOptions(targetRows, options) {
        if (options === void 0) { options = {}; }
        var _a = options.checkedOnly, checkedOnly = _a === void 0 ? false : _a, _b = options.withRawData, withRawData = _b === void 0 ? false : _b, _c = options.rowKeyOnly, rowKeyOnly = _c === void 0 ? false : _c, _d = options.ignoredColumns, ignoredColumns = _d === void 0 ? [] : _d;
        var rows = targetRows.map(function (row) { return observable_1.getOriginObject(row); });
        if (checkedOnly) {
            rows = rows.filter(function (row) { return row._attributes.checked; });
        }
        if (ignoredColumns.length) {
            // @ts-ignore
            rows = rows.map(function (row) { return common_1.omit.apply(void 0, tslib_1.__spreadArrays([row], ignoredColumns)); });
        }
        if (!withRawData) {
            rows = rows.map(function (row) { return data_1.getOmittedInternalProp(row); });
        }
        if (rowKeyOnly) {
            return rows.map(function (row) { return row.rowKey; });
        }
        return rows;
    }
    exports.getDataWithOptions = getDataWithOptions;
    function createManager() {
        var originData = [];
        var mixedOrder = false;
        var dataMap = {
            CREATE: [],
            UPDATE: [],
            DELETE: [],
        };
        var splice = function (type, rowKey, row) {
            var index = common_1.findIndex(function (createdRow) { return createdRow.rowKey === rowKey; }, dataMap[type]);
            if (index !== -1) {
                if (common_1.isUndefined(row)) {
                    dataMap[type].splice(index, 1);
                }
                else {
                    dataMap[type].splice(index, 1, row);
                }
            }
        };
        var spliceAll = function (rowKey, row) {
            splice('CREATE', rowKey, row);
            splice('UPDATE', rowKey, row);
            splice('DELETE', rowKey, row);
        };
        return {
            // only for restore
            setOriginData: function (data) {
                originData = data_1.changeRawDataToOriginDataForTree(data);
            },
            getOriginData: function () {
                return originData;
            },
            getModifiedData: function (type, options) {
                var _a;
                return _a = {}, _a[paramNameMap[type]] = getDataWithOptions(dataMap[type], options), _a;
            },
            getAllModifiedData: function (options) {
                var _this = this;
                return Object.keys(dataMap)
                    .map(function (key) { return _this.getModifiedData(key, options); })
                    .reduce(function (acc, data) { return (tslib_1.__assign(tslib_1.__assign({}, acc), data)); }, {});
            },
            isModified: function () {
                return !!(dataMap.CREATE.length || dataMap.UPDATE.length || dataMap.DELETE.length);
            },
            isModifiedByType: function (type) {
                return !!dataMap[type].length;
            },
            push: function (type, row, mixed) {
                if (mixed === void 0) { mixed = false; }
                var rowKey = row.rowKey;
                mixedOrder = mixedOrder || mixed;
                if (type === 'UPDATE' || type === 'DELETE') {
                    splice('UPDATE', rowKey);
                    // if the row was already registered in createdRows,
                    // would update it in createdRows and not add it to updatedRows or deletedRows
                    if (common_1.someProp('rowKey', rowKey, dataMap.CREATE)) {
                        if (type === 'UPDATE') {
                            splice('CREATE', rowKey, row);
                        }
                        else {
                            splice('CREATE', rowKey);
                        }
                        return;
                    }
                }
                if (!common_1.someProp('rowKey', rowKey, dataMap[type])) {
                    dataMap[type].push(row);
                }
            },
            clearSpecificRows: function (rowsMap) {
                common_1.forEachObject(function (_, key) {
                    rowsMap[key].forEach(function (row) {
                        spliceAll(common_1.isObject(row) ? row.rowKey : row);
                    });
                }, rowsMap);
            },
            clear: function (requestTypeCode) {
                if (requestTypeCode === 'MODIFY') {
                    this.clearAll();
                    return;
                }
                dataMap[requestTypeCode] = [];
            },
            clearAll: function () {
                dataMap.CREATE = [];
                dataMap.UPDATE = [];
                dataMap.DELETE = [];
            },
            isMixedOrder: function () {
                return mixedOrder;
            },
        };
    }
    exports.createManager = createManager;


    /***/ }),
    /* 57 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAlertMessage = exports.getConfirmMessage = void 0;
    var tslib_1 = __webpack_require__(1);
    var _1 = tslib_1.__importDefault(__webpack_require__(19));
    var confirmMessageMap = {
        CREATE: 'net.confirmCreate',
        UPDATE: 'net.confirmUpdate',
        DELETE: 'net.confirmDelete',
        MODIFY: 'net.confirmModify',
    };
    var alertMessageMap = {
        CREATE: 'net.noDataToCreate',
        UPDATE: 'net.noDataToUpdate',
        DELETE: 'net.noDataToDelete',
        MODIFY: 'net.noDataToModify',
    };
    function getConfirmMessage(type, count) {
        return _1.default.get(confirmMessageMap[type], { count: String(count) });
    }
    exports.getConfirmMessage = getConfirmMessage;
    function getAlertMessage(type) {
        return _1.default.get(alertMessageMap[type]);
    }
    exports.getAlertMessage = getAlertMessage;


    /***/ }),
    /* 58 */
    /***/ (function(module, exports, __webpack_require__) {

    var tslib_1 = __webpack_require__(1);
    var grid_1 = tslib_1.__importDefault(__webpack_require__(59));
    __webpack_require__(137);
    grid_1.default.setLanguage('en');
    module.exports = grid_1.default;


    /***/ }),
    /* 59 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var create_1 = __webpack_require__(60);
    var root_1 = __webpack_require__(85);
    var create_2 = __webpack_require__(119);
    var manager_1 = tslib_1.__importDefault(__webpack_require__(125));
    var instance_1 = __webpack_require__(7);
    var i18n_1 = tslib_1.__importDefault(__webpack_require__(19));
    var validation_1 = __webpack_require__(129);
    var dom_1 = __webpack_require__(2);
    var common_1 = __webpack_require__(0);
    var observable_1 = __webpack_require__(5);
    var eventBus_1 = __webpack_require__(8);
    var data_1 = __webpack_require__(6);
    var column_1 = __webpack_require__(10);
    var serverSideDataProvider_1 = __webpack_require__(130);
    var modifiedDataManager_1 = __webpack_require__(56);
    var message_1 = __webpack_require__(57);
    var paginationManager_1 = __webpack_require__(135);
    var tree_1 = __webpack_require__(22);
    var rowSpan_1 = __webpack_require__(11);
    var googleAnalytics_1 = __webpack_require__(136);
    var filter_1 = __webpack_require__(29);
    var filter_2 = __webpack_require__(45);
    var clipboard_1 = __webpack_require__(54);
    /**
     * Grid public API
     * @param {Object} options
     *      @param {HTMLElement} el - The target element to create grid.
     *      @param {Array|Object} [options.data] - Grid data for making rows. When using the data source, sets to object.
     *      @param {Object} [options.pageOptions={}] The object for the pagination options.
     *      @param {Object} [options.header] - Options object for header.
     *      @param {number} [options.header.height=40] - The height of the header area.
     *      @param {number} [options.header.align=center] - Horizontal alignment of the header content.
     *              Available values are 'left', 'center', 'right'.
     *      @param {number} [options.header.valign=middle] - Vertical alignment of the row header content.
     *              Available values are 'top', 'middle', 'bottom'.
     *      @param {Array} [options.header.complexColumns] - This options creates new parent headers of the multiple columns
     *          which includes the headers of specified columns, and sets up the hierarchy.
     *          @param {string} [options.header.complexColumns.header] - The header of the complex column to be shown on the header.
     *          @param {string} [options.header.complexColumns.name] - The name of column that makes tree column.
     *          @param {Array} [options.header.complexColumns.childNames] - The name of the child header(subheader).
     *          @param {function} [options.header.complexColumns.renderer] - Sets the custom renderer to customize the header content.
     *          @param {string} [options.header.complexColumns.headerAlign=center] - Horizontal alignment of the header content.
     *              Available values are 'left', 'center', 'right'.
     *          @param {string} [options.header.complexColumns.headerVAlign=middle] - Vertical alignment of the row header content.
     *              Available values are 'top', 'middle', 'bottom'.
     *          @param {boolean} [options.header.complexColumns.hideChildHeaders=false] - If set to true, the child columns header are hidden.
     *          @param {boolean} [options.header.complexColumns.resizable=false] - If set to true, resize-handles of each complex columns will be shown.
     *      @param {string|number} [options.width='auto'] - Options for grid width.
     *      @param {string|number} [options.rowHeight] - The height of each rows. The default value is 40,
     *          the height of each rows expands to dom's height. If set to number, the height is fixed.
     *      @param {number} [options.minRowHeight=40] - The minimum height of each rows. When this value is larger than
     *          the row's height, it set to the row's height.
     *      @param {string|number} [options.bodyHeight] - The height of body area. The default value is 'auto',
     *          the height of body area expands to total height of rows. If set to 'fitToParent', the height of the grid
     *          will expand to fit the height of parent element. If set to number, the height is fixed.
     *      @param {number} [options.minBodyHeight=minRowHeight] - The minimum height of body area. When this value
     *          is larger than the body's height, it set to the body's height.
     *      @param {Object} [options.columnOptions] - Option object for all columns
     *      @param {number} [options.columnOptions.minWidth=50] - Minimum width of each columns
     *      @param {boolean} [options.columnOptions.resizable=false] - If set to true, resize-handles of each columns
     *          will be shown.
     *      @param {number} [options.columnOptions.frozenCount=0] - The number of frozen columns.
     *          The columns indexed from 0 to this value will always be shown on the left side.
     *          {@link Grid#setFrozenColumnCount} can be used for setting this value dynamically.
     *      @param {number} [options.columnOptions.frozenBorderWidth=1] - The value of frozen border width.
     *          When the frozen columns are created by "frozenCount" option, the frozen border width set.
     *      @param {Object} [options.treeColumnOptions] - Option object for the tree column.
     *      @param {string} [options.treeColumnOptions.name] - The name of column that makes tree column.
     *      @param {boolean} [options.treeColumnOptions.useIcon=true] - If set to true, the folder or file icon is created on
     *          the left side of the tree cell data.
     *      @param {boolean} [options.treeColumnOptions.useCascadingCheckbox] - If set to true, a cascading relationship is
     *          created in the checkbox between parent and child rows.
     *      @param {Object} [options.copyOptions] - Option object for clipboard copying
     *      @param {boolean} [options.copyOptions.useFormattedValue] - Whether to use formatted values or original values
     *          as a string to be copied to the clipboard
     *      @param {boolean} [options.copyOptions.useListItemText] - Copy select or checkbox cell values to 'text'
     *          rather than 'value' of the listItem option.
     *      @param {string|function} [options.copyOptions.customValue] - Copy text with 'formatter' in cell.
     *      @param {boolean} [options.useClientSort=true] - If set to true, sorting will be executed by client itself
     *          without server.
     *      @param {string} [options.editingEvent='dblclick'] - If set to 'click', editable cell in the view-mode will be
     *          changed to edit-mode by a single click.
     *      @param {boolean} [options.scrollX=true] - Specifies whether to show horizontal scrollbar.
     *      @param {boolean} [options.scrollY=true] - Specifies whether to show vertical scrollbar.
     *      @param {boolean} [options.showDummyRows=false] - If set to true, empty area will be filled with dummy rows.
     *      @param {string} [options.keyColumnName] - The name of the column to be used to identify each rows.
     *          If not specified, unique value for each rows will be created internally.
     *      @param {boolean} [options.heightResizable=false] - If set to true, a handle for resizing height will be shown.
     *      @param {string} [options.selectionUnit='cell'] - The unit of selection on Grid. ('cell', 'row')
     *      @param {Array} [options.rowHeaders] - Options for making the row header. The row header content is number of
     *          each row or input element. The value of each item is enable to set string type. (ex: ['rowNum', 'checkbox'])
     *          @param {string} [options.rowHeaders.type] - The type of the row header. ('rowNum', 'checkbox')
     *          @param {string} [options.rowHeaders.header] - The header of the row header.
     *          @param {number} [options.rowHeaders.width] - The width of the row header column. The unit is pixel.
     *              If this value isn't set, the column's width sets to default value.
     *          @param {string} [options.rowHeaders.align=left] - Horizontal alignment of the row header content.
     *              Available values are 'left', 'center', 'right'.
     *          @param {string} [options.rowHeaders.valign=middle] - Vertical alignment of the row header content.
     *              Available values are 'top', 'middle', 'bottom'.
     *          @param {function} [options.rowHeaders.renderer] - Sets the custom renderer to customize the header content.
     *      @param {Array} options.columns - The configuration of the grid columns.
     *          @param {string} options.columns.name - The name of the column.
     *          @param {boolean} [options.columns.ellipsis=false] - If set to true, ellipsis will be used
     *              for overflowing content.(This option will be deprecated)
     *          @param {string} [options.columns.align=left] - Horizontal alignment of the column content.
     *              Available values are 'left', 'center', 'right'.
     *          @param {string} [options.columns.valign=middle] - Vertical alignment of the column content.
     *              Available values are 'top', 'middle', 'bottom'.
     *          @param {string} [options.columns.className] - The name of the class to be used for all cells of
     *              the column.
     *          @param {string} [options.columns.header] - The header of the column to be shown on the header.
     *          @param {number} [options.columns.width] - The width of the column. The unit is pixel. If this value
     *              isn't set, the column's width is automatically resized.
     *          @param {number} [options.columns.minWidth=50] - The minimum width of the column. The unit is pixel.
     *          @param {boolean} [options.columns.hidden] - If set to true, the column will not be shown.
     *          @param {boolean} [options.columns.resizable] - If set to false, the width of the column
     *              will not be changed.
     *          @param {Object} [options.columns.validation] - The options to be used for validation.
     *              Validation is executed whenever data is changed or the {@link Grid#validate} is called.
     *          @param {boolean} [options.columns.validation.required=false] - If set to true, the data of the column
     *              will be checked to be not empty.
     *          @param {number|string} [options.columns.validation.dataType='string'] - Specifies the type of the cell value.
     *              Available types are 'string' and 'number'.
     *          @param {number} [options.columns.validation.min] - If set to numeric value, the data of the column
     *              will be checked to be greater than 'min' value.
     *              Available types are 'string' and 'number'.
     *          @param {number} [options.columns.validation.max] - If set to numeric value, the data of the column
     *              will be checked to be less than 'max' value.
     *          @param {RegExp} [options.columns.validation.regExp] - If set to regular expression, the data of the column
     *              will be checked using the regular expression.
     *          @param {function} [options.columns.validation.validatorFn] - If set to function, the data of the column
     *              will be checked using the result of the custom validator.
     *          @param {boolean} [options.columns.validation.unique] - If set to true, check the uniqueness on the data of the column.
     *          @param {string} [options.columns.defaultValue] - The default value to be shown when the column
     *              doesn't have a value.
     *          @param {function|string} [options.columns.formatter] - The function that formats the value of the cell.
     *              The return value of the function will be shown as the value of the cell. If set to 'listItemText',
     *              the value will be shown the text.
     *          @param {boolean} [options.columns.escapeHTML=false] - If set to true, the value of the cell
     *              will be encoded as HTML entities.
     *          @param {boolean} [options.columns.ignored=false] - If set to true, the value of the column will be
     *               ignored when setting up the list of modified rows.
     *          @param {boolean} [options.columns.sortable=false] - If set to true, sort button will be shown on
     *              the right side of the column header, which executes the sort action when clicked.
     *          @param {string} [options.columns.sortingType='asc'] - If set to 'desc', will execute descending sort initially
     *              when sort button is clicked.
     *          @param {function} [options.columns.comparator] - The custom comparator that sorts the data of the column.
     *              The return value should be same as the result of general 'compareFunction'.
     *          @param {function} [options.columns.onBeforeChange] - The function that will be
     *              called before changing the value of the cell. If stop() method in event object is called,
     *              the changing will be canceled.
     *          @param {function} [options.columns.onAfterChange] - The function that will be
     *              called after changing the value of the cell.
     *          @param {Object} [options.columns.editor] - The object for configuring editing UI.
     *              @param {string|function} [options.columns.editor.type='text'] - The string value that specifies
     *                  the type of the editing UI. Available values are 'text', 'password', 'select', 'radio', 'checkbox'.
     *                  When using the custom editor, sets to the customized renderer constructor.
     *              @param {Object} [options.columns.editor.options] - Option object using editor
     *                  @param {Array} [options.columns.editor.options.listItems] - Specifies the option items for the
     *                       'select', 'radio', 'checkbox' type. The item of the array must contain properties named
     *                       'text' and 'value'. (e.g. [{text: 'option1', value: 1}, {...}])
     *              @param {Object} [options.columns.copyOptions] - Option object for clipboard copying.
     *                  This option is column specific, and overrides the global copyOptions.
     *              @param {boolean} [options.columns.copyOptions.useFormattedValue] - Whether to use
     *                  formatted values or original values as a string to be copied to the clipboard
     *              @param {boolean} [options.columns.copyOptions.useListItemText] - Whether to use
     *                  concatenated text or original values as a string to be copied to the clipboard
     *              @param {function} [options.columns.copyOptions.customValue] - Whether to use
     *                  customized value from "customValue" callback or original values as a string to be copied to the clipboard
     *          @param {Array} [options.columns.relations] - Specifies relation between this and other column.
     *              @param {Array} [options.columns.relations.targetNames] - Array of the names of target columns.
     *              @param {function} [options.columns.relations.disabled] - If returns true, target columns
     *                  will be disabled.
     *              @param {function} [options.columns.relations.editable] - If returns true, target columns
     *                  will be editable.
     *              @param {function} [options.columns.relations.listItems] - The function whose return
     *                  value specifies the option list for the 'select', 'radio', 'checkbox' type.
     *                  The options list of target columns will be replaced with the return value of this function.
     *          @param {string} [options.columns.whiteSpace='nowrap'] - If set to 'normal', the text line is broken
     *              by fitting to the column's width. If set to 'pre', spaces are preserved and the text is braken by
     *              new line characters. If set to 'pre-wrap', spaces are preserved, the text line is broken by
     *              fitting to the column's width and new line characters. If set to 'pre-line', spaces are merged,
     *              the text line is broken by fitting to the column's width and new line characters.(This option will be deprecated)
     *      @param {Object} [options.summary] - The object for configuring summary area.
     *          @param {number} [options.summary.height] - The height of the summary area.
     *          @param {string} [options.summary.position='bottom'] - The position of the summary area. ('bottom', 'top')
     *          @param {(string|Object)} [options.summary.defaultContent]
     *              The configuring of summary cell for every column.
     *              This options can be overriden for each column by columnContent options.
     *              If type is string, the value is used as HTML of summary cell for every columns
     *              without auto-calculation.
     *              @param {boolean} [options.summary.defaultContent.useAutoSummary=true]
     *                  If set to true, the summary value of every column is served as a parameter to the template
     *                  function whenever data is changed.
     *              @param {function} [options.summary.defaultContent.template] - Template function which returns the
     *                  content(HTML) of the column of the summary. This function takes an K-V object as a parameter
     *                  which contains a summary values keyed by 'sum', 'avg', 'min', 'max' and 'cnt'.
     *          @param {Object} [options.summary.columnContent]
     *              The configuring of summary cell for each column.
     *              Sub options below are keyed by each column name.
     *              If type of value of this object is string, the value is used as HTML of summary cell for
     *              the column without auto-calculation.
     *              @param {boolean} [options.summary.columnContent.useAutoSummary=true]
     *                  If set to true, the summary value of each column is served as a parameter to the template
     *                  function whenever data is changed.
     *              @param {function} [options.summary.columnContent.template] - Template function which returns the
     *                  content(HTML) of the column of the summary. This function takes an K-V object as a parameter
     *                  which contains a summary values keyed by 'sum', 'avg', 'min', 'max' and 'cnt'.
     *      @param {boolean} [options.usageStatistics=true] Send the hostname to google analytics.
     *          If you do not want to send the hostname, this option set to false.
     *      @param {function} [options.onGridMounted] - The function that will be called after rendering the grid.
     *      @param {function} [options.onGridUpdated] - The function that will be called after updating the all data of the grid and rendering the grid.
     *      @param {function} [options.onGridBeforeDestroy] - The function that will be called before destroying the grid.
     *      @param {boolean} [options.draggable] - Whether to enable to drag the row for changing the order of rows.
     *      @param {Array} [options.contextMenu] - Option array for the context menu.
     */
    var Grid = /** @class */ (function () {
        function Grid(options) {
            var _this = this;
            var el = options.el, _a = options.usageStatistics, usageStatistics = _a === void 0 ? true : _a;
            var id = instance_1.register(this);
            var store = create_1.createStore(id, options);
            var dispatch = create_2.createDispatcher(store);
            var eventBus = eventBus_1.createEventBus(id);
            var dataProvider = serverSideDataProvider_1.createProvider(store, dispatch, options.data);
            var dataManager = modifiedDataManager_1.createManager();
            var paginationManager = paginationManager_1.createPaginationManager();
            this.el = el;
            this.store = store;
            this.dispatch = dispatch;
            this.eventBus = eventBus;
            this.dataProvider = dataProvider;
            this.dataManager = dataManager;
            this.paginationManager = paginationManager;
            this.usageStatistics = usageStatistics;
            if (this.usageStatistics) {
                googleAnalytics_1.sendHostname();
            }
            instance_1.registerDataSources(id, dataProvider, dataManager, paginationManager);
            if (!manager_1.default.isApplied()) {
                manager_1.default.apply('default');
            }
            if (Array.isArray(options.data)) {
                this.dataManager.setOriginData(options.data);
            }
            var lifeCycleEvent = common_1.pick(options, 'onGridMounted', 'onGridBeforeDestroy', 'onGridUpdated');
            Object.keys(lifeCycleEvent).forEach(function (eventName) {
                _this.eventBus.on(eventName, lifeCycleEvent[eventName]);
            });
            this.gridEl = preact_1.render(preact_1.h(root_1.Root, { store: store, dispatch: dispatch, rootElement: el }), el);
            this.dispatch('setColumnWidthsByText');
        }
        /**
         * Apply theme to all grid instances with the preset options of a given name.
         * @static
         * @param {string} presetName - preset theme name. Available values are 'default', 'striped' and 'clean'.
         * @param {Object} [extOptions] - if exist, extend preset options with this object.
         *     @param {Object} [extOptions.outline] - Styles for the table outline.
         *         @param {string} [extOptions.outline.border] - Color of the table outline.
         *         @param {boolean} [extOptions.outline.showVerticalBorder] - Whether vertical outlines of
         *             the table are visible.
         *     @param {Object} [extOptions.selection] - Styles for a selection layer.
         *         @param {string} [extOptions.selection.background] - Background color of a selection layer.
         *         @param {string} [extOptions.selection.border] - Border color of a selection layer.
         *     @param {Object} [extOptions.scrollbar] - Styles for scrollbars.
         *         @param {string} [extOptions.scrollbar.border] - Border color of scrollbars.
         *         @param {string} [extOptions.scrollbar.background] - Background color of scrollbars.
         *         @param {string} [extOptions.scrollbar.emptySpace] - Color of extra spaces except scrollbar.
         *         @param {string} [extOptions.scrollbar.thumb] - Color of thumbs in scrollbars.
         *         @param {string} [extOptions.scrollbar.active] - Color of arrows(for IE) or
         *              thumb:hover(for other browsers) in scrollbars.
         *     @param {Object} [extOptions.frozenBorder] - Styles for a frozen border.
         *         @param {string} [extOptions.frozenBorder.border] - Border color of a frozen border.
         *     @param {Object} [extOptions.area] - Styles for the table areas.
         *         @param {Object} [extOptions.area.header] - Styles for the header area in the table.
         *             @param {string} [extOptions.area.header.background] - Background color of the header area
         *                 in the table.
         *             @param {string} [extOptions.area.header.border] - Border color of the header area
         *                 in the table.
         *         @param {Object} [extOptions.area.body] - Styles for the body area in the table.
         *             @param {string} [extOptions.area.body.background] - Background color of the body area
         *                 in the table.
         *         @param {Object} [extOptions.area.summary] - Styles for the summary area in the table.
         *             @param {string} [extOptions.area.summary.background] - Background color of the summary area
         *                 in the table.
         *             @param {string} [extOptions.area.summary.border] - Border color of the summary area
         *                 in the table.
         *     @param {Object} [extOptions.row] - Styles for the table rows.
         *         @param {Object} [extOptions.row.even] - Styles for even row.
         *             @param {string} [extOptions.row.even.background] - background color of even row.
         *             @param {string} [extOptions.row.even.text] - text color of even row.
         *         @param {Object} [extOptions.row.odd] - Styles for odd row.
         *             @param {string} [extOptions.row.odd.background] - background color of cells in odd row.
         *             @param {string} [extOptions.row.odd.text] - text color of odd row.
         *         @param {Object} [extOptions.row.dummy] - Styles of dummy row.
         *             @param {string} [extOptions.row.dummy.background] - background color of dummy row.
         *         @param {Object} [extOptions.row.hover] - Styles of hovered row.
         *             @param {string} [extOptions.row.hover.background] - background color of hovered row.
         *     @param {Object} [extOptions.cell] - Styles for the table cells.
         *         @param {Object} [extOptions.cell.normal] - Styles for normal cells.
         *             @param {string} [extOptions.cell.normal.background] - Background color of normal cells.
         *             @param {string} [extOptions.cell.normal.border] - Border color of normal cells.
         *             @param {string} [extOptions.cell.normal.text] - Text color of normal cells.
         *             @param {boolean} [extOptions.cell.normal.showVerticalBorder] - Whether vertical borders of
         *                 normal cells are visible.
         *             @param {boolean} [extOptions.cell.normal.showHorizontalBorder] - Whether horizontal borders of
         *                 normal cells are visible.
         *         @param {Object} [extOptions.cell.header] - Styles for header cells.
         *             @param {string} [extOptions.cell.header.background] - Background color of header cells.
         *             @param {string} [extOptions.cell.header.border] - border color of header cells.
         *             @param {string} [extOptions.cell.header.text] - text color of header cells.
         *             @param {boolean} [extOptions.cell.header.showVerticalBorder] - Whether vertical borders of
         *                 header cells are visible.
         *             @param {boolean} [extOptions.cell.header.showHorizontalBorder] - Whether horizontal borders of
         *                 header cells are visible.
         *         @param {Object} [extOptions.cell.selectedHeader] - Styles for selected header cells.
         *             @param {string} [extOptions.cell.selectedHeader.background] - background color of selected header cells.
         *         @param {Object} [extOptions.cell.rowHeader] - Styles for row's header cells.
         *             @param {string} [extOptions.cell.rowHeader.background] - Background color of row's header cells.
         *             @param {string} [extOptions.cell.rowHeader.border] - border color of row's header cells.
         *             @param {string} [extOptions.cell.rowHeader.text] - text color of row's header cells.
         *             @param {boolean} [extOptions.cell.rowHeader.showVerticalBorder] - Whether vertical borders of
         *                 row's header cells are visible.
         *             @param {boolean} [extOptions.cell.rowHeader.showHorizontalBorder] - Whether horizontal borders of
         *                 row's header cells are visible.
         *         @param {Object} [extOptions.cell.selectedRowHeader] - Styles for selected row's header cells.
         *             @param {string} [extOptions.cell.selectedRowHeader.background] - background color of selected row's haed cells.
         *         @param {Object} [extOptions.cell.summary] - Styles for cells in the summary area.
         *             @param {string} [extOptions.cell.summary.background] - Background color of cells in the summary area.
         *             @param {string} [extOptions.cell.summary.border] - border color of cells in the summary area.
         *             @param {string} [extOptions.cell.summary.text] - text color of cells in the summary area.
         *             @param {boolean} [extOptions.cell.summary.showVerticalBorder] - Whether vertical borders of
         *                 cells in the summary area are visible.
         *             @param {boolean} [extOptions.cell.summary.showHorizontalBorder] - Whether horizontal borders of
         *                 cells in the summary area are visible.
         *         @param {Object} [extOptions.cell.focused] - Styles for a focused cell.
         *             @param {string} [extOptions.cell.focused.background] - background color of a focused cell.
         *             @param {string} [extOptions.cell.focused.border] - border color of a focused cell.
         *         @param {Object} [extOptions.cell.focusedInactive] - Styles for a inactive focus cell.
         *             @param {string} [extOptions.cell.focusedInactive.border] - border color of a inactive focus cell.
         *         @param {Object} [extOptions.cell.required] - Styles for required cells.
         *             @param {string} [extOptions.cell.required.background] - background color of required cells.
         *             @param {string} [extOptions.cell.required.text] - text color of required cells.
         *         @param {Object} [extOptions.cell.editable] - Styles for editable cells.
         *             @param {string} [extOptions.cell.editable.background] - background color of the editable cells.
         *             @param {string} [extOptions.cell.editable.text] - text color of the selected editable cells.
         *         @param {Object} [extOptions.cell.disabled] - Styles for disabled cells.
         *             @param {string} [extOptions.cell.disabled.background] - background color of disabled cells.
         *             @param {string} [extOptions.cell.disabled.text] - text color of disabled cells.
         *         @param {Object} [extOptions.cell.invalid] - Styles for invalid cells.
         *             @param {string} [extOptions.cell.invalid.background] - background color of invalid cells.
         *             @param {string} [extOptions.cell.invalid.text] - text color of invalid cells.
         *         @param {Object} [extOptions.cell.currentRow] - Styles for cells in a current row.(deprecated since version 4.4.0)
         *             @param {string} [extOptions.cell.currentRow.background] - background color of cells in a current row.
         *             @param {string} [extOptions.cell.currentRow.text] - text color of cells in a current row.
         *         @param {Object} [extOptions.cell.evenRow] - Styles for cells in even rows.(deprecated since version 4.4.0)
         *             @param {string} [extOptions.cell.evenRow.background] - background color of cells in even rows.
         *             @param {string} [extOptions.cell.evenRow.text] - text color of cells in even rows.
         *         @param {Object} [extOptions.cell.oddRow] - Styles for cells in even rows.(deprecated since version 4.4.0)
         *             @param {string} [extOptions.cell.oddRow.background] - background color of cells in odd rows.
         *             @param {string} [extOptions.cell.oddRow.text] - text color of cells in odd rows.
         *         @param {Object} [extOptions.cell.dummy] - Styles for dummy cells.(deprecated since version 4.4.0)
         *             @param {string} [extOptions.cell.dummy.background] - background color of dummy cells.
         * @example
         * var Grid = tui.Grid; // or require('tui-grid')
         *
         * Grid.applyTheme('striped', {
         *     grid: {
         *         border: '#aaa',
         *         text: '#333'
         *     },
         *     cell: {
         *         disabled: {
         *             text: '#999'
         *         }
         *     }
         * });
         */
        Grid.applyTheme = function (presetName, extOptions) {
            manager_1.default.apply(presetName, extOptions);
        };
        /**
         * Set language
         * @static
         * @param {string} localeCode - Code to set locale messages and
         *     this is the language or language-region combination (ex: en-US)
         * @param {Object} [data] - Messages using in Grid
         * @example
         * var Grid = tui.Grid; // or require('tui-grid')
         *
         * Grid.setLanguage('en'); // default and set English
         * Grid.setLanguage('ko'); // set Korean
         * Grid.setLanguage('en-US', { // set new language
         *      display: {
         *          noData: 'No data.',
         *          loadingData: 'Loading data.',
         *          resizeHandleGuide: 'You can change the width of the column by mouse drag, ' +
         *                              'and initialize the width by double-clicking.'
         *      },
         *      net: {
         *          confirmCreate: 'Are you sure you want to create {{count}} data?',
         *          confirmUpdate: 'Are you sure you want to update {{count}} data?',
         *          confirmDelete: 'Are you sure you want to delete {{count}} data?',
         *          confirmModify: 'Are you sure you want to modify {{count}} data?',
         *          noDataToCreate: 'No data to create.',
         *          noDataToUpdate: 'No data to update.',
         *          noDataToDelete: 'No data to delete.',
         *          noDataToModify: 'No data to modify.',
         *          failResponse: 'An error occurred while requesting data.\nPlease try again.'
         *      }
         * });
         */
        Grid.setLanguage = function (localeCode, data) {
            i18n_1.default.setLanguage(localeCode, data);
        };
        /**
         * Set the width of the dimension.
         * @param {number} width - The width of the dimension
         */
        Grid.prototype.setWidth = function (width) {
            this.dispatch('setWidth', width, false);
        };
        /**
         * Set the height of the dimension.
         * @param {number} height - The height of the dimension
         */
        Grid.prototype.setHeight = function (height) {
            this.dispatch('setHeight', height);
        };
        /**
         * Set the height of body-area.
         * @param {number} bodyHeight - The number of pixel
         */
        Grid.prototype.setBodyHeight = function (bodyHeight) {
            this.dispatch('setBodyHeight', bodyHeight);
        };
        /**
         * Set options for header.
         * @param {Object} options - Options for header
         * @param {number} [options.height] -  The height value
         * @param {Array} [options.complexColumns] - The complex columns info
         */
        Grid.prototype.setHeader = function (_a) {
            var height = _a.height, complexColumns = _a.complexColumns;
            if (height) {
                this.dispatch('setHeaderHeight', height);
            }
            if (complexColumns) {
                this.dispatch('setComplexColumnHeaders', complexColumns);
            }
        };
        /**
         * Set the count of frozen columns.
         * @param {number} count - The count of columns to be frozen
         */
        Grid.prototype.setFrozenColumnCount = function (count) {
            this.dispatch('setFrozenColumnCount', count);
        };
        /**
         * Hide columns
         * @param {...string} arguments - Column names to hide
         */
        Grid.prototype.hideColumn = function (columnName) {
            this.dispatch('hideColumn', columnName);
        };
        /**
         * Show columns
         * @param {...string} arguments - Column names to show
         */
        Grid.prototype.showColumn = function (columnName) {
            this.dispatch('showColumn', columnName);
        };
        /**
         * Select cells or rows by range
         * @param {Object} range - Selection range
         *     @param {Array} [range.start] - Index info of start selection (ex: [rowIndex, columnIndex])
         *     @param {Array} [range.end] - Index info of end selection (ex: [rowIndex, columnIndex])
         */
        Grid.prototype.setSelectionRange = function (range) {
            this.dispatch('setSelection', range);
        };
        /**
         * get Selection range
         * @returns {Object | null} range - Selection range
         *     @returns {Array} [range.start] - Index info of start selection (ex: [rowIndex, columnIndex])
         *     @returns {Array} [range.end] - Index info of end selection (ex: [rowIndex, columnIndex])
         */
        Grid.prototype.getSelectionRange = function () {
            var rangeWithRowHeader = this.store.selection.rangeWithRowHeader;
            if (rangeWithRowHeader) {
                var column = rangeWithRowHeader.column, row = rangeWithRowHeader.row;
                return {
                    start: [row[0], column[0]],
                    end: [row[1], column[1]],
                };
            }
            return null;
        };
        /**
         * Return data of currently focused cell
         * @returns {number|string} rowKey - The unique key of the row
         * @returns {string} columnName - The name of the column
         * @returns {string} value - The value of the cell
         */
        Grid.prototype.getFocusedCell = function () {
            var _a = this.store.focus, columnName = _a.columnName, rowKey = _a.rowKey;
            var value = null;
            if (rowKey !== null && columnName !== null) {
                value = this.getValue(rowKey, columnName);
            }
            return { rowKey: rowKey, columnName: columnName, value: value };
        };
        /**
         * Remove focus from the focused cell.
         */
        Grid.prototype.blur = function () {
            this.dispatch('setFocusInfo', null, null, false);
        };
        /**
         * Focus to the cell identified by given rowKey and columnName.
         * @param {Number|String} rowKey - rowKey
         * @param {String} columnName - columnName
         * @param {Boolean} [setScroll=true] - if set to true, move scroll position to focused position
         * @returns {Boolean} true if focused cell is changed
         */
        Grid.prototype.focus = function (rowKey, columnName, setScroll) {
            var _this = this;
            if (setScroll === void 0) { setScroll = true; }
            var row = this.getRow(rowKey);
            if (!row || !data_1.getRowHeight(row, this.store.dimension.rowHeight)) {
                return false;
            }
            this.dispatch('setFocusInfo', rowKey, columnName, true);
            if (setScroll) {
                // Use setTimeout to wait until the DOM element is actually mounted or updated.
                // For example, when expands the tree row at bottom of the grid area with scroll,
                // grid needs to wait for mounting the expanded tree DOM element to detect the accurate scrolling position.
                setTimeout(function () {
                    _this.dispatch('setScrollToFocus');
                });
            }
            return true;
        };
        /**
         * Focus to the cell identified by given rowIndex and columnIndex.
         * @param {Number} rowIndex - rowIndex
         * @param {Number} columnIndex - columnIndex
         * @param {boolean} [setScroll=true] - if set to true, scroll to focused cell
         * @returns {Boolean} true if success
         */
        Grid.prototype.focusAt = function (rowIndex, columnIndex, setScroll) {
            var _a = data_1.getCellAddressByIndex(this.store, rowIndex, columnIndex), rowKey = _a.rowKey, columnName = _a.columnName;
            if (!common_1.isUndefined(rowKey) && columnName) {
                return this.focus(rowKey, columnName, setScroll);
            }
            return false;
        };
        /**
         * Make view ready to get keyboard input.
         */
        Grid.prototype.activateFocus = function () {
            this.dispatch('setNavigating', true);
        };
        /**
         * Set focus on the cell at the specified index of row and column and starts to edit.
         * @param {number|string} rowKey - The unique key of the row
         * @param {string} columnName - The name of the column
         * @param {boolean} [setScroll=true] - If set to true, the view will scroll to the cell element.
         */
        Grid.prototype.startEditing = function (rowKey, columnName, setScroll) {
            if (this.focus(rowKey, columnName, setScroll)) {
                if (this.store.focus.rowKey === rowKey && this.store.focus.columnName === columnName) {
                    this.dispatch('startEditing', rowKey, columnName);
                }
            }
        };
        /**
         * Set focus on the cell at the specified index of row and column and starts to edit.
         * @param {number|string} rowIndex - The index of the row
         * @param {string} columnIndex - The index of the column
         * @param {boolean} [setScroll=true] - If set to true, the view will scroll to the cell element.
         */
        Grid.prototype.startEditingAt = function (rowIndex, columnIndex, setScroll) {
            var _a = data_1.getCellAddressByIndex(this.store, rowIndex, columnIndex), rowKey = _a.rowKey, columnName = _a.columnName;
            this.startEditing(rowKey, columnName, setScroll);
        };
        /**
         * Save editing value and finishes to edit.
         */
        Grid.prototype.finishEditing = function (rowKey, columnName, value) {
            // @TODO: should change the function signature as removing all current paramaters.
            // The signature will be as below.
            // ex) finishEditing()
            this.dispatch('saveAndFinishEditing', value);
        };
        /**
         * Cancel the editing.
         */
        Grid.prototype.cancelEditing = function () {
            var editingAddress = this.store.focus.editingAddress;
            if (editingAddress) {
                var rowKey = editingAddress.rowKey, columnName = editingAddress.columnName;
                var value = this.getValue(rowKey, columnName);
                this.dispatch('finishEditing', rowKey, columnName, value, { save: false });
            }
        };
        /**
         * Set the value of the cell identified by the specified rowKey and columnName.
         * @param {number|string} rowKey - The unique key of the row
         * @param {string} columnName - The name of the column
         * @param {number|string} value - The value to be set
         * @param {boolean} [checkCellState=false] - If set to true, only editable and not disabled cells will be affected.
         */
        Grid.prototype.setValue = function (rowKey, columnName, value, checkCellState) {
            this.dispatch('setValue', rowKey, columnName, value, checkCellState);
        };
        /**
         * Return the value of the cell identified by the rowKey and columnName.
         * @param {number|string} rowKey - The unique key of the target row.
         * @param {string} columnName - The name of the column
         * @returns {number|string|boolean|null} - The value of the cell
         */
        Grid.prototype.getValue = function (rowKey, columnName) {
            var _a;
            var _b = this.store, data = _b.data, column = _b.column, id = _b.id;
            var targetRow = data_1.findRowByRowKey(data, column, id, rowKey, false);
            if (targetRow) {
                return (_a = targetRow[columnName]) !== null && _a !== void 0 ? _a : null;
            }
            return null;
        };
        /**
         * Set the all values in the specified column.
         * @param {string} columnName - The name of the column
         * @param {number|string} columnValue - The value to be set
         * @param {boolean} [checkCellState=false] - If set to true, only editable and not disabled cells will be affected.
         */
        Grid.prototype.setColumnValues = function (columnName, columnValue, checkCellState) {
            this.dispatch('setColumnValues', columnName, columnValue, checkCellState);
        };
        /**
         * Return the HTMLElement of the cell identified by the rowKey and columnName.
         * @param {number|string} rowKey - The unique key of the row
         * @param {string} columnName - The name of the column
         * @returns {HTMLElement} - The HTMLElement of the cell element
         */
        Grid.prototype.getElement = function (rowKey, columnName) {
            return this.el.querySelector("." + dom_1.cls('cell') + "[" + dom_1.dataAttr.ROW_KEY + "=\"" + rowKey + "\"][" + dom_1.dataAttr.COLUMN_NAME + "=\"" + columnName + "\"]");
        };
        /**
         * Set the HTML string of given column summary.
         * The type of content is the same as the options.summary.columnContent of the constructor.
         * @param {string} columnName - column name
         * @param {string|object} columnContent - HTML string or options object.
         */
        Grid.prototype.setSummaryColumnContent = function (columnName, columnContent) {
            this.dispatch('setSummaryColumnContent', columnName, columnContent);
        };
        /**
         * Return the values of given column summary.
         * If the column name is not specified, all values of available columns are returned.
         * The shape of returning object looks like the example below.
         * @param {string} [columnName] - column name
         * @returns {Object}
         * @example
         * {
         *     sum: 1000,
         *     avg: 200,
         *     max: 300,
         *     min: 50,
         *     cnt: 5,
         *     filtered: {
         *       sum: 1000,
         *       avg: 200,
         *       max: 300,
         *       min: 50,
         *       cnt: 5
         *     }
         * }
         */
        Grid.prototype.getSummaryValues = function (columnName) {
            var summary = this.store.summary;
            var content = summary.summaryColumnContents[columnName];
            if (content && content.useAutoSummary) {
                return summary.summaryValues[columnName];
            }
            return null;
        };
        /**
         * Return a list of the column model.
         * @returns {Array} - A list of the column model.
         */
        Grid.prototype.getColumns = function () {
            return this.store.column.allColumns
                .filter(function (_a) {
                var name = _a.name;
                return !column_1.isRowHeader(name);
            })
                .map(function (column) { return observable_1.getOriginObject(column); });
        };
        /**
         * Set the list of column model.
         * @param {Array} columns - A new list of column model
         */
        Grid.prototype.setColumns = function (columns) {
            this.dispatch('setColumns', columns);
        };
        /**
         * Set columns title
         * @param {Object} columnsMap - columns map to be change
         * @example
         * {
         *      columnName1: 'title1',
         *      columnName2: 'title2',
         *      columnName3: 'title3'
         * }
         */
        Grid.prototype.setColumnHeaders = function (columnsMap) {
            this.dispatch('changeColumnHeadersByName', columnsMap);
        };
        /**
         * Reset the width of each column by using initial setting of column models.
         */
        Grid.prototype.resetColumnWidths = function (widths) {
            this.dispatch('resetColumnWidths', widths);
        };
        /**
         * Return a list of all values in the specified column.
         * @param {string} columnName - The name of the column
         * @returns {(Array|string)} - A List of all values in the specified column. (or JSON string of the list)
         */
        Grid.prototype.getColumnValues = function (columnName) {
            return common_1.mapProp(columnName, this.store.data.rawData);
        };
        /**
         * Return the index of the column indentified by the column name.
         * @param {string} columnName - The unique key of the column
         * @returns {number} - The index of the column
         */
        Grid.prototype.getIndexOfColumn = function (columnName) {
            return common_1.findPropIndex('name', columnName, this.store.column.allColumns.filter(function (_a) {
                var name = _a.name;
                return !column_1.isRowHeader(name);
            }));
        };
        /**
         * Check the row identified by the specified rowKey.
         * @param {number|string} rowKey - The unique key of the row
         */
        Grid.prototype.check = function (rowKey) {
            this.dispatch('check', rowKey);
        };
        /**
         * Uncheck the row identified by the specified rowKey.
         * @param {number|string} rowKey - The unique key of the row
         */
        Grid.prototype.uncheck = function (rowKey) {
            this.dispatch('uncheck', rowKey);
        };
        /**
         * Check all rows.
         * @param {boolean} [allPage] - check all rows when using pagination. The default value is 'true'.
         */
        Grid.prototype.checkAll = function (allPage) {
            this.dispatch('checkAll', allPage);
        };
        /**
         * Uncheck all rows.
         * @param {boolean} [allPage] - Uncheck all rows when using pagination. The default value is 'true'.
         */
        Grid.prototype.uncheckAll = function (allPage) {
            this.dispatch('uncheckAll', allPage);
        };
        /**
         * Return a list of the rowKey of checked rows.
         * @returns {Array.<string|number>} - A list of the rowKey.
         */
        Grid.prototype.getCheckedRowKeys = function () {
            var rows = data_1.getCheckedRowInfoList(this.store).rows;
            return rows.map(function (_a) {
                var rowKey = _a.rowKey;
                return rowKey;
            });
        };
        /**
         * Return a list of the checked rows.
         * @returns {Array.<object>} - A list of the checked rows.
         */
        Grid.prototype.getCheckedRows = function () {
            var rows = data_1.getCheckedRowInfoList(this.store).rows;
            return rows.map(function (row) { return observable_1.getOriginObject(row); });
        };
        /**
         * Find rows by conditions
         * @param {Object|Function} conditions - object (key: column name, value: column value) or
         *     function that check the value and returns true/false result to find rows
         * @returns {Array} Row list
         * @example <caption>Conditions type is object.</caption>
         * grid.findRows({
         *     artist: 'Birdy',
         *     price: 10000
         * });
         * @example <caption>Conditions type is function.</caption>
         * grid.findRows((row) => {
         *     return (/b/ig.test(row.artist) && row.price > 10000);
         * });
         */
        Grid.prototype.findRows = function (conditions) {
            return data_1.getConditionalRows(this.store, conditions);
        };
        /**
         * Sort all rows by the specified column.
         * @param {string} columnName - The name of the column to be used to compare the rows
         * @param {boolean} [ascending] - Whether the sort order is ascending.
         *        If not specified, use the negative value of the current order.
         * @param {boolean} [multiple] - Whether using multiple sort
         */
        Grid.prototype.sort = function (columnName, ascending, multiple) {
            if (this.store.data.sortState.useClient) {
                this.dispatch('sort', columnName, ascending, multiple, false);
            }
            else {
                // @TODO: apply multi sort to dataSource
                this.dataProvider.sort(columnName, ascending, false);
            }
        };
        /**
         * If the parameter exists, unsort only column with columnName. If not exist, unsort all rows
         * @param {string} [columnName] - The name of the column to be used to compare the rows
         */
        Grid.prototype.unsort = function (columnName) {
            if (this.store.data.sortState.useClient) {
                this.dispatch('unsort', columnName);
            }
            else {
                this.dataProvider.unsort(columnName);
            }
        };
        /**
         * Get state of the sorted column in rows
         * @returns {{columns: [{columnName: string, ascending: boolean}], useClient: boolean}} Sorted column's state
         */
        Grid.prototype.getSortState = function () {
            return common_1.deepCopy(this.store.data.sortState);
        };
        /**
         * Copy to clipboard
         */
        Grid.prototype.copyToClipboard = function () {
            clipboard_1.execCopy(this.store);
        };
        /**
         * Validate all data and returns the result.
         * Return value is an array which contains only rows which have invalid cell data.
         * @returns {Array.<Object>} An array of error object
         * @example
         * // return value example
         * [
         *     {
         *         rowKey: 1,
         *         errors: [
         *             {
         *                 columnName: 'c1',
         *                 errorCode: ['REQUIRED'],
         *                 errorInfo: [{ code: 'REQUIRED' }]
         *             },
         *             {
         *                 columnName: 'c2',
         *                 errorCode: ['VALIDATOR_FN'],
         *                 errorInfo: [{ code: 'VALIDATOR_FN', customCode: 'CUSTOM_CODE' }]
         *             }
         *         ]
         *     },
         *     {
         *         rowKey: 3,
         *         errors: [
         *             {
         *                 columnName: 'c2',
         *                 errorCode: ['MIN'],
         *                 errorInfo: [{ code: 'MIN', min: 1000 }]
         *             }
         *         ]
         *     }
         * ]
         */
        Grid.prototype.validate = function () {
            return validation_1.getInvalidRows(this.store);
        };
        /**
         * Enable all rows.
         */
        Grid.prototype.enable = function () {
            this.dispatch('setDisabled', false);
        };
        /**
         * Disable all rows.
         */
        Grid.prototype.disable = function () {
            this.dispatch('setDisabled', true);
        };
        /**
         * Disable the row identified by the rowkey.
         * @param {number|string} rowKey - The unique key of the target row
         * @param {boolean} [withCheckbox] - change including checkbox. The default value is 'true'
         */
        Grid.prototype.disableRow = function (rowKey, withCheckbox) {
            if (withCheckbox === void 0) { withCheckbox = true; }
            this.dispatch('setRowDisabled', true, rowKey, withCheckbox);
        };
        /**
         * Enable the row identified by the rowKey.
         * @param {number|string} rowKey - The unique key of the target row
         * @param {boolean} [withCheckbox] - change including checkbox. The default value is 'true'
         */
        Grid.prototype.enableRow = function (rowKey, withCheckbox) {
            if (withCheckbox === void 0) { withCheckbox = true; }
            this.dispatch('setRowDisabled', false, rowKey, withCheckbox);
        };
        /**
         * Disable the row identified by the specified rowKey to not be able to check.
         * @param {number|string} rowKey - The unique keyof the row.
         */
        Grid.prototype.disableRowCheck = function (rowKey) {
            this.dispatch('setRowCheckDisabled', true, rowKey);
        };
        /**
         * Enable the row identified by the rowKey to be able to check.
         * @param {number|string} rowKey - The unique key of the row
         */
        Grid.prototype.enableRowCheck = function (rowKey) {
            this.dispatch('setRowCheckDisabled', false, rowKey);
        };
        /**
         * Disable the column identified by the column name.
         * @param {string} columnName - column name
         */
        Grid.prototype.disableColumn = function (columnName) {
            this.dispatch('setColumnDisabled', true, columnName);
        };
        /**
         * Enable the column identified by the column name.
         * @param {string} columnName - column name
         */
        Grid.prototype.enableColumn = function (columnName) {
            this.dispatch('setColumnDisabled', false, columnName);
        };
        /**
         * Insert the new row with specified data to the end of table.
         * @param {Object} [row] - The data for the new row
         * @param {Object} [options] - Options
         * @param {number} [options.at] - The index at which new row will be inserted
         * @param {boolean} [options.extendPrevRowSpan] - If set to true and the previous row at target index
         *        has a rowspan data, the new row will extend the existing rowspan data.
         * @param {boolean} [options.focus] - If set to true, move focus to the new row after appending
         * @param {number|string} [options.parentRowKey] - Deprecated: Tree row key of the parent which appends given rows
         */
        Grid.prototype.appendRow = function (row, options) {
            if (row === void 0) { row = {}; }
            if (options === void 0) { options = {}; }
            var treeColumnName = this.store.column.treeColumnName;
            if (treeColumnName) {
                var offset = options.at, focus = options.focus, parentRowKey = options.parentRowKey;
                this.dispatch('appendTreeRow', row, { offset: offset, focus: focus, parentRowKey: parentRowKey });
            }
            else {
                this.dispatch('appendRow', row, options);
            }
            if (options.focus) {
                var rowIdx = common_1.isUndefined(options.at) ? this.getRowCount() - 1 : options.at;
                this.focusAt(rowIdx, 0);
            }
        };
        /**
         * Insert the new row with specified data to the beginning of table.
         * @param {Object} [row] - The data for the new row
         * @param {Object} [options] - Options
         * @param {boolean} [options.focus] - If set to true, move focus to the new row after appending
         */
        Grid.prototype.prependRow = function (row, options) {
            if (options === void 0) { options = {}; }
            this.appendRow(row, tslib_1.__assign(tslib_1.__assign({}, options), { at: 0 }));
        };
        /**
         * Remove the row identified by the specified rowKey.
         * @param {number|string} rowKey - The unique key of the row
         * @param {boolean} [options.removeOriginalData] - If set to true, the original data will be removed.
         * @param {boolean} [options.keepRowSpanData] - If set to true, the value of the merged cells will not be
         *     removed although the target is first cell of them.
         */
        Grid.prototype.removeRow = function (rowKey, options) {
            if (options === void 0) { options = {}; }
            var treeColumnName = this.store.column.treeColumnName;
            if (treeColumnName) {
                this.removeTreeRow(rowKey);
            }
            else {
                this.dispatch('removeRow', rowKey, options);
            }
        };
        /**
         * Return the object that contains all values in the specified row.
         * @param {number|string} rowKey - The unique key of the target row
         * @returns {Object} - The object that contains all values in the row.
         */
        Grid.prototype.getRow = function (rowKey) {
            return this.getRowAt(this.getIndexOfRow(rowKey));
        };
        /**
         * Return the object that contains all values in the row at specified index.
         * @param {number} rowIdx - The index of the row
         * @returns {Object} - The object that contains all values in the row.
         */
        Grid.prototype.getRowAt = function (rowIdx) {
            var row = this.store.data.rawData[rowIdx];
            return row ? observable_1.getOriginObject(row) : null;
        };
        /**
         * Return the index of the row indentified by the rowKey.
         * @param {number|string} rowKey - The unique key of the row
         * @returns {number} - The index of the row
         */
        Grid.prototype.getIndexOfRow = function (rowKey) {
            var _a = this.store, data = _a.data, column = _a.column, id = _a.id;
            return data_1.findIndexByRowKey(data, column, id, rowKey, false);
        };
        /**
         * Return a list of all rows.
         * @returns {Array} - A list of all rows
         */
        Grid.prototype.getData = function () {
            return this.store.data.rawData.map(function (row) { return data_1.getOmittedInternalProp(row); });
        };
        /**
         * Return the total number of the rows.
         * @returns {number} - The total number of the rows
         */
        Grid.prototype.getRowCount = function () {
            return this.store.data.rawData.length;
        };
        /**
         * Remove all rows.
         */
        Grid.prototype.clear = function () {
            this.dispatch('clearData');
        };
        /**
         * Replace all rows with the specified list. This will not change the original data.
         * @param {Array} data - A list of new rows
         * @param {Object} [options] - Options
         *     @param {Object} [options.sortState] - If set the sortState, the sort state will be applied when the new rows are set.
         *       It is recommended that you do not use it unless you are getting the sorted data by communicating with the server without DataSource.
         *         @param {string} [options.sortState.columnName] - Target column name.
         *         @param {boolean} [options.sortState.ascending] - The ascending state of specific column which will apply to the grid.
         *         @param {boolean} [options.sortState.multiple] - Whether to use multiple sorting.
         *     @param {Object} [options.filterState] - If set the filterState, the filter state will be applied when the new rows are set.
         *       It is recommended that you do not use it unless you are getting the filtered data by communicating with the server without DataSource.
         *         @param {string} [options.filterState.columnName] - Target column name.
         *         @param {Object} [options.filterState.columnFilterState] - The column filter state of column which will apply to the grid.
         *             @param {string} [options.filterState.columnFilterState.code] - Code for column filter(ex. 'eq', 'gt').
         *             @param {string} [options.filterState.columnFilterState.value] - Input value for column filter.
         *     @param {Object} [options.pageState] - If set the pageState, the pagination state will be applied when the new rows are set.
         *       It is recommended that you do not use it unless you are getting the paginated data by communicating with the server without DataSource.
         *         @param {number} [options.pageState.page] - Target page number.
         *         @param {number} [options.pageState.totalCount] - The total pagination count.
         *         @param {number} [options.pageState.perPage] - Number of rows per page.
         */
        Grid.prototype.resetData = function (data, options) {
            if (options === void 0) { options = {}; }
            this.dispatch('resetData', data, options);
        };
        /**
         * Add the specified css class to cell element identified by the rowKey and className
         * @param {number|string} rowKey - The unique key of the row
         * @param {string} columnName - The name of the column
         * @param {string} className - The css class name to add
         */
        Grid.prototype.addCellClassName = function (rowKey, columnName, className) {
            this.dispatch('addCellClassName', rowKey, columnName, className);
        };
        /**
         * Add the specified css class to all cell elements in the row identified by the rowKey
         * @param {number|string} rowKey - The unique key of the row
         * @param {string} className - The css class name to add
         */
        Grid.prototype.addRowClassName = function (rowKey, className) {
            this.dispatch('addRowClassName', rowKey, className);
        };
        /**
         * Remove the specified css class from the cell element indentified by the rowKey and columnName.
         * @param {number|string} rowKey - The unique key of the row
         * @param {string} columnName - The name of the column
         * @param {string} className - The css class name to be removed
         */
        Grid.prototype.removeCellClassName = function (rowKey, columnName, className) {
            this.dispatch('removeCellClassName', rowKey, columnName, className);
        };
        /**
         * Remove the specified css class from all cell elements in the row identified by the rowKey.
         * @param {number|string} rowKey - The unique key of the row
         * @param {string} className - The css class name to be removed
         */
        Grid.prototype.removeRowClassName = function (rowKey, className) {
            this.dispatch('removeRowClassName', rowKey, className);
        };
        /**
         * Add custom event to grid.
         * @param {string} eventName - custom event name
         * @param {function} fn - event handler
         */
        Grid.prototype.on = function (eventName, fn) {
            this.eventBus.on(eventName, fn);
        };
        /**
         * Remove custom event to grid.
         * @param {string} eventName - custom event name
         * @param {function} fn - event handler
         */
        Grid.prototype.off = function (eventName, fn) {
            this.eventBus.off(eventName, fn);
        };
        /**
         * Return an instance of tui.Pagination.
         * @deprecated
         * @returns {tui.Pagination}
         */
        Grid.prototype.getPagination = function () {
            return this.paginationManager.getPagination();
        };
        /**
         * Set number of rows per page and reload current page
         * @param {number} perPage - Number of rows per page
         * @param {Params} data - Data(parameters) to send to the server
         */
        Grid.prototype.setPerPage = function (perPage, data) {
            var pagination = this.getPagination();
            if (pagination) {
                var pageOptions = this.store.data.pageOptions;
                if (pageOptions.useClient) {
                    this.dispatch('updatePageOptions', { perPage: perPage, page: 1 });
                    this.dispatch('updateHeights');
                }
                else {
                    this.readData(1, tslib_1.__assign(tslib_1.__assign({}, data), { perPage: perPage }));
                }
            }
        };
        /**
         * Return true if there are at least one row modified.
         * @returns {boolean} - True if there are at least one row modified.
         */
        Grid.prototype.isModified = function () {
            return this.dataManager.isModified();
        };
        /**
         * Return the object that contains the lists of changed data compared to the original data.
         * The object has properties 'createdRows', 'updatedRows', 'deletedRows'.
         * @param {Object} [options] Options
         *     @param {boolean} [options.checkedOnly=false] - If set to true, only checked rows will be considered.
         *     @param {boolean} [options.withRawData=false] - If set to true, the data will contains
         *         the row data for internal use.
         *     @param {boolean} [options.rowKeyOnly=false] - If set to true, only keys of the changed
         *         rows will be returned.
         *     @param {Array} [options.ignoredColumns] - A list of column name to be excluded.
         * @returns {{createdRows: Array, updatedRows: Array, deletedRows: Array}} - Object that contains the result list.
         */
        Grid.prototype.getModifiedRows = function (options) {
            if (options === void 0) { options = {}; }
            var ignoredColumns = options.ignoredColumns;
            var originIgnoredColumns = this.store.column.ignoredColumns;
            options.ignoredColumns = Array.isArray(ignoredColumns)
                ? ignoredColumns.concat(originIgnoredColumns)
                : originIgnoredColumns;
            return this.dataManager.getAllModifiedData(options);
        };
        /**
         * Request 'readData' to the server. The last requested data will be extended with new data.
         * @param {Number} page - Page number
         * @param {Object} data - Data(parameters) to send to the server
         * @param {Boolean} resetData - If set to true, last requested data will be ignored.
         */
        Grid.prototype.readData = function (page, data, resetData) {
            if (data && data.sortColumn) {
                this.dataProvider.sort(data.sortColumn, data.sortAscending, false);
            }
            else {
                this.dataProvider.readData(page, data, resetData);
            }
        };
        /**
         * Send request to server to sync data
         * @param {String} requestType - 'createData|updateData|deleteData|modifyData'
         * @param {object} options - Options
         *      @param {String} [options.url] - URL to send the request
         *      @param {String} [options.method] - method to send the request
         *      @param {boolean} [options.checkedOnly=false] - Whether the request param only contains checked rows
         *      @param {boolean} [options.modifiedOnly=true] - Whether the request param only contains modified rows
         *      @param {boolean} [options.showConfirm=true] - Whether to show confirm dialog before sending request
         *      @param {boolean} [options.withCredentials=false] - Use withCredentials flag of XMLHttpRequest for ajax requests if true
         */
        Grid.prototype.request = function (requestType, options) {
            if (options === void 0) { options = {}; }
            this.dataProvider.request(requestType, options);
        };
        /**
         * Request 'readData' with last requested data.
         */
        Grid.prototype.reloadData = function () {
            this.dataProvider.reloadData();
        };
        /**
         * Restore the data to the original data.
         * (Original data is set by {@link Grid#resetData|resetData}
         */
        Grid.prototype.restore = function () {
            this.resetData(this.dataManager.getOriginData());
        };
        /**
         * Insert the new tree row with specified data.
         * @param {Object} [row] - The tree data for the new row
         * @param {Object} [options] - Options
         * @param {number|string} [options.parentRowKey] - Tree row key of the parent which appends given rows
         * @param {number} [options.offset] - The offset value to insert new tree row
         * @param {boolean} [options.focus] - If set to true, move focus to the new tree row after appending
         */
        Grid.prototype.appendTreeRow = function (row, options) {
            if (row === void 0) { row = {}; }
            if (options === void 0) { options = {}; }
            var treeColumnName = this.store.column.treeColumnName;
            var parentRowKey = options.parentRowKey;
            if (!treeColumnName || common_1.isUndefined(parentRowKey)) {
                return;
            }
            this.dispatch('appendTreeRow', row, options);
            if (options.focus) {
                var offset = options.offset;
                var childRows = tree_1.getChildRows(this.store, parentRowKey);
                if (childRows.length) {
                    var rowKey = (common_1.isUndefined(offset)
                        ? childRows[childRows.length - 1]
                        : childRows[offset]).rowKey;
                    var rowIdx = this.getIndexOfRow(rowKey);
                    this.focusAt(rowIdx, 0);
                }
            }
        };
        /**
         * Remove the tree row identified by the specified rowKey.
         * @param {number|string} rowKey - The unique key of the row
         */
        Grid.prototype.removeTreeRow = function (rowKey) {
            var treeColumnName = this.store.column.treeColumnName;
            if (treeColumnName) {
                this.dispatch('removeTreeRow', rowKey);
            }
        };
        /**
         * Expand tree row.
         * @param {number|string} rowKey - The unique key of the row
         * @param {boolean} recursive - true for recursively expand all descendant
         */
        Grid.prototype.expand = function (rowKey, recursive) {
            this.dispatch('expandByRowKey', rowKey, recursive);
        };
        /**
         * Expand all tree row.
         */
        Grid.prototype.expandAll = function () {
            this.dispatch('expandAll');
        };
        /**
         * Expand tree row.
         * @param {number|string} rowKey - The unique key of the row
         * @param {boolean} recursive - true for recursively expand all descendant
         */
        Grid.prototype.collapse = function (rowKey, recursive) {
            this.dispatch('collapseByRowKey', rowKey, recursive);
        };
        /**
         * Collapse all tree row.
         */
        Grid.prototype.collapseAll = function () {
            this.dispatch('collapseAll');
        };
        /**
         * Get the parent of the row which has the given row key.
         * @param {number|string} rowKey - The unique key of the row
         * @returns {Object} - the parent row
         */
        Grid.prototype.getParentRow = function (rowKey) {
            return tree_1.getParentRow(this.store, rowKey, true);
        };
        /**
         * Get the children of the row which has the given row key.
         * @param {number|string} rowKey - The unique key of the row
         * @returns {Array.<Object>} - the children rows
         */
        Grid.prototype.getChildRows = function (rowKey) {
            return tree_1.getChildRows(this.store, rowKey, true);
        };
        /**
         * Get the ancestors of the row which has the given row key.
         * @param {number|string} rowKey - The unique key of the row
         * @returns {Array.<TreeRow>} - the ancestor rows
         */
        Grid.prototype.getAncestorRows = function (rowKey) {
            return tree_1.getAncestorRows(this.store, rowKey);
        };
        /**
         * Get the descendants of the row which has the given row key.
         * @param {number|string} rowKey - The unique key of the row
         * @returns {Array.<Object>} - the descendant rows
         */
        Grid.prototype.getDescendantRows = function (rowKey) {
            return tree_1.getDescendantRows(this.store, rowKey);
        };
        /**
         * Get the depth of the row which has the given row key.
         * @param {number|string} rowKey - The unique key of the row
         * @returns {number} - the depth
         */
        Grid.prototype.getDepth = function (rowKey) {
            var _a = this.store, data = _a.data, column = _a.column, id = _a.id;
            var rawData = data.rawData;
            var row = data_1.findRowByRowKey(data, column, id, rowKey);
            return row ? tree_1.getDepth(rawData, row) : 0;
        };
        /**
         * Return the rowspan data of the cell identified by the rowKey and columnName.
         * @param {number|string} rowKey - The unique key of the row
         * @param {string} columnName - The name of the column
         * @returns {Object} - Row span data
         */
        Grid.prototype.getRowSpanData = function (rowKey, columnName) {
            return rowSpan_1.getRowSpanByRowKey(rowKey, columnName, this.store.data.rawData);
        };
        /**
         * reset original data to current data.
         * (Original data is set by {@link Grid#resetData|resetData}
         */
        Grid.prototype.resetOriginData = function () {
            this.dataManager.setOriginData(this.store.data.rawData);
        };
        /** Remove all checked rows.
         * @param {boolean} [showConfirm] - If set to true, confirm message will be shown before remove.
         * @returns {boolean} - True if there's at least one row removed.
         */
        Grid.prototype.removeCheckedRows = function (showConfirm) {
            var checkedRowInfoList = data_1.getCheckedRowInfoList(this.store);
            var deletedCount = checkedRowInfoList.rows.length;
            var confirmMessage = message_1.getConfirmMessage('DELETE', deletedCount);
            if (deletedCount > 0 && (!showConfirm || confirm(confirmMessage))) {
                this.dispatch('removeRows', checkedRowInfoList);
                return true;
            }
            return false;
        };
        /**
         * Refresh the layout view. Use this method when the view was rendered while hidden.
         */
        Grid.prototype.refreshLayout = function () {
            var containerEl = this.el.querySelector("." + dom_1.cls('container'));
            var parentElement = this.el.parentElement;
            this.dispatch('refreshLayout', containerEl, parentElement);
        };
        /**
         * Destroy the instance.
         */
        Grid.prototype.destroy = function () {
            preact_1.render('', this.el, this.gridEl);
            for (var key in this) {
                if (common_1.hasOwnProp(this, key)) {
                    delete this[key];
                }
            }
        };
        /**
         * Set the option of column filter.
         * @param {string} columnName - columnName
         * @param {string | FilterOpt} filterOpt - filter type
         */
        Grid.prototype.setFilter = function (columnName, filterOpt) {
            this.dispatch('setFilter', columnName, filterOpt);
        };
        /**
         * Get filter state.
         * @returns {Array.<FilterState>} - filter state
         */
        Grid.prototype.getFilterState = function () {
            // @TODO: unify the structure to ResetOptions.filterState type definition
            return filter_2.getFilterState(this.store);
        };
        /**
         * Filter the data.
         * @param {string} columnName - column name to filter
         * @param {Array.<FilterState>} state - filter state
         * @example
         * grid.filter('name', [{code: 'eq', value: 3}, {code: 'eq', value: 4}]);
         */
        Grid.prototype.filter = function (columnName, state) {
            var filter = this.store.column.allColumnMap[columnName].filter;
            if (filter) {
                var type_1 = filter.type, operator = filter.operator;
                var conditionFn = state.map(function (_a) {
                    var code = _a.code, value = _a.value;
                    return filter_1.getFilterConditionFn(code, value, type_1);
                });
                this.dispatch('filter', columnName, filter_1.composeConditionFn(conditionFn, operator), state);
            }
        };
        /**
         * Remove filter state of specific column.
         * @param {string} columnName - column name to unfilter
         */
        Grid.prototype.unfilter = function (columnName) {
            this.dispatch('unfilter', columnName);
        };
        /**
         * Add class name to all cell data of specific column.
         * @param {string} columnName - column name to add className
         * @param {string} className - class name
         */
        Grid.prototype.addColumnClassName = function (columnName, className) {
            this.dispatch('addColumnClassName', columnName, className);
        };
        /**
         * Remove class name to all cell data of specific column.
         * @param {string} columnName - column name to add className
         * @param {string} className - class name
         */
        Grid.prototype.removeColumnClassName = function (columnName, className) {
            this.dispatch('removeColumnClassName', columnName, className);
        };
        /**
         * Set new data to the row identified by the specified rowKey.
         * @param {number|string} rowKey - The unique key of the row
         * @param {object} row - The object that contains all values in the row.
         */
        Grid.prototype.setRow = function (rowKey, row) {
            var _a = this.store, data = _a.data, column = _a.column, id = _a.id;
            var rowIndex = data_1.findIndexByRowKey(data, column, id, rowKey, false);
            this.dispatch('setRow', rowIndex, row);
        };
        /**
         * Move the row identified by the specified rowKey to target index.
         * If data is sorted or filtered, this couldn't be used.
         * @param {number|string} rowKey - The unique key of the row
         * @param {number} targetIndex - Target index for moving
         * @param {Object} [options] - Options
         * @param {number} [options.appended] - This option for only tree data. Whether the row is appended to other row as the child.
         */
        Grid.prototype.moveRow = function (rowKey, targetIndex, options) {
            if (options === void 0) { options = { appended: false }; }
            var _a = this.store, column = _a.column, data = _a.data;
            if (column.treeColumnName) {
                var moveToLast = false;
                if (!options.appended) {
                    if (targetIndex === data.rawData.length - 1) {
                        moveToLast = true;
                    }
                    else if (this.getIndexOfRow(rowKey) < targetIndex) {
                        targetIndex += 1;
                    }
                }
                this.dispatch('moveTreeRow', rowKey, targetIndex, tslib_1.__assign(tslib_1.__assign({}, options), { moveToLast: moveToLast }));
            }
            else {
                this.dispatch('moveRow', rowKey, targetIndex);
            }
        };
        /**
         * Set parameters to be sent with the request to communicate with the server.
         * @param {Object} params - parameters to send to the server
         */
        Grid.prototype.setRequestParams = function (params) {
            this.dataProvider.setRequestParams(params);
        };
        /**
         * clear the modified data that is returned as the result of 'getModifiedRows' method.
         * If the 'type' parameter is undefined, all modified data is cleared.
         * @param {string} type - The modified type
         */
        Grid.prototype.clearModifiedData = function (type) {
            if (type) {
                this.dataManager.clear(type);
            }
            else {
                this.dataManager.clearAll();
            }
        };
        /**
         * append rows.
         * @param {Array} data - A list of new rows
         */
        Grid.prototype.appendRows = function (data) {
            this.dispatch('appendRows', data);
        };
        /**
         * Return the formatted value of the cell identified by the rowKey and columnName.
         * @param {number|string} rowKey - The unique key of the target row.
         * @param {string} columnName - The name of the column
         * @returns {string|null} - The formatted value of the cell
         */
        Grid.prototype.getFormattedValue = function (rowKey, columnName) {
            return data_1.getFormattedValue(this.store, rowKey, columnName);
        };
        /**
         * Set total count of items for calculating the pagination.
         * @param {number} totalCount - total count
         */
        Grid.prototype.setPaginationTotalCount = function (totalCount) {
            this.dispatch('updatePageOptions', { totalCount: totalCount });
        };
        /**
         * Get total count of items with the current pagination
         * @returns {number} - total count
         */
        Grid.prototype.getPaginationTotalCount = function () {
            return this.store.data.pageOptions.totalCount;
        };
        return Grid;
    }());
    exports.default = Grid;


    /***/ }),
    /* 60 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createStore = void 0;
    var observable_1 = __webpack_require__(5);
    var data_1 = __webpack_require__(15);
    var column_1 = __webpack_require__(32);
    var dimension_1 = __webpack_require__(76);
    var viewport_1 = __webpack_require__(77);
    var columnCoords_1 = __webpack_require__(78);
    var rowCoords_1 = __webpack_require__(79);
    var focus_1 = __webpack_require__(80);
    var summary_1 = __webpack_require__(44);
    var selection_1 = __webpack_require__(81);
    var renderState_1 = __webpack_require__(82);
    var filterLayerState_1 = __webpack_require__(83);
    var contextMenu_1 = __webpack_require__(84);
    var dimension_2 = __webpack_require__(46);
    var lazyObservable_1 = __webpack_require__(27);
    var validation_1 = __webpack_require__(25);
    function createStore(id, options) {
        validation_1.createNewValidationMap(id);
        var el = options.el, width = options.width, rowHeight = options.rowHeight, bodyHeight = options.bodyHeight, heightResizable = options.heightResizable, minRowHeight = options.minRowHeight, minBodyHeight = options.minBodyHeight, _a = options.columnOptions, columnOptions = _a === void 0 ? {} : _a, keyColumnName = options.keyColumnName, _b = options.rowHeaders, rowHeaders = _b === void 0 ? [] : _b, _c = options.copyOptions, copyOptions = _c === void 0 ? {} : _c, _d = options.summary, summaryOptions = _d === void 0 ? {} : _d, _e = options.selectionUnit, selectionUnit = _e === void 0 ? 'cell' : _e, _f = options.showDummyRows, showDummyRows = _f === void 0 ? false : _f, _g = options.editingEvent, editingEvent = _g === void 0 ? 'dblclick' : _g, _h = options.tabMode, tabMode = _h === void 0 ? 'moveAndEdit' : _h, scrollX = options.scrollX, scrollY = options.scrollY, _j = options.useClientSort, useClientSort = _j === void 0 ? true : _j, _k = options.pageOptions, pageOptions = _k === void 0 ? {} : _k, _l = options.treeColumnOptions, treeColumnOptions = _l === void 0 ? { name: '' } : _l, _m = options.header, header = _m === void 0 ? {} : _m, _o = options.disabled, disabled = _o === void 0 ? false : _o, _p = options.draggable, draggable = _p === void 0 ? false : _p, createMenuGroups = options.contextMenu;
        var frozenBorderWidth = columnOptions.frozenBorderWidth;
        var summaryHeight = summaryOptions.height, summaryPosition = summaryOptions.position;
        var _q = header.height, headerHeight = _q === void 0 ? 40 : _q, _r = header.complexColumns, complexColumns = _r === void 0 ? [] : _r, _s = header.align, align = _s === void 0 ? 'center' : _s, _t = header.valign, valign = _t === void 0 ? 'middle' : _t, _u = header.columns, columnHeaders = _u === void 0 ? [] : _u;
        var column = column_1.create({
            columns: options.columns,
            columnOptions: columnOptions,
            rowHeaders: rowHeaders,
            copyOptions: copyOptions,
            keyColumnName: keyColumnName,
            treeColumnOptions: treeColumnOptions,
            complexColumns: complexColumns,
            align: align,
            valign: valign,
            columnHeaders: columnHeaders,
            disabled: disabled,
            draggable: draggable,
        });
        var data = data_1.create({
            data: Array.isArray(options.data) ? options.data : [],
            column: column,
            pageOptions: pageOptions,
            useClientSort: useClientSort,
            id: id,
            disabled: disabled,
        });
        var dimension = dimension_1.create({
            column: column,
            width: width,
            domWidth: el.clientWidth,
            rowHeight: rowHeight,
            bodyHeight: bodyHeight,
            minBodyHeight: minBodyHeight,
            minRowHeight: minRowHeight,
            heightResizable: heightResizable,
            frozenBorderWidth: frozenBorderWidth,
            summaryHeight: summaryHeight,
            summaryPosition: summaryPosition,
            scrollX: scrollX,
            scrollY: scrollY,
            headerHeight: headerHeight,
        });
        var columnCoords = columnCoords_1.create({ column: column, dimension: dimension });
        var rowCoords = rowCoords_1.create({ data: data, dimension: dimension });
        var viewport = viewport_1.create({
            data: data,
            column: column,
            dimension: dimension,
            rowCoords: rowCoords,
            columnCoords: columnCoords,
            showDummyRows: showDummyRows,
        });
        var focus = focus_1.create({
            data: data,
            column: column,
            dimension: dimension,
            columnCoords: columnCoords,
            rowCoords: rowCoords,
            editingEvent: editingEvent,
            tabMode: tabMode,
            id: id,
        });
        var summary = summary_1.create({ column: column, data: data, summary: summaryOptions });
        var selection = selection_1.create({
            selectionUnit: selectionUnit,
            columnCoords: columnCoords,
            column: column,
            dimension: dimension,
            rowCoords: rowCoords,
            data: data,
        });
        var filterLayerState = filterLayerState_1.create();
        var renderState = renderState_1.create();
        var contextMenu = contextMenu_1.create({ createMenuGroups: createMenuGroups });
        var store = observable_1.observable({
            id: id,
            data: data,
            column: column,
            dimension: dimension,
            columnCoords: columnCoords,
            rowCoords: rowCoords,
            viewport: viewport,
            focus: focus,
            summary: summary,
            selection: selection,
            renderState: renderState,
            filterLayerState: filterLayerState,
            contextMenu: contextMenu,
        });
        // manual observe to resolve circular references
        observable_1.observe(function () {
            dimension_2.setAutoBodyHeight(store);
        });
        // makes the data observable as changes viewport
        observable_1.observe(function () {
            lazyObservable_1.createObservableData(store);
        }, false, 'lazyObservable');
        return store;
    }
    exports.createStore = createStore;


    /***/ }),
    /* 61 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.patchArrayMethods = void 0;
    var observable_1 = __webpack_require__(5);
    var common_1 = __webpack_require__(0);
    var methods = ['splice', 'push', 'pop', 'shift', 'unshift'];
    function patchArrayMethods(arr, obj, key) {
        methods.forEach(function (method) {
            var patchedMethod = common_1.hasOwnProp(arr, method) ? arr[method] : Array.prototype[method];
            var derivedPatchedMethod = !patchedMethod.registered && common_1.hasOwnProp(arr, method);
            // To prevent to stack the patched method recursively
            if (derivedPatchedMethod || !common_1.hasOwnProp(arr, method)) {
                arr[method] = function patch() {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    var result = patchedMethod.apply(this, args);
                    observable_1.notify(obj, key);
                    return result;
                };
                if (derivedPatchedMethod) {
                    arr[method].registered = true;
                }
            }
        });
        return arr;
    }
    exports.patchArrayMethods = patchArrayMethods;


    /***/ }),
    /* 62 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.listItemText = void 0;
    var common_1 = __webpack_require__(0);
    function getListItemText(listItems, value) {
        var item = common_1.findProp('value', value, listItems);
        return item ? item.text : '';
    }
    function listItemText(_a, relationListItems) {
        var column = _a.column, value = _a.value;
        var type = column.editor.options.type;
        var listItems = column.editor.options.listItems;
        if (Array.isArray(relationListItems)) {
            listItems = relationListItems;
        }
        if (type === 'checkbox') {
            return String(value)
                .split(',')
                .map(getListItemText.bind(null, listItems))
                .filter(function (text) { return Boolean(text); })
                .join(',');
        }
        return getListItemText(listItems, value);
    }
    exports.listItemText = listItemText;


    /***/ }),
    /* 63 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultRenderer = void 0;
    var dom_1 = __webpack_require__(2);
    var common_1 = __webpack_require__(0);
    var DefaultRenderer = /** @class */ (function () {
        function DefaultRenderer(props) {
            var el = document.createElement('div');
            var _a = props.columnInfo, ellipsis = _a.ellipsis, whiteSpace = _a.whiteSpace, renderer = _a.renderer;
            var className = '';
            this.props = props;
            this.el = el;
            if (renderer) {
                var attributes = renderer.attributes, styles = renderer.styles, classNames = renderer.classNames;
                if (attributes) {
                    this.setAttrsOrStyles('attrs', attributes);
                }
                if (styles) {
                    this.setAttrsOrStyles('styles', styles);
                }
                if (classNames) {
                    className = " " + classNames.join(' ');
                }
            }
            el.className = dom_1.cls('cell-content') + className;
            // @TODO: we should remove below options and consider common the renderer option for style, attribute and class names
            if (ellipsis) {
                el.style.textOverflow = 'ellipsis';
            }
            if (whiteSpace) {
                el.style.whiteSpace = whiteSpace;
            }
            this.render(props);
        }
        DefaultRenderer.prototype.setAttrsOrStyles = function (type, targets) {
            var _this = this;
            Object.keys(targets).forEach(function (name) {
                var value = common_1.isFunction(targets[name]) ? targets[name](_this.props) : targets[name];
                if (type === 'attrs') {
                    _this.el.setAttribute(name, value);
                }
                else {
                    _this.el.style[name] = value;
                }
            });
        };
        DefaultRenderer.prototype.getElement = function () {
            return this.el;
        };
        DefaultRenderer.prototype.render = function (props) {
            this.el.innerHTML = "" + props.formattedValue;
        };
        return DefaultRenderer;
    }());
    exports.DefaultRenderer = DefaultRenderer;


    /***/ }),
    /* 64 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.editorMap = void 0;
    var text_1 = __webpack_require__(65);
    var checkbox_1 = __webpack_require__(66);
    var select_1 = __webpack_require__(67);
    var datePicker_1 = __webpack_require__(70);
    exports.editorMap = {
        text: [text_1.TextEditor, { type: 'text' }],
        password: [text_1.TextEditor, { type: 'password' }],
        checkbox: [checkbox_1.CheckboxEditor, { type: 'checkbox' }],
        radio: [checkbox_1.CheckboxEditor, { type: 'radio' }],
        select: [select_1.SelectEditor],
        datePicker: [datePicker_1.DatePickerEditor],
    };


    /***/ }),
    /* 65 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TextEditor = void 0;
    var dom_1 = __webpack_require__(2);
    var common_1 = __webpack_require__(0);
    var TextEditor = /** @class */ (function () {
        function TextEditor(props) {
            var el = document.createElement('input');
            var options = props.columnInfo.editor.options;
            el.className = dom_1.cls('content-text');
            el.type = options.type;
            el.value = String(common_1.isNil(props.value) ? '' : props.value);
            this.el = el;
        }
        TextEditor.prototype.getElement = function () {
            return this.el;
        };
        TextEditor.prototype.getValue = function () {
            return this.el.value;
        };
        TextEditor.prototype.mounted = function () {
            this.el.select();
        };
        return TextEditor;
    }());
    exports.TextEditor = TextEditor;


    /***/ }),
    /* 66 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CheckboxEditor = void 0;
    var editor_1 = __webpack_require__(39);
    var dom_1 = __webpack_require__(2);
    var keyboard_1 = __webpack_require__(17);
    var common_1 = __webpack_require__(0);
    var dom_2 = __webpack_require__(33);
    var LAYER_CLASSNAME = dom_1.cls('editor-checkbox-list-layer');
    var LIST_ITEM_CLASSNAME = dom_1.cls('editor-checkbox');
    var HOVERED_LIST_ITEM_CLASSNAME = dom_1.cls('editor-checkbox-hovered') + " " + LIST_ITEM_CLASSNAME;
    var UNCHECKED_RADIO_LABEL_CLASSNAME = dom_1.cls('editor-label-icon-radio');
    var CHECKED_RADIO_LABEL_CLASSNAME = dom_1.cls('editor-label-icon-radio-checked');
    var UNCHECKED_CHECKBOX_LABEL_CLASSNAME = dom_1.cls('editor-label-icon-checkbox');
    var CHECKED_CHECKBOX_LABEL_CLASSNAME = dom_1.cls('editor-label-icon-checkbox-checked');
    var CheckboxEditor = /** @class */ (function () {
        function CheckboxEditor(props) {
            var _this = this;
            this.hoveredItemId = '';
            this.elementIds = [];
            this.onMouseover = function (ev) {
                var targetId = _this.getItemId(ev.target);
                if (targetId && targetId !== _this.hoveredItemId) {
                    _this.highlightItem(targetId);
                }
            };
            this.onChange = function (ev) {
                var value = ev.target.value;
                _this.setLabelClass(value);
            };
            this.onKeydown = function (ev) {
                var keyName = keyboard_1.getKeyStrokeString(ev);
                if (keyboard_1.isArrowKey(keyName)) {
                    ev.preventDefault();
                    var elementIdx = common_1.findIndex(function (id) { return id === _this.hoveredItemId; }, _this.elementIds);
                    var totalCount = _this.elementIds.length;
                    var offset = totalCount + (keyName === 'down' || keyName === 'right' ? 1 : -1);
                    var id = _this.elementIds[(elementIdx + offset) % totalCount];
                    _this.highlightItem(id);
                }
                else {
                    // except arrow key, pass the event to editing layer for using existing editing keyMap
                    _this.portalEditingKeydown(ev);
                }
            };
            var columnInfo = props.columnInfo, width = props.width, formattedValue = props.formattedValue, portalEditingKeydown = props.portalEditingKeydown;
            var el = document.createElement('div');
            var value = String(common_1.isNil(props.value) ? '' : props.value);
            el.className = dom_1.cls('layer-editing-inner');
            el.innerText = formattedValue;
            this.inputType = columnInfo.editor.options.type;
            var listItems = editor_1.getListItems(props);
            var layer = this.createLayer(listItems, width);
            this.portalEditingKeydown = portalEditingKeydown;
            this.el = el;
            this.layer = layer;
            this.setValue(value);
        }
        CheckboxEditor.prototype.createLayer = function (listItems, width) {
            var _this = this;
            var layer = document.createElement('ul');
            layer.className = LAYER_CLASSNAME;
            layer.style.minWidth = width - 10 + "px";
            // To hide the initial layer which is having the position which is not calculated properly
            dom_2.setOpacity(layer, 0);
            listItems.forEach(function (_a) {
                var text = _a.text, value = _a.value;
                var id = "checkbox-" + value;
                var listItemEl = document.createElement('li');
                listItemEl.id = id;
                listItemEl.className = LIST_ITEM_CLASSNAME;
                listItemEl.appendChild(_this.createCheckboxLabel(value, text));
                _this.elementIds.push(id);
                layer.appendChild(listItemEl);
            });
            layer.addEventListener('change', this.onChange);
            layer.addEventListener('mouseover', this.onMouseover);
            layer.addEventListener('keydown', this.onKeydown);
            return layer;
        };
        CheckboxEditor.prototype.createCheckboxLabel = function (value, text) {
            var input = document.createElement('input');
            var label = document.createElement('label');
            var span = document.createElement('span');
            label.className =
                this.inputType === 'radio'
                    ? UNCHECKED_RADIO_LABEL_CLASSNAME
                    : UNCHECKED_CHECKBOX_LABEL_CLASSNAME;
            input.type = this.inputType;
            input.name = 'checkbox';
            input.value = String(value);
            span.innerText = text;
            label.appendChild(input);
            label.appendChild(span);
            return label;
        };
        CheckboxEditor.prototype.getItemId = function (target) {
            return target.id || target.parentElement.id;
        };
        CheckboxEditor.prototype.highlightItem = function (targetId) {
            if (this.hoveredItemId) {
                this.layer.querySelector("#" + this.hoveredItemId).className = LIST_ITEM_CLASSNAME;
            }
            this.hoveredItemId = targetId;
            var item = this.layer.querySelector("#" + targetId);
            item.className = HOVERED_LIST_ITEM_CLASSNAME;
            item.querySelector('input').focus();
        };
        CheckboxEditor.prototype.setLabelClass = function (inputValue) {
            var label = this.layer.querySelector("#checkbox-" + inputValue + " label");
            if (this.inputType === 'checkbox') {
                label.className = dom_1.hasClass(label, 'editor-label-icon-checkbox-checked')
                    ? UNCHECKED_CHECKBOX_LABEL_CLASSNAME
                    : CHECKED_CHECKBOX_LABEL_CLASSNAME;
            }
            else {
                var checkedLabel = this.layer.querySelector("." + CHECKED_RADIO_LABEL_CLASSNAME);
                if (checkedLabel) {
                    checkedLabel.className = UNCHECKED_RADIO_LABEL_CLASSNAME;
                }
                label.className = CHECKED_RADIO_LABEL_CLASSNAME;
            }
        };
        CheckboxEditor.prototype.getCheckedInput = function () {
            return (this.layer.querySelector('input:checked') ||
                this.layer.querySelector('input'));
        };
        CheckboxEditor.prototype.getElement = function () {
            return this.el;
        };
        CheckboxEditor.prototype.setValue = function (value) {
            var _this = this;
            String(value)
                .split(',')
                .forEach(function (inputValue) {
                var input = _this.layer.querySelector("input[value=\"" + inputValue + "\"]");
                if (input) {
                    input.checked = true;
                    _this.setLabelClass(inputValue);
                }
            });
        };
        CheckboxEditor.prototype.getValue = function () {
            var checkedInputs = this.layer.querySelectorAll('input:checked');
            var checkedValues = [];
            for (var i = 0, len = checkedInputs.length; i < len; i += 1) {
                checkedValues.push(checkedInputs[i].value);
            }
            return checkedValues.join(',');
        };
        CheckboxEditor.prototype.mounted = function () {
            // To prevent wrong stacked z-index context, layer append to grid container
            dom_2.getContainerElement(this.el).appendChild(this.layer);
            // @ts-ignore
            dom_2.setLayerPosition(this.el, this.layer);
            var checkedInput = this.getCheckedInput();
            if (checkedInput) {
                this.highlightItem("checkbox-" + checkedInput.value);
            }
            // To show the layer which has appropriate position
            dom_2.setOpacity(this.layer, 1);
        };
        CheckboxEditor.prototype.beforeDestroy = function () {
            this.layer.removeEventListener('change', this.onChange);
            this.layer.removeEventListener('mouseover', this.onMouseover);
            this.layer.removeEventListener('keydown', this.onKeydown);
            dom_2.getContainerElement(this.el).removeChild(this.layer);
        };
        return CheckboxEditor;
    }());
    exports.CheckboxEditor = CheckboxEditor;


    /***/ }),
    /* 67 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SelectEditor = void 0;
    var tslib_1 = __webpack_require__(1);
    var select_box_1 = tslib_1.__importDefault(__webpack_require__(68));
    __webpack_require__(69);
    var editor_1 = __webpack_require__(39);
    var dom_1 = __webpack_require__(2);
    var dom_2 = __webpack_require__(33);
    var keyboard_1 = __webpack_require__(17);
    var common_1 = __webpack_require__(0);
    var SelectEditor = /** @class */ (function () {
        function SelectEditor(props) {
            var _this = this;
            this.selectFinish = false;
            this.isMounted = false;
            this.onKeydown = function (ev) {
                var passingKeyNames = ['esc', 'shift-tab', 'tab'];
                var keyName = keyboard_1.getKeyStrokeString(ev);
                if (_this.selectFinish || common_1.includes(passingKeyNames, keyName)) {
                    // with passingKeyNames, pass the event to editing layer for using existing editing keyMap
                    _this.portalEditingKeydown(ev);
                }
                else {
                    ev.preventDefault();
                }
            };
            var width = props.width, formattedValue = props.formattedValue, portalEditingKeydown = props.portalEditingKeydown;
            var el = document.createElement('div');
            var value = String(common_1.isNil(props.value) ? '' : props.value);
            el.className = dom_1.cls('layer-editing-inner');
            el.innerText = formattedValue;
            var listItems = editor_1.getListItems(props);
            var layer = this.createLayer(listItems, width, value);
            this.portalEditingKeydown = portalEditingKeydown;
            this.el = el;
            this.layer = layer;
            this.layer.addEventListener('keydown', this.onKeydown);
        }
        SelectEditor.prototype.setSelectFinish = function (selectFinish) {
            var _this = this;
            setTimeout(function () {
                _this.selectFinish = selectFinish;
            });
        };
        SelectEditor.prototype.createLayer = function (listItems, width, value) {
            var _this = this;
            var layer = document.createElement('div');
            layer.className = dom_1.cls('editor-select-box-layer');
            layer.style.minWidth = width - 10 + "px";
            // To hide the initial layer which is having the position which is not calculated properly
            dom_2.setOpacity(layer, 0);
            var data = listItems.map(function (item) { return ({ value: String(item.value), label: item.text }); });
            this.selectBoxEl = new select_box_1.default(layer, { data: data });
            this.selectBoxEl.on('close', function () {
                _this.focusSelectBox();
                _this.setSelectFinish(true);
                // @ts-ignore
                dom_2.setLayerPosition(_this.el, _this.layer, _this.selectBoxEl.dropdown.el);
            });
            this.selectBoxEl.on('open', function () {
                _this.setSelectFinish(false);
                if (_this.isMounted) {
                    // @ts-ignore
                    dom_2.setLayerPosition(_this.el, _this.layer, _this.selectBoxEl.dropdown.el);
                }
            });
            if (value) {
                this.selectBoxEl.select(value);
            }
            return layer;
        };
        SelectEditor.prototype.focusSelectBox = function () {
            // https://github.com/nhn/toast-ui.select-box/issues/3
            // @TODO: need to change after apply this issue
            // @ts-ignore
            this.selectBoxEl.input.focus();
        };
        SelectEditor.prototype.getElement = function () {
            return this.el;
        };
        SelectEditor.prototype.getValue = function () {
            var _a, _b;
            return (_b = (_a = this.selectBoxEl.getSelectedItem()) === null || _a === void 0 ? void 0 : _a.getValue()) !== null && _b !== void 0 ? _b : '';
        };
        SelectEditor.prototype.mounted = function () {
            this.selectBoxEl.open();
            // To prevent wrong stacked z-index context, layer append to grid container
            dom_2.getContainerElement(this.el).appendChild(this.layer);
            // @ts-ignore
            dom_2.setLayerPosition(this.el, this.layer, this.selectBoxEl.dropdown.el);
            this.focusSelectBox();
            this.isMounted = true;
            // To show the layer which has appropriate position
            dom_2.setOpacity(this.layer, 1);
        };
        SelectEditor.prototype.beforeDestroy = function () {
            this.selectBoxEl.destroy();
            this.layer.removeEventListener('keydown', this.onKeydown);
            dom_2.getContainerElement(this.el).removeChild(this.layer);
        };
        return SelectEditor;
    }());
    exports.SelectEditor = SelectEditor;


    /***/ }),
    /* 68 */
    /***/ (function(module, exports, __webpack_require__) {

    /*!
     * TOAST UI Select Box
     * @version 1.0.0 | Thu Oct 24 2019
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     * @license MIT
     */
    (function webpackUniversalModuleDefinition(root, factory) {
    	module.exports = factory();
    })(window, function() {
    return /******/ (function(modules) { // webpackBootstrap
    /******/ 	function hotDisposeChunk(chunkId) {
    /******/ 		delete installedChunks[chunkId];
    /******/ 	}
    /******/ 	var parentHotUpdateCallback = window["webpackHotUpdate"];
    /******/ 	window["webpackHotUpdate"] = // eslint-disable-next-line no-unused-vars
    /******/ 	function webpackHotUpdateCallback(chunkId, moreModules) {
    /******/ 		hotAddUpdateChunk(chunkId, moreModules);
    /******/ 		if (parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
    /******/ 	} ;
    /******/
    /******/ 	// eslint-disable-next-line no-unused-vars
    /******/ 	function hotDownloadUpdateChunk(chunkId) {
    /******/ 		var script = document.createElement("script");
    /******/ 		script.charset = "utf-8";
    /******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
    /******/ 		document.head.appendChild(script);
    /******/ 	}
    /******/
    /******/ 	// eslint-disable-next-line no-unused-vars
    /******/ 	function hotDownloadManifest(requestTimeout) {
    /******/ 		requestTimeout = requestTimeout || 10000;
    /******/ 		return new Promise(function(resolve, reject) {
    /******/ 			if (typeof XMLHttpRequest === "undefined") {
    /******/ 				return reject(new Error("No browser support"));
    /******/ 			}
    /******/ 			try {
    /******/ 				var request = new XMLHttpRequest();
    /******/ 				var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
    /******/ 				request.open("GET", requestPath, true);
    /******/ 				request.timeout = requestTimeout;
    /******/ 				request.send(null);
    /******/ 			} catch (err) {
    /******/ 				return reject(err);
    /******/ 			}
    /******/ 			request.onreadystatechange = function() {
    /******/ 				if (request.readyState !== 4) return;
    /******/ 				if (request.status === 0) {
    /******/ 					// timeout
    /******/ 					reject(
    /******/ 						new Error("Manifest request to " + requestPath + " timed out.")
    /******/ 					);
    /******/ 				} else if (request.status === 404) {
    /******/ 					// no update available
    /******/ 					resolve();
    /******/ 				} else if (request.status !== 200 && request.status !== 304) {
    /******/ 					// other failure
    /******/ 					reject(new Error("Manifest request to " + requestPath + " failed."));
    /******/ 				} else {
    /******/ 					// success
    /******/ 					try {
    /******/ 						var update = JSON.parse(request.responseText);
    /******/ 					} catch (e) {
    /******/ 						reject(e);
    /******/ 						return;
    /******/ 					}
    /******/ 					resolve(update);
    /******/ 				}
    /******/ 			};
    /******/ 		});
    /******/ 	}
    /******/
    /******/ 	var hotApplyOnUpdate = true;
    /******/ 	// eslint-disable-next-line no-unused-vars
    /******/ 	var hotCurrentHash = "fbd02ae0ea88b9f7e886";
    /******/ 	var hotRequestTimeout = 10000;
    /******/ 	var hotCurrentModuleData = {};
    /******/ 	var hotCurrentChildModule;
    /******/ 	// eslint-disable-next-line no-unused-vars
    /******/ 	var hotCurrentParents = [];
    /******/ 	// eslint-disable-next-line no-unused-vars
    /******/ 	var hotCurrentParentsTemp = [];
    /******/
    /******/ 	// eslint-disable-next-line no-unused-vars
    /******/ 	function hotCreateRequire(moduleId) {
    /******/ 		var me = installedModules[moduleId];
    /******/ 		if (!me) return __webpack_require__;
    /******/ 		var fn = function(request) {
    /******/ 			if (me.hot.active) {
    /******/ 				if (installedModules[request]) {
    /******/ 					if (installedModules[request].parents.indexOf(moduleId) === -1) {
    /******/ 						installedModules[request].parents.push(moduleId);
    /******/ 					}
    /******/ 				} else {
    /******/ 					hotCurrentParents = [moduleId];
    /******/ 					hotCurrentChildModule = request;
    /******/ 				}
    /******/ 				if (me.children.indexOf(request) === -1) {
    /******/ 					me.children.push(request);
    /******/ 				}
    /******/ 			} else {
    /******/ 				console.warn(
    /******/ 					"[HMR] unexpected require(" +
    /******/ 						request +
    /******/ 						") from disposed module " +
    /******/ 						moduleId
    /******/ 				);
    /******/ 				hotCurrentParents = [];
    /******/ 			}
    /******/ 			return __webpack_require__(request);
    /******/ 		};
    /******/ 		var ObjectFactory = function ObjectFactory(name) {
    /******/ 			return {
    /******/ 				configurable: true,
    /******/ 				enumerable: true,
    /******/ 				get: function() {
    /******/ 					return __webpack_require__[name];
    /******/ 				},
    /******/ 				set: function(value) {
    /******/ 					__webpack_require__[name] = value;
    /******/ 				}
    /******/ 			};
    /******/ 		};
    /******/ 		for (var name in __webpack_require__) {
    /******/ 			if (
    /******/ 				Object.prototype.hasOwnProperty.call(__webpack_require__, name) &&
    /******/ 				name !== "e" &&
    /******/ 				name !== "t"
    /******/ 			) {
    /******/ 				Object.defineProperty(fn, name, ObjectFactory(name));
    /******/ 			}
    /******/ 		}
    /******/ 		fn.e = function(chunkId) {
    /******/ 			if (hotStatus === "ready") hotSetStatus("prepare");
    /******/ 			hotChunksLoading++;
    /******/ 			return __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {
    /******/ 				finishChunkLoading();
    /******/ 				throw err;
    /******/ 			});
    /******/
    /******/ 			function finishChunkLoading() {
    /******/ 				hotChunksLoading--;
    /******/ 				if (hotStatus === "prepare") {
    /******/ 					if (!hotWaitingFilesMap[chunkId]) {
    /******/ 						hotEnsureUpdateChunk(chunkId);
    /******/ 					}
    /******/ 					if (hotChunksLoading === 0 && hotWaitingFiles === 0) {
    /******/ 						hotUpdateDownloaded();
    /******/ 					}
    /******/ 				}
    /******/ 			}
    /******/ 		};
    /******/ 		fn.t = function(value, mode) {
    /******/ 			if (mode & 1) value = fn(value);
    /******/ 			return __webpack_require__.t(value, mode & ~1);
    /******/ 		};
    /******/ 		return fn;
    /******/ 	}
    /******/
    /******/ 	// eslint-disable-next-line no-unused-vars
    /******/ 	function hotCreateModule(moduleId) {
    /******/ 		var hot = {
    /******/ 			// private stuff
    /******/ 			_acceptedDependencies: {},
    /******/ 			_declinedDependencies: {},
    /******/ 			_selfAccepted: false,
    /******/ 			_selfDeclined: false,
    /******/ 			_disposeHandlers: [],
    /******/ 			_main: hotCurrentChildModule !== moduleId,
    /******/
    /******/ 			// Module API
    /******/ 			active: true,
    /******/ 			accept: function(dep, callback) {
    /******/ 				if (dep === undefined) hot._selfAccepted = true;
    /******/ 				else if (typeof dep === "function") hot._selfAccepted = dep;
    /******/ 				else if (typeof dep === "object")
    /******/ 					for (var i = 0; i < dep.length; i++)
    /******/ 						hot._acceptedDependencies[dep[i]] = callback || function() {};
    /******/ 				else hot._acceptedDependencies[dep] = callback || function() {};
    /******/ 			},
    /******/ 			decline: function(dep) {
    /******/ 				if (dep === undefined) hot._selfDeclined = true;
    /******/ 				else if (typeof dep === "object")
    /******/ 					for (var i = 0; i < dep.length; i++)
    /******/ 						hot._declinedDependencies[dep[i]] = true;
    /******/ 				else hot._declinedDependencies[dep] = true;
    /******/ 			},
    /******/ 			dispose: function(callback) {
    /******/ 				hot._disposeHandlers.push(callback);
    /******/ 			},
    /******/ 			addDisposeHandler: function(callback) {
    /******/ 				hot._disposeHandlers.push(callback);
    /******/ 			},
    /******/ 			removeDisposeHandler: function(callback) {
    /******/ 				var idx = hot._disposeHandlers.indexOf(callback);
    /******/ 				if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
    /******/ 			},
    /******/
    /******/ 			// Management API
    /******/ 			check: hotCheck,
    /******/ 			apply: hotApply,
    /******/ 			status: function(l) {
    /******/ 				if (!l) return hotStatus;
    /******/ 				hotStatusHandlers.push(l);
    /******/ 			},
    /******/ 			addStatusHandler: function(l) {
    /******/ 				hotStatusHandlers.push(l);
    /******/ 			},
    /******/ 			removeStatusHandler: function(l) {
    /******/ 				var idx = hotStatusHandlers.indexOf(l);
    /******/ 				if (idx >= 0) hotStatusHandlers.splice(idx, 1);
    /******/ 			},
    /******/
    /******/ 			//inherit from previous dispose call
    /******/ 			data: hotCurrentModuleData[moduleId]
    /******/ 		};
    /******/ 		hotCurrentChildModule = undefined;
    /******/ 		return hot;
    /******/ 	}
    /******/
    /******/ 	var hotStatusHandlers = [];
    /******/ 	var hotStatus = "idle";
    /******/
    /******/ 	function hotSetStatus(newStatus) {
    /******/ 		hotStatus = newStatus;
    /******/ 		for (var i = 0; i < hotStatusHandlers.length; i++)
    /******/ 			hotStatusHandlers[i].call(null, newStatus);
    /******/ 	}
    /******/
    /******/ 	// while downloading
    /******/ 	var hotWaitingFiles = 0;
    /******/ 	var hotChunksLoading = 0;
    /******/ 	var hotWaitingFilesMap = {};
    /******/ 	var hotRequestedFilesMap = {};
    /******/ 	var hotAvailableFilesMap = {};
    /******/ 	var hotDeferred;
    /******/
    /******/ 	// The update info
    /******/ 	var hotUpdate, hotUpdateNewHash;
    /******/
    /******/ 	function toModuleId(id) {
    /******/ 		var isNumber = +id + "" === id;
    /******/ 		return isNumber ? +id : id;
    /******/ 	}
    /******/
    /******/ 	function hotCheck(apply) {
    /******/ 		if (hotStatus !== "idle") {
    /******/ 			throw new Error("check() is only allowed in idle status");
    /******/ 		}
    /******/ 		hotApplyOnUpdate = apply;
    /******/ 		hotSetStatus("check");
    /******/ 		return hotDownloadManifest(hotRequestTimeout).then(function(update) {
    /******/ 			if (!update) {
    /******/ 				hotSetStatus("idle");
    /******/ 				return null;
    /******/ 			}
    /******/ 			hotRequestedFilesMap = {};
    /******/ 			hotWaitingFilesMap = {};
    /******/ 			hotAvailableFilesMap = update.c;
    /******/ 			hotUpdateNewHash = update.h;
    /******/
    /******/ 			hotSetStatus("prepare");
    /******/ 			var promise = new Promise(function(resolve, reject) {
    /******/ 				hotDeferred = {
    /******/ 					resolve: resolve,
    /******/ 					reject: reject
    /******/ 				};
    /******/ 			});
    /******/ 			hotUpdate = {};
    /******/ 			var chunkId = "main";
    /******/ 			// eslint-disable-next-line no-lone-blocks
    /******/ 			{
    /******/ 				/*globals chunkId */
    /******/ 				hotEnsureUpdateChunk(chunkId);
    /******/ 			}
    /******/ 			if (
    /******/ 				hotStatus === "prepare" &&
    /******/ 				hotChunksLoading === 0 &&
    /******/ 				hotWaitingFiles === 0
    /******/ 			) {
    /******/ 				hotUpdateDownloaded();
    /******/ 			}
    /******/ 			return promise;
    /******/ 		});
    /******/ 	}
    /******/
    /******/ 	// eslint-disable-next-line no-unused-vars
    /******/ 	function hotAddUpdateChunk(chunkId, moreModules) {
    /******/ 		if (!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
    /******/ 			return;
    /******/ 		hotRequestedFilesMap[chunkId] = false;
    /******/ 		for (var moduleId in moreModules) {
    /******/ 			if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
    /******/ 				hotUpdate[moduleId] = moreModules[moduleId];
    /******/ 			}
    /******/ 		}
    /******/ 		if (--hotWaitingFiles === 0 && hotChunksLoading === 0) {
    /******/ 			hotUpdateDownloaded();
    /******/ 		}
    /******/ 	}
    /******/
    /******/ 	function hotEnsureUpdateChunk(chunkId) {
    /******/ 		if (!hotAvailableFilesMap[chunkId]) {
    /******/ 			hotWaitingFilesMap[chunkId] = true;
    /******/ 		} else {
    /******/ 			hotRequestedFilesMap[chunkId] = true;
    /******/ 			hotWaitingFiles++;
    /******/ 			hotDownloadUpdateChunk(chunkId);
    /******/ 		}
    /******/ 	}
    /******/
    /******/ 	function hotUpdateDownloaded() {
    /******/ 		hotSetStatus("ready");
    /******/ 		var deferred = hotDeferred;
    /******/ 		hotDeferred = null;
    /******/ 		if (!deferred) return;
    /******/ 		if (hotApplyOnUpdate) {
    /******/ 			// Wrap deferred object in Promise to mark it as a well-handled Promise to
    /******/ 			// avoid triggering uncaught exception warning in Chrome.
    /******/ 			// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666
    /******/ 			Promise.resolve()
    /******/ 				.then(function() {
    /******/ 					return hotApply(hotApplyOnUpdate);
    /******/ 				})
    /******/ 				.then(
    /******/ 					function(result) {
    /******/ 						deferred.resolve(result);
    /******/ 					},
    /******/ 					function(err) {
    /******/ 						deferred.reject(err);
    /******/ 					}
    /******/ 				);
    /******/ 		} else {
    /******/ 			var outdatedModules = [];
    /******/ 			for (var id in hotUpdate) {
    /******/ 				if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
    /******/ 					outdatedModules.push(toModuleId(id));
    /******/ 				}
    /******/ 			}
    /******/ 			deferred.resolve(outdatedModules);
    /******/ 		}
    /******/ 	}
    /******/
    /******/ 	function hotApply(options) {
    /******/ 		if (hotStatus !== "ready")
    /******/ 			throw new Error("apply() is only allowed in ready status");
    /******/ 		options = options || {};
    /******/
    /******/ 		var cb;
    /******/ 		var i;
    /******/ 		var j;
    /******/ 		var module;
    /******/ 		var moduleId;
    /******/
    /******/ 		function getAffectedStuff(updateModuleId) {
    /******/ 			var outdatedModules = [updateModuleId];
    /******/ 			var outdatedDependencies = {};
    /******/
    /******/ 			var queue = outdatedModules.map(function(id) {
    /******/ 				return {
    /******/ 					chain: [id],
    /******/ 					id: id
    /******/ 				};
    /******/ 			});
    /******/ 			while (queue.length > 0) {
    /******/ 				var queueItem = queue.pop();
    /******/ 				var moduleId = queueItem.id;
    /******/ 				var chain = queueItem.chain;
    /******/ 				module = installedModules[moduleId];
    /******/ 				if (!module || module.hot._selfAccepted) continue;
    /******/ 				if (module.hot._selfDeclined) {
    /******/ 					return {
    /******/ 						type: "self-declined",
    /******/ 						chain: chain,
    /******/ 						moduleId: moduleId
    /******/ 					};
    /******/ 				}
    /******/ 				if (module.hot._main) {
    /******/ 					return {
    /******/ 						type: "unaccepted",
    /******/ 						chain: chain,
    /******/ 						moduleId: moduleId
    /******/ 					};
    /******/ 				}
    /******/ 				for (var i = 0; i < module.parents.length; i++) {
    /******/ 					var parentId = module.parents[i];
    /******/ 					var parent = installedModules[parentId];
    /******/ 					if (!parent) continue;
    /******/ 					if (parent.hot._declinedDependencies[moduleId]) {
    /******/ 						return {
    /******/ 							type: "declined",
    /******/ 							chain: chain.concat([parentId]),
    /******/ 							moduleId: moduleId,
    /******/ 							parentId: parentId
    /******/ 						};
    /******/ 					}
    /******/ 					if (outdatedModules.indexOf(parentId) !== -1) continue;
    /******/ 					if (parent.hot._acceptedDependencies[moduleId]) {
    /******/ 						if (!outdatedDependencies[parentId])
    /******/ 							outdatedDependencies[parentId] = [];
    /******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
    /******/ 						continue;
    /******/ 					}
    /******/ 					delete outdatedDependencies[parentId];
    /******/ 					outdatedModules.push(parentId);
    /******/ 					queue.push({
    /******/ 						chain: chain.concat([parentId]),
    /******/ 						id: parentId
    /******/ 					});
    /******/ 				}
    /******/ 			}
    /******/
    /******/ 			return {
    /******/ 				type: "accepted",
    /******/ 				moduleId: updateModuleId,
    /******/ 				outdatedModules: outdatedModules,
    /******/ 				outdatedDependencies: outdatedDependencies
    /******/ 			};
    /******/ 		}
    /******/
    /******/ 		function addAllToSet(a, b) {
    /******/ 			for (var i = 0; i < b.length; i++) {
    /******/ 				var item = b[i];
    /******/ 				if (a.indexOf(item) === -1) a.push(item);
    /******/ 			}
    /******/ 		}
    /******/
    /******/ 		// at begin all updates modules are outdated
    /******/ 		// the "outdated" status can propagate to parents if they don't accept the children
    /******/ 		var outdatedDependencies = {};
    /******/ 		var outdatedModules = [];
    /******/ 		var appliedUpdate = {};
    /******/
    /******/ 		var warnUnexpectedRequire = function warnUnexpectedRequire() {
    /******/ 			console.warn(
    /******/ 				"[HMR] unexpected require(" + result.moduleId + ") to disposed module"
    /******/ 			);
    /******/ 		};
    /******/
    /******/ 		for (var id in hotUpdate) {
    /******/ 			if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
    /******/ 				moduleId = toModuleId(id);
    /******/ 				/** @type {TODO} */
    /******/ 				var result;
    /******/ 				if (hotUpdate[id]) {
    /******/ 					result = getAffectedStuff(moduleId);
    /******/ 				} else {
    /******/ 					result = {
    /******/ 						type: "disposed",
    /******/ 						moduleId: id
    /******/ 					};
    /******/ 				}
    /******/ 				/** @type {Error|false} */
    /******/ 				var abortError = false;
    /******/ 				var doApply = false;
    /******/ 				var doDispose = false;
    /******/ 				var chainInfo = "";
    /******/ 				if (result.chain) {
    /******/ 					chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
    /******/ 				}
    /******/ 				switch (result.type) {
    /******/ 					case "self-declined":
    /******/ 						if (options.onDeclined) options.onDeclined(result);
    /******/ 						if (!options.ignoreDeclined)
    /******/ 							abortError = new Error(
    /******/ 								"Aborted because of self decline: " +
    /******/ 									result.moduleId +
    /******/ 									chainInfo
    /******/ 							);
    /******/ 						break;
    /******/ 					case "declined":
    /******/ 						if (options.onDeclined) options.onDeclined(result);
    /******/ 						if (!options.ignoreDeclined)
    /******/ 							abortError = new Error(
    /******/ 								"Aborted because of declined dependency: " +
    /******/ 									result.moduleId +
    /******/ 									" in " +
    /******/ 									result.parentId +
    /******/ 									chainInfo
    /******/ 							);
    /******/ 						break;
    /******/ 					case "unaccepted":
    /******/ 						if (options.onUnaccepted) options.onUnaccepted(result);
    /******/ 						if (!options.ignoreUnaccepted)
    /******/ 							abortError = new Error(
    /******/ 								"Aborted because " + moduleId + " is not accepted" + chainInfo
    /******/ 							);
    /******/ 						break;
    /******/ 					case "accepted":
    /******/ 						if (options.onAccepted) options.onAccepted(result);
    /******/ 						doApply = true;
    /******/ 						break;
    /******/ 					case "disposed":
    /******/ 						if (options.onDisposed) options.onDisposed(result);
    /******/ 						doDispose = true;
    /******/ 						break;
    /******/ 					default:
    /******/ 						throw new Error("Unexception type " + result.type);
    /******/ 				}
    /******/ 				if (abortError) {
    /******/ 					hotSetStatus("abort");
    /******/ 					return Promise.reject(abortError);
    /******/ 				}
    /******/ 				if (doApply) {
    /******/ 					appliedUpdate[moduleId] = hotUpdate[moduleId];
    /******/ 					addAllToSet(outdatedModules, result.outdatedModules);
    /******/ 					for (moduleId in result.outdatedDependencies) {
    /******/ 						if (
    /******/ 							Object.prototype.hasOwnProperty.call(
    /******/ 								result.outdatedDependencies,
    /******/ 								moduleId
    /******/ 							)
    /******/ 						) {
    /******/ 							if (!outdatedDependencies[moduleId])
    /******/ 								outdatedDependencies[moduleId] = [];
    /******/ 							addAllToSet(
    /******/ 								outdatedDependencies[moduleId],
    /******/ 								result.outdatedDependencies[moduleId]
    /******/ 							);
    /******/ 						}
    /******/ 					}
    /******/ 				}
    /******/ 				if (doDispose) {
    /******/ 					addAllToSet(outdatedModules, [result.moduleId]);
    /******/ 					appliedUpdate[moduleId] = warnUnexpectedRequire;
    /******/ 				}
    /******/ 			}
    /******/ 		}
    /******/
    /******/ 		// Store self accepted outdated modules to require them later by the module system
    /******/ 		var outdatedSelfAcceptedModules = [];
    /******/ 		for (i = 0; i < outdatedModules.length; i++) {
    /******/ 			moduleId = outdatedModules[i];
    /******/ 			if (
    /******/ 				installedModules[moduleId] &&
    /******/ 				installedModules[moduleId].hot._selfAccepted &&
    /******/ 				// removed self-accepted modules should not be required
    /******/ 				appliedUpdate[moduleId] !== warnUnexpectedRequire
    /******/ 			) {
    /******/ 				outdatedSelfAcceptedModules.push({
    /******/ 					module: moduleId,
    /******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
    /******/ 				});
    /******/ 			}
    /******/ 		}
    /******/
    /******/ 		// Now in "dispose" phase
    /******/ 		hotSetStatus("dispose");
    /******/ 		Object.keys(hotAvailableFilesMap).forEach(function(chunkId) {
    /******/ 			if (hotAvailableFilesMap[chunkId] === false) {
    /******/ 				hotDisposeChunk(chunkId);
    /******/ 			}
    /******/ 		});
    /******/
    /******/ 		var idx;
    /******/ 		var queue = outdatedModules.slice();
    /******/ 		while (queue.length > 0) {
    /******/ 			moduleId = queue.pop();
    /******/ 			module = installedModules[moduleId];
    /******/ 			if (!module) continue;
    /******/
    /******/ 			var data = {};
    /******/
    /******/ 			// Call dispose handlers
    /******/ 			var disposeHandlers = module.hot._disposeHandlers;
    /******/ 			for (j = 0; j < disposeHandlers.length; j++) {
    /******/ 				cb = disposeHandlers[j];
    /******/ 				cb(data);
    /******/ 			}
    /******/ 			hotCurrentModuleData[moduleId] = data;
    /******/
    /******/ 			// disable module (this disables requires from this module)
    /******/ 			module.hot.active = false;
    /******/
    /******/ 			// remove module from cache
    /******/ 			delete installedModules[moduleId];
    /******/
    /******/ 			// when disposing there is no need to call dispose handler
    /******/ 			delete outdatedDependencies[moduleId];
    /******/
    /******/ 			// remove "parents" references from all children
    /******/ 			for (j = 0; j < module.children.length; j++) {
    /******/ 				var child = installedModules[module.children[j]];
    /******/ 				if (!child) continue;
    /******/ 				idx = child.parents.indexOf(moduleId);
    /******/ 				if (idx >= 0) {
    /******/ 					child.parents.splice(idx, 1);
    /******/ 				}
    /******/ 			}
    /******/ 		}
    /******/
    /******/ 		// remove outdated dependency from module children
    /******/ 		var dependency;
    /******/ 		var moduleOutdatedDependencies;
    /******/ 		for (moduleId in outdatedDependencies) {
    /******/ 			if (
    /******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
    /******/ 			) {
    /******/ 				module = installedModules[moduleId];
    /******/ 				if (module) {
    /******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
    /******/ 					for (j = 0; j < moduleOutdatedDependencies.length; j++) {
    /******/ 						dependency = moduleOutdatedDependencies[j];
    /******/ 						idx = module.children.indexOf(dependency);
    /******/ 						if (idx >= 0) module.children.splice(idx, 1);
    /******/ 					}
    /******/ 				}
    /******/ 			}
    /******/ 		}
    /******/
    /******/ 		// Now in "apply" phase
    /******/ 		hotSetStatus("apply");
    /******/
    /******/ 		hotCurrentHash = hotUpdateNewHash;
    /******/
    /******/ 		// insert new code
    /******/ 		for (moduleId in appliedUpdate) {
    /******/ 			if (Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
    /******/ 				modules[moduleId] = appliedUpdate[moduleId];
    /******/ 			}
    /******/ 		}
    /******/
    /******/ 		// call accept handlers
    /******/ 		var error = null;
    /******/ 		for (moduleId in outdatedDependencies) {
    /******/ 			if (
    /******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
    /******/ 			) {
    /******/ 				module = installedModules[moduleId];
    /******/ 				if (module) {
    /******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
    /******/ 					var callbacks = [];
    /******/ 					for (i = 0; i < moduleOutdatedDependencies.length; i++) {
    /******/ 						dependency = moduleOutdatedDependencies[i];
    /******/ 						cb = module.hot._acceptedDependencies[dependency];
    /******/ 						if (cb) {
    /******/ 							if (callbacks.indexOf(cb) !== -1) continue;
    /******/ 							callbacks.push(cb);
    /******/ 						}
    /******/ 					}
    /******/ 					for (i = 0; i < callbacks.length; i++) {
    /******/ 						cb = callbacks[i];
    /******/ 						try {
    /******/ 							cb(moduleOutdatedDependencies);
    /******/ 						} catch (err) {
    /******/ 							if (options.onErrored) {
    /******/ 								options.onErrored({
    /******/ 									type: "accept-errored",
    /******/ 									moduleId: moduleId,
    /******/ 									dependencyId: moduleOutdatedDependencies[i],
    /******/ 									error: err
    /******/ 								});
    /******/ 							}
    /******/ 							if (!options.ignoreErrored) {
    /******/ 								if (!error) error = err;
    /******/ 							}
    /******/ 						}
    /******/ 					}
    /******/ 				}
    /******/ 			}
    /******/ 		}
    /******/
    /******/ 		// Load self accepted modules
    /******/ 		for (i = 0; i < outdatedSelfAcceptedModules.length; i++) {
    /******/ 			var item = outdatedSelfAcceptedModules[i];
    /******/ 			moduleId = item.module;
    /******/ 			hotCurrentParents = [moduleId];
    /******/ 			try {
    /******/ 				__webpack_require__(moduleId);
    /******/ 			} catch (err) {
    /******/ 				if (typeof item.errorHandler === "function") {
    /******/ 					try {
    /******/ 						item.errorHandler(err);
    /******/ 					} catch (err2) {
    /******/ 						if (options.onErrored) {
    /******/ 							options.onErrored({
    /******/ 								type: "self-accept-error-handler-errored",
    /******/ 								moduleId: moduleId,
    /******/ 								error: err2,
    /******/ 								originalError: err
    /******/ 							});
    /******/ 						}
    /******/ 						if (!options.ignoreErrored) {
    /******/ 							if (!error) error = err2;
    /******/ 						}
    /******/ 						if (!error) error = err;
    /******/ 					}
    /******/ 				} else {
    /******/ 					if (options.onErrored) {
    /******/ 						options.onErrored({
    /******/ 							type: "self-accept-errored",
    /******/ 							moduleId: moduleId,
    /******/ 							error: err
    /******/ 						});
    /******/ 					}
    /******/ 					if (!options.ignoreErrored) {
    /******/ 						if (!error) error = err;
    /******/ 					}
    /******/ 				}
    /******/ 			}
    /******/ 		}
    /******/
    /******/ 		// handle errors in accept handlers and self accepted module load
    /******/ 		if (error) {
    /******/ 			hotSetStatus("fail");
    /******/ 			return Promise.reject(error);
    /******/ 		}
    /******/
    /******/ 		hotSetStatus("idle");
    /******/ 		return new Promise(function(resolve) {
    /******/ 			resolve(outdatedModules);
    /******/ 		});
    /******/ 	}
    /******/
    /******/ 	// The module cache
    /******/ 	var installedModules = {};
    /******/
    /******/ 	// The require function
    /******/ 	function __webpack_require__(moduleId) {
    /******/
    /******/ 		// Check if module is in cache
    /******/ 		if(installedModules[moduleId]) {
    /******/ 			return installedModules[moduleId].exports;
    /******/ 		}
    /******/ 		// Create a new module (and put it into the cache)
    /******/ 		var module = installedModules[moduleId] = {
    /******/ 			i: moduleId,
    /******/ 			l: false,
    /******/ 			exports: {},
    /******/ 			hot: hotCreateModule(moduleId),
    /******/ 			parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),
    /******/ 			children: []
    /******/ 		};
    /******/
    /******/ 		// Execute the module function
    /******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
    /******/
    /******/ 		// Flag the module as loaded
    /******/ 		module.l = true;
    /******/
    /******/ 		// Return the exports of the module
    /******/ 		return module.exports;
    /******/ 	}
    /******/
    /******/
    /******/ 	// expose the modules object (__webpack_modules__)
    /******/ 	__webpack_require__.m = modules;
    /******/
    /******/ 	// expose the module cache
    /******/ 	__webpack_require__.c = installedModules;
    /******/
    /******/ 	// define getter function for harmony exports
    /******/ 	__webpack_require__.d = function(exports, name, getter) {
    /******/ 		if(!__webpack_require__.o(exports, name)) {
    /******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
    /******/ 		}
    /******/ 	};
    /******/
    /******/ 	// define __esModule on exports
    /******/ 	__webpack_require__.r = function(exports) {
    /******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
    /******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
    /******/ 		}
    /******/ 		Object.defineProperty(exports, '__esModule', { value: true });
    /******/ 	};
    /******/
    /******/ 	// create a fake namespace object
    /******/ 	// mode & 1: value is a module id, require it
    /******/ 	// mode & 2: merge all properties of value into the ns
    /******/ 	// mode & 4: return value when already ns object
    /******/ 	// mode & 8|1: behave like require
    /******/ 	__webpack_require__.t = function(value, mode) {
    /******/ 		if(mode & 1) value = __webpack_require__(value);
    /******/ 		if(mode & 8) return value;
    /******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
    /******/ 		var ns = Object.create(null);
    /******/ 		__webpack_require__.r(ns);
    /******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
    /******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
    /******/ 		return ns;
    /******/ 	};
    /******/
    /******/ 	// getDefaultExport function for compatibility with non-harmony modules
    /******/ 	__webpack_require__.n = function(module) {
    /******/ 		var getter = module && module.__esModule ?
    /******/ 			function getDefault() { return module['default']; } :
    /******/ 			function getModuleExports() { return module; };
    /******/ 		__webpack_require__.d(getter, 'a', getter);
    /******/ 		return getter;
    /******/ 	};
    /******/
    /******/ 	// Object.prototype.hasOwnProperty.call
    /******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
    /******/
    /******/ 	// __webpack_public_path__
    /******/ 	__webpack_require__.p = "dist";
    /******/
    /******/ 	// __webpack_hash__
    /******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
    /******/
    /******/
    /******/ 	// Load entry module and return exports
    /******/ 	return hotCreateRequire("./src/js/index.js")(__webpack_require__.s = "./src/js/index.js");
    /******/ })
    /************************************************************************/
    /******/ ({

    /***/ "./node_modules/tui-code-snippet/array/inArray.js":
    /*!********************************************************!*\
      !*** ./node_modules/tui-code-snippet/array/inArray.js ***!
      \********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    /* eslint-disable complexity */
    /**
     * @fileoverview Returns the first index at which a given element can be found in the array.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var isArray = __webpack_require__(/*! ../type/isArray */ "./node_modules/tui-code-snippet/type/isArray.js");

    /**
     * @module array
     */

    /**
     * Returns the first index at which a given element can be found in the array
     * from start index(default 0), or -1 if it is not present.
     * It compares searchElement to elements of the Array using strict equality
     * (the same method used by the ===, or triple-equals, operator).
     * @param {*} searchElement Element to locate in the array
     * @param {Array} array Array that will be traversed.
     * @param {number} startIndex Start index in array for searching (default 0)
     * @returns {number} the First index at which a given element, or -1 if it is not present
     * @memberof module:array
     * @example
     * var inArray = require('tui-code-snippet/array/inArray'); // node, commonjs
     *
     * var arr = ['one', 'two', 'three', 'four'];
     * var idx1 = inArray('one', arr, 3); // -1
     * var idx2 = inArray('one', arr); // 0
     */
    function inArray(searchElement, array, startIndex) {
        var i;
        var length;
        startIndex = startIndex || 0;

        if (!isArray(array)) {
            return -1;
        }

        if (Array.prototype.indexOf) {
            return Array.prototype.indexOf.call(array, searchElement, startIndex);
        }

        length = array.length;
        for (i = startIndex; startIndex >= 0 && i < length; i += 1) {
            if (array[i] === searchElement) {
                return i;
            }
        }

        return -1;
    }

    module.exports = inArray;


    /***/ }),

    /***/ "./node_modules/tui-code-snippet/collection/forEach.js":
    /*!*************************************************************!*\
      !*** ./node_modules/tui-code-snippet/collection/forEach.js ***!
      \*************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Execute the provided callback once for each property of object(or element of array) which actually exist.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var isArray = __webpack_require__(/*! ../type/isArray */ "./node_modules/tui-code-snippet/type/isArray.js");
    var forEachArray = __webpack_require__(/*! ../collection/forEachArray */ "./node_modules/tui-code-snippet/collection/forEachArray.js");
    var forEachOwnProperties = __webpack_require__(/*! ../collection/forEachOwnProperties */ "./node_modules/tui-code-snippet/collection/forEachOwnProperties.js");

    /**
     * @module collection
     */

    /**
     * Execute the provided callback once for each property of object(or element of array) which actually exist.
     * If the object is Array-like object(ex-arguments object), It needs to transform to Array.(see 'ex2' of example).
     * If the callback function returns false, the loop will be stopped.
     * Callback function(iteratee) is invoked with three arguments:
     *  - The value of the property(or The value of the element)
     *  - The name of the property(or The index of the element)
     *  - The object being traversed
     * @param {Object} obj The object that will be traversed
     * @param {function} iteratee Callback function
     * @param {Object} [context] Context(this) of callback function
     * @memberof module:collection
     * @example
     * var forEach = require('tui-code-snippet/collection/forEach'); // node, commonjs
     *
     * var sum = 0;
     *
     * forEach([1,2,3], function(value){
     *     sum += value;
     * });
     * alert(sum); // 6
     *
     * // In case of Array-like object
     * var array = Array.prototype.slice.call(arrayLike); // change to array
     * forEach(array, function(value){
     *     sum += value;
     * });
     */
    function forEach(obj, iteratee, context) {
        if (isArray(obj)) {
            forEachArray(obj, iteratee, context);
        } else {
            forEachOwnProperties(obj, iteratee, context);
        }
    }

    module.exports = forEach;


    /***/ }),

    /***/ "./node_modules/tui-code-snippet/collection/forEachArray.js":
    /*!******************************************************************!*\
      !*** ./node_modules/tui-code-snippet/collection/forEachArray.js ***!
      \******************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Execute the provided callback once for each element present in the array(or Array-like object) in ascending order.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Execute the provided callback once for each element present
     * in the array(or Array-like object) in ascending order.
     * If the callback function returns false, the loop will be stopped.
     * Callback function(iteratee) is invoked with three arguments:
     *  - The value of the element
     *  - The index of the element
     *  - The array(or Array-like object) being traversed
     * @param {Array} arr The array(or Array-like object) that will be traversed
     * @param {function} iteratee Callback function
     * @param {Object} [context] Context(this) of callback function
     * @memberof module:collection
     * @example
     * var forEachArray = require('tui-code-snippet/collection/forEachArray'); // node, commonjs
     *
     * var sum = 0;
     *
     * forEachArray([1,2,3], function(value){
     *     sum += value;
     * });
     * alert(sum); // 6
     */
    function forEachArray(arr, iteratee, context) {
        var index = 0;
        var len = arr.length;

        context = context || null;

        for (; index < len; index += 1) {
            if (iteratee.call(context, arr[index], index, arr) === false) {
                break;
            }
        }
    }

    module.exports = forEachArray;


    /***/ }),

    /***/ "./node_modules/tui-code-snippet/collection/forEachOwnProperties.js":
    /*!**************************************************************************!*\
      !*** ./node_modules/tui-code-snippet/collection/forEachOwnProperties.js ***!
      \**************************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Execute the provided callback once for each property of object which actually exist.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Execute the provided callback once for each property of object which actually exist.
     * If the callback function returns false, the loop will be stopped.
     * Callback function(iteratee) is invoked with three arguments:
     *  - The value of the property
     *  - The name of the property
     *  - The object being traversed
     * @param {Object} obj The object that will be traversed
     * @param {function} iteratee  Callback function
     * @param {Object} [context] Context(this) of callback function
     * @memberof module:collection
     * @example
     * var forEachOwnProperties = require('tui-code-snippet/collection/forEachOwnProperties'); // node, commonjs
     *
     * var sum = 0;
     *
     * forEachOwnProperties({a:1,b:2,c:3}, function(value){
     *     sum += value;
     * });
     * alert(sum); // 6
     */
    function forEachOwnProperties(obj, iteratee, context) {
        var key;

        context = context || null;

        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                if (iteratee.call(context, obj[key], key, obj) === false) {
                    break;
                }
            }
        }
    }

    module.exports = forEachOwnProperties;


    /***/ }),

    /***/ "./node_modules/tui-code-snippet/collection/toArray.js":
    /*!*************************************************************!*\
      !*** ./node_modules/tui-code-snippet/collection/toArray.js ***!
      \*************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Transform the Array-like object to Array.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var forEachArray = __webpack_require__(/*! ./forEachArray */ "./node_modules/tui-code-snippet/collection/forEachArray.js");

    /**
     * Transform the Array-like object to Array.
     * In low IE (below 8), Array.prototype.slice.call is not perfect. So, try-catch statement is used.
     * @param {*} arrayLike Array-like object
     * @returns {Array} Array
     * @memberof module:collection
     * @example
     * var toArray = require('tui-code-snippet/collection/toArray'); // node, commonjs
     *
     * var arrayLike = {
     *     0: 'one',
     *     1: 'two',
     *     2: 'three',
     *     3: 'four',
     *     length: 4
     * };
     * var result = toArray(arrayLike);
     *
     * alert(result instanceof Array); // true
     * alert(result); // one,two,three,four
     */
    function toArray(arrayLike) {
        var arr;
        try {
            arr = Array.prototype.slice.call(arrayLike);
        } catch (e) {
            arr = [];
            forEachArray(arrayLike, function(value) {
                arr.push(value);
            });
        }

        return arr;
    }

    module.exports = toArray;


    /***/ }),

    /***/ "./node_modules/tui-code-snippet/customEvents/customEvents.js":
    /*!********************************************************************!*\
      !*** ./node_modules/tui-code-snippet/customEvents/customEvents.js ***!
      \********************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview This module provides some functions for custom events. And it is implemented in the observer design pattern.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var extend = __webpack_require__(/*! ../object/extend */ "./node_modules/tui-code-snippet/object/extend.js");
    var isExisty = __webpack_require__(/*! ../type/isExisty */ "./node_modules/tui-code-snippet/type/isExisty.js");
    var isString = __webpack_require__(/*! ../type/isString */ "./node_modules/tui-code-snippet/type/isString.js");
    var isObject = __webpack_require__(/*! ../type/isObject */ "./node_modules/tui-code-snippet/type/isObject.js");
    var isArray = __webpack_require__(/*! ../type/isArray */ "./node_modules/tui-code-snippet/type/isArray.js");
    var isFunction = __webpack_require__(/*! ../type/isFunction */ "./node_modules/tui-code-snippet/type/isFunction.js");
    var forEach = __webpack_require__(/*! ../collection/forEach */ "./node_modules/tui-code-snippet/collection/forEach.js");

    var R_EVENTNAME_SPLIT = /\s+/g;

    /**
     * @class
     * @example
     * // node, commonjs
     * var CustomEvents = require('tui-code-snippet/customEvents/customEvents');
     */
    function CustomEvents() {
        /**
         * @type {HandlerItem[]}
         */
        this.events = null;

        /**
         * only for checking specific context event was binded
         * @type {object[]}
         */
        this.contexts = null;
    }

    /**
     * Mixin custom events feature to specific constructor
     * @param {function} func - constructor
     * @example
     * var CustomEvents = require('tui-code-snippet/customEvents/customEvents'); // node, commonjs
     *
     * var model;
     * function Model() {
     *     this.name = '';
     * }
     * CustomEvents.mixin(Model);
     *
     * model = new Model();
     * model.on('change', function() { this.name = 'model'; }, this);
     * model.fire('change');
     * alert(model.name); // 'model';
     */
    CustomEvents.mixin = function(func) {
        extend(func.prototype, CustomEvents.prototype);
    };

    /**
     * Get HandlerItem object
     * @param {function} handler - handler function
     * @param {object} [context] - context for handler
     * @returns {HandlerItem} HandlerItem object
     * @private
     */
    CustomEvents.prototype._getHandlerItem = function(handler, context) {
        var item = {handler: handler};

        if (context) {
            item.context = context;
        }

        return item;
    };

    /**
     * Get event object safely
     * @param {string} [eventName] - create sub event map if not exist.
     * @returns {(object|array)} event object. if you supplied `eventName`
     *  parameter then make new array and return it
     * @private
     */
    CustomEvents.prototype._safeEvent = function(eventName) {
        var events = this.events;
        var byName;

        if (!events) {
            events = this.events = {};
        }

        if (eventName) {
            byName = events[eventName];

            if (!byName) {
                byName = [];
                events[eventName] = byName;
            }

            events = byName;
        }

        return events;
    };

    /**
     * Get context array safely
     * @returns {array} context array
     * @private
     */
    CustomEvents.prototype._safeContext = function() {
        var context = this.contexts;

        if (!context) {
            context = this.contexts = [];
        }

        return context;
    };

    /**
     * Get index of context
     * @param {object} ctx - context that used for bind custom event
     * @returns {number} index of context
     * @private
     */
    CustomEvents.prototype._indexOfContext = function(ctx) {
        var context = this._safeContext();
        var index = 0;

        while (context[index]) {
            if (ctx === context[index][0]) {
                return index;
            }

            index += 1;
        }

        return -1;
    };

    /**
     * Memorize supplied context for recognize supplied object is context or
     *  name: handler pair object when off()
     * @param {object} ctx - context object to memorize
     * @private
     */
    CustomEvents.prototype._memorizeContext = function(ctx) {
        var context, index;

        if (!isExisty(ctx)) {
            return;
        }

        context = this._safeContext();
        index = this._indexOfContext(ctx);

        if (index > -1) {
            context[index][1] += 1;
        } else {
            context.push([ctx, 1]);
        }
    };

    /**
     * Forget supplied context object
     * @param {object} ctx - context object to forget
     * @private
     */
    CustomEvents.prototype._forgetContext = function(ctx) {
        var context, contextIndex;

        if (!isExisty(ctx)) {
            return;
        }

        context = this._safeContext();
        contextIndex = this._indexOfContext(ctx);

        if (contextIndex > -1) {
            context[contextIndex][1] -= 1;

            if (context[contextIndex][1] <= 0) {
                context.splice(contextIndex, 1);
            }
        }
    };

    /**
     * Bind event handler
     * @param {(string|{name:string, handler:function})} eventName - custom
     *  event name or an object {eventName: handler}
     * @param {(function|object)} [handler] - handler function or context
     * @param {object} [context] - context for binding
     * @private
     */
    CustomEvents.prototype._bindEvent = function(eventName, handler, context) {
        var events = this._safeEvent(eventName);
        this._memorizeContext(context);
        events.push(this._getHandlerItem(handler, context));
    };

    /**
     * Bind event handlers
     * @param {(string|{name:string, handler:function})} eventName - custom
     *  event name or an object {eventName: handler}
     * @param {(function|object)} [handler] - handler function or context
     * @param {object} [context] - context for binding
     * //-- #1. Get Module --//
     * var CustomEvents = require('tui-code-snippet/customEvents/customEvents'); // node, commonjs
     *
     * //-- #2. Use method --//
     * // # 2.1 Basic Usage
     * CustomEvents.on('onload', handler);
     *
     * // # 2.2 With context
     * CustomEvents.on('onload', handler, myObj);
     *
     * // # 2.3 Bind by object that name, handler pairs
     * CustomEvents.on({
     *     'play': handler,
     *     'pause': handler2
     * });
     *
     * // # 2.4 Bind by object that name, handler pairs with context object
     * CustomEvents.on({
     *     'play': handler
     * }, myObj);
     */
    CustomEvents.prototype.on = function(eventName, handler, context) {
        var self = this;

        if (isString(eventName)) {
            // [syntax 1, 2]
            eventName = eventName.split(R_EVENTNAME_SPLIT);
            forEach(eventName, function(name) {
                self._bindEvent(name, handler, context);
            });
        } else if (isObject(eventName)) {
            // [syntax 3, 4]
            context = handler;
            forEach(eventName, function(func, name) {
                self.on(name, func, context);
            });
        }
    };

    /**
     * Bind one-shot event handlers
     * @param {(string|{name:string,handler:function})} eventName - custom
     *  event name or an object {eventName: handler}
     * @param {function|object} [handler] - handler function or context
     * @param {object} [context] - context for binding
     */
    CustomEvents.prototype.once = function(eventName, handler, context) {
        var self = this;

        if (isObject(eventName)) {
            context = handler;
            forEach(eventName, function(func, name) {
                self.once(name, func, context);
            });

            return;
        }

        function onceHandler() { // eslint-disable-line require-jsdoc
            handler.apply(context, arguments);
            self.off(eventName, onceHandler, context);
        }

        this.on(eventName, onceHandler, context);
    };

    /**
     * Splice supplied array by callback result
     * @param {array} arr - array to splice
     * @param {function} predicate - function return boolean
     * @private
     */
    CustomEvents.prototype._spliceMatches = function(arr, predicate) {
        var i = 0;
        var len;

        if (!isArray(arr)) {
            return;
        }

        for (len = arr.length; i < len; i += 1) {
            if (predicate(arr[i]) === true) {
                arr.splice(i, 1);
                len -= 1;
                i -= 1;
            }
        }
    };

    /**
     * Get matcher for unbind specific handler events
     * @param {function} handler - handler function
     * @returns {function} handler matcher
     * @private
     */
    CustomEvents.prototype._matchHandler = function(handler) {
        var self = this;

        return function(item) {
            var needRemove = handler === item.handler;

            if (needRemove) {
                self._forgetContext(item.context);
            }

            return needRemove;
        };
    };

    /**
     * Get matcher for unbind specific context events
     * @param {object} context - context
     * @returns {function} object matcher
     * @private
     */
    CustomEvents.prototype._matchContext = function(context) {
        var self = this;

        return function(item) {
            var needRemove = context === item.context;

            if (needRemove) {
                self._forgetContext(item.context);
            }

            return needRemove;
        };
    };

    /**
     * Get matcher for unbind specific hander, context pair events
     * @param {function} handler - handler function
     * @param {object} context - context
     * @returns {function} handler, context matcher
     * @private
     */
    CustomEvents.prototype._matchHandlerAndContext = function(handler, context) {
        var self = this;

        return function(item) {
            var matchHandler = (handler === item.handler);
            var matchContext = (context === item.context);
            var needRemove = (matchHandler && matchContext);

            if (needRemove) {
                self._forgetContext(item.context);
            }

            return needRemove;
        };
    };

    /**
     * Unbind event by event name
     * @param {string} eventName - custom event name to unbind
     * @param {function} [handler] - handler function
     * @private
     */
    CustomEvents.prototype._offByEventName = function(eventName, handler) {
        var self = this;
        var andByHandler = isFunction(handler);
        var matchHandler = self._matchHandler(handler);

        eventName = eventName.split(R_EVENTNAME_SPLIT);

        forEach(eventName, function(name) {
            var handlerItems = self._safeEvent(name);

            if (andByHandler) {
                self._spliceMatches(handlerItems, matchHandler);
            } else {
                forEach(handlerItems, function(item) {
                    self._forgetContext(item.context);
                });

                self.events[name] = [];
            }
        });
    };

    /**
     * Unbind event by handler function
     * @param {function} handler - handler function
     * @private
     */
    CustomEvents.prototype._offByHandler = function(handler) {
        var self = this;
        var matchHandler = this._matchHandler(handler);

        forEach(this._safeEvent(), function(handlerItems) {
            self._spliceMatches(handlerItems, matchHandler);
        });
    };

    /**
     * Unbind event by object(name: handler pair object or context object)
     * @param {object} obj - context or {name: handler} pair object
     * @param {function} handler - handler function
     * @private
     */
    CustomEvents.prototype._offByObject = function(obj, handler) {
        var self = this;
        var matchFunc;

        if (this._indexOfContext(obj) < 0) {
            forEach(obj, function(func, name) {
                self.off(name, func);
            });
        } else if (isString(handler)) {
            matchFunc = this._matchContext(obj);

            self._spliceMatches(this._safeEvent(handler), matchFunc);
        } else if (isFunction(handler)) {
            matchFunc = this._matchHandlerAndContext(handler, obj);

            forEach(this._safeEvent(), function(handlerItems) {
                self._spliceMatches(handlerItems, matchFunc);
            });
        } else {
            matchFunc = this._matchContext(obj);

            forEach(this._safeEvent(), function(handlerItems) {
                self._spliceMatches(handlerItems, matchFunc);
            });
        }
    };

    /**
     * Unbind custom events
     * @param {(string|object|function)} eventName - event name or context or
     *  {name: handler} pair object or handler function
     * @param {(function)} handler - handler function
     * @example
     * //-- #1. Get Module --//
     * var CustomEvents = require('tui-code-snippet/customEvents/customEvents'); // node, commonjs
     *
     * //-- #2. Use method --//
     * // # 2.1 off by event name
     * CustomEvents.off('onload');
     *
     * // # 2.2 off by event name and handler
     * CustomEvents.off('play', handler);
     *
     * // # 2.3 off by handler
     * CustomEvents.off(handler);
     *
     * // # 2.4 off by context
     * CustomEvents.off(myObj);
     *
     * // # 2.5 off by context and handler
     * CustomEvents.off(myObj, handler);
     *
     * // # 2.6 off by context and event name
     * CustomEvents.off(myObj, 'onload');
     *
     * // # 2.7 off by an Object.<string, function> that is {eventName: handler}
     * CustomEvents.off({
     *   'play': handler,
     *   'pause': handler2
     * });
     *
     * // # 2.8 off the all events
     * CustomEvents.off();
     */
    CustomEvents.prototype.off = function(eventName, handler) {
        if (isString(eventName)) {
            // [syntax 1, 2]
            this._offByEventName(eventName, handler);
        } else if (!arguments.length) {
            // [syntax 8]
            this.events = {};
            this.contexts = [];
        } else if (isFunction(eventName)) {
            // [syntax 3]
            this._offByHandler(eventName);
        } else if (isObject(eventName)) {
            // [syntax 4, 5, 6]
            this._offByObject(eventName, handler);
        }
    };

    /**
     * Fire custom event
     * @param {string} eventName - name of custom event
     */
    CustomEvents.prototype.fire = function(eventName) {  // eslint-disable-line
        this.invoke.apply(this, arguments);
    };

    /**
     * Fire a event and returns the result of operation 'boolean AND' with all
     *  listener's results.
     *
     * So, It is different from {@link CustomEvents#fire}.
     *
     * In service code, use this as a before event in component level usually
     *  for notifying that the event is cancelable.
     * @param {string} eventName - Custom event name
     * @param {...*} data - Data for event
     * @returns {boolean} The result of operation 'boolean AND'
     * @example
     * var map = new Map();
     * map.on({
     *     'beforeZoom': function() {
     *         // It should cancel the 'zoom' event by some conditions.
     *         if (that.disabled && this.getState()) {
     *             return false;
     *         }
     *         return true;
     *     }
     * });
     *
     * if (this.invoke('beforeZoom')) {    // check the result of 'beforeZoom'
     *     // if true,
     *     // doSomething
     * }
     */
    CustomEvents.prototype.invoke = function(eventName) {
        var events, args, index, item;

        if (!this.hasListener(eventName)) {
            return true;
        }

        events = this._safeEvent(eventName);
        args = Array.prototype.slice.call(arguments, 1);
        index = 0;

        while (events[index]) {
            item = events[index];

            if (item.handler.apply(item.context, args) === false) {
                return false;
            }

            index += 1;
        }

        return true;
    };

    /**
     * Return whether at least one of the handlers is registered in the given
     *  event name.
     * @param {string} eventName - Custom event name
     * @returns {boolean} Is there at least one handler in event name?
     */
    CustomEvents.prototype.hasListener = function(eventName) {
        return this.getListenerLength(eventName) > 0;
    };

    /**
     * Return a count of events registered.
     * @param {string} eventName - Custom event name
     * @returns {number} number of event
     */
    CustomEvents.prototype.getListenerLength = function(eventName) {
        var events = this._safeEvent(eventName);

        return events.length;
    };

    module.exports = CustomEvents;


    /***/ }),

    /***/ "./node_modules/tui-code-snippet/domEvent/_safeEvent.js":
    /*!**************************************************************!*\
      !*** ./node_modules/tui-code-snippet/domEvent/_safeEvent.js ***!
      \**************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Get event collection for specific HTML element
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var EVENT_KEY = '_feEventKey';

    /**
     * Get event collection for specific HTML element
     * @param {HTMLElement} element - HTML element
     * @param {string} type - event type
     * @returns {array}
     * @private
     */
    function safeEvent(element, type) {
        var events = element[EVENT_KEY];
        var handlers;

        if (!events) {
            events = element[EVENT_KEY] = {};
        }

        handlers = events[type];
        if (!handlers) {
            handlers = events[type] = [];
        }

        return handlers;
    }

    module.exports = safeEvent;


    /***/ }),

    /***/ "./node_modules/tui-code-snippet/domEvent/getTarget.js":
    /*!*************************************************************!*\
      !*** ./node_modules/tui-code-snippet/domEvent/getTarget.js ***!
      \*************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Get a target element from an event object.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Get a target element from an event object.
     * @param {Event} e - event object
     * @returns {HTMLElement} - target element
     * @memberof module:domEvent
     */
    function getTarget(e) {
        return e.target || e.srcElement;
    }

    module.exports = getTarget;


    /***/ }),

    /***/ "./node_modules/tui-code-snippet/domEvent/off.js":
    /*!*******************************************************!*\
      !*** ./node_modules/tui-code-snippet/domEvent/off.js ***!
      \*******************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Unbind DOM events
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var isString = __webpack_require__(/*! ../type/isString */ "./node_modules/tui-code-snippet/type/isString.js");
    var forEach = __webpack_require__(/*! ../collection/forEach */ "./node_modules/tui-code-snippet/collection/forEach.js");

    var safeEvent = __webpack_require__(/*! ./_safeEvent */ "./node_modules/tui-code-snippet/domEvent/_safeEvent.js");

    /**
     * Unbind DOM events
     * If a handler function is not passed, remove all events of that type.
     * @param {HTMLElement} element - element to unbindbind events
     * @param {(string|object)} types - Space splitted events names or
     *  eventName:handler object
     * @param {function} [handler] - handler function
     * @memberof module:domEvent
     */
    function off(element, types, handler) {
        if (isString(types)) {
            forEach(types.split(/\s+/g), function(type) {
                unbindEvent(element, type, handler);
            });

            return;
        }

        forEach(types, function(func, type) {
            unbindEvent(element, type, func);
        });
    }

    /**
     * Unbind DOM events
     * If a handler function is not passed, remove all events of that type.
     * @param {HTMLElement} element - element to unbind events
     * @param {string} type - events name
     * @param {function} [handler] - handler function
     * @private
     */
    function unbindEvent(element, type, handler) {
        var events = safeEvent(element, type);
        var index;

        if (!handler) {
            forEach(events, function(item) {
                removeHandler(element, type, item.wrappedHandler);
            });
            events.splice(0, events.length);
        } else {
            forEach(events, function(item, idx) {
                if (handler === item.handler) {
                    removeHandler(element, type, item.wrappedHandler);
                    index = idx;

                    return false;
                }

                return true;
            });
            events.splice(index, 1);
        }
    }

    /**
     * Remove an event handler
     * @param {HTMLElement} element - An element to remove an event
     * @param {string} type - event type
     * @param {function} handler - event handler
     * @private
     */
    function removeHandler(element, type, handler) {
        if ('removeEventListener' in element) {
            element.removeEventListener(type, handler);
        } else if ('detachEvent' in element) {
            element.detachEvent('on' + type, handler);
        }
    }

    module.exports = off;


    /***/ }),

    /***/ "./node_modules/tui-code-snippet/domEvent/on.js":
    /*!******************************************************!*\
      !*** ./node_modules/tui-code-snippet/domEvent/on.js ***!
      \******************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Bind DOM events
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var isString = __webpack_require__(/*! ../type/isString */ "./node_modules/tui-code-snippet/type/isString.js");
    var forEach = __webpack_require__(/*! ../collection/forEach */ "./node_modules/tui-code-snippet/collection/forEach.js");

    var safeEvent = __webpack_require__(/*! ./_safeEvent */ "./node_modules/tui-code-snippet/domEvent/_safeEvent.js");

    /**
     * Bind DOM events
     * @param {HTMLElement} element - element to bind events
     * @param {(string|object)} types - Space splitted events names or
     *  eventName:handler object
     * @param {(function|object)} handler - handler function or context for handler
     *  method
     * @param {object} [context] context - context for handler method.
     * @memberof module:domEvent
     */
    function on(element, types, handler, context) {
        if (isString(types)) {
            forEach(types.split(/\s+/g), function(type) {
                bindEvent(element, type, handler, context);
            });

            return;
        }

        forEach(types, function(func, type) {
            bindEvent(element, type, func, handler);
        });
    }

    /**
     * Bind DOM events
     * @param {HTMLElement} element - element to bind events
     * @param {string} type - events name
     * @param {function} handler - handler function or context for handler
     *  method
     * @param {object} [context] context - context for handler method.
     * @private
     */
    function bindEvent(element, type, handler, context) {
        /**
         * Event handler
         * @param {Event} e - event object
         */
        function eventHandler(e) {
            handler.call(context || element, e || window.event);
        }

        if ('addEventListener' in element) {
            element.addEventListener(type, eventHandler);
        } else if ('attachEvent' in element) {
            element.attachEvent('on' + type, eventHandler);
        }
        memorizeHandler(element, type, handler, eventHandler);
    }

    /**
     * Memorize DOM event handler for unbinding.
     * @param {HTMLElement} element - element to bind events
     * @param {string} type - events name
     * @param {function} handler - handler function that user passed at on() use
     * @param {function} wrappedHandler - handler function that wrapped by domevent for implementing some features
     * @private
     */
    function memorizeHandler(element, type, handler, wrappedHandler) {
        var events = safeEvent(element, type);
        var existInEvents = false;

        forEach(events, function(obj) {
            if (obj.handler === handler) {
                existInEvents = true;

                return false;
            }

            return true;
        });

        if (!existInEvents) {
            events.push({
                handler: handler,
                wrappedHandler: wrappedHandler
            });
        }
    }

    module.exports = on;


    /***/ }),

    /***/ "./node_modules/tui-code-snippet/domEvent/preventDefault.js":
    /*!******************************************************************!*\
      !*** ./node_modules/tui-code-snippet/domEvent/preventDefault.js ***!
      \******************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Prevent default action
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Prevent default action
     * @param {Event} e - event object
     * @memberof module:domEvent
     */
    function preventDefault(e) {
        if (e.preventDefault) {
            e.preventDefault();

            return;
        }

        e.returnValue = false;
    }

    module.exports = preventDefault;


    /***/ }),

    /***/ "./node_modules/tui-code-snippet/domUtil/_setClassName.js":
    /*!****************************************************************!*\
      !*** ./node_modules/tui-code-snippet/domUtil/_setClassName.js ***!
      \****************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Set className value
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var isArray = __webpack_require__(/*! ../type/isArray */ "./node_modules/tui-code-snippet/type/isArray.js");
    var isUndefined = __webpack_require__(/*! ../type/isUndefined */ "./node_modules/tui-code-snippet/type/isUndefined.js");

    /**
     * Set className value
     * @param {(HTMLElement|SVGElement)} element - target element
     * @param {(string|string[])} cssClass - class names
     * @private
     */
    function setClassName(element, cssClass) {
        cssClass = isArray(cssClass) ? cssClass.join(' ') : cssClass;

        cssClass = cssClass.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

        if (isUndefined(element.className.baseVal)) {
            element.className = cssClass;

            return;
        }

        element.className.baseVal = cssClass;
    }

    module.exports = setClassName;


    /***/ }),

    /***/ "./node_modules/tui-code-snippet/domUtil/addClass.js":
    /*!***********************************************************!*\
      !*** ./node_modules/tui-code-snippet/domUtil/addClass.js ***!
      \***********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Add css class to element
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var forEach = __webpack_require__(/*! ../collection/forEach */ "./node_modules/tui-code-snippet/collection/forEach.js");
    var inArray = __webpack_require__(/*! ../array/inArray */ "./node_modules/tui-code-snippet/array/inArray.js");
    var getClass = __webpack_require__(/*! ./getClass */ "./node_modules/tui-code-snippet/domUtil/getClass.js");
    var setClassName = __webpack_require__(/*! ./_setClassName */ "./node_modules/tui-code-snippet/domUtil/_setClassName.js");

    /**
     * domUtil module
     * @module domUtil
     */

    /**
     * Add css class to element
     * @param {(HTMLElement|SVGElement)} element - target element
     * @param {...string} cssClass - css classes to add
     * @memberof module:domUtil
     */
    function addClass(element) {
        var cssClass = Array.prototype.slice.call(arguments, 1);
        var classList = element.classList;
        var newClass = [];
        var origin;

        if (classList) {
            forEach(cssClass, function(name) {
                element.classList.add(name);
            });

            return;
        }

        origin = getClass(element);

        if (origin) {
            cssClass = [].concat(origin.split(/\s+/), cssClass);
        }

        forEach(cssClass, function(cls) {
            if (inArray(cls, newClass) < 0) {
                newClass.push(cls);
            }
        });

        setClassName(element, newClass);
    }

    module.exports = addClass;


    /***/ }),

    /***/ "./node_modules/tui-code-snippet/domUtil/closest.js":
    /*!**********************************************************!*\
      !*** ./node_modules/tui-code-snippet/domUtil/closest.js ***!
      \**********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Find parent element recursively
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var matches = __webpack_require__(/*! ./matches */ "./node_modules/tui-code-snippet/domUtil/matches.js");

    /**
     * Find parent element recursively
     * @param {HTMLElement} element - base element to start find
     * @param {string} selector - selector string for find
     * @returns {HTMLElement} - element finded or null
     * @memberof module:domUtil
     */
    function closest(element, selector) {
        var parent = element.parentNode;

        if (matches(element, selector)) {
            return element;
        }

        while (parent && parent !== document) {
            if (matches(parent, selector)) {
                return parent;
            }

            parent = parent.parentNode;
        }

        return null;
    }

    module.exports = closest;


    /***/ }),

    /***/ "./node_modules/tui-code-snippet/domUtil/getClass.js":
    /*!***********************************************************!*\
      !*** ./node_modules/tui-code-snippet/domUtil/getClass.js ***!
      \***********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Get HTML element's design classes.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var isUndefined = __webpack_require__(/*! ../type/isUndefined */ "./node_modules/tui-code-snippet/type/isUndefined.js");

    /**
     * Get HTML element's design classes.
     * @param {(HTMLElement|SVGElement)} element target element
     * @returns {string} element css class name
     * @memberof module:domUtil
     */
    function getClass(element) {
        if (!element || !element.className) {
            return '';
        }

        if (isUndefined(element.className.baseVal)) {
            return element.className;
        }

        return element.className.baseVal;
    }

    module.exports = getClass;


    /***/ }),

    /***/ "./node_modules/tui-code-snippet/domUtil/matches.js":
    /*!**********************************************************!*\
      !*** ./node_modules/tui-code-snippet/domUtil/matches.js ***!
      \**********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check element match selector
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var inArray = __webpack_require__(/*! ../array/inArray */ "./node_modules/tui-code-snippet/array/inArray.js");
    var toArray = __webpack_require__(/*! ../collection/toArray */ "./node_modules/tui-code-snippet/collection/toArray.js");

    var elProto = Element.prototype;
    var matchSelector = elProto.matches ||
        elProto.webkitMatchesSelector ||
        elProto.mozMatchesSelector ||
        elProto.msMatchesSelector ||
        function(selector) {
            var doc = this.document || this.ownerDocument;

            return inArray(this, toArray(doc.querySelectorAll(selector))) > -1;
        };

    /**
     * Check element match selector
     * @param {HTMLElement} element - element to check
     * @param {string} selector - selector to check
     * @returns {boolean} is selector matched to element?
     * @memberof module:domUtil
     */
    function matches(element, selector) {
        return matchSelector.call(element, selector);
    }

    module.exports = matches;


    /***/ }),

    /***/ "./node_modules/tui-code-snippet/domUtil/removeClass.js":
    /*!**************************************************************!*\
      !*** ./node_modules/tui-code-snippet/domUtil/removeClass.js ***!
      \**************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Remove css class from element
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var forEachArray = __webpack_require__(/*! ../collection/forEachArray */ "./node_modules/tui-code-snippet/collection/forEachArray.js");
    var inArray = __webpack_require__(/*! ../array/inArray */ "./node_modules/tui-code-snippet/array/inArray.js");
    var getClass = __webpack_require__(/*! ./getClass */ "./node_modules/tui-code-snippet/domUtil/getClass.js");
    var setClassName = __webpack_require__(/*! ./_setClassName */ "./node_modules/tui-code-snippet/domUtil/_setClassName.js");

    /**
     * Remove css class from element
     * @param {(HTMLElement|SVGElement)} element - target element
     * @param {...string} cssClass - css classes to remove
     * @memberof module:domUtil
     */
    function removeClass(element) {
        var cssClass = Array.prototype.slice.call(arguments, 1);
        var classList = element.classList;
        var origin, newClass;

        if (classList) {
            forEachArray(cssClass, function(name) {
                classList.remove(name);
            });

            return;
        }

        origin = getClass(element).split(/\s+/);
        newClass = [];
        forEachArray(origin, function(name) {
            if (inArray(name, cssClass) < 0) {
                newClass.push(name);
            }
        });

        setClassName(element, newClass);
    }

    module.exports = removeClass;


    /***/ }),

    /***/ "./node_modules/tui-code-snippet/domUtil/removeElement.js":
    /*!****************************************************************!*\
      !*** ./node_modules/tui-code-snippet/domUtil/removeElement.js ***!
      \****************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Remove element from parent node.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Remove element from parent node.
     * @param {HTMLElement} element - element to remove.
     * @memberof module:domUtil
     */
    function removeElement(element) {
        if (element && element.parentNode) {
            element.parentNode.removeChild(element);
        }
    }

    module.exports = removeElement;


    /***/ }),

    /***/ "./node_modules/tui-code-snippet/object/extend.js":
    /*!********************************************************!*\
      !*** ./node_modules/tui-code-snippet/object/extend.js ***!
      \********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Extend the target object from other objects.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * @module object
     */

    /**
     * Extend the target object from other objects.
     * @param {object} target - Object that will be extended
     * @param {...object} objects - Objects as sources
     * @returns {object} Extended object
     * @memberof module:object
     */
    function extend(target, objects) { // eslint-disable-line no-unused-vars
        var hasOwnProp = Object.prototype.hasOwnProperty;
        var source, prop, i, len;

        for (i = 1, len = arguments.length; i < len; i += 1) {
            source = arguments[i];
            for (prop in source) {
                if (hasOwnProp.call(source, prop)) {
                    target[prop] = source[prop];
                }
            }
        }

        return target;
    }

    module.exports = extend;


    /***/ }),

    /***/ "./node_modules/tui-code-snippet/request/imagePing.js":
    /*!************************************************************!*\
      !*** ./node_modules/tui-code-snippet/request/imagePing.js ***!
      \************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Request image ping.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var forEachOwnProperties = __webpack_require__(/*! ../collection/forEachOwnProperties */ "./node_modules/tui-code-snippet/collection/forEachOwnProperties.js");

    /**
     * @module request
     */

    /**
     * Request image ping.
     * @param {String} url url for ping request
     * @param {Object} trackingInfo infos for make query string
     * @returns {HTMLElement}
     * @memberof module:request
     * @example
     * var imagePing = require('tui-code-snippet/request/imagePing'); // node, commonjs
     *
     * imagePing('https://www.google-analytics.com/collect', {
     *     v: 1,
     *     t: 'event',
     *     tid: 'trackingid',
     *     cid: 'cid',
     *     dp: 'dp',
     *     dh: 'dh'
     * });
     */
    function imagePing(url, trackingInfo) {
        var trackingElement = document.createElement('img');
        var queryString = '';
        forEachOwnProperties(trackingInfo, function(value, key) {
            queryString += '&' + key + '=' + value;
        });
        queryString = queryString.substring(1);

        trackingElement.src = url + '?' + queryString;

        trackingElement.style.display = 'none';
        document.body.appendChild(trackingElement);
        document.body.removeChild(trackingElement);

        return trackingElement;
    }

    module.exports = imagePing;


    /***/ }),

    /***/ "./node_modules/tui-code-snippet/request/sendHostname.js":
    /*!***************************************************************!*\
      !*** ./node_modules/tui-code-snippet/request/sendHostname.js ***!
      \***************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Send hostname on DOMContentLoaded.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var isUndefined = __webpack_require__(/*! ../type/isUndefined */ "./node_modules/tui-code-snippet/type/isUndefined.js");
    var imagePing = __webpack_require__(/*! ./imagePing */ "./node_modules/tui-code-snippet/request/imagePing.js");

    var ms7days = 7 * 24 * 60 * 60 * 1000;

    /**
     * Check if the date has passed 7 days
     * @param {number} date - milliseconds
     * @returns {boolean}
     * @private
     */
    function isExpired(date) {
        var now = new Date().getTime();

        return now - date > ms7days;
    }

    /**
     * Send hostname on DOMContentLoaded.
     * To prevent hostname set tui.usageStatistics to false.
     * @param {string} appName - application name
     * @param {string} trackingId - GA tracking ID
     * @ignore
     */
    function sendHostname(appName, trackingId) {
        var url = 'https://www.google-analytics.com/collect';
        var hostname = location.hostname;
        var hitType = 'event';
        var eventCategory = 'use';
        var applicationKeyForStorage = 'TOAST UI ' + appName + ' for ' + hostname + ': Statistics';
        var date = window.localStorage.getItem(applicationKeyForStorage);

        // skip if the flag is defined and is set to false explicitly
        if (!isUndefined(window.tui) && window.tui.usageStatistics === false) {
            return;
        }

        // skip if not pass seven days old
        if (date && !isExpired(date)) {
            return;
        }

        window.localStorage.setItem(applicationKeyForStorage, new Date().getTime());

        setTimeout(function() {
            if (document.readyState === 'interactive' || document.readyState === 'complete') {
                imagePing(url, {
                    v: 1,
                    t: hitType,
                    tid: trackingId,
                    cid: hostname,
                    dp: hostname,
                    dh: appName,
                    el: appName,
                    ec: eventCategory
                });
            }
        }, 1000);
    }

    module.exports = sendHostname;


    /***/ }),

    /***/ "./node_modules/tui-code-snippet/type/isArray.js":
    /*!*******************************************************!*\
      !*** ./node_modules/tui-code-snippet/type/isArray.js ***!
      \*******************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is an instance of Array or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Check whether the given variable is an instance of Array or not.
     * If the given variable is an instance of Array, return true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is array instance?
     * @memberof module:type
     */
    function isArray(obj) {
        return obj instanceof Array;
    }

    module.exports = isArray;


    /***/ }),

    /***/ "./node_modules/tui-code-snippet/type/isBoolean.js":
    /*!*********************************************************!*\
      !*** ./node_modules/tui-code-snippet/type/isBoolean.js ***!
      \*********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is a string or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Check whether the given variable is a boolean or not.
     *  If the given variable is a boolean, return true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is boolean?
     * @memberof module:type
     */
    function isBoolean(obj) {
        return typeof obj === 'boolean' || obj instanceof Boolean;
    }

    module.exports = isBoolean;


    /***/ }),

    /***/ "./node_modules/tui-code-snippet/type/isExisty.js":
    /*!********************************************************!*\
      !*** ./node_modules/tui-code-snippet/type/isExisty.js ***!
      \********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is existing or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    var isUndefined = __webpack_require__(/*! ./isUndefined */ "./node_modules/tui-code-snippet/type/isUndefined.js");
    var isNull = __webpack_require__(/*! ./isNull */ "./node_modules/tui-code-snippet/type/isNull.js");

    /**
     * Check whether the given variable is existing or not.
     * If the given variable is not null and not undefined, returns true.
     * @param {*} param - Target for checking
     * @returns {boolean} Is existy?
     * @memberof module:type
     * @example
     * var isExisty = require('tui-code-snippet/type/isExisty'); // node, commonjs
     *
     * isExisty(''); //true
     * isExisty(0); //true
     * isExisty([]); //true
     * isExisty({}); //true
     * isExisty(null); //false
     * isExisty(undefined); //false
    */
    function isExisty(param) {
        return !isUndefined(param) && !isNull(param);
    }

    module.exports = isExisty;


    /***/ }),

    /***/ "./node_modules/tui-code-snippet/type/isFunction.js":
    /*!**********************************************************!*\
      !*** ./node_modules/tui-code-snippet/type/isFunction.js ***!
      \**********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is a function or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Check whether the given variable is a function or not.
     * If the given variable is a function, return true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is function?
     * @memberof module:type
     */
    function isFunction(obj) {
        return obj instanceof Function;
    }

    module.exports = isFunction;


    /***/ }),

    /***/ "./node_modules/tui-code-snippet/type/isHTMLNode.js":
    /*!**********************************************************!*\
      !*** ./node_modules/tui-code-snippet/type/isHTMLNode.js ***!
      \**********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is a instance of HTMLNode or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Check whether the given variable is a instance of HTMLNode or not.
     * If the given variables is a instance of HTMLNode, return true.
     * @param {*} html - Target for checking
     * @returns {boolean} Is HTMLNode ?
     * @memberof module:type
     */
    function isHTMLNode(html) {
        if (typeof HTMLElement === 'object') {
            return (html && (html instanceof HTMLElement || !!html.nodeType));
        }

        return !!(html && html.nodeType);
    }

    module.exports = isHTMLNode;


    /***/ }),

    /***/ "./node_modules/tui-code-snippet/type/isNull.js":
    /*!******************************************************!*\
      !*** ./node_modules/tui-code-snippet/type/isNull.js ***!
      \******************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is null or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Check whether the given variable is null or not.
     * If the given variable(arguments[0]) is null, returns true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is null?
     * @memberof module:type
     */
    function isNull(obj) {
        return obj === null;
    }

    module.exports = isNull;


    /***/ }),

    /***/ "./node_modules/tui-code-snippet/type/isNumber.js":
    /*!********************************************************!*\
      !*** ./node_modules/tui-code-snippet/type/isNumber.js ***!
      \********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is a number or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Check whether the given variable is a number or not.
     * If the given variable is a number, return true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is number?
     * @memberof module:type
     */
    function isNumber(obj) {
        return typeof obj === 'number' || obj instanceof Number;
    }

    module.exports = isNumber;


    /***/ }),

    /***/ "./node_modules/tui-code-snippet/type/isObject.js":
    /*!********************************************************!*\
      !*** ./node_modules/tui-code-snippet/type/isObject.js ***!
      \********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is an object or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Check whether the given variable is an object or not.
     * If the given variable is an object, return true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is object?
     * @memberof module:type
     */
    function isObject(obj) {
        return obj === Object(obj);
    }

    module.exports = isObject;


    /***/ }),

    /***/ "./node_modules/tui-code-snippet/type/isString.js":
    /*!********************************************************!*\
      !*** ./node_modules/tui-code-snippet/type/isString.js ***!
      \********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is a string or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Check whether the given variable is a string or not.
     * If the given variable is a string, return true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is string?
     * @memberof module:type
     */
    function isString(obj) {
        return typeof obj === 'string' || obj instanceof String;
    }

    module.exports = isString;


    /***/ }),

    /***/ "./node_modules/tui-code-snippet/type/isUndefined.js":
    /*!***********************************************************!*\
      !*** ./node_modules/tui-code-snippet/type/isUndefined.js ***!
      \***********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    /**
     * @fileoverview Check whether the given variable is undefined or not.
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     */



    /**
     * Check whether the given variable is undefined or not.
     * If the given variable is undefined, returns true.
     * @param {*} obj - Target for checking
     * @returns {boolean} Is undefined?
     * @memberof module:type
     */
    function isUndefined(obj) {
        return obj === undefined; // eslint-disable-line no-undefined
    }

    module.exports = isUndefined;


    /***/ }),

    /***/ "./src/css/selectBox.css":
    /*!*******************************!*\
      !*** ./src/css/selectBox.css ***!
      \*******************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    // extracted by mini-css-extract-plugin

    /***/ }),

    /***/ "./src/js/constants.js":
    /*!*****************************!*\
      !*** ./src/js/constants.js ***!
      \*****************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
      {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! tui-code-snippet/collection/forEachOwnProperties */ "./node_modules/tui-code-snippet/collection/forEachOwnProperties.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
    				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
    				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
    				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
      }
    })(this, function (_exports, _forEachOwnProperties) {

      _exports.__esModule = true;
      _exports.cls = void 0;
      _forEachOwnProperties = _interopRequireDefault(_forEachOwnProperties);

      function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

      /**
       * @fileoverview The static values
       * @author NHN. FE dev team.<dl_javascript@nhn.com>
       */
      var CSS_PREFIX = 'tui-select-box';
      var classNames = {
        SELECT_BOX: '',
        ITEM: 'item',
        ITEM_GROUP: 'item-group',
        ITEM_GROUP_LABEL: 'item-group-label',
        DROPDOWN: 'dropdown',
        INPUT: 'input',
        PLACEHOLDER: 'placeholder',
        ICON: 'icon',
        OPEN: 'open',
        HIDDEN: 'hidden',
        DISABLED: 'disabled',
        SELECTED: 'selected',
        HIGHLIGHT: 'highlight'
      };

      var cls = function () {
        (0, _forEachOwnProperties["default"])(classNames, function (value, key) {
          if (value) {
            classNames[key] = CSS_PREFIX + "-" + value;
          } else {
            classNames[key] = CSS_PREFIX;
          }
        });
        return classNames;
      }();

      _exports.cls = cls;
    });

    /***/ }),

    /***/ "./src/js/dropdown.js":
    /*!****************************!*\
      !*** ./src/js/dropdown.js ***!
      \****************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
      {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! tui-code-snippet/collection/forEachArray */ "./node_modules/tui-code-snippet/collection/forEachArray.js"), __webpack_require__(/*! tui-code-snippet/type/isExisty */ "./node_modules/tui-code-snippet/type/isExisty.js"), __webpack_require__(/*! tui-code-snippet/type/isNumber */ "./node_modules/tui-code-snippet/type/isNumber.js"), __webpack_require__(/*! tui-code-snippet/domUtil/addClass */ "./node_modules/tui-code-snippet/domUtil/addClass.js"), __webpack_require__(/*! tui-code-snippet/domUtil/removeClass */ "./node_modules/tui-code-snippet/domUtil/removeClass.js"), __webpack_require__(/*! tui-code-snippet/domUtil/removeElement */ "./node_modules/tui-code-snippet/domUtil/removeElement.js"), __webpack_require__(/*! ./utils */ "./src/js/utils.js"), __webpack_require__(/*! ./constants */ "./src/js/constants.js"), __webpack_require__(/*! ./itemGroup */ "./src/js/itemGroup.js"), __webpack_require__(/*! ./item */ "./src/js/item.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
    				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
    				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
    				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
      }
    })(this, function (_exports, _forEachArray, _isExisty, _isNumber, _addClass, _removeClass, _removeElement, _utils, _constants, _itemGroup, _item) {

      _exports.__esModule = true;
      _exports["default"] = void 0;
      _forEachArray = _interopRequireDefault(_forEachArray);
      _isExisty = _interopRequireDefault(_isExisty);
      _isNumber = _interopRequireDefault(_isNumber);
      _addClass = _interopRequireDefault(_addClass);
      _removeClass = _interopRequireDefault(_removeClass);
      _removeElement = _interopRequireDefault(_removeElement);
      _itemGroup = _interopRequireDefault(_itemGroup);
      _item = _interopRequireDefault(_item);

      function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

      function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

      function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

      function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

      /**
       * @class
       * @ignore
       * @param {object} options - options
       *   @param {string} [options.placeholder] - placeholder for an input
       *   @param {array<itemData|itemGroupData>} options.data - data for ItemGroups and Items
       *   @param {boolean} [options.disabled=false] - whether a dropdown should be disabled or not
       */
      var Dropdown =
      /*#__PURE__*/
      function () {
        function Dropdown(_ref) {
          var placeholder = _ref.placeholder,
              data = _ref.data,
              _ref$disabled = _ref.disabled,
              disabled = _ref$disabled === void 0 ? false : _ref$disabled;

          /**
           * @type {HTMLElement}
           * @private
           */
          this.el = (0, _utils.createElement)('ul', '', {
            className: _constants.cls.DROPDOWN + " " + _constants.cls.HIDDEN
          });
          /**
           * @type {HTMLElement}
           * @private
           */

          this.nativeEl = (0, _utils.createElement)('select', '', {
            className: _constants.cls.HIDDEN,
            tabIndex: -1
          });
          /**
           * Items and ItemGroups
           * @type {Array.<Item|ItemGroup>}
           * @private
           */

          this.items = [];
          /**
           * the number of Item
           * @type {number}
           * @private
           */

          this.itemLength = 0;
          /**
           * @type {Item}
           * @private
           */

          this.selectedItem = null;
          /**
           * @type {Item}
           * @private
           */

          this.highlightedItem = null;
          this.initialize(data, disabled, placeholder);
        }
        /**
         * Create Items and ItemGroups and calculate the number of Items
         * @return {array<Item|ItemGroup>}
         * @private
         */


        var _proto = Dropdown.prototype;

        _proto.initializeItems = function initializeItems(data) {
          var _this = this;

          var item;
          var itemIndex = 0;
          var itemGroupIndex = 0;
          data.forEach(function (datum) {
            if (datum.data) {
              item = new _itemGroup["default"](_objectSpread({
                index: itemIndex,
                itemGroupIndex: itemGroupIndex
              }, datum));
              itemIndex += datum.data.length - 1;
              itemGroupIndex += 1;
            } else {
              item = new _item["default"](_objectSpread({
                index: itemIndex
              }, datum));
            }

            _this.items.push(item);

            item.appendToContainer(_this.el, _this.nativeEl);
            itemIndex += 1;
          });
          this.itemLength = itemIndex;
        }
        /**
         * Initialize
         * @private
         */
        ;

        _proto.initialize = function initialize(data, disabled, placeholder) {
          var _this2 = this;

          if (placeholder) {
            (0, _utils.createElement)('option', '', {
              label: placeholder,
              value: ''
            }, this.nativeEl);
          }

          this.initializeItems(data);
          this.iterateItems(function (item) {
            if (!_this2.selectedItem && item.isSelected()) {
              _this2.selectedItem = item;
            } else if (_this2.selectedItem && item.isSelected()) {
              item.deselect();
            }
          });

          if (disabled) {
            this.disable();
          }
        }
        /**
         * Execute a function while iterating items
         * @param {function} callback - function to execute
         * @param  {...any} args - arguments
         * @private
         */
        ;

        _proto.iterateItems = function iterateItems(callback) {
          var _this3 = this;

          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          var index = 0;
          (0, _forEachArray["default"])(this.items, function (item) {
            var result = true;

            if (item instanceof _itemGroup["default"]) {
              (0, _forEachArray["default"])(item.getItems(), function (itemInGroup) {
                result = callback.apply(_this3, [itemInGroup, index].concat(args)) || false;
                index += 1;
                return result;
              });
              return result;
            }

            result = callback.apply(_this3, [item, index].concat(args));
            index += 1;
            return result;
          });
        }
        /**
         * Open a dropdown list
         */
        ;

        _proto.open = function open() {
          (0, _removeClass["default"])(this.el, _constants.cls.HIDDEN);
          var highlightedItem = !this.selectedItem || this.selectedItem.isDisabled() ? this.getItems(function (item) {
            return !item.isDisabled();
          })[0] : this.selectedItem;
          this.highlight(highlightedItem);
        }
        /**
         * Close a dropdown list
         */
        ;

        _proto.close = function close() {
          (0, _addClass["default"])(this.el, _constants.cls.HIDDEN);
          this.dehighlight();
        }
        /**
         * Disable an dropdown
         */
        ;

        _proto.disable = function disable() {
          this.nativeEl.disabled = true;
          (0, _addClass["default"])(this.el, _constants.cls.DISABLED);
        }
        /**
         * Enable an dropdown
         */
        ;

        _proto.enable = function enable() {
          this.nativeEl.disabled = false;
          (0, _removeClass["default"])(this.el, _constants.cls.DISABLED);
        }
        /**
         * Select an Item
         * @param {string|number|Item} value - if string, find an Item by its value. if number, find an Item by its index.
         * @return {Item} result of selection
         */
        ;

        _proto.select = function select(value) {
          var selectedItem = value instanceof _item["default"] ? value : this.getItem(value);
          this.deselect();

          if (!selectedItem || selectedItem && selectedItem.isDisabled()) {
            return null;
          }

          selectedItem.select();
          this.selectedItem = selectedItem;
          return selectedItem;
        }
        /**
         * Deselect an Item
         */
        ;

        _proto.deselect = function deselect() {
          if (this.selectedItem) {
            this.selectedItem.deselect();
            this.selectedItem = null;
          }
        }
        /**
         * Highlight an Item
         * @param {number|string|Item} value - if string, find an Item by its value. if number, find an Item by its index.
         */
        ;

        _proto.highlight = function highlight(value) {
          var highlightedItem;

          if (value instanceof _item["default"]) {
            highlightedItem = value;
          } else if ((0, _isExisty["default"])(value)) {
            highlightedItem = this.getItem(value);
          }

          if (highlightedItem && highlightedItem !== this.highlightedItem) {
            this.dehighlight();
            highlightedItem.highlight();
            this.highlightedItem = highlightedItem;
          }
        }
        /**
         * Dehighlight an Item
         */
        ;

        _proto.dehighlight = function dehighlight() {
          if (this.highlightedItem) {
            this.highlightedItem.dehighlight();
            this.highlightedItem = null;
          }
        }
        /**
         * Move a highlighted Item
         * @param {number} direction - direction to move
         */
        ;

        _proto.moveHighlightedItem = function moveHighlightedItem(direction) {
          var highlightedItem = this.getHighlightedItem();
          var items = this.getItems();
          var index = items.indexOf(highlightedItem);

          if (index > -1) {
            index += direction;

            for (; index < items.length && index >= 0; index += direction) {
              if (!items[index].isDisabled()) {
                this.highlight(items[index]);
                break;
              }
            }
          }
        }
        /**
         * Get all Items that pass the test implemented by the provided function
         * If filter function is not passed, it returns all Items
         * @param {function} callback - callback function to filter items
         * @param {number} number - the number of items to find. -1 means all items.
         * @return {array<Item>}
         */
        ;

        _proto.getItems = function getItems(callback, number) {
          if (callback === void 0) {
            callback = function callback() {
              return true;
            };
          }

          if (number === void 0) {
            number = -1;
          }

          var items = [];
          this.iterateItems(function (item) {
            if (callback(item)) {
              items.push(item);
              number -= 1;
              return number !== 0;
            }

            return true;
          });
          return items;
        }
        /**
         * Get an Item by its index or value
         * @param {number|string} value - if string, the Item's value. if number, the Item's index.
         * @return {Item}
         */
        ;

        _proto.getItem = function getItem(value) {
          var isValidItem = (0, _isNumber["default"])(value) ? function (comparedItem) {
            return comparedItem.getIndex() === value;
          } : function (comparedItem) {
            return comparedItem.getValue() === value;
          };
          return this.getItems(isValidItem, 1)[0];
        }
        /**
         * Get all ItemGroups that pass the test implemented by the provided function
         * If filter function is not passed, it returns all ItemGroups
         * @param {function} callback - callback function to filter item groups
         * @param {number} number - the number of item groups to find. -1 means all item groups.
         * @return {array<ItemGroup>}
         */
        ;

        _proto.getItemGroups = function getItemGroups(callback, number) {
          if (callback === void 0) {
            callback = function callback() {
              return true;
            };
          }

          if (number === void 0) {
            number = -1;
          }

          var itemGroups = [];
          (0, _forEachArray["default"])(this.items, function (itemGroup) {
            if (itemGroup instanceof _itemGroup["default"] && callback(itemGroup)) {
              itemGroups.push(itemGroup);
              number -= 1;
              return number !== 0;
            }

            return true;
          });
          return itemGroups;
        }
        /**
         * Get an ItemGroup by its index
         * @param {number} index - groupIndex of the ItemGroup
         * @return {ItemGroup}
         */
        ;

        _proto.getItemGroup = function getItemGroup(index) {
          return this.getItemGroups(function (itemGroup) {
            return itemGroup.getIndex() === index;
          }, 1)[0];
        }
        /**
         * Return the number of Items
         * @return {number}
         */
        ;

        _proto.getItemLength = function getItemLength() {
          return this.itemLength;
        }
        /**
         * Return the selected Item
         * @return {Item}
         */
        ;

        _proto.getSelectedItem = function getSelectedItem() {
          return this.selectedItem;
        }
        /**
         * Return the highlighted Item
         * @return {Item}
         */
        ;

        _proto.getHighlightedItem = function getHighlightedItem() {
          return this.highlightedItem;
        }
        /**
         * Append the element and native element to the container
         * @param {HTMLElement} container - container element
         */
        ;

        _proto.appendToContainer = function appendToContainer(container) {
          container.appendChild(this.el);
          container.appendChild(this.nativeEl);
        }
        /**
         * Destory a dropdown
         */
        ;

        _proto.destroy = function destroy() {
          this.items.forEach(function (item) {
            return item.destroy();
          });
          (0, _removeElement["default"])(this.el);
          (0, _removeElement["default"])(this.nativeEl);
          this.el = this.nativeEl = this.items = this.selectedItem = this.highlightedItem = null;
        };

        return Dropdown;
      }();

      _exports["default"] = Dropdown;
    });

    /***/ }),

    /***/ "./src/js/index.js":
    /*!*************************!*\
      !*** ./src/js/index.js ***!
      \*************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
      {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./selectBox */ "./src/js/selectBox.js"), __webpack_require__(/*! ../css/selectBox.css */ "./src/css/selectBox.css")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
    				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
    				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
    				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
      }
    })(this, function (_exports, _selectBox, _selectBox2) {

      _exports.__esModule = true;
      _exports["default"] = void 0;
      _selectBox = _interopRequireDefault(_selectBox);

      function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

      /**
       * @fileoverview
       * @author NHN FE Development Lab <dl_javascript@nhn.com>
       */
      var _default = _selectBox["default"];
      _exports["default"] = _default;
    });

    /***/ }),

    /***/ "./src/js/input.js":
    /*!*************************!*\
      !*** ./src/js/input.js ***!
      \*************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
      {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! tui-code-snippet/domUtil/addClass */ "./node_modules/tui-code-snippet/domUtil/addClass.js"), __webpack_require__(/*! tui-code-snippet/domUtil/removeClass */ "./node_modules/tui-code-snippet/domUtil/removeClass.js"), __webpack_require__(/*! tui-code-snippet/domUtil/removeElement */ "./node_modules/tui-code-snippet/domUtil/removeElement.js"), __webpack_require__(/*! ./utils */ "./src/js/utils.js"), __webpack_require__(/*! ./constants */ "./src/js/constants.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
    				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
    				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
    				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
      }
    })(this, function (_exports, _addClass, _removeClass, _removeElement, _utils, _constants) {

      _exports.__esModule = true;
      _exports["default"] = void 0;
      _addClass = _interopRequireDefault(_addClass);
      _removeClass = _interopRequireDefault(_removeClass);
      _removeElement = _interopRequireDefault(_removeElement);

      function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

      /**
       * @fileoverview Input
       * @author NHN FE Development Lab <dl_javascript@nhn.com>
       */

      /**
       * @class
       * @ignore
       * @param {object} options - options
       *   @param {string} [options.placeholder] - placeholder for a select box
       *   @param {string} [options.disabled] - whether an input should be disabled or not
       *   @param {boolean} [options.showIcon] - whether an arrow icon in the input should be shown
       */
      var Input =
      /*#__PURE__*/
      function () {
        function Input(_ref) {
          var placeholder = _ref.placeholder,
              disabled = _ref.disabled,
              showIcon = _ref.showIcon;

          /**
           * text for a placeholder
           * @type {string}
           * @private
           */
          this.placeholderText = placeholder;
          /**
           * @type {HTMLElement}
           * @private
           */

          this.el = (0, _utils.createElement)('div', '', {
            className: _constants.cls.INPUT,
            tabIndex: 0
          });
          /**
           * @type {HTMLElement}
           * @private
           */

          this.placeholderEl = (0, _utils.createElement)('p', this.placeholderText, {
            className: _constants.cls.PLACEHOLDER
          }, this.el);
          this.initialize(disabled, showIcon);
        }
        /**
         * Initialize
         * @private
         */


        var _proto = Input.prototype;

        _proto.initialize = function initialize(disabled, showIcon) {
          if (showIcon) {
            (0, _utils.createElement)('span', 'select', {
              className: _constants.cls.ICON
            }, this.el);
          } else {
            this.placeholderEl.width = '100%';
          }

          if (disabled) {
            this.disable();
          }
        }
        /**
         * Disable an input
         */
        ;

        _proto.disable = function disable() {
          (0, _addClass["default"])(this.el, _constants.cls.DISABLED);
        }
        /**
         * Enable an input
         */
        ;

        _proto.enable = function enable() {
          (0, _removeClass["default"])(this.el, _constants.cls.DISABLED);
        }
        /**
         * Open an input
         */
        ;

        _proto.open = function open() {
          (0, _addClass["default"])(this.el, _constants.cls.OPEN);
        }
        /**
         * Close an input
         */
        ;

        _proto.close = function close() {
          (0, _removeClass["default"])(this.el, _constants.cls.OPEN);
        }
        /**
         * Focus
         */
        ;

        _proto.focus = function focus() {
          this.el.focus();
        }
        /**
         * Change the text in the placeholder
         * @param {Item} item - selected Item
         */
        ;

        _proto.changeText = function changeText(item) {
          if (item) {
            this.placeholderEl.innerText = item.getLabel();
          } else {
            this.placeholderEl.innerText = this.placeholderText;
          }
        }
        /**
         * Append the element to the container
         * @param {HTMLElement} container - container element
         */
        ;

        _proto.appendToContainer = function appendToContainer(container) {
          container.appendChild(this.el);
        }
        /**
         * Destroy an input
         */
        ;

        _proto.destroy = function destroy() {
          (0, _removeElement["default"])(this.el);
          this.el = this.placeholderEl = null;
        };

        return Input;
      }();

      _exports["default"] = Input;
    });

    /***/ }),

    /***/ "./src/js/item.js":
    /*!************************!*\
      !*** ./src/js/item.js ***!
      \************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
      {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! tui-code-snippet/domUtil/addClass */ "./node_modules/tui-code-snippet/domUtil/addClass.js"), __webpack_require__(/*! tui-code-snippet/domUtil/removeClass */ "./node_modules/tui-code-snippet/domUtil/removeClass.js"), __webpack_require__(/*! tui-code-snippet/domUtil/removeElement */ "./node_modules/tui-code-snippet/domUtil/removeElement.js"), __webpack_require__(/*! ./utils */ "./src/js/utils.js"), __webpack_require__(/*! ./constants */ "./src/js/constants.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
    				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
    				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
    				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
      }
    })(this, function (_exports, _addClass, _removeClass, _removeElement, _utils, _constants) {

      _exports.__esModule = true;
      _exports["default"] = void 0;
      _addClass = _interopRequireDefault(_addClass);
      _removeClass = _interopRequireDefault(_removeClass);
      _removeElement = _interopRequireDefault(_removeElement);

      function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

      /**
       * @fileoverview Item
       * @author NHN FE Development Lab <dl_javascript@nhn.com>
       */

      /**
       * @class
       * @description
       * An item.
       * You can get Item by {@link SelectBox#getItem SelectBox.getItem()} and {@link SelectBox#getItems SelectBox.getItems()}.
       */
      var Item =
      /*#__PURE__*/
      function () {
        /**
         * @hideconstructor
         * @param {object} options - options
         *   @param {string} [options.label] - label to be displayed in the drop-down list
         *   @param {string} options.value - value of an item
         *   @param {boolean} [options.disabled=false] - whether an Item should be disabled or not
         *   @param {boolean} [options.selected=false] - whether an Item should be pre-selected or not
         *   @param {number} options.index - Item's index
         */
        function Item(_ref) {
          var value = _ref.value,
              label = _ref.label,
              disabled = _ref.disabled,
              selected = _ref.selected,
              index = _ref.index;

          /**
           * value of an item
           * @type {string}
           * @private
           */
          this.value = "" + value;
          /**
           * label to be displayed in the drop-down list
           * if label is an empty string, it should be same as its value
           * @type {string}
           * @private
           */

          this.label = label || this.value;
          /**
           * @type {number}
           * @private
           */

          this.index = index;
          /**
           * whether an ItemGroup of the Item is disabled or not
           * @type {boolean}
           * @private
           */

          this.itemGroupDisabled = false;
          /**
           * whether an Item is disabled or not
           * @type {boolean}
           * @private
           */

          this.itemDisabled = false;
          /**
           * @type {boolean}
           * @private
           */

          this.selected = false;
          /**
           * <li> element for a custom dropdown item
           * @type {HTMLElement}
           * @private
           */

          this.el = (0, _utils.createElement)('li', this.label, {
            className: _constants.cls.ITEM,
            tabIndex: -1,
            'data-value': this.value,
            'data-index': this.index
          });
          /**
           * <option> element for a select element
           * @type {HTMLElement}
           * @private
           */

          this.nativeEl = (0, _utils.createElement)('option', '', {
            value: this.value,
            label: this.label
          });
          this.initialize(disabled, selected);
        }
        /**
         * Initialize
         * @private
         */


        var _proto = Item.prototype;

        _proto.initialize = function initialize(disabled, selected) {
          if (selected) {
            this.select();
          }

          if (disabled) {
            this.disable();
          }
        }
        /**
         * Make an Item disable
         * @private
         */
        ;

        _proto.makeDisable = function makeDisable() {
          this.nativeEl.disabled = true;
          (0, _addClass["default"])(this.el, _constants.cls.DISABLED);
        }
        /**
         * Make an Item enable
         * @private
         */
        ;

        _proto.makeEnable = function makeEnable() {
          this.nativeEl.disabled = false;
          (0, _removeClass["default"])(this.el, _constants.cls.DISABLED);
        }
        /**
         * Disable an Item due to an ItemGroup
         * @ignore
         */
        ;

        _proto.disableItemGroup = function disableItemGroup() {
          this.itemGroupDisabled = true;
          this.makeDisable();
        }
        /**
         * Enable an Item due to an ItemGroup
         * @ignore
         */
        ;

        _proto.enableItemGroup = function enableItemGroup() {
          this.itemGroupDisabled = false;

          if (!this.isDisabled()) {
            this.makeEnable();
          }
        }
        /**
         * Disable an Item
         * @ignore
         */
        ;

        _proto.disable = function disable() {
          this.itemDisabled = true;
          this.makeDisable();
        }
        /**
         * Enable an Item
         * @ignore
         */
        ;

        _proto.enable = function enable() {
          this.itemDisabled = false;

          if (!this.isDisabled()) {
            this.makeEnable();
          }
        }
        /**
         * Select an Item
         * @ignore
         */
        ;

        _proto.select = function select() {
          if (!this.isDisabled()) {
            this.selected = this.nativeEl.selected = true;
            (0, _addClass["default"])(this.el, _constants.cls.SELECTED);
          }
        }
        /**
         * Deselect an Item
         * @ignore
         */
        ;

        _proto.deselect = function deselect() {
          this.selected = this.nativeEl.selected = false;
          (0, _removeClass["default"])(this.el, _constants.cls.SELECTED);
        }
        /**
         * Highlight an Item
         * @ignore
         */
        ;

        _proto.highlight = function highlight() {
          if (!this.isDisabled()) {
            (0, _addClass["default"])(this.el, _constants.cls.HIGHLIGHT);
            this.el.focus();
          }
        }
        /**
         * Remove a highlight from an Item
         * @ignore
         */
        ;

        _proto.dehighlight = function dehighlight() {
          (0, _removeClass["default"])(this.el, _constants.cls.HIGHLIGHT);
          this.el.blur();
        }
        /**
         * Return an item's value.
         * @return {string}
         */
        ;

        _proto.getValue = function getValue() {
          return this.value;
        }
        /**
         * Return an item's label.
         * @return {string}
         */
        ;

        _proto.getLabel = function getLabel() {
          return this.label;
        }
        /**
         * Return an item's index.
         * @return {number}
         */
        ;

        _proto.getIndex = function getIndex() {
          return this.index;
        }
        /**
         * Return whether an item is selected or not.
         * @return {boolean}
         */
        ;

        _proto.isSelected = function isSelected() {
          return this.selected;
        }
        /**
         * Return whether an item is disabled or not.
         * The result is true if any of the items and item groups are disabled.
         * @return {boolean}
         */
        ;

        _proto.isDisabled = function isDisabled() {
          return this.itemDisabled || this.itemGroupDisabled;
        }
        /**
         * Append the element and native element to the containers
         * @param {HTMLElement} container - container element
         * @param {HTMLElement} nativeContainer - native container element
         * @ignore
         */
        ;

        _proto.appendToContainer = function appendToContainer(container, nativeContainer) {
          container.appendChild(this.el);
          nativeContainer.appendChild(this.nativeEl);
        }
        /**
         * Destroy an Item
         * @ignore
         */
        ;

        _proto.destroy = function destroy() {
          (0, _removeElement["default"])(this.el);
          (0, _removeElement["default"])(this.nativeEl);
          this.el = this.nativeEl = null;
        };

        return Item;
      }();

      _exports["default"] = Item;
    });

    /***/ }),

    /***/ "./src/js/itemGroup.js":
    /*!*****************************!*\
      !*** ./src/js/itemGroup.js ***!
      \*****************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
      {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! tui-code-snippet/domUtil/addClass */ "./node_modules/tui-code-snippet/domUtil/addClass.js"), __webpack_require__(/*! tui-code-snippet/domUtil/removeClass */ "./node_modules/tui-code-snippet/domUtil/removeClass.js"), __webpack_require__(/*! tui-code-snippet/domUtil/removeElement */ "./node_modules/tui-code-snippet/domUtil/removeElement.js"), __webpack_require__(/*! ./utils */ "./src/js/utils.js"), __webpack_require__(/*! ./constants */ "./src/js/constants.js"), __webpack_require__(/*! ./item */ "./src/js/item.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
    				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
    				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
    				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
      }
    })(this, function (_exports, _addClass, _removeClass, _removeElement, _utils, _constants, _item) {

      _exports.__esModule = true;
      _exports["default"] = void 0;
      _addClass = _interopRequireDefault(_addClass);
      _removeClass = _interopRequireDefault(_removeClass);
      _removeElement = _interopRequireDefault(_removeElement);
      _item = _interopRequireDefault(_item);

      function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

      function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

      function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

      function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

      /**
       * @class
       * @description
       * A group of items.
       * You can get ItemGroup by {@link SelectBox#getItemGroup SelectBox.getItemGroup()} and {@link SelectBox#getItemGroups SelectBox.getItemGroups()}.
       */
      var ItemGroup =
      /*#__PURE__*/
      function () {
        /**
         * @hideconstructor
         * @param {object} options - options
         *   @param {string} [options.label] - label to be displayed in the dropdown list
         *   @param {array<itemData>} options.data - data for Items to be included in the ItemGroup
         *   @param {boolean} [options.disabled=false] - whether an ItemGroup should be disabled or not
         *   @param {number} options.index - index of the first Item in the ItemGroup
         *   @param {number} options.itemGroupIndex - index of the ItemGroup
         */
        function ItemGroup(_ref) {
          var _ref$label = _ref.label,
              label = _ref$label === void 0 ? '' : _ref$label,
              data = _ref.data,
              _ref$disabled = _ref.disabled,
              disabled = _ref$disabled === void 0 ? false : _ref$disabled,
              index = _ref.index,
              itemGroupIndex = _ref.itemGroupIndex;

          /**
           * @type {HTMLElement}
           * @private
           */
          this.el = (0, _utils.createElement)('li', '', {
            'data-group-index': itemGroupIndex
          });
          /**
           * @type {HTMLElement}
           * @private
           */

          this.labelEl = (0, _utils.createElement)('span', label, {
            className: _constants.cls.ITEM_GROUP_LABEL
          }, this.el);
          /**
           * @type {HTMLElement}
           * @private
           */

          this.itemContainerEl = (0, _utils.createElement)('ul', '', {
            className: _constants.cls.ITEM_GROUP
          }, this.el);
          /**
           * @type {HTMLElement}
           * @private
           */

          this.nativeEl = (0, _utils.createElement)('optgroup', label);
          /**
           * @type {array<Item>}
           * @private
           */

          this.items = this.createItems(data, index);
          /**
           * @type {number}
           * @private
           */

          this.index = itemGroupIndex;
          /**
           * @type {string}
           * @private
           */

          this.label = label;
          /**
           * whether an ItemGroup is disabled or not
           * @type {boolean}
           * @private
           */

          this.disabled = false;
          this.initialize(disabled);
        }
        /**
         * Create Items to be included in the ItemGroup
         * @return {array<Item>}
         * @private
         */


        var _proto = ItemGroup.prototype;

        _proto.createItems = function createItems(data, index) {
          var _this = this;

          return data.map(function (datum, itemIndex) {
            var item = new _item["default"](_objectSpread({
              index: index + itemIndex
            }, datum));
            item.appendToContainer(_this.itemContainerEl, _this.nativeEl);
            return item;
          });
        }
        /**
         * Initialize
         * @private
         */
        ;

        _proto.initialize = function initialize(disabled) {
          if (disabled) {
            this.disable();
          }
        }
        /**
         * Disable an ItemGroup
         * @ignore
         */
        ;

        _proto.disable = function disable() {
          this.disabled = this.nativeEl.disabled = true;
          (0, _addClass["default"])(this.labelEl, _constants.cls.DISABLED);
          this.items.forEach(function (item) {
            return item.disableItemGroup();
          });
        }
        /**
         * Enable an ItemGroup
         * @ignore
         */
        ;

        _proto.enable = function enable() {
          this.disabled = this.nativeEl.disabled = false;
          (0, _removeClass["default"])(this.labelEl, _constants.cls.DISABLED);
          this.items.forEach(function (item) {
            return item.enableItemGroup();
          });
        }
        /**
         * Get {@link Item items} in the item group.
         * @return {array<Item>}
         * @example
         * const items = itemGroup.getItems();
         * console.log(items[0]); // first item in the item group
         * console.log(items.length); // the number of items in the item group
         */
        ;

        _proto.getItems = function getItems() {
          return this.items;
        }
        /**
         * Return an item group's index.
         * @return {number}
         */
        ;

        _proto.getIndex = function getIndex() {
          return this.index;
        }
        /**
         * Return an item group's label.
         * @return {string}
         */
        ;

        _proto.getLabel = function getLabel() {
          return this.label;
        }
        /**
         * Return whether an ItemGroup is disabled or not.
         * @return {boolean}
         */
        ;

        _proto.isDisabled = function isDisabled() {
          return this.disabled;
        }
        /**
         * Append the element and native element to the containers
         * @param {HTMLElement} container - container element
         * @param {HTMLElement} nativeContainer - native container element
         * @ignore
         */
        ;

        _proto.appendToContainer = function appendToContainer(container, nativeContainer) {
          container.appendChild(this.el);
          nativeContainer.appendChild(this.nativeEl);
        }
        /**
         * Destory an ItemGroup
         * @ignore
         */
        ;

        _proto.destroy = function destroy() {
          this.items.forEach(function (item) {
            return item.destroy();
          });
          (0, _removeElement["default"])(this.el);
          (0, _removeElement["default"])(this.nativeEl);
          this.el = this.labelEl = this.itemContainerEl = this.nativeEl = this.items = null;
        };

        return ItemGroup;
      }();

      _exports["default"] = ItemGroup;
    });

    /***/ }),

    /***/ "./src/js/keyEventUtils.js":
    /*!*********************************!*\
      !*** ./src/js/keyEventUtils.js ***!
      \*********************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
      {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
    				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
    				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
    				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
      }
    })(this, function (_exports) {

      _exports.__esModule = true;
      _exports.identifyKey = void 0;

      /**
       * @fileoverview Utility functions related to key events
       * @author NHN. FE dev team.<dl_javascript@nhn.com>
       */
      var keyCodeMap = {
        38: 'arrowUp',
        40: 'arrowDown',
        32: 'space',
        13: 'enter',
        27: 'escape',
        61: 'tab'
      };
      var keyMap = {
        ArrowUp: 'arrowUp',
        Up: 'arrowUp',
        ArrowDown: 'arrowDown',
        Down: 'arrowDown',
        ' ': 'space',
        Spacebar: 'space',
        Enter: 'enter',
        Escape: 'escape',
        Esc: 'escape',
        Tab: 'tab'
      };
      /**
       * Identify the key (polyfill for IE)
       * @param {string} ev - keyboard event
       * @return {string} - key
       */

      var identifyKey = function identifyKey(ev) {
        var key = ev.key,
            keyCode = ev.keyCode;

        if (key) {
          return keyMap[key] || key;
        }

        return keyCodeMap[keyCode] || keyCode;
      };

      _exports.identifyKey = identifyKey;
    });

    /***/ }),

    /***/ "./src/js/selectBox.js":
    /*!*****************************!*\
      !*** ./src/js/selectBox.js ***!
      \*****************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
      {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! tui-code-snippet/customEvents/customEvents */ "./node_modules/tui-code-snippet/customEvents/customEvents.js"), __webpack_require__(/*! tui-code-snippet/domEvent/on */ "./node_modules/tui-code-snippet/domEvent/on.js"), __webpack_require__(/*! tui-code-snippet/domEvent/off */ "./node_modules/tui-code-snippet/domEvent/off.js"), __webpack_require__(/*! tui-code-snippet/domEvent/preventDefault */ "./node_modules/tui-code-snippet/domEvent/preventDefault.js"), __webpack_require__(/*! tui-code-snippet/domEvent/getTarget */ "./node_modules/tui-code-snippet/domEvent/getTarget.js"), __webpack_require__(/*! tui-code-snippet/domUtil/closest */ "./node_modules/tui-code-snippet/domUtil/closest.js"), __webpack_require__(/*! tui-code-snippet/domUtil/removeElement */ "./node_modules/tui-code-snippet/domUtil/removeElement.js"), __webpack_require__(/*! tui-code-snippet/type/isObject */ "./node_modules/tui-code-snippet/type/isObject.js"), __webpack_require__(/*! tui-code-snippet/type/isExisty */ "./node_modules/tui-code-snippet/type/isExisty.js"), __webpack_require__(/*! tui-code-snippet/type/isHTMLNode */ "./node_modules/tui-code-snippet/type/isHTMLNode.js"), __webpack_require__(/*! tui-code-snippet/request/sendHostname */ "./node_modules/tui-code-snippet/request/sendHostname.js"), __webpack_require__(/*! ./utils */ "./src/js/utils.js"), __webpack_require__(/*! ./keyEventUtils */ "./src/js/keyEventUtils.js"), __webpack_require__(/*! ./constants */ "./src/js/constants.js"), __webpack_require__(/*! ./input */ "./src/js/input.js"), __webpack_require__(/*! ./dropdown */ "./src/js/dropdown.js"), __webpack_require__(/*! ./itemGroup */ "./src/js/itemGroup.js"), __webpack_require__(/*! ./item */ "./src/js/item.js"), __webpack_require__(/*! ./theme */ "./src/js/theme.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
    				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
    				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
    				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
      }
    })(this, function (_exports, _customEvents, _on, _off, _preventDefault, _getTarget, _closest, _removeElement, _isObject, _isExisty, _isHTMLNode, _sendHostname, _utils, _keyEventUtils, _constants, _input, _dropdown, _itemGroup, _item, _theme) {

      _exports.__esModule = true;
      _exports["default"] = void 0;
      _customEvents = _interopRequireDefault(_customEvents);
      _on = _interopRequireDefault(_on);
      _off = _interopRequireDefault(_off);
      _preventDefault = _interopRequireDefault(_preventDefault);
      _getTarget = _interopRequireDefault(_getTarget);
      _closest = _interopRequireDefault(_closest);
      _removeElement = _interopRequireDefault(_removeElement);
      _isObject = _interopRequireDefault(_isObject);
      _isExisty = _interopRequireDefault(_isExisty);
      _isHTMLNode = _interopRequireDefault(_isHTMLNode);
      _sendHostname = _interopRequireDefault(_sendHostname);
      _input = _interopRequireDefault(_input);
      _dropdown = _interopRequireDefault(_dropdown);
      _itemGroup = _interopRequireDefault(_itemGroup);
      _item = _interopRequireDefault(_item);
      _theme = _interopRequireDefault(_theme);

      function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

      /**
       * @fileoverview SelectBox
       * @author NHN FE Development Lab <dl_javascript@nhn.com>
       */

      /**
       * @class
       * @param {HTMLElement|string} container - container element or selector
       * @mixes CustomEvents
       * @param {object} options
       *   @param {array<itemData|itemGroupData>} options.data - array of {@link itemData} and {@link itemGroupData}
       *   @param {string} [options.placeholder] - placeholder for an input
       *   @param {boolean} [options.disabled] - whether an Item should be disabled or not
       *   @param {boolean} [options.autofocus] - whether a selectbox should get focus when the select box appends to the container
       *   @param {boolean} [options.autoclose] - whether a selectbox should close after selection
       *   @param {boolean} [options.showIcon] - whether an arrow icon in the input should be shown
       *   @param {object} [options.theme] - {@link themeConfig} for custom style
       *   @param {boolean} [options.usageStatistics] - whether send hostname to google analytics. If you don't want to send the hostname, please set to false.
       * @example
       * import SelectBox from '@toast-ui/select-box';
       * // or const SelectBox = require('@toast-ui/select-box');
       * // or const SelectBox = tui.SelectBox;
       *
       * const selectBox = new SelectBox('#select-box', {
       *   placeholder: 'Please select an option.',
       *   data: [
       *     {
       *       label: 'Fruits',
       *       data: [ { label: 'Apple', value: 'apple' }, { label: 'Banana', value: 'banana' } ]
       *     },
       *     { label: 'The quick brown fox jumps over the lazy dog.', value: 'none' },
       *     {
       *       label: 'Colors',
       *       data: [
       *         { label: 'Red', value: 'red' },
       *         { label: 'Yellow', value: 'yellow' },
       *         { label: 'Green', value: 'green', disabled: true },
       *         { label: 'Blue', value: 'blue', disabled: true },
       *         { label: 'Purple', value: 'purple' }
       *       ]
       *     }
       *   ],
       *   autofocus: true,
       *   showIcon: false,
       *   theme: {
       *     'common.border': '1px solid black',
       *     'common.color': 'black',
       *     'item.highlighted.background': 'yellow'
       *   }
       * });
       */

      /**
       * SelectBox provides some custom events: ({@link SelectBox#event-open open}, {@link SelectBox#event-close close}, {@link SelectBox#event-disable disable}, {@link SelectBox#event-enable enable}, {@link SelectBox#event-change change}).
       * You can bind event handlers by {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents#on selectBox.on(eventName, handler)} and unbind by {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents#off selectBox.off(eventName, handler)}.
       * Refer to the {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents CustomEvents} document at {@link https://github.com/nhn/tui.code-snippet tui-code-snippet} to know how to bind, and unbind custom events.
       * The example using custom events can be found {@link tutorial-example03-custom-events here}.
       * @typedef {class} CustomEvents
       * @example
       * // bind 'change' event
       * selectBox.on('change', ev => {
       *   console.log(`selected item is changed from ${ev.prev.getLabel()} to ${ev.curr.getLabel()}.`);
       * });
       *
       * // bind 'disable' and enable event
       * const print = ev => {
       *   let target = '';
       *   if (ev.target instanceof SelectBox) {
       *     target = 'Select box';
       *   } else {
       *     target = ev.target.getLabel();
       *   }
       *   console.log(`${target} is ${ev.type}.`);
       * }
       * selectBox.on({
       *   disable: print,
       *   enable: print
       * });
       *
       * // unbind change event
       * selectBox.off('change');
       *
       * // unbind disable event
       * selectBox.off(disable, print);
       *
       * // unbind all events
       * selectBox.off();
       */

      /**
       * Data of an {@link Item item}.
       * It is used for creating a {@link SelectBox}.
       * @typedef {object} itemData - data for {@link Item item}
       * @property {string} label - label to be displayed
       * @property {string} value - value of an item
       * @property {boolean} [disabled=false] - whether an item should be disabled or not
       * @property {boolean} [selected=false] - whether an item should be pre-selected or not
       * @example
       * const itemData = {
       *   label: 'disabled item',
       *   value: '0',
       *   disabled: true,
       *   selected: false
       * };
       */

      /**
       * Data of an {@link ItemGroup item group}.
       * It is used for creating a {@link SelectBox}.
       * ItemGroup supports only 1 level choices, so it does not work to add item groups in the item group.
       * The example using item groups can be found {@link tutorial-example01-basic here}.
       * @typedef {object} itemGroupData - data for {@link ItemGroup item group}
       * @property {string} label - label to be displayed
       * @property {array} data - {@link itemData data for item}
       * @property {boolean} [disabled=false] - whether an item group should be disabled or not
       * @example
       * const itemGroupData = {
       *   label: 'disabled items',
       *   data: [
       *     { label: 'disable', value: 'disable' },
       *     { label: 'none', value: '0' }
       *   ],
       *   disabled: true
       * };
       */
      var SelectBox =
      /*#__PURE__*/
      function () {
        function SelectBox(container, _ref) {
          var data = _ref.data,
              _ref$placeholder = _ref.placeholder,
              placeholder = _ref$placeholder === void 0 ? '' : _ref$placeholder,
              _ref$disabled = _ref.disabled,
              disabled = _ref$disabled === void 0 ? false : _ref$disabled,
              _ref$autofocus = _ref.autofocus,
              autofocus = _ref$autofocus === void 0 ? false : _ref$autofocus,
              _ref$autoclose = _ref.autoclose,
              autoclose = _ref$autoclose === void 0 ? true : _ref$autoclose,
              _ref$showIcon = _ref.showIcon,
              showIcon = _ref$showIcon === void 0 ? true : _ref$showIcon,
              theme = _ref.theme,
              _ref$usageStatistics = _ref.usageStatistics,
              usageStatistics = _ref$usageStatistics === void 0 ? true : _ref$usageStatistics;

          /**
           * @type {HTMLElement}
           * @private
           */
          this.el = (0, _utils.createElement)('div', '', {
            className: _constants.cls.SELECT_BOX
          });
          /**
           * @type {Input}
           * @private
           */

          this.input = new _input["default"]({
            placeholder: placeholder,
            disabled: disabled,
            showIcon: showIcon
          });
          /**
           * @type {Dropdown}
           * @private
           */

          this.dropdown = new _dropdown["default"]({
            placeholder: placeholder,
            disabled: disabled,
            data: data
          });
          /**
           * @type {boolean}
           * @private
           */

          this.opened = false;
          /**
           * @type {boolean}
           * @private
           */

          this.diabled = false;
          /**
           * @type {boolean}
           */

          this.autoclose = autoclose;
          /**
           * @type {Theme}
           * @private
           */

          this.theme = (0, _isObject["default"])(theme) ? new _theme["default"](theme, container) : null;
          this.initialize({
            placeholder: placeholder,
            disabled: disabled
          });
          this.appendToContainer(container);

          if (autofocus) {
            this.input.focus();
          }

          if (usageStatistics) {
            (0, _sendHostname["default"])('select-box', 'UA-129987462-1');
          }
        }
        /**
         * Append the select box element to the container
         * @param {HTMLElement|string} container - container element or selector
         * @private
         */


        var _proto = SelectBox.prototype;

        _proto.appendToContainer = function appendToContainer(container) {
          var containerEl = (0, _isHTMLNode["default"])(container) ? container : document.querySelector(container);
          containerEl.appendChild(this.el);
        }
        /**
         * Initialize
         * @param {object} options - options
         * @private
         */
        ;

        _proto.initialize = function initialize(options) {
          var selectedItem = this.getSelectedItem();

          if (selectedItem) {
            this.input.changeText(selectedItem);
          } else if (!options.placeholder) {
            this.select(0);
          }

          if (options.disabled) {
            this.disable();
          }

          this.bindEvents();
          this.input.appendToContainer(this.el);
          this.dropdown.appendToContainer(this.el);
        }
        /**
         * Bind events
         * @private
         */
        ;

        _proto.bindEvents = function bindEvents() {
          var _this = this;

          (0, _on["default"])(document, 'click', function (ev) {
            var target = (0, _getTarget["default"])(ev);

            if (!(0, _closest["default"])(target, "." + _constants.cls.SELECT_BOX) && _this.opened) {
              _this.close();
            }
          }, this);
          (0, _on["default"])(this.el, 'click', function (ev) {
            return _this.handleClick(ev, _constants.cls);
          });
          (0, _on["default"])(this.el, 'mouseover', function (ev) {
            return _this.handleMouseover(ev, _constants.cls);
          });
          (0, _on["default"])(this.el, 'keydown', function (ev) {
            return _this.handleKeydown(ev, _constants.cls);
          });
        }
        /**
         * Unbind events
         * @private
         */
        ;

        _proto.unbindEvents = function unbindEvents() {
          (0, _off["default"])(document, 'click');
          (0, _off["default"])(this.el, 'click mouseover keydown');
        }
        /**
         * Handle click events
         * @param {Event} ev - an event
         * @param {object} cls - cls
         * @private
         */
        ;

        _proto.handleClick = function handleClick(ev, _ref2) {
          var INPUT = _ref2.INPUT,
              ITEM = _ref2.ITEM;
          var target = (0, _getTarget["default"])(ev);
          var itemEl = (0, _closest["default"])(target, "." + ITEM);

          if (itemEl) {
            this.select(itemEl.getAttribute('data-value'));
          } else if ((0, _closest["default"])(target, "." + INPUT)) {
            this.toggle();
          }
        }
        /**
         * Handle mouseover events
         * @param {Event} ev - an event
         * @param {object} cls - cls
         * @private
         */
        ;

        _proto.handleMouseover = function handleMouseover(ev, _ref3) {
          var ITEM = _ref3.ITEM;

          if (this.checkMousemove(ev.clientX, ev.clientY)) {
            var target = (0, _getTarget["default"])(ev);
            var itemEl = (0, _closest["default"])(target, "." + ITEM);

            if (itemEl) {
              this.dropdown.highlight(itemEl.getAttribute('data-value'));
            }
          }
        }
        /**
         * Check if a pointer is moved
         * @param {number} x - mouseEvent.clientX
         * @param {number} y - mouseEvent.clientY
         * @return {boolean}
         * @private
         */
        ;

        _proto.checkMousemove = function checkMousemove(x, y) {
          if (this.prevX !== x || this.prevY !== y) {
            this.prevX = x;
            this.prevY = y;
            return true;
          }

          return false;
        }
        /**
         * Handle keydown events
         * @param {Event} ev - an event
         * @param {object} classNames - cls
         * @private
         */
        ;

        _proto.handleKeydown = function handleKeydown(ev, classNames) {
          var key = (0, _keyEventUtils.identifyKey)(ev);
          var closeKeys = ['tab', 'escape'];
          var activeKeys = ['arrowUp', 'arrowDown', 'space', 'enter'];

          if (closeKeys.indexOf(key) > -1 && this.opened) {
            this.close();

            if (key === 'escape') {
              this.input.focus();
            }
          } else if (activeKeys.indexOf(key) > -1) {
            (0, _preventDefault["default"])(ev);
            this.activateKeydown(ev, key, classNames);
          }
        }
        /**
         * Activate keydown events
         * @param {Event} ev - an event
         * @param {string} key - key pressed
         * @param {object} classNames - cls
         * @private
         */
        ;

        _proto.activateKeydown = function activateKeydown(ev, key, _ref4) {
          var ITEM = _ref4.ITEM,
              INPUT = _ref4.INPUT;
          var target = (0, _getTarget["default"])(ev);
          var itemEl = (0, _closest["default"])(target, "." + ITEM);

          if (key === 'escape' && this.opened) {
            this.close();
            this.input.focus();
          } else if (itemEl) {
            this.pressKeyOnItem(key, itemEl);
          } else if ((0, _closest["default"])(target, "." + INPUT)) {
            this.pressKeyOnInput(key);
          }
        }
        /**
         * Handle keydown events when it occurs on the Input
         * @param {string} key - key
         * @private
         */
        ;

        _proto.pressKeyOnInput = function pressKeyOnInput(key) {
          if (!this.opened) {
            this.open();
          } else if (key === 'arrowUp' || key === 'arrowDown') {
            this.dropdown.moveHighlightedItem(key === 'arrowUp' ? -1 : 1);
          }
        }
        /**
         * Handle keydown events when it occurs on the Item
         * @param {string} key - key
         * @param {HTMLElement} itemEl - Item.el
         * @private
         */
        ;

        _proto.pressKeyOnItem = function pressKeyOnItem(key, itemEl) {
          if (key === 'enter' || key === 'space') {
            this.selectByKeydown(itemEl);
          } else if (key === 'arrowUp' || key === 'arrowDown') {
            this.dropdown.moveHighlightedItem(key === 'arrowUp' ? -1 : 1);
          }
        }
        /**
         * Select an Item by space or enter
         * @param {HTMLElement} itemEl - Item.el
         * @private
         */
        ;

        _proto.selectByKeydown = function selectByKeydown(itemEl) {
          this.select(itemEl.getAttribute('data-value'));
          this.close();
          this.input.focus();
        }
        /**
         * Disable a select box, {@link ItemGroup item group} or {@link Item item}.
         * If it takes no arguments, a select box is disabled.
         * If it takes string, an item with the same value as the argument is disabled.
         * If it takes number, an item with the same index as the argument is disabled.
         * If it takes Item or ItemGroup, an argument itself is disabled.
         * @param {string|number|Item|ItemGroup} value - if string, find an Item by its value. if number, find an Item by its index.
         * @example
         * selectBox.disable(); // select box is disabled.
         * selectBox.disable(1); // second item is disabled.
         * selectBox.disable('value') // item which of value is 'value' is disabled.
         * selectBox.disable(selectBox.getSelectedItem()); // selected item is disabled.
         */
        ;

        _proto.disable = function disable(value) {
          if (!(0, _isExisty["default"])(value)) {
            this.disabled = true;
            this.input.disable();
            this.dropdown.disable();
            /**
             * Occurs when a select box, {@link ItemGroup item group} or {@link Item item} is disabled.
             * @event SelectBox#disable
             * @type {object} ev
             * @property {string} type - event name ('disable')
             * @property {SelectBox|ItemGroup|Item} target - disabled target
             * @example
             * selectBox.on('disable', ev => {
             *   console.log(ev.target);
             * });
             */

            this.fire('disable', {
              type: 'disable',
              target: this
            });
          } else if (value instanceof _item["default"] || value instanceof _itemGroup["default"]) {
            value.disable();
            this.fire('disable', {
              type: 'disable',
              target: value
            });
          } else {
            var disabledItem = this.dropdown.getItem(value);

            if (disabledItem) {
              disabledItem.disable();
              this.fire('disable', {
                type: 'disable',
                target: disabledItem
              });
            }
          }
        }
        /**
         * Enable a select box, {@link ItemGroup item group} or {@link Item item}.
         * If it takes no arguments, a select box is enabled.
         * If it takes string, an item with the same value as the argument is enabled.
         * If it takes number, an item with the same index as the argument is enabled.
         * If it takes Item or ItemGroup, an argument itself is enabled.
         * @param {string|number|Item|ItemGroup} value - if string, find an Item by its value. if number, find an Item by its index.
         * @example
         * selectBox.enable(); // select box is enabled.
         * selectBox.enable(1); // second item is enabled.
         * selectBox.enable('value') // item which of value is 'value' is enabled.
         * selectBox.enable(selectBox.getSelectedItem()); // selected item is enabled.
         */
        ;

        _proto.enable = function enable(value) {
          if (!(0, _isExisty["default"])(value)) {
            this.disabled = false;
            this.input.enable();
            this.dropdown.enable();
            /**
             * Occurs when a select box, {@link ItemGroup item group} or {@link Item item} is enabled.
             * @event SelectBox#enable
             * @type {object} ev
             * @property {string} type - event name ('enable')
             * @property {SelectBox|ItemGroup|Item} target - enable target
             * @example
             * selectBox.on('enable', ev => {
             *   console.log(ev.target);
             * });
             */

            this.fire('enable', {
              type: 'enable',
              target: this
            });
          } else if (value instanceof _item["default"] || value instanceof _itemGroup["default"]) {
            value.enable();
            this.fire('enable', {
              type: 'enable',
              target: value
            });
          } else {
            var disabledItem = this.dropdown.getItem(value);

            if (disabledItem) {
              disabledItem.enable();
              this.fire('enable', {
                type: 'enable',
                target: disabledItem
              });
            }
          }
        }
        /**
         * Open a dropdown list.
         * @example
         * selectBox.open();
         */
        ;

        _proto.open = function open() {
          if (!this.disabled) {
            this.opened = true;
            this.dropdown.open();
            this.input.open();
            /**
             * Occurs when a select box opens.
             * @event SelectBox#open
             * @property {string} type - event name ('open')
             * @example
             * selectBox.on('open', ev => {
             *   console.log('open');
             * });
             */

            this.fire('open', {
              type: 'open'
            });
          }
        }
        /**
         * Close a dropdown list.
         * @example
         * selectBox.close();
         */
        ;

        _proto.close = function close() {
          this.opened = false;
          this.dropdown.close();
          this.input.close();
          /**
           * Occurs when a select box closes.
           * @event SelectBox#close
           * @property {string} type - event name ('close')
           * @example
           * selectBox.on('close', ev => {
           *   console.log('close');
           * });
           */

          this.fire('close', {
            type: 'close'
          });
        }
        /**
         * Toggle a dropdown list.
         * @example
         * selectBox.toggle();
         */
        ;

        _proto.toggle = function toggle() {
          if (this.opened) {
            this.close();
          } else {
            this.open();
          }
        }
        /**
         * Select an {@link Item item}.
         * If it takes string, an item with the same value as the argument is selected.
         * If it takes number, an item with the same index as the argument is selected.
         * If it takes Item, an argument itself is selected.
         * @param {string|number|Item} value - if string, find an Item by its value. if number, find an Item by its index.
         * @return {Item} - selected Item.
         * @example
         * selectBox.select(1); // second item is selected.
         * selectBox.select('value') // item which of value is 'value' is selected.
         */
        ;

        _proto.select = function select(value) {
          var selectedItem = null;
          var prevSelectedItem = this.getSelectedItem();

          if (!this.disabled) {
            selectedItem = this.dropdown.select(value);

            if (selectedItem) {
              this.input.changeText(selectedItem);
              /**
               * Occurs when an {@link Item item} is selected.
               * @event SelectBox#select
               * @type {object} ev
               * @property {string} type - event name ('select')
               * @property {Item} target - selected item
               * @ignore
               * @example
               * selectBox.on('select', ev => {
               *   console.log(`${ev.target.getLabel()} is selected.`);
               * });
               */

              this.fire('select', {
                type: 'select',
                target: selectedItem
              });

              if (prevSelectedItem !== selectedItem) {
                /**
                 * Occurs when a selected {@link Item item} is changed.
                 * @event SelectBox#change
                 * @type {object} ev
                 * @property {string} type - event name ('change')
                 * @property {Item} prev - previous selected item
                 * @property {Item} curr - current selected item
                 * @example
                 * selectBox.on('change', ev => {
                 *   console.log(`selected item is changed from ${ev.prev.getLabel()} to ${ev.curr.getLabel()}.`);
                 * });
                 */
                this.fire('change', {
                  type: 'change',
                  prev: prevSelectedItem,
                  curr: selectedItem
                });
              }

              if (this.autoclose && this.opened) {
                this.close();
              }
            }
          }

          return selectedItem;
        }
        /**
         * Deselect an item.
         * If selectBox has a placeholder, the input's text is a placeholder.
         * If no placeholder, ths input is empty.
         * @example
         * selectBox.deselect();
         */
        ;

        _proto.deselect = function deselect() {
          if (!this.disabled) {
            this.dropdown.deselect();
            this.input.changeText();
          }
        }
        /**
         * Return the selected {@link Item item}.
         * @return {Item}
         */
        ;

        _proto.getSelectedItem = function getSelectedItem() {
          return this.dropdown.getSelectedItem();
        }
        /**
         * Get all {@link Item items} that pass the test implemented by the provided function.
         * If filter function is not passed, it returns all items.
         * @param {function} callback - callback function to filter items
         * @param {number} number - the number of items to find. If it is not passed, iterate all items.
         * @return {array<Item>}
         * @example
         * selectBox.getItems(); // all items
         * selectBox.getItems(item => {
         *  return !item.isDisabled();
         * }); // all enabled items
         */
        ;

        _proto.getItems = function getItems(callback, number) {
          return this.dropdown.getItems(callback, number);
        }
        /**
         * Get an {@link Item item} by its index or value.
         * @param {number|string} value - if string, the Item's value. if number, the Item's index.
         * @return {Item}
         * @example
         * selectBox.getItem(0); // first item
         * selectBox.getItem('value') // item which of value is 'value'
         */
        ;

        _proto.getItem = function getItem(value) {
          return this.dropdown.getItem(value);
        }
        /**
         * Get all {@link ItemGroup item groups} that pass the test implemented by the provided function.
         * If filter function is not passed, it returns all item groups.
         * @param {function} callback - callback function to filter item groups
         * @param {number} number - the number of items to find. If it is not passed, iterate all item groups.
         * @return {array<ItemGroup>}
         * @example
         * selectBox.getItemGroups(); // all item groups
         * selectBox.getItemGroups(itemGroup => {
         *  return !itemGroup.isDisabled();
         * }); // all enabled item groups
         */
        ;

        _proto.getItemGroups = function getItemGroups(callback, number) {
          return this.dropdown.getItemGroups(callback, number);
        }
        /**
         * Get an {@link ItemGroup item group} by its index.
         * @param {number} index - groupIndex of the ItemGroup
         * @return {ItemGroup}
         * @example
         * selectBox.getItemGroup(0); // first item group
         */
        ;

        _proto.getItemGroup = function getItemGroup(index) {
          return this.dropdown.getItemGroup(index);
        }
        /**
         * Destory a select box.
         * @example
         * selectBox.destroy();
         */
        ;

        _proto.destroy = function destroy() {
          this.unbindEvents();
          this.input.destroy();
          this.dropdown.destroy();

          if (this.theme) {
            this.theme.destroy();
          }

          (0, _removeElement["default"])(this.el);
          this.container = this.el = this.input = this.dropdown = this.theme = null;
        };

        return SelectBox;
      }();

      _customEvents["default"].mixin(SelectBox);

      var _default = SelectBox;
      _exports["default"] = _default;
    });

    /***/ }),

    /***/ "./src/js/theme.js":
    /*!*************************!*\
      !*** ./src/js/theme.js ***!
      \*************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
      {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! tui-code-snippet/collection/forEachOwnProperties */ "./node_modules/tui-code-snippet/collection/forEachOwnProperties.js"), __webpack_require__(/*! tui-code-snippet/domUtil/removeElement */ "./node_modules/tui-code-snippet/domUtil/removeElement.js"), __webpack_require__(/*! tui-code-snippet/type/isArray */ "./node_modules/tui-code-snippet/type/isArray.js"), __webpack_require__(/*! tui-code-snippet/type/isBoolean */ "./node_modules/tui-code-snippet/type/isBoolean.js"), __webpack_require__(/*! tui-code-snippet/type/isString */ "./node_modules/tui-code-snippet/type/isString.js"), __webpack_require__(/*! ./utils */ "./src/js/utils.js"), __webpack_require__(/*! ./constants */ "./src/js/constants.js"), __webpack_require__(/*! ./themeConfig */ "./src/js/themeConfig.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
    				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
    				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
    				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
      }
    })(this, function (_exports, _forEachOwnProperties, _removeElement, _isArray, _isBoolean, _isString, _utils, _constants, _themeConfig) {

      _exports.__esModule = true;
      _exports["default"] = void 0;
      _forEachOwnProperties = _interopRequireDefault(_forEachOwnProperties);
      _removeElement = _interopRequireDefault(_removeElement);
      _isArray = _interopRequireDefault(_isArray);
      _isBoolean = _interopRequireDefault(_isBoolean);
      _isString = _interopRequireDefault(_isString);
      _themeConfig = _interopRequireDefault(_themeConfig);

      function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

      function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

      function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

      function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

      /**
       * @class
       * @ignore
       * @param {object} customTheme - theme object for custom style
       * @param {HTMLElement|string} container - container element or selector
       */
      var Theme =
      /*#__PURE__*/
      function () {
        function Theme(customTheme, container) {
          this.containerSelector = (0, _utils.getSelector)(container);
          this.cssString = this.buildAll((0, _utils.transform)(customTheme));
          this.styleEl = this.createStyleElement();
          document.getElementsByTagName('head')[0].appendChild(this.styleEl);
        }
        /**
         * Create a style element
         * @return {HTMLElement}
         * @private
         */


        var _proto = Theme.prototype;

        _proto.createStyleElement = function createStyleElement() {
          var styleEl = document.createElement('style');
          styleEl.type = 'text/css';

          if (styleEl.styleSheet) {
            styleEl.styleSheet.cssText = this.cssString;
          } else {
            styleEl.appendChild(document.createTextNode(this.cssString));
          }

          return styleEl;
        }
        /**
         * Build css strings for Input, Dropdown, ItemGroup, and Item.
         * @param {object} theme - theme object
         * @return {string}
         * @private
         */
        ;

        _proto.buildAll = function buildAll(theme) {
          var exclude = {
            border: '',
            background: ''
          };
          return this.buildInput(_objectSpread({}, theme.common, {}, theme.input)) + this.buildDropdown(_objectSpread({}, theme.common, {
            borderTop: '0'
          }, theme.dropdown, {
            height: ''
          })) + this.buildItemGroup(theme.itemGroup ? _objectSpread({}, theme.common, {}, exclude, {}, theme.itemGroup.label) : _objectSpread({}, theme.common, {}, exclude)) + this.buildItem(theme.itemGroup ? _objectSpread({}, theme.common, {}, exclude, {}, theme.item, {
            inItemGroup: theme.itemGroup.items
          }) : _objectSpread({}, theme.common, {}, exclude, {}, theme.item));
        }
        /**
         * Build css strings for Input
         * @param {object} theme - theme object
         * @return {string}
         * @private
         */
        ;

        _proto.buildInput = function buildInput(theme) {
          theme.placeholder = {};

          if (theme.height) {
            theme.placeholder.lineHeight = theme.height;
          }

          if ((0, _isBoolean["default"])(theme.showIcon) && !theme.showIcon) {
            theme.icon = {
              display: 'none'
            };
            theme.placeholder.width = '100%';
          }

          return this.buildCssString(_constants.cls.INPUT, theme) + this.buildCssString([_constants.cls.INPUT, _constants.cls.OPEN], theme.open) + this.buildCssString([_constants.cls.INPUT, _constants.cls.DISABLED], theme.disabled) + this.buildCssString(_constants.cls.PLACEHOLDER, theme.placeholder) + this.buildCssString(_constants.cls.ICON, theme.icon);
        }
        /**
         * Build css strings for Dropdown
         * @param {object} theme - theme object
         * @return {string}
         * @private
         */
        ;

        _proto.buildDropdown = function buildDropdown(theme) {
          return this.buildCssString(_constants.cls.DROPDOWN, theme);
        }
        /**
         * Build css strings for ItemGroup
         * @param {object} theme - theme object
         * @return {string}
         * @private
         */
        ;

        _proto.buildItemGroup = function buildItemGroup(theme) {
          if (theme.height) {
            theme.lineHeight = theme.height;
          }

          return this.buildCssString(_constants.cls.ITEM_GROUP_LABEL, theme) + this.buildCssString([_constants.cls.ITEM_GROUP_LABEL, _constants.cls.DISABLED], theme.disabled);
        }
        /**
         * Build css strings for Item
         * @param {object} theme - theme object
         * @return {string}
         * @private
         */
        ;

        _proto.buildItem = function buildItem(theme) {
          if (theme.height) {
            theme.lineHeight = theme.height;
          }

          if (theme.selected) {
            var base = (0, _utils.transform)(_themeConfig["default"]);
            theme.selected = _objectSpread({}, base.item.selected, {}, theme.selected);
            theme.disabled = _objectSpread({}, base.item.disabled, {}, theme.disabled);
            theme.highlighted = _objectSpread({}, base.item.highlighted, {}, theme.highlighted);
          }

          return this.buildCssString(_constants.cls.ITEM, theme) + this.buildCssString([_constants.cls.ITEM, _constants.cls.SELECTED], theme.selected) + this.buildCssString([_constants.cls.ITEM, _constants.cls.DISABLED], theme.disabled) + this.buildCssString([_constants.cls.ITEM, _constants.cls.HIGHLIGHT], theme.highlighted) + this.buildCssString(_constants.cls.ITEM_GROUP + ">." + _constants.cls.ITEM, theme.inItemGroup);
        }
        /**
         * Build css strings
         * @param {string} className - className
         * @param {object} theme - theme object
         * @return {string}
         * @private
         */
        ;

        _proto.buildCssString = function buildCssString(className, theme) {
          if ((0, _isArray["default"])(className)) {
            className = className.join('.');
          }

          className = "." + className;
          var cssString = '';
          (0, _forEachOwnProperties["default"])(theme, function (value, key) {
            if ((0, _isString["default"])(value) && value) {
              key = key.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();
              cssString += key + ":" + value + ";";
            }
          });
          return cssString ? this.containerSelector + " " + className + "{" + cssString + "}" : '';
        }
        /**
         * Destory a theme
         */
        ;

        _proto.destroy = function destroy() {
          (0, _removeElement["default"])(this.styleEl);
          this.styleEl = null;
        };

        return Theme;
      }();

      _exports["default"] = Theme;
    });

    /***/ }),

    /***/ "./src/js/themeConfig.js":
    /*!*******************************!*\
      !*** ./src/js/themeConfig.js ***!
      \*******************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
      {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
    				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
    				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
    				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
      }
    })(this, function (_exports) {

      _exports.__esModule = true;
      _exports["default"] = void 0;

      /**
       * @fileoverview Theme configuration
       * @author NHN FE Development Lab <dl_javascript@nhn.com>
       */

      /**
       * Theme configuration.
       * "common" prefix is for the entire select box. Its properties are overriden by "input", "dropdown", "itemGroup", and "item".
       * The example using theme can be found {@link tutorial-example02-theme here}.
       * @typedef {object} themeConfig
       * @example
       * const themeConfig = {
       *   'common.border': '1px solid #ddd', // border for input and dropdown (not itemGroup and item)
       *   'common.background': '#fff',
       *   'common.color': '#333',
       *   'common.width': '100%',
       *   'common.height': '29px', // height for item and itemGroup label (not entire select box)
       *
       *   'common.disabled.background': '#f9f9f9',
       *   'common.disabled.color': 'c8c8c8',
       *
       *   // Input
       *   'input.border': '1px solid #ddd',
       *   'input.borderBottom': '',
       *   'input.background': 'inherit',
       *   'input.color': '#333',
       *   'input.width': '100%',
       *   'input.height': '29px',
       *
       *   // Input when dropdown is open
       *   'input.open.border': '1px solid #aaa',
       *   'input.open.background': 'inherit',
       *   'input.open.color': '#333',
       *
       *   // Input when selectbox is disabled
       *   'input.disabled.border': '1px solid #aaa',
       *   'input.disabled.background': '#f9f9f9',
       *   'input.disabled.color': '#c8c8c8',
       *
       *   // Dropdown
       *   'dropdown.border': '1px solid #aaa',
       *   'dropdown.borderTop': '0',
       *   'dropdown.background': 'inherit',
       *   'dropdown.width': '100%',
       *   'dropdown.maxHeight': '',
       *
       *   // ItemGroup's items
       *   // if you want to set the same padding value as the itemGroup.label, set to '8px'.
       *   'itemGroup.items.paddingLeft': '20px',
       *
       *   // ItemGroup's label
       *   'itemGroup.label.border': '0',
       *   'itemGroup.label.background': 'inherit',
       *   'itemGroup.label.color': '#333',
       *   'itemGroup.label.fontWeight': 'bold',
       *   'itemGroup.label.height': '29px',
       *
       *   // disabled ItemGroup's label
       *   'itemGroup.label.disabled.border': '0',
       *   'itemGroup.label.disabled.background': 'inherit',
       *   'itemGroup.label.disabled.color': '#333',
       *
       *   // Item
       *   'item.border': '0',
       *   'item.background': 'inherit',
       *   'item.color': '#333',
       *   'item.height': '29px',
       *
       *   // selected Item
       *   'item.selected.border': '0',
       *   'item.selected.background': '#f4f4f4',
       *   'item.selected.color': '#333',
       *
       *   // disabled Item
       *   'item.disabled.border': '0',
       *   'item.disabled.background': '#f9f9f9',
       *   'item.disabled.color': '#c8c8c8',
       *
       *   // highlighted Item
       *   'item.highlighted.border': '0',
       *   'item.highlighted.background': '#e5f6ff',
       *   'item.highlighted.color': '#333'
       * };
       */
      var _default = {
        'common.border': '1px solid #ddd',
        // border for input and dropdown (not itemGroup and item)
        'common.background': '#fff',
        'common.color': '#333',
        'common.width': '100%',
        'common.height': '29px',
        // height for item and itemGroup label (not entire select box)
        'common.disabled.background': '#f9f9f9',
        'common.disabled.color': 'c8c8c8',
        // Input
        'input.border': '1px solid #ddd',
        'input.borderBottom': '',
        'input.background': 'inherit',
        'input.color': '#333',
        'input.width': '100%',
        'input.height': '29px',
        // Input when dropdown is open
        'input.open.border': '1px solid #aaa',
        'input.open.background': 'inherit',
        'input.open.color': '#333',
        // Input when selectbox is disabled
        'input.disabled.border': '1px solid #aaa',
        'input.disabled.background': '#f9f9f9',
        'input.disabled.color': '#c8c8c8',
        // Dropdown
        'dropdown.border': '1px solid #aaa',
        'dropdown.borderTop': '0',
        'dropdown.background': 'inherit',
        'dropdown.width': '100%',
        'dropdown.maxHeight': '',
        // ItemGroup's items
        'itemGroup.items.paddingLeft': '20px',
        // ItemGroup's label
        'itemGroup.label.border': '0',
        'itemGroup.label.background': 'inherit',
        'itemGroup.label.color': '#333',
        'itemGroup.label.fontWeight': 'bold',
        'itemGroup.label.height': '29px',
        // disabled ItemGroup's label
        'itemGroup.label.disabled.border': '0',
        'itemGroup.label.disabled.background': 'inherit',
        'itemGroup.label.disabled.color': '#333',
        // Item
        'item.border': '0',
        'item.background': 'inherit',
        'item.color': '#333',
        'item.height': '29px',
        // selected Item
        'item.selected.border': '0',
        'item.selected.background': '#f4f4f4',
        'item.selected.color': '#333',
        // disabled Item
        'item.disabled.border': '0',
        'item.disabled.background': '#f9f9f9',
        'item.disabled.color': '#c8c8c8',
        // highlighted Item
        'item.highlighted.border': '0',
        'item.highlighted.background': '#e5f6ff',
        'item.highlighted.color': '#333'
      };
      _exports["default"] = _default;
    });

    /***/ }),

    /***/ "./src/js/utils.js":
    /*!*************************!*\
      !*** ./src/js/utils.js ***!
      \*************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
      {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! tui-code-snippet/collection/forEachOwnProperties */ "./node_modules/tui-code-snippet/collection/forEachOwnProperties.js"), __webpack_require__(/*! tui-code-snippet/type/isString */ "./node_modules/tui-code-snippet/type/isString.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
    				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
    				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
    				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
      }
    })(this, function (_exports, _forEachOwnProperties, _isString) {

      _exports.__esModule = true;
      _exports.getSelector = _exports.createElement = _exports.transform = void 0;
      _forEachOwnProperties = _interopRequireDefault(_forEachOwnProperties);
      _isString = _interopRequireDefault(_isString);

      function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

      /**
       * @fileoverview Utility functions
       * @author NHN. FE dev team.<dl_javascript@nhn.com>
       */

      /**
       * Transform an object using dot notation
       * @param {object} obj - object to transform
       * @return {object}
       */
      var transform = function transform(obj) {
        var result = {};
        (0, _forEachOwnProperties["default"])(obj, function (value, prop) {
          var keys = prop.split('.');
          var curr = result;
          keys.forEach(function (key, index) {
            if (index === keys.length - 1) {
              curr[key] = value;
            } else if (!curr[key]) {
              curr[key] = {};
            }

            curr = curr[key];
          });
        });
        return result;
      };
      /**
       * Create a HTML element
       * @param {string} tagName - tag name
       * @param {string} content - content in the element
       * @param {object} options - other properties for the element
       * @param {HTMLElement} container - parent element for the element
       * @return {HTMLElement}
       */


      _exports.transform = transform;

      var createElement = function createElement(tagName, content, options, container) {
        var el = document.createElement(tagName);

        if (content) {
          el.innerText = content;
        }

        (0, _forEachOwnProperties["default"])(options, function (value, key) {
          if (key.indexOf('data-') > -1) {
            el.setAttribute(key, value);
          } else {
            el[key] = value;
          }
        });

        if (container) {
          container.appendChild(el);
        }

        return el;
      };
      /**
       * Get selectors for an element
       * @param {HTMLElement} el - element
       * @return {string}
       */


      _exports.createElement = createElement;

      var getSelector = function getSelector(el) {
        if ((0, _isString["default"])(el)) {
          return el;
        }

        if (el.id) {
          return "#" + el.id;
        }

        var className = "." + el.className.replace(/\s+/g, '.');

        if (className) {
          var elems = document.querySelectorAll(className);

          if (elems.length === 1) {
            return className;
          }
        }

        var tagName = el.tagName.toLowerCase();
        return "" + tagName + className;
      };

      _exports.getSelector = getSelector;
    });

    /***/ })

    /******/ })["default"];
    });


    /***/ }),
    /* 69 */
    /***/ (function(module, exports, __webpack_require__) {

    // extracted by mini-css-extract-plugin

    /***/ }),
    /* 70 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DatePickerEditor = void 0;
    var tslib_1 = __webpack_require__(1);
    var tui_date_picker_1 = tslib_1.__importDefault(__webpack_require__(40));
    var dom_1 = __webpack_require__(2);
    var common_1 = __webpack_require__(0);
    var dom_2 = __webpack_require__(33);
    var DatePickerEditor = /** @class */ (function () {
        function DatePickerEditor(props) {
            var _this = this;
            var usageStatistics = props.grid.usageStatistics, columnInfo = props.columnInfo;
            var value = String(common_1.isNil(props.value) ? '' : props.value);
            var el = document.createElement('div');
            el.className = dom_1.cls('layer-editing-inner');
            this.el = el;
            this.inputEl = this.createInputElement();
            var datepickerInputContainer = document.createElement('div');
            datepickerInputContainer.className = dom_1.cls('datepicker-input-container');
            datepickerInputContainer.appendChild(this.inputEl);
            this.el.appendChild(datepickerInputContainer);
            var layer = this.createLayer();
            this.layer = layer;
            var options = tslib_1.__assign({ showIcon: true }, columnInfo.editor.options);
            if (options.showIcon) {
                var icon = this.createIcon();
                this.iconEl = icon;
                this.inputEl.className = dom_1.cls('datepicker-input');
                datepickerInputContainer.appendChild(icon);
            }
            var date;
            if (!options.format) {
                options.format = 'yyyy-MM-dd';
            }
            if (common_1.isNumber(value) || common_1.isString(value)) {
                date = new Date(value);
            }
            var defaultOptions = {
                date: date,
                type: 'date',
                input: {
                    element: this.inputEl,
                    format: options.format,
                },
                usageStatistics: usageStatistics,
            };
            this.datePickerEl = new tui_date_picker_1.default(layer, common_1.deepMergedCopy(defaultOptions, options));
            this.datePickerEl.on('close', function () { return _this.focus(); });
        }
        DatePickerEditor.prototype.createInputElement = function () {
            var inputEl = document.createElement('input');
            inputEl.className = dom_1.cls('content-text');
            inputEl.type = 'text';
            return inputEl;
        };
        DatePickerEditor.prototype.createLayer = function () {
            var layer = document.createElement('div');
            layer.className = dom_1.cls('editor-datepicker-layer');
            // To hide the initial layer which is having the position which is not calculated properly
            dom_2.setOpacity(layer, 0);
            return layer;
        };
        DatePickerEditor.prototype.openDatePicker = function () {
            this.datePickerEl.open();
        };
        DatePickerEditor.prototype.createIcon = function () {
            var _this = this;
            var icon = document.createElement('i');
            icon.className = dom_1.cls('date-icon');
            icon.addEventListener('click', function () { return _this.openDatePicker(); });
            return icon;
        };
        DatePickerEditor.prototype.focus = function () {
            this.inputEl.focus();
        };
        DatePickerEditor.prototype.getElement = function () {
            return this.el;
        };
        DatePickerEditor.prototype.getValue = function () {
            return this.inputEl.value;
        };
        DatePickerEditor.prototype.mounted = function () {
            // To prevent wrong stacked z-index context, layer append to grid container
            dom_2.getContainerElement(this.el).appendChild(this.layer);
            this.inputEl.select();
            this.datePickerEl.open();
            // `this.layer.firstElementChild` is real datePicker layer(it is need to get total height)
            dom_2.setLayerPosition(this.el, this.layer, this.layer.firstElementChild, true);
            // To show the layer which has appropriate position
            dom_2.setOpacity(this.layer, 1);
        };
        DatePickerEditor.prototype.beforeDestroy = function () {
            if (this.iconEl) {
                this.iconEl.removeEventListener('click', this.openDatePicker);
            }
            this.datePickerEl.destroy();
            dom_2.getContainerElement(this.el).removeChild(this.layer);
        };
        return DatePickerEditor;
    }());
    exports.DatePickerEditor = DatePickerEditor;


    /***/ }),
    /* 71 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RowHeaderInputRenderer = void 0;
    var dom_1 = __webpack_require__(2);
    var RowHeaderInputRenderer = /** @class */ (function () {
        function RowHeaderInputRenderer(props) {
            var el = document.createElement('div');
            var input = document.createElement('input');
            var grid = props.grid, rowKey = props.rowKey, disabled = props.disabled;
            el.className = dom_1.cls('row-header-checkbox');
            input.type = 'checkbox';
            input.name = '_checked';
            input.disabled = disabled;
            input.addEventListener('change', function () {
                if (input.checked) {
                    grid.check(rowKey);
                }
                else {
                    grid.uncheck(rowKey);
                }
            });
            el.appendChild(input);
            this.el = el;
            this.input = input;
            this.render(props);
        }
        RowHeaderInputRenderer.prototype.getElement = function () {
            return this.el;
        };
        RowHeaderInputRenderer.prototype.render = function (props) {
            var value = props.value, disabled = props.disabled;
            this.input.checked = Boolean(value);
            this.input.disabled = disabled;
        };
        return RowHeaderInputRenderer;
    }());
    exports.RowHeaderInputRenderer = RowHeaderInputRenderer;


    /***/ }),
    /* 72 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RowHeaderDraggableRenderer = void 0;
    var dom_1 = __webpack_require__(2);
    var ROW_COUNT = 3;
    var COL_COUNT = 3;
    var RowHeaderDraggableRenderer = /** @class */ (function () {
        function RowHeaderDraggableRenderer() {
            var el = document.createElement('div');
            el.className = dom_1.cls('row-header-draggable');
            this.el = el;
            this.renderDraggableIcon();
        }
        RowHeaderDraggableRenderer.prototype.getElement = function () {
            return this.el;
        };
        RowHeaderDraggableRenderer.prototype.renderDraggableIcon = function () {
            for (var i = 0; i < ROW_COUNT; i += 1) {
                var wrapper = document.createElement('div');
                wrapper.style.lineHeight = '0';
                for (var j = 0; j < COL_COUNT; j += 1) {
                    var square = document.createElement('span');
                    wrapper.appendChild(square);
                }
                this.el.appendChild(wrapper);
            }
        };
        return RowHeaderDraggableRenderer;
    }());
    exports.RowHeaderDraggableRenderer = RowHeaderDraggableRenderer;


    /***/ }),
    /* 73 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sortRawData = exports.compare = void 0;
    var common_1 = __webpack_require__(0);
    function compare(valueA, valueB) {
        var isBlankA = common_1.isBlank(valueA);
        var isBlankB = common_1.isBlank(valueB);
        var convertedA = common_1.convertToNumber(valueA);
        var convertedB = common_1.convertToNumber(valueB);
        if (!common_1.isNumber(convertedA) || !common_1.isNumber(convertedB)) {
            convertedA = String(valueA);
            convertedB = String(valueB);
        }
        var result = 0;
        if (isBlankA && !isBlankB) {
            result = -1;
        }
        else if (!isBlankA && isBlankB) {
            result = 1;
        }
        else if (convertedA < convertedB) {
            result = -1;
        }
        else if (convertedA > convertedB) {
            result = 1;
        }
        return result;
    }
    exports.compare = compare;
    function getComparators(columns) {
        var comparators = [];
        columns.forEach(function (column) {
            var columnName = column.columnName, ascending = column.ascending, customComparator = column.comparator;
            var comparator = customComparator || compare;
            comparators.push({
                name: columnName,
                comparator: ascending
                    ? comparator
                    : function (valueA, valueB, rowA, rowB) {
                        return -comparator(valueA, valueB, rowA, rowB);
                    },
            });
        });
        return comparators;
    }
    function sortRawData(columns) {
        var comparators = getComparators(columns);
        return function (rowA, rowB) {
            for (var _i = 0, comparators_1 = comparators; _i < comparators_1.length; _i++) {
                var _a = comparators_1[_i], columnName = _a.name, comparator = _a.comparator;
                var result = comparator(rowA[columnName], rowB[columnName], rowA, rowB);
                if (result) {
                    return result;
                }
            }
            return 0;
        };
    }
    exports.sortRawData = sortRawData;


    /***/ }),
    /* 74 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getChangedScrollPosition = void 0;
    function getHorizontalScrollPosition(rightSideWidth, cellPosRect, scrollLeft, tableBorderWidth) {
        var left = cellPosRect.left, right = cellPosRect.right;
        if (left < scrollLeft) {
            return left;
        }
        if (right > scrollLeft + rightSideWidth - tableBorderWidth) {
            return right - rightSideWidth + tableBorderWidth;
        }
        return null;
    }
    function getVerticalScrollPosition(height, cellPosRect, scrollTop, tableBorderWidth) {
        var top = cellPosRect.top, bottom = cellPosRect.bottom;
        if (top < scrollTop) {
            return top + tableBorderWidth;
        }
        if (bottom > scrollTop + height) {
            return bottom - height + tableBorderWidth;
        }
        return null;
    }
    function getChangedScrollPosition(store, side, changedCellPosRect) {
        var _a = store.dimension, bodyHeight = _a.bodyHeight, scrollXHeight = _a.scrollXHeight, scrollYWidth = _a.scrollYWidth, tableBorderWidth = _a.tableBorderWidth, areaWidth = store.columnCoords.areaWidth, focusedCellPostRect = store.focus.cellPosRect, viewport = store.viewport;
        var scrollLeft = viewport.scrollLeft, scrollTop = viewport.scrollTop;
        var cellPosRect = changedCellPosRect || focusedCellPostRect;
        var changedScrollLeft = side === 'R'
            ? getHorizontalScrollPosition(areaWidth.R - scrollYWidth, cellPosRect, scrollLeft, tableBorderWidth)
            : null;
        var changedScrollTop = getVerticalScrollPosition(bodyHeight - scrollXHeight, cellPosRect, scrollTop, tableBorderWidth);
        return [changedScrollLeft, changedScrollTop];
    }
    exports.getChangedScrollPosition = getChangedScrollPosition;


    /***/ }),
    /* 75 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.updateRowSpanWhenRemoving = exports.updateRowSpanWhenAppending = void 0;
    var data_1 = __webpack_require__(15);
    var common_1 = __webpack_require__(0);
    function updateRowSpanWhenAppending(data, prevRow, extendPrevRowSpan) {
        var prevRowSpanMap = prevRow.rowSpanMap;
        if (common_1.isEmpty(prevRowSpanMap)) {
            return;
        }
        Object.keys(prevRowSpanMap).forEach(function (columnName) {
            var prevRowSpan = prevRowSpanMap[columnName];
            if (prevRowSpan) {
                var count = prevRowSpan.count, keyRow = prevRowSpan.mainRow, mainRowKey = prevRowSpan.mainRowKey;
                var mainRow = keyRow ? prevRow : common_1.findProp('rowKey', mainRowKey, data);
                var mainRowSpan = mainRow.rowSpanMap[columnName];
                var startOffset = keyRow || extendPrevRowSpan ? 1 : -count + 1;
                // keep rowSpan state when appends row in the middle of rowSpan
                if (mainRowSpan.spanCount > startOffset) {
                    mainRowSpan.count += 1;
                    mainRowSpan.spanCount += 1;
                    updateSubRowSpan(data, mainRow, columnName, 1, mainRowSpan.spanCount);
                }
            }
        });
    }
    exports.updateRowSpanWhenAppending = updateRowSpanWhenAppending;
    function updateRowSpanWhenRemoving(data, removedRow, nextRow, keepRowSpanData) {
        var removedRowSpanMap = removedRow.rowSpanMap;
        if (common_1.isEmpty(removedRowSpanMap)) {
            return;
        }
        Object.keys(removedRowSpanMap).forEach(function (columnName) {
            var removedRowSpan = removedRowSpanMap[columnName];
            var count = removedRowSpan.count, keyRow = removedRowSpan.mainRow, mainRowKey = removedRowSpan.mainRowKey;
            var mainRow, spanCount;
            if (keyRow) {
                mainRow = nextRow;
                spanCount = count - 1;
                if (spanCount > 1) {
                    var mainRowSpan = mainRow.rowSpanMap[columnName];
                    mainRowSpan.mainRowKey = mainRow.rowKey;
                    mainRowSpan.mainRow = true;
                }
                if (keepRowSpanData) {
                    mainRow[columnName] = removedRow[columnName];
                }
            }
            else {
                mainRow = common_1.findProp('rowKey', mainRowKey, data);
                spanCount = mainRow.rowSpanMap[columnName].spanCount - 1;
            }
            if (spanCount > 1) {
                var mainRowSpan = mainRow.rowSpanMap[columnName];
                mainRowSpan.count = spanCount;
                mainRowSpan.spanCount = spanCount;
                updateSubRowSpan(data, mainRow, columnName, 1, spanCount);
            }
            else {
                delete mainRow.rowSpanMap[columnName];
            }
        });
    }
    exports.updateRowSpanWhenRemoving = updateRowSpanWhenRemoving;
    function updateSubRowSpan(data, mainRow, columnName, startOffset, spanCount) {
        var mainRowIndex = common_1.findPropIndex('rowKey', mainRow.rowKey, data);
        for (var offset = startOffset; offset < spanCount; offset += 1) {
            var row = data[mainRowIndex + offset];
            row.rowSpanMap[columnName] = data_1.createRowSpan(false, mainRow.rowKey, -offset, spanCount);
        }
    }


    /***/ }),
    /* 76 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.create = void 0;
    var observable_1 = __webpack_require__(5);
    var common_1 = __webpack_require__(0);
    function create(_a) {
        var column = _a.column, _b = _a.width, width = _b === void 0 ? 'auto' : _b, domWidth = _a.domWidth, _c = _a.rowHeight, rowHeight = _c === void 0 ? 40 : _c, _d = _a.bodyHeight, bodyHeight = _d === void 0 ? 'auto' : _d, _e = _a.minRowHeight, minRowHeight = _e === void 0 ? 40 : _e, _f = _a.minBodyHeight, minBodyHeight = _f === void 0 ? 130 : _f, _g = _a.frozenBorderWidth, frozenBorderWidth = _g === void 0 ? 1 : _g, _h = _a.heightResizable, heightResizable = _h === void 0 ? false : _h, _j = _a.scrollX, scrollX = _j === void 0 ? true : _j, _k = _a.scrollY, scrollY = _k === void 0 ? true : _k, _l = _a.summaryHeight, summaryHeight = _l === void 0 ? 0 : _l, _m = _a.summaryPosition, summaryPosition = _m === void 0 ? 'bottom' : _m, _o = _a.headerHeight, headerHeight = _o === void 0 ? 40 : _o;
        var bodyHeightVal = typeof bodyHeight === 'number' ? bodyHeight : 0;
        return observable_1.observable({
            offsetLeft: 0,
            offsetTop: 0,
            width: width === 'auto' ? domWidth : width,
            autoWidth: width === 'auto',
            minBodyHeight: minBodyHeight,
            bodyHeight: Math.max(bodyHeightVal, minBodyHeight),
            autoHeight: bodyHeight === 'auto',
            heightResizable: heightResizable,
            fitToParentHeight: bodyHeight === 'fitToParent',
            minRowHeight: minRowHeight,
            rowHeight: common_1.isNumber(rowHeight) ? Math.max(rowHeight, minRowHeight) : minRowHeight,
            autoRowHeight: rowHeight === 'auto',
            scrollX: scrollX,
            scrollY: scrollY,
            summaryHeight: summaryHeight,
            summaryPosition: summaryPosition,
            headerHeight: headerHeight,
            scrollbarWidth: 17,
            tableBorderWidth: 1,
            cellBorderWidth: 1,
            get scrollYWidth() {
                return this.scrollY ? this.scrollbarWidth : 0;
            },
            get scrollXHeight() {
                return this.scrollX ? this.scrollbarWidth : 0;
            },
            get frozenBorderWidth() {
                var visibleColumnsBySide = column.visibleColumnsBySide;
                var visibleLeftColumnCount = visibleColumnsBySide.L.length;
                return visibleLeftColumnCount > 0 ? frozenBorderWidth : 0;
            },
            get contentsWidth() {
                var columnLen = column.visibleColumnsWithRowHeader.length;
                var totalBorderWidth = columnLen * this.cellBorderWidth;
                return this.width - this.scrollYWidth - this.frozenBorderWidth - totalBorderWidth;
            },
        });
    }
    exports.create = create;


    /***/ }),
    /* 77 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.create = void 0;
    var observable_1 = __webpack_require__(5);
    var common_1 = __webpack_require__(0);
    var rowSpan_1 = __webpack_require__(11);
    var data_1 = __webpack_require__(6);
    function findIndexByPosition(offsets, position) {
        var rowOffset = common_1.findIndex(function (offset) { return offset > position; }, offsets);
        return rowOffset === -1 ? offsets.length - 1 : rowOffset - 1;
    }
    function calculateRange(scrollPos, totalSize, offsets, data, rowCalculation) {
        // safari uses negative scroll position for bouncing effect
        scrollPos = Math.max(scrollPos, 0);
        var start = findIndexByPosition(offsets, scrollPos);
        var end = findIndexByPosition(offsets, scrollPos + totalSize) + 1;
        var filteredRawData = data.filteredRawData, sortState = data.sortState, pageRowRange = data.pageRowRange;
        var dataLength = filteredRawData.length;
        if (rowCalculation && data_1.isClientPagination(data)) {
            start = pageRowRange[0], end = pageRowRange[1];
        }
        if (dataLength && dataLength >= start && rowCalculation && rowSpan_1.isRowSpanEnabled(sortState)) {
            var maxRowSpanCount = rowSpan_1.getMaxRowSpanCount(start, filteredRawData);
            var topRowSpanIndex = start - maxRowSpanCount;
            return [topRowSpanIndex >= 0 ? topRowSpanIndex : 0, end];
        }
        return [start, end];
    }
    function getCachedRange(cachedRange, newRange) {
        if (cachedRange && common_1.arrayEqual(cachedRange, newRange)) {
            return cachedRange;
        }
        return newRange;
    }
    function create(_a) {
        var data = _a.data, column = _a.column, dimension = _a.dimension, rowCoords = _a.rowCoords, columnCoords = _a.columnCoords, showDummyRows = _a.showDummyRows;
        return observable_1.observable({
            scrollLeft: 0,
            scrollTop: 0,
            scrollPixelScale: 40,
            get maxScrollLeft() {
                var scrollbarWidth = dimension.scrollbarWidth, cellBorderWidth = dimension.cellBorderWidth;
                var areaWidth = columnCoords.areaWidth, widths = columnCoords.widths;
                var totalRWidth = 0;
                widths.R.forEach(function (width) {
                    totalRWidth += width + cellBorderWidth;
                });
                return totalRWidth - areaWidth.R + scrollbarWidth;
            },
            get maxScrollTop() {
                var bodyHeight = dimension.bodyHeight, scrollbarWidth = dimension.scrollbarWidth;
                var totalRowHeight = rowCoords.totalRowHeight;
                return totalRowHeight - bodyHeight + scrollbarWidth;
            },
            // only for right side columns
            get colRange() {
                var range = calculateRange(this.scrollLeft, columnCoords.areaWidth.R, columnCoords.offsets.R, data);
                return getCachedRange(this.__storage__.colRange, range);
            },
            // only for right side columns
            get columns() {
                var _a;
                return (_a = column.visibleColumnsBySideWithRowHeader.R).slice.apply(_a, this.colRange);
            },
            get offsetLeft() {
                return columnCoords.offsets.R[this.colRange[0]];
            },
            get rowRange() {
                var range = calculateRange(this.scrollTop, dimension.bodyHeight, rowCoords.offsets, data, true);
                return getCachedRange(this.__storage__.rowRange, range);
            },
            get rows() {
                var _a;
                return (_a = data.filteredViewData).slice.apply(_a, this.rowRange);
            },
            get offsetTop() {
                return rowCoords.offsets[this.rowRange[0] - data.pageRowRange[0]];
            },
            get dummyRowCount() {
                var rowHeight = dimension.rowHeight, bodyHeight = dimension.bodyHeight, scrollXHeight = dimension.scrollXHeight, cellBorderWidth = dimension.cellBorderWidth;
                var totalRowHeight = rowCoords.totalRowHeight;
                var adjustedRowHeight = rowHeight + cellBorderWidth;
                var adjustedBodyHeight = bodyHeight - scrollXHeight;
                if (showDummyRows && totalRowHeight < adjustedBodyHeight) {
                    return Math.ceil((adjustedBodyHeight - totalRowHeight) / adjustedRowHeight) + 1;
                }
                return 0;
            },
        });
    }
    exports.create = create;


    /***/ }),
    /* 78 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.create = void 0;
    var tslib_1 = __webpack_require__(1);
    var observable_1 = __webpack_require__(5);
    var common_1 = __webpack_require__(0);
    function distributeExtraWidthEqually(extraWidth, targetIdxes, widths) {
        var targetLen = targetIdxes.length;
        var avgValue = Math.round(extraWidth / targetLen);
        var errorValue = avgValue * targetLen - extraWidth; // to correct total width
        var result = tslib_1.__spreadArrays(widths);
        targetIdxes.forEach(function (idx) {
            result[idx] += avgValue;
        });
        if (targetLen) {
            result[targetIdxes[targetLen - 1]] -= errorValue;
        }
        return result;
    }
    function fillEmptyWidth(contentWidth, widths) {
        var remainTotalWidth = contentWidth - common_1.sum(widths);
        var emptyIndexes = common_1.findIndexes(function (width) { return !width; }, widths);
        return distributeExtraWidthEqually(remainTotalWidth, emptyIndexes, widths);
    }
    function applyMinimumWidth(minWidths, widths) {
        return widths.map(function (width, index) { return Math.max(width, minWidths[index]); });
    }
    function reduceExcessColumnWidthSub(totalRemainWidth, availableList, widths) {
        var avgValue = Math.round(totalRemainWidth / availableList.length);
        var newAvailableList = [];
        availableList.forEach(function (_a) {
            var index = _a[0], width = _a[1];
            // note that totalRemainWidth and avgValue are negative number.
            if (width < Math.abs(avgValue)) {
                totalRemainWidth += width;
                widths[index] -= width;
            }
            else {
                newAvailableList.push([index, width]);
            }
        });
        // call recursively until all available width are less than average
        if (availableList.length > newAvailableList.length) {
            return reduceExcessColumnWidthSub(totalRemainWidth, newAvailableList, widths);
        }
        var columnIndexes = availableList.map(function (_a) {
            var index = _a[0];
            return index;
        });
        return distributeExtraWidthEqually(totalRemainWidth, columnIndexes, widths);
    }
    function adjustWidths(minWidths, fixedFlags, availableWidth, fitToReducedTotal, widths) {
        var columnLength = widths.length;
        var totalExtraWidth = availableWidth - common_1.sum(widths);
        var fixedCount = fixedFlags.filter(Boolean).length;
        var fixedIndexes = common_1.findIndexes(function (v) { return !v; }, fixedFlags);
        if (totalExtraWidth > 0 && columnLength > fixedCount) {
            return distributeExtraWidthEqually(totalExtraWidth, fixedIndexes, widths);
        }
        if (fitToReducedTotal && totalExtraWidth < 0) {
            var availableWidthInfos = fixedIndexes.map(function (index) { return [index, widths[index] - minWidths[index]]; });
            return reduceExcessColumnWidthSub(totalExtraWidth, availableWidthInfos, widths);
        }
        return widths;
    }
    function calculateWidths(columns, cellBorderWidth, contentsWidth) {
        var baseWidths = columns.map(function (_a) {
            var baseWidth = _a.baseWidth;
            return (baseWidth ? baseWidth - cellBorderWidth : 0);
        });
        var minWidths = columns.map(function (_a) {
            var minWidth = _a.minWidth;
            return minWidth - cellBorderWidth;
        });
        var fixedFlags = common_1.mapProp('fixedWidth', columns);
        return common_1.pipe(baseWidths, fillEmptyWidth.bind(null, contentsWidth), applyMinimumWidth.bind(null, minWidths), adjustWidths.bind(null, minWidths, fixedFlags, contentsWidth, true));
    }
    function calculateOffsets(widths, borderWidth) {
        var offsets = [0];
        for (var i = 1, len = widths.length; i < len; i += 1) {
            offsets[i] = offsets[i - 1] + widths[i - 1] + borderWidth;
        }
        return offsets;
    }
    function create(_a) {
        var column = _a.column, dimension = _a.dimension;
        return observable_1.observable({
            get widths() {
                var visibleColumnsWithRowHeader = column.visibleColumnsWithRowHeader, visibleFrozenCount = column.visibleFrozenCount;
                var widths = calculateWidths(visibleColumnsWithRowHeader, dimension.cellBorderWidth, dimension.contentsWidth);
                return {
                    L: widths.slice(0, visibleFrozenCount),
                    R: widths.slice(visibleFrozenCount),
                };
            },
            get offsets() {
                return {
                    L: calculateOffsets(this.widths.L, dimension.cellBorderWidth),
                    R: calculateOffsets(this.widths.R, dimension.cellBorderWidth),
                };
            },
            get areaWidth() {
                var visibleFrozenCount = column.visibleFrozenCount;
                var width = dimension.width, frozenBorderWidth = dimension.frozenBorderWidth, cellBorderWidth = dimension.cellBorderWidth;
                var leftAreaWidth = 0;
                if (visibleFrozenCount) {
                    var leftBorderWidth = (visibleFrozenCount + 1) * cellBorderWidth;
                    leftAreaWidth = common_1.sum(this.widths.L) + leftBorderWidth;
                }
                return {
                    L: leftAreaWidth - frozenBorderWidth,
                    R: width - leftAreaWidth,
                };
            },
            get totalColumnWidth() {
                return {
                    L: common_1.last(this.offsets.L) + common_1.last(this.widths.L),
                    R: common_1.last(this.offsets.R) + common_1.last(this.widths.R),
                };
            },
        });
    }
    exports.create = create;


    /***/ }),
    /* 79 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.create = void 0;
    var observable_1 = __webpack_require__(5);
    var common_1 = __webpack_require__(0);
    var data_1 = __webpack_require__(6);
    function create(_a) {
        var _b;
        var data = _a.data, dimension = _a.dimension;
        var rowHeight = dimension.rowHeight;
        var pageOptions = data.pageOptions, pageRowRange = data.pageRowRange;
        return observable_1.observable({
            heights: pageOptions.useClient
                ? (_b = data.filteredRawData).slice.apply(_b, pageRowRange).map(function (row) { return data_1.getRowHeight(row, rowHeight); })
                : data.filteredRawData.map(function (row) { return data_1.getRowHeight(row, rowHeight); }),
            get offsets() {
                var offsets = [0];
                var heights = this.heights;
                for (var i = 1, len = heights.length; i < len; i += 1) {
                    offsets[i] = offsets[i - 1] + heights[i - 1];
                }
                return offsets;
            },
            get totalRowHeight() {
                return this.heights.length ? common_1.last(this.offsets) + common_1.last(this.heights) : 0;
            },
        });
    }
    exports.create = create;


    /***/ }),
    /* 80 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.create = void 0;
    var observable_1 = __webpack_require__(5);
    var common_1 = __webpack_require__(0);
    var rowSpan_1 = __webpack_require__(11);
    var data_1 = __webpack_require__(6);
    function create(_a) {
        var column = _a.column, data = _a.data, dimension = _a.dimension, rowCoords = _a.rowCoords, columnCoords = _a.columnCoords, editingEvent = _a.editingEvent, tabMode = _a.tabMode, id = _a.id;
        return observable_1.observable({
            rowKey: null,
            columnName: null,
            prevRowKey: null,
            prevColumnName: null,
            editingAddress: null,
            editingEvent: editingEvent,
            navigating: false,
            forcedDestroyEditing: false,
            tabMode: tabMode,
            get side() {
                if (this.columnName === null) {
                    return null;
                }
                return common_1.someProp('name', this.columnName, column.visibleColumnsBySideWithRowHeader.R)
                    ? 'R'
                    : 'L';
            },
            get columnIndex() {
                var _a = this, columnName = _a.columnName, side = _a.side;
                return columnName === null || side === null
                    ? null
                    : common_1.findPropIndex('name', columnName, column.visibleColumnsBySideWithRowHeader[side]);
            },
            get totalColumnIndex() {
                var visibleColumnsBySideWithRowHeader = column.visibleColumnsBySideWithRowHeader;
                var _a = this, columnIndex = _a.columnIndex, side = _a.side;
                if (columnIndex === null) {
                    return columnIndex;
                }
                return side === 'R' ? columnIndex + visibleColumnsBySideWithRowHeader.L.length : columnIndex;
            },
            get rowIndex() {
                var rowKey = this.rowKey;
                if (common_1.isNull(rowKey)) {
                    return null;
                }
                var index = data_1.findIndexByRowKey(data, column, id, rowKey);
                return data_1.isClientPagination(data) ? index - data.pageRowRange[0] : index;
            },
            get originalRowIndex() {
                var rowIndex = this.rowIndex;
                if (common_1.isNull(rowIndex)) {
                    return null;
                }
                if (data_1.isClientPagination(data)) {
                    return rowIndex + data.pageRowRange[0];
                }
                return rowIndex;
            },
            get cellPosRect() {
                var _a = this, columnIndex = _a.columnIndex, rowIndex = _a.rowIndex, side = _a.side, columnName = _a.columnName, rowKey = _a.rowKey;
                var filteredRawData = data.filteredRawData, sortState = data.sortState;
                var cellBorderWidth = dimension.cellBorderWidth;
                if (columnIndex === null || rowIndex === null || side === null || columnName === null) {
                    return null;
                }
                var widths = columnCoords.widths, offsets = columnCoords.offsets;
                var borderWidth = widths[side].length - 1 === columnIndex ? 0 : cellBorderWidth;
                var left = offsets[side][columnIndex];
                var right = left + widths[side][columnIndex] + borderWidth;
                var top = rowCoords.offsets[rowIndex];
                var bottom = top + rowCoords.heights[rowIndex];
                var rowSpan = rowSpan_1.getRowSpanByRowKey(rowKey, columnName, filteredRawData);
                if (rowSpan_1.isRowSpanEnabled(sortState) && rowSpan) {
                    var verticalPos = rowSpan_1.getVerticalPosWithRowSpan(columnName, rowSpan, rowCoords, filteredRawData);
                    return { left: left, right: right, top: verticalPos[0], bottom: verticalPos[1] };
                }
                return { left: left, right: right, top: top, bottom: bottom };
            },
        });
    }
    exports.create = create;


    /***/ }),
    /* 81 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.create = void 0;
    var tslib_1 = __webpack_require__(1);
    var observable_1 = __webpack_require__(5);
    var selection_1 = __webpack_require__(20);
    var data_1 = __webpack_require__(6);
    function getOwnSideColumnRange(columnRange, side, visibleFrozenCount) {
        var _a = columnRange.map(function (columnIdx) { return columnIdx; }), start = _a[0], end = _a[1];
        if (side === 'L' && start < visibleFrozenCount) {
            return [start, Math.min(end, visibleFrozenCount - 1)];
        }
        if (side === 'R' && end >= visibleFrozenCount) {
            return [Math.max(start, visibleFrozenCount) - visibleFrozenCount, end - visibleFrozenCount];
        }
        return null;
    }
    function getVerticalStyles(rowRange, rowOffsets, rowHeights, cellBorderWidth) {
        var top = rowOffsets[rowRange[0]];
        var bottom = rowOffsets[rowRange[1]] + rowHeights[rowRange[1]];
        return { top: top, height: bottom - top - cellBorderWidth };
    }
    function getHorizontalStyles(columnRange, columnWidths, side, cellBorderWidth) {
        var left = 0;
        var width = 0;
        if (!columnRange) {
            return { left: left, width: width };
        }
        var widths = columnWidths[side];
        var startIndex = columnRange[0];
        var endIndex = Math.min(columnRange[1], widths.length - 1);
        for (var i = 0; i <= endIndex; i += 1) {
            if (i < startIndex) {
                left += widths[i] + cellBorderWidth;
            }
            else {
                width += widths[i] + cellBorderWidth;
            }
        }
        width -= cellBorderWidth;
        if (side === 'R' && endIndex === widths.length - 1) {
            width -= cellBorderWidth;
        }
        return { left: left, width: width };
    }
    function create(_a) {
        var selectionUnit = _a.selectionUnit, rowCoords = _a.rowCoords, columnCoords = _a.columnCoords, columnInfo = _a.column, dimension = _a.dimension, data = _a.data;
        return observable_1.observable({
            inputRange: null,
            unit: selectionUnit,
            type: 'cell',
            intervalIdForAutoScroll: null,
            get range() {
                if (!this.inputRange) {
                    return null;
                }
                var columnWidths = columnCoords.widths;
                var row = selection_1.getSortedRange(this.inputRange.row);
                var column = selection_1.getSortedRange(this.inputRange.column);
                if (this.unit === 'row') {
                    var endColumnIndex = columnWidths.L.length + columnWidths.R.length - 1;
                    column = [0, endColumnIndex];
                }
                return { row: row, column: column };
            },
            get rangeBySide() {
                if (!this.range) {
                    return null;
                }
                var visibleFrozenCount = columnInfo.visibleFrozenCount;
                var _a = this.range, column = _a.column, row = _a.row;
                return {
                    L: { row: row, column: getOwnSideColumnRange(column, 'L', visibleFrozenCount) },
                    R: { row: row, column: getOwnSideColumnRange(column, 'R', visibleFrozenCount) },
                };
            },
            get rangeAreaInfo() {
                if (!this.rangeBySide) {
                    return null;
                }
                var cellBorderWidth = dimension.cellBorderWidth;
                var rowOffsets = rowCoords.offsets, rowHeights = rowCoords.heights;
                var columnWidths = columnCoords.widths;
                var _a = this.rangeBySide, leftRange = _a.L, rightRange = _a.R;
                var leftSideStyles = null;
                var rightSideStyles = null;
                if (leftRange.column) {
                    leftSideStyles = tslib_1.__assign(tslib_1.__assign({}, getVerticalStyles(leftRange.row, rowOffsets, rowHeights, cellBorderWidth)), getHorizontalStyles(leftRange.column, columnWidths, 'L', cellBorderWidth));
                }
                if (rightRange.column) {
                    rightSideStyles = tslib_1.__assign(tslib_1.__assign({}, getVerticalStyles(rightRange.row, rowOffsets, rowHeights, cellBorderWidth)), getHorizontalStyles(rightRange.column, columnWidths, 'R', cellBorderWidth));
                }
                return {
                    L: leftSideStyles,
                    R: rightSideStyles,
                };
            },
            get rangeWithRowHeader() {
                if (!this.range) {
                    return null;
                }
                var rowHeaderCount = columnInfo.rowHeaderCount;
                var _a = this.range, row = _a.row, column = _a.column;
                var columnStartIndex = Math.max(column[0] - rowHeaderCount, 0);
                var columnEndIndex = Math.max(column[1] - rowHeaderCount, 0);
                return {
                    row: row,
                    column: [columnStartIndex, columnEndIndex],
                };
            },
            get originalRange() {
                if (!this.range) {
                    return null;
                }
                var pageOptions = data.pageOptions;
                var _a = this.range, row = _a.row, column = _a.column;
                if (data_1.isClientPagination(data)) {
                    var perPage = pageOptions.perPage, page = pageOptions.page;
                    var prevPageRowCount = perPage * (page - 1);
                    return {
                        row: [row[0] + prevPageRowCount, row[1] + prevPageRowCount],
                        column: column,
                    };
                }
                return this.range;
            },
        });
    }
    exports.create = create;


    /***/ }),
    /* 82 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.create = void 0;
    var observable_1 = __webpack_require__(5);
    function create() {
        return observable_1.observable({ hoveredRowKey: null, cellHeightMap: {} });
    }
    exports.create = create;


    /***/ }),
    /* 83 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.create = void 0;
    var observable_1 = __webpack_require__(5);
    function create() {
        return observable_1.observable({ activeColumnAddress: null, activeFilterState: null });
    }
    exports.create = create;


    /***/ }),
    /* 84 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.create = void 0;
    var tslib_1 = __webpack_require__(1);
    var observable_1 = __webpack_require__(5);
    var i18n_1 = tslib_1.__importDefault(__webpack_require__(19));
    function createDefaultContextMenu() {
        return [
            [
                {
                    name: 'copy',
                    label: i18n_1.default.get('contextMenu.copy'),
                    action: 'copy',
                },
                {
                    name: 'copyColumns',
                    label: i18n_1.default.get('contextMenu.copyColumns'),
                    action: 'copyColumns',
                },
                {
                    name: 'copyRows',
                    label: i18n_1.default.get('contextMenu.copyRows'),
                    action: 'copyRows',
                },
            ],
        ];
    }
    function create(_a) {
        var createMenuGroups = _a.createMenuGroups;
        return observable_1.observable({
            posInfo: null,
            createMenuGroups: createMenuGroups || createDefaultContextMenu,
            get flattenTopMenuItems() {
                if (!this.posInfo) {
                    return [];
                }
                var _a = this.posInfo, rowKey = _a.rowKey, columnName = _a.columnName;
                var menuGroups = this.createMenuGroups({ rowKey: rowKey, columnName: columnName });
                return menuGroups.reduce(function (acc, group, groupIndex) {
                    var menuItems = [];
                    group.forEach(function (menuItem, itemIndex) {
                        menuItems.push(menuItem);
                        if (groupIndex < menuGroups.length - 1 && itemIndex === group.length - 1) {
                            menuItems.push({ name: 'separator' });
                        }
                    });
                    return acc.concat(menuItems);
                }, []);
            },
        });
    }
    exports.create = create;


    /***/ }),
    /* 85 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Root = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var container_1 = __webpack_require__(86);
    var gridEvent_1 = tslib_1.__importDefault(__webpack_require__(9));
    var eventBus_1 = __webpack_require__(8);
    var Root = /** @class */ (function (_super) {
        tslib_1.__extends(Root, _super);
        function Root() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Root.prototype.getChildContext = function () {
            return {
                store: this.props.store,
                dispatch: this.props.dispatch,
            };
        };
        Root.prototype.componentDidMount = function () {
            var eventBus = eventBus_1.getEventBus(this.props.store.id);
            var gridEvent = new gridEvent_1.default();
            setTimeout(function () {
                /**
                 * Occurs when the grid is mounted on DOM
                 * @event Grid#onGridMounted
                 * @property {Grid} instance - Current grid instance
                 */
                eventBus.trigger('onGridMounted', gridEvent);
            });
        };
        Root.prototype.componentWillUnmount = function () {
            var eventBus = eventBus_1.getEventBus(this.props.store.id);
            var gridEvent = new gridEvent_1.default();
            /**
             * Occurs before the grid is detached from DOM
             * @event Grid#onGridBeforeDestroy
             * @property {Grid} instance - Current grid instance
             */
            eventBus.trigger('onGridBeforeDestroy', gridEvent);
        };
        Root.prototype.render = function () {
            return preact_1.h(container_1.Container, { rootElement: this.props.rootElement });
        };
        return Root;
    }(preact_1.Component));
    exports.Root = Root;


    /***/ }),
    /* 86 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Container = exports.ContainerComp = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var leftSide_1 = __webpack_require__(87);
    var rightSide_1 = __webpack_require__(106);
    var stateLayer_1 = __webpack_require__(107);
    var filterLayer_1 = __webpack_require__(108);
    var contextMenu_1 = __webpack_require__(51);
    var heightResizeHandle_1 = __webpack_require__(115);
    var clipboard_1 = __webpack_require__(116);
    var pagination_1 = __webpack_require__(117);
    var dom_1 = __webpack_require__(2);
    var hoc_1 = __webpack_require__(4);
    var eventBus_1 = __webpack_require__(8);
    var gridEvent_1 = tslib_1.__importDefault(__webpack_require__(9));
    var browser_1 = __webpack_require__(52);
    var common_1 = __webpack_require__(0);
    var keyboard_1 = __webpack_require__(17);
    var DOUBLE_TAP_DURATION = 200;
    var TAP_THRESHOLD = 10;
    var ContainerComp = /** @class */ (function (_super) {
        tslib_1.__extends(ContainerComp, _super);
        function ContainerComp() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.touchEvent = {
                start: false,
                move: false,
                eventInfo: {
                    pageX: -1,
                    pageY: -1,
                    timestamp: 0,
                },
            };
            _this.handleTouchStart = function () {
                if (!_this.el || !browser_1.isMobile()) {
                    return;
                }
                _this.touchEvent.start = true;
            };
            _this.handleTouchMove = function () {
                if (!_this.el || !browser_1.isMobile() || !_this.touchEvent.start) {
                    return;
                }
                _this.touchEvent.move = true;
            };
            _this.getCellRowKey = function (elem) {
                var address = dom_1.getCellAddress(elem);
                if (address) {
                    return address.rowKey;
                }
                return null;
            };
            _this.handleTouchEnd = function (event) {
                if (!_this.el || !browser_1.isMobile()) {
                    return;
                }
                var timeStamp = event.timeStamp;
                var _a = event.changedTouches[0], pageX = _a.pageX, pageY = _a.pageY;
                var _b = _this.touchEvent, eventInfo = _b.eventInfo, start = _b.start, move = _b.move;
                if (start && !move) {
                    var prevPageX = eventInfo.pageX, prevPageY = eventInfo.pageY, prevTimestamp = eventInfo.timestamp;
                    if (timeStamp - prevTimestamp <= DOUBLE_TAP_DURATION) {
                        if (Math.abs(prevPageX - pageX) <= TAP_THRESHOLD &&
                            Math.abs(prevPageY - pageY) <= TAP_THRESHOLD) {
                            _this.startEditing(event.target);
                        }
                    }
                    else {
                        eventInfo.pageX = pageX;
                        eventInfo.pageY = pageY;
                        eventInfo.timestamp = timeStamp;
                    }
                }
                _this.touchEvent.start = false;
                _this.touchEvent.move = false;
            };
            _this.handleMouseover = function (event) {
                var _a = _this.props, eventBus = _a.eventBus, dispatch = _a.dispatch, renderState = _a.renderState;
                var hoveredRowKey = renderState.hoveredRowKey;
                var gridEvent = new gridEvent_1.default({ event: event });
                var rowKey = _this.getCellRowKey(event.target);
                if (!common_1.isNull(rowKey)) {
                    if (hoveredRowKey !== rowKey) {
                        dispatch('setHoveredRowKey', rowKey);
                    }
                }
                /**
                 * Occurs when a mouse pointer is moved onto the Grid.
                 * The properties of the event object include the native MouseEvent object.
                 * @event Grid#mouseover
                 * @property {Event} nativeEvent - Event object
                 * @property {string} targetType - Type of event target
                 * @property {number} rowKey - rowKey of the target cell
                 * @property {string} columnName - columnName of the target cell
                 * @property {Grid} instance - Current grid instance
                 */
                eventBus.trigger('mouseover', gridEvent);
            };
            _this.handleClick = function (event) {
                var _a = _this.props, eventBus = _a.eventBus, editingEvent = _a.editingEvent;
                var gridEvent = new gridEvent_1.default({ event: event });
                /**
                 * Occurs when a mouse button is clicked on the Grid.
                 * The properties of the event object include the native event object.
                 * @event Grid#click
                 * @property {Event} nativeEvent - Event object
                 * @property {string} targetType - Type of event target
                 * @property {number} rowKey - rowKey of the target cell
                 * @property {string} columnName - columnName of the target cell
                 * @property {Grid} instance - Current grid instance
                 */
                eventBus.trigger('click', gridEvent);
                if (!gridEvent.isStopped() && editingEvent === 'click') {
                    _this.startEditing(event.target);
                }
            };
            _this.handleMouseout = function (event) {
                var _a = _this.props, eventBus = _a.eventBus, dispatch = _a.dispatch, renderState = _a.renderState;
                var hoveredRowKey = renderState.hoveredRowKey;
                var gridEvent = new gridEvent_1.default({ event: event });
                if (!common_1.isNull(hoveredRowKey)) {
                    dispatch('setHoveredRowKey', null);
                }
                /**
                 * Occurs when a mouse pointer is moved off from the Grid.
                 * The event object has all properties copied from the native MouseEvent.
                 * @event Grid#mouseout
                 * @property {Event} nativeEvent - Event object
                 * @property {string} targetType - Type of event target
                 * @property {number | string} rowKey - rowKey of the target cell
                 * @property {string} columnName - columnName of the target cell
                 * @property {Grid} instance - Current grid instance
                 */
                eventBus.trigger('mouseout', gridEvent);
            };
            _this.handleMouseDown = function (event) {
                if (!_this.el) {
                    return;
                }
                var _a = _this.props, dispatch = _a.dispatch, editing = _a.editing, eventBus = _a.eventBus, filtering = _a.filtering;
                var el = _this.el;
                var gridEvent = new gridEvent_1.default({ event: event });
                /**
                 * Occurs when a mouse button is downed on the Grid.
                 * The event object has all properties copied from the native MouseEvent.
                 * @event Grid#mousedown
                 * @property {Event} nativeEvent - Event object
                 * @property {string} targetType - Type of event target
                 * @property {number | string} rowKey - rowKey of the target cell
                 * @property {string} columnName - columnName of the target cell
                 * @property {Grid} instance - Current grid instance
                 */
                eventBus.trigger('mousedown', gridEvent);
                if (!gridEvent.isStopped()) {
                    dispatch('setNavigating', true);
                    if (!editing && !filtering) {
                        event.preventDefault();
                    }
                    var _b = el.getBoundingClientRect(), top = _b.top, left = _b.left;
                    dispatch('setOffsetTop', top + el.scrollTop);
                    dispatch('setOffsetLeft', left + el.scrollLeft);
                }
            };
            _this.handleDblClick = function (event) {
                if (!_this.el || browser_1.isMobile()) {
                    return;
                }
                var _a = _this.props, eventBus = _a.eventBus, editingEvent = _a.editingEvent;
                var gridEvent = new gridEvent_1.default({ event: event });
                /**
                 * Occurs when a mouse button is double clicked on the Grid.
                 * The properties of the event object include the native event object.
                 * @event Grid#dblclick
                 * @property {Event} nativeEvent - Event object
                 * @property {string} targetType - Type of event target
                 * @property {number} rowKey - rowKey of the target cell
                 * @property {string} columnName - columnName of the target cell
                 * @property {Grid} instance - Current grid instance
                 */
                eventBus.trigger('dblclick', gridEvent);
                if (!gridEvent.isStopped() && editingEvent === 'dblclick') {
                    _this.startEditing(event.target);
                }
            };
            _this.handleDocumentKeyDown = function (ev) {
                var keyName = keyboard_1.keyNameMap[ev.keyCode];
                if (keyName === 'esc') {
                    _this.props.dispatch('setActiveColumnAddress', null);
                    _this.props.dispatch('hideContextMenu');
                }
            };
            _this.handleDocumentMouseDown = function (ev) {
                var _a = _this.props, dispatch = _a.dispatch, filtering = _a.filtering;
                var target = ev.target;
                if (filtering && !dom_1.findParent(target, 'btn-filter') && !dom_1.findParent(target, 'filter-container')) {
                    dispatch('setActiveColumnAddress', null);
                }
                if (!dom_1.findParent(target, 'context-menu')) {
                    _this.props.dispatch('hideContextMenu');
                }
            };
            _this.syncWithDOMWidth = function () {
                _this.props.dispatch('refreshLayout', _this.el, _this.props.rootElement.parentElement);
            };
            _this.handleContextMenu = function (ev) {
                if (dom_1.findParent(ev.target, 'cell-header')) {
                    return;
                }
                ev.preventDefault();
                var _a = _this.props, offsetLeft = _a.offsetLeft, offsetTop = _a.offsetTop;
                var pos = { left: ev.clientX - offsetLeft, top: ev.clientY - offsetTop };
                var _b = dom_1.getCoordinateWithOffset(ev.pageX, ev.pageY), pageX = _b[0], pageY = _b[1];
                var bodyArea = dom_1.findParent(ev.target, 'body-area');
                var side = dom_1.findParent(bodyArea, 'lside-area') ? 'L' : 'R';
                var scrollTop = bodyArea.scrollTop, scrollLeft = bodyArea.scrollLeft;
                var _c = bodyArea.getBoundingClientRect(), top = _c.top, left = _c.left;
                var elementInfo = { scrollTop: scrollTop, scrollLeft: scrollLeft, side: side, top: top, left: left };
                var eventInfo = { pageX: pageX, pageY: pageY };
                _this.props.dispatch('showContextMenu', pos, elementInfo, eventInfo);
            };
            return _this;
        }
        ContainerComp.prototype.startEditing = function (eventTarget) {
            var _a = this.props, dispatch = _a.dispatch, focusedRowKey = _a.focusedRowKey, focusedColumnName = _a.focusedColumnName;
            var address = dom_1.getCellAddress(eventTarget);
            if (address) {
                var rowKey = address.rowKey, columnName = address.columnName;
                if (focusedRowKey === rowKey && focusedColumnName === columnName) {
                    dispatch('startEditing', rowKey, columnName);
                }
            }
        };
        ContainerComp.prototype.componentDidMount = function () {
            if (this.props.autoWidth) {
                window.addEventListener('resize', this.syncWithDOMWidth);
                // In Preact, the componentDidMount is called before the DOM elements are actually mounted.
                // https://github.com/preactjs/preact/issues/648
                // Use setTimeout to wait until the DOM element is actually mounted
                window.setTimeout(this.syncWithDOMWidth, 0);
            }
            document.addEventListener('mousedown', this.handleDocumentMouseDown);
            document.addEventListener('keydown', this.handleDocumentKeyDown);
        };
        ContainerComp.prototype.componentWillUnmount = function () {
            if (this.props.autoWidth) {
                window.removeEventListener('resize', this.syncWithDOMWidth);
            }
        };
        ContainerComp.prototype.shouldComponentUpdate = function (nextProps) {
            if (this.props.autoWidth && nextProps.autoWidth) {
                return false;
            }
            return true;
        };
        ContainerComp.prototype.render = function () {
            var _a;
            var _this = this;
            var _b = this.props, summaryHeight = _b.summaryHeight, summaryPosition = _b.summaryPosition, heightResizable = _b.heightResizable, gridId = _b.gridId, width = _b.width, autoWidth = _b.autoWidth, scrollXHeight = _b.scrollXHeight, showLeftSide = _b.showLeftSide, scrollX = _b.scrollX, scrollY = _b.scrollY, pageOptions = _b.pageOptions;
            var style = { width: autoWidth ? '100%' : width };
            var attrs = (_a = {}, _a[dom_1.dataAttr.GRID_ID] = gridId, _a);
            return (preact_1.h("div", tslib_1.__assign({}, attrs, { style: style, class: dom_1.cls('container', [showLeftSide, 'show-lside-area']), onMouseDown: this.handleMouseDown, onDblClick: this.handleDblClick, onClick: this.handleClick, onMouseOut: this.handleMouseout, onMouseOver: this.handleMouseover, onTouchStart: this.handleTouchStart, onTouchMove: this.handleTouchMove, onTouchEnd: this.handleTouchEnd, onContextMenu: this.handleContextMenu, ref: function (el) {
                    _this.el = el;
                } }),
                pageOptions.position === 'top' && preact_1.h(pagination_1.Pagination, null),
                preact_1.h("div", { class: dom_1.cls('content-area', [!!summaryHeight, summaryPosition === 'top' ? 'has-summary-top' : 'has-summary-bottom'], [!scrollX, 'no-scroll-x'], [!scrollY, 'no-scroll-y']) },
                    preact_1.h(leftSide_1.LeftSide, null),
                    preact_1.h(rightSide_1.RightSide, null),
                    preact_1.h("div", { class: dom_1.cls('border-line', 'border-line-top') }),
                    preact_1.h("div", { class: dom_1.cls('border-line', 'border-line-left') }),
                    preact_1.h("div", { class: dom_1.cls('border-line', 'border-line-right') }),
                    preact_1.h("div", { class: dom_1.cls('border-line', 'border-line-bottom'), style: { bottom: scrollXHeight } })),
                heightResizable && preact_1.h(heightResizeHandle_1.HeightResizeHandle, null),
                preact_1.h(stateLayer_1.StateLayer, null),
                preact_1.h(clipboard_1.Clipboard, null),
                pageOptions.position === 'bottom' && preact_1.h(pagination_1.Pagination, null),
                preact_1.h(filterLayer_1.FilterLayer, null),
                preact_1.h(contextMenu_1.ContextMenu, null)));
        };
        return ContainerComp;
    }(preact_1.Component));
    exports.ContainerComp = ContainerComp;
    exports.Container = hoc_1.connect(function (_a) {
        var id = _a.id, dimension = _a.dimension, focus = _a.focus, columnCoords = _a.columnCoords, data = _a.data, filterLayerState = _a.filterLayerState, renderState = _a.renderState;
        return ({
            gridId: id,
            width: dimension.width,
            autoWidth: dimension.autoWidth,
            editing: !!focus.editingAddress,
            filtering: !!filterLayerState.activeColumnAddress,
            scrollXHeight: dimension.scrollX ? dimension.scrollbarWidth : 0,
            fitToParentHeight: dimension.fitToParentHeight,
            summaryHeight: dimension.summaryHeight,
            summaryPosition: dimension.summaryPosition,
            heightResizable: dimension.heightResizable,
            showLeftSide: !!columnCoords.areaWidth.L,
            editingEvent: focus.editingEvent,
            viewData: data.viewData,
            pageOptions: data.pageOptions,
            eventBus: eventBus_1.getEventBus(id),
            scrollX: dimension.scrollX,
            scrollY: dimension.scrollY,
            renderState: renderState,
            focusedRowKey: focus.rowKey,
            focusedColumnName: focus.columnName,
            offsetLeft: dimension.offsetLeft,
            offsetTop: dimension.offsetTop,
        });
    })(ContainerComp);


    /***/ }),
    /* 87 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LeftSide = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var headerArea_1 = __webpack_require__(47);
    var bodyArea_1 = __webpack_require__(49);
    var summaryArea_1 = __webpack_require__(50);
    var dom_1 = __webpack_require__(2);
    var hoc_1 = __webpack_require__(4);
    var LeftSideComp = /** @class */ (function (_super) {
        tslib_1.__extends(LeftSideComp, _super);
        function LeftSideComp() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        LeftSideComp.prototype.render = function (_a) {
            var width = _a.width, scrollX = _a.scrollX;
            var style = { width: width, display: 'block' };
            var summaryPosition = this.props.summaryPosition;
            return (preact_1.h("div", { class: dom_1.cls('lside-area'), style: style },
                preact_1.h(headerArea_1.HeaderArea, { side: "L" }),
                summaryPosition === 'top' && preact_1.h(summaryArea_1.SummaryArea, { side: "L" }),
                preact_1.h(bodyArea_1.BodyArea, { side: "L" }),
                summaryPosition === 'bottom' && preact_1.h(summaryArea_1.SummaryArea, { side: "L" }),
                scrollX && preact_1.h("div", { class: dom_1.cls('scrollbar-left-bottom') })));
        };
        return LeftSideComp;
    }(preact_1.Component));
    exports.LeftSide = hoc_1.connect(function (_a) {
        var columnCoords = _a.columnCoords, dimension = _a.dimension;
        return ({
            width: columnCoords.areaWidth.L,
            scrollX: dimension.scrollX,
            summaryPosition: dimension.summaryPosition,
        });
    })(LeftSideComp);


    /***/ }),
    /* 88 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ColumnResizer = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var dom_1 = __webpack_require__(2);
    var hoc_1 = __webpack_require__(4);
    var common_1 = __webpack_require__(0);
    var column_1 = __webpack_require__(12);
    var WIDTH = 7;
    var HALF_WIDTH = 3;
    var ColumnResizerComp = /** @class */ (function (_super) {
        tslib_1.__extends(ColumnResizerComp, _super);
        function ColumnResizerComp() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.dragStartX = -1;
            _this.draggingRange = [-1, -1];
            _this.draggingWidths = [];
            _this.handleMouseDown = function (ev, name) {
                var range = _this.getComplexHeaderRange(name);
                _this.draggingRange = range;
                _this.dragStartX = ev.pageX;
                _this.draggingWidths = _this.props.widths.slice(range[0], range[1] + 1);
                dom_1.setCursorStyle('col-resize');
                document.addEventListener('mousemove', _this.handleMouseMove);
                document.addEventListener('mouseup', _this.clearDocumentEvents);
                document.addEventListener('selectstart', _this.handleSelectStart);
            };
            _this.handleSelectStart = function (ev) {
                ev.preventDefault();
            };
            _this.handleMouseMove = function (ev) {
                var _a = _this.props, side = _a.side, dispatch = _a.dispatch;
                var resizeAmount = ev.pageX - _this.dragStartX;
                dispatch('setColumnWidth', side, _this.draggingRange, resizeAmount, _this.draggingWidths);
            };
            _this.clearDocumentEvents = function () {
                dom_1.setCursorStyle('');
                document.removeEventListener('mousemove', _this.handleMouseMove);
                document.removeEventListener('mouseup', _this.clearDocumentEvents);
                document.removeEventListener('selectstart', _this.handleSelectStart);
            };
            return _this;
        }
        ColumnResizerComp.prototype.componentWillUnmount = function () {
            this.clearDocumentEvents();
        };
        ColumnResizerComp.prototype.renderHandle = function (info, index) {
            var _a;
            var _this = this;
            var name = info.name, height = info.height, offsetX = info.offsetX, offsetY = info.offsetY, width = info.width, header = info.header;
            var attrs = (_a = {},
                _a[dom_1.dataAttr.COLUMN_INDEX] = index,
                _a[dom_1.dataAttr.COLUMN_NAME] = name,
                _a);
            return (preact_1.h("div", tslib_1.__assign({ class: dom_1.cls('column-resize-handle'), title: header }, attrs, { style: {
                    height: height,
                    width: WIDTH,
                    left: offsetX + width - HALF_WIDTH,
                    bottom: offsetY,
                }, onMouseDown: function (ev) { return _this.handleMouseDown(ev, name); } })));
        };
        ColumnResizerComp.prototype.isHideChildColumns = function (name) {
            return common_1.some(function (item) { return common_1.includes(item.childNames, name) && !!item.hideChildHeaders; }, this.props.complexColumns);
        };
        ColumnResizerComp.prototype.findComplexColumnStartIndex = function (name) {
            var _a = this.props, columns = _a.columns, complexColumns = _a.complexColumns, allColumnMap = _a.allColumnMap;
            var idx = common_1.findPropIndex('name', name, columns);
            if (idx === -1 && !allColumnMap[name].hidden) {
                var complexColumn = common_1.findProp('name', name, complexColumns);
                return this.findComplexColumnStartIndex(complexColumn.childNames[0]);
            }
            return idx;
        };
        ColumnResizerComp.prototype.findComplexColumnEndIndex = function (name) {
            var _a = this.props, columns = _a.columns, complexColumns = _a.complexColumns, allColumnMap = _a.allColumnMap;
            var idx = common_1.findPropIndex('name', name, columns);
            if (idx === -1 && !allColumnMap[name].hidden) {
                var childNames = common_1.findProp('name', name, complexColumns).childNames;
                return this.findComplexColumnEndIndex(childNames[childNames.length - 1]);
            }
            return idx;
        };
        ColumnResizerComp.prototype.getComplexHeaderRange = function (name) {
            var _this = this;
            var _a = this.props, columns = _a.columns, complexColumns = _a.complexColumns;
            var index = common_1.findPropIndex('name', name, columns);
            if (index === -1) {
                var startIndex_1 = Number.MAX_VALUE;
                var endIndex_1 = Number.MIN_VALUE;
                var childNames = common_1.findProp('name', name, complexColumns).childNames;
                childNames.forEach(function (childName) {
                    startIndex_1 = Math.min(startIndex_1, _this.findComplexColumnStartIndex(childName));
                    endIndex_1 = Math.max(startIndex_1, _this.findComplexColumnEndIndex(childName));
                });
                return [startIndex_1, endIndex_1];
            }
            return [index, index];
        };
        ColumnResizerComp.prototype.getResizerCoords = function (name) {
            var _a = this.props, offsets = _a.offsets, widths = _a.widths, columns = _a.columns, cellBorderWidth = _a.cellBorderWidth, complexColumns = _a.complexColumns;
            var _b = this.getComplexHeaderRange(name), startIndex = _b[0], endIndex = _b[1];
            var count = column_1.getChildHeaderCount(columns, complexColumns, name);
            var cellBorder = count ? count * cellBorderWidth : cellBorderWidth;
            return {
                width: common_1.sum(widths.slice(startIndex, endIndex + 1)),
                offsetX: offsets[startIndex] + cellBorder,
            };
        };
        ColumnResizerComp.prototype.getResizableColumnsInfo = function () {
            var _this = this;
            var _a = this.props, columns = _a.columns, complexColumns = _a.complexColumns, headerHeight = _a.headerHeight;
            var hierarchies = column_1.getComplexColumnsHierarchy(columns, complexColumns);
            var maxLen = column_1.getHierarchyMaxRowCount(hierarchies);
            var defaultHeight = headerHeight / maxLen;
            var nameMap = {};
            var resizerInfo = [];
            hierarchies.forEach(function (cols) {
                var len = cols.length;
                var offsetY = headerHeight;
                cols.forEach(function (col, idx) {
                    var resizable = col.resizable, name = col.name, header = col.header;
                    var height = idx === len - 1 ? defaultHeight * (maxLen - len + 1) : defaultHeight;
                    offsetY -= height;
                    if (resizable && !_this.isHideChildColumns(name) && !nameMap[name]) {
                        resizerInfo.push(tslib_1.__assign({ name: name,
                            header: header,
                            height: height,
                            offsetY: offsetY }, _this.getResizerCoords(name)));
                        nameMap[name] = true;
                    }
                });
            });
            return resizerInfo;
        };
        ColumnResizerComp.prototype.render = function () {
            var _this = this;
            return (preact_1.h("div", { class: dom_1.cls('column-resize-container'), style: "display: block; margin-top: -35px; height: 35px;" }, this.getResizableColumnsInfo().map(function (info, index) { return _this.renderHandle(info, index); })));
        };
        return ColumnResizerComp;
    }(preact_1.Component));
    exports.ColumnResizer = hoc_1.connect(function (_a, _b) {
        var column = _a.column, columnCoords = _a.columnCoords, dimension = _a.dimension;
        var side = _b.side;
        return ({
            widths: columnCoords.widths[side],
            offsets: columnCoords.offsets[side],
            headerHeight: dimension.headerHeight,
            cellBorderWidth: dimension.cellBorderWidth,
            columns: column.visibleColumnsBySideWithRowHeader[side],
            complexColumns: column.complexColumnHeaders,
            allColumnMap: column.allColumnMap,
        });
    })(ColumnResizerComp);


    /***/ }),
    /* 89 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ComplexHeader = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var hoc_1 = __webpack_require__(4);
    var selection_1 = __webpack_require__(20);
    var columnHeader_1 = __webpack_require__(48);
    var column_1 = __webpack_require__(12);
    var ComplexHeaderComp = /** @class */ (function (_super) {
        tslib_1.__extends(ComplexHeaderComp, _super);
        function ComplexHeaderComp() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ComplexHeaderComp.prototype.isSelected = function (name) {
            var _a = this.props, columnSelectionRange = _a.columnSelectionRange, columns = _a.columns, complexColumnHeaders = _a.complexColumnHeaders;
            if (!columnSelectionRange) {
                return false;
            }
            var selectionStart = columnSelectionRange[0], selectionEnd = columnSelectionRange[1];
            var _b = selection_1.getChildColumnRange(columns, complexColumnHeaders, name), columnStart = _b[0], columnEnd = _b[1];
            return (columnStart >= selectionStart &&
                columnStart <= selectionEnd &&
                columnEnd >= selectionStart &&
                columnEnd <= selectionEnd);
        };
        ComplexHeaderComp.prototype.createTableHeaderComponent = function (column, height, colspan, rowspan) {
            var name = column.name;
            return (preact_1.h(columnHeader_1.ColumnHeader, { key: name, height: height, colspan: colspan, rowspan: rowspan, columnInfo: column, selected: this.isSelected(name), grid: this.props.grid }));
        };
        ComplexHeaderComp.prototype.render = function () {
            var _this = this;
            var _a = this.props, columns = _a.columns, headerHeight = _a.headerHeight, cellBorderWidth = _a.cellBorderWidth, complexColumnHeaders = _a.complexColumnHeaders;
            var hierarchies = column_1.getComplexColumnsHierarchy(columns, complexColumnHeaders);
            var maxRowCount = column_1.getHierarchyMaxRowCount(hierarchies);
            var rows = new Array(maxRowCount);
            var columnNames = new Array(maxRowCount);
            var colspans = [];
            var rowHeight = (maxRowCount ? Math.floor((headerHeight - 1) / maxRowCount) : 0) - 1;
            var rowspan = 1;
            var height;
            hierarchies.forEach(function (hierarchy, i) {
                var length = hierarchies[i].length;
                var curHeight = 0;
                hierarchy.forEach(function (column, j) {
                    var columnName = column.name;
                    rowspan = length - 1 === j && maxRowCount - length + 1 > 1 ? maxRowCount - length + 1 : 1;
                    height = rowHeight * rowspan;
                    if (j === length - 1) {
                        height = headerHeight - curHeight - cellBorderWidth;
                    }
                    else {
                        curHeight += height + cellBorderWidth;
                    }
                    if (columnNames[j] === columnName) {
                        rows[j].pop();
                        colspans[j] += 1;
                    }
                    else {
                        colspans[j] = 1;
                    }
                    columnNames[j] = columnName;
                    rows[j] = rows[j] || [];
                    rows[j].push(_this.createTableHeaderComponent(column, height + cellBorderWidth, colspans[j], rowspan));
                });
            });
            return (preact_1.h("tbody", null, rows.map(function (row, index) { return (preact_1.h("tr", { key: "complex-header-" + index }, row)); })));
        };
        return ComplexHeaderComp;
    }(preact_1.Component));
    exports.ComplexHeader = hoc_1.connect(function (store, _a) {
        var side = _a.side;
        var _b = store.column, rowHeaderCount = _b.rowHeaderCount, visibleColumnsBySideWithRowHeader = _b.visibleColumnsBySideWithRowHeader, complexColumnHeaders = _b.complexColumnHeaders, _c = store.dimension, headerHeight = _c.headerHeight, cellBorderWidth = _c.cellBorderWidth, rangeBySide = store.selection.rangeBySide;
        return {
            headerHeight: headerHeight,
            cellBorderWidth: cellBorderWidth,
            columns: visibleColumnsBySideWithRowHeader[side],
            complexColumnHeaders: complexColumnHeaders,
            columnSelectionRange: rangeBySide && rangeBySide[side].column ? rangeBySide[side].column : null,
            rowHeaderCount: rowHeaderCount,
        };
    })(ComplexHeaderComp);


    /***/ }),
    /* 90 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HeaderCheckbox = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var hoc_1 = __webpack_require__(4);
    var HeaderCheckboxComp = /** @class */ (function (_super) {
        tslib_1.__extends(HeaderCheckboxComp, _super);
        function HeaderCheckboxComp() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.handleChange = function (ev) {
                var target = ev.target;
                var dispatch = _this.props.dispatch;
                if (target.checked) {
                    dispatch('checkAll', false);
                }
                else {
                    dispatch('uncheckAll', false);
                }
            };
            return _this;
        }
        HeaderCheckboxComp.prototype.componentDidMount = function () {
            this.setCheckboxState();
        };
        HeaderCheckboxComp.prototype.componentDidUpdate = function () {
            this.setCheckboxState();
        };
        HeaderCheckboxComp.prototype.setCheckboxState = function () {
            var _a = this.props, checkedAllRows = _a.checkedAllRows, disabled = _a.disabled;
            var input = this.el.querySelector('input[name=_checked]');
            if (input) {
                input.checked = checkedAllRows;
                input.disabled = disabled;
            }
        };
        HeaderCheckboxComp.prototype.render = function () {
            var _this = this;
            return (preact_1.h("span", { ref: function (el) {
                    _this.el = el;
                }, dangerouslySetInnerHTML: { __html: this.props.header }, onChange: this.handleChange }));
        };
        return HeaderCheckboxComp;
    }(preact_1.Component));
    exports.HeaderCheckbox = hoc_1.connect(function (store) {
        var _a = store.data, checkedAllRows = _a.checkedAllRows, disabledAllCheckbox = _a.disabledAllCheckbox, allColumnMap = store.column.allColumnMap;
        return {
            header: allColumnMap._checked.header,
            checkedAllRows: checkedAllRows,
            disabled: disabledAllCheckbox,
        };
    })(HeaderCheckboxComp);


    /***/ }),
    /* 91 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SortingButton = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var dom_1 = __webpack_require__(2);
    var hoc_1 = __webpack_require__(4);
    var instance_1 = __webpack_require__(7);
    var common_1 = __webpack_require__(0);
    var SortingButtonComp = /** @class */ (function (_super) {
        tslib_1.__extends(SortingButtonComp, _super);
        function SortingButtonComp() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.handleClick = function (ev) {
                var target = ev.target;
                var multiple = ev.ctrlKey || ev.metaKey;
                if (!dom_1.hasClass(target, 'btn-sorting')) {
                    return;
                }
                var _a = _this.props, dispatch = _a.dispatch, sortState = _a.sortState, dataProvider = _a.dataProvider, defaultAscending = _a.defaultAscending;
                var columns = sortState.columns;
                var th = dom_1.findParent(target, 'cell');
                var columnName = th.getAttribute('data-column-name');
                var index = common_1.findPropIndex('columnName', columnName, columns);
                var ascending = index !== -1 ? !columns[index].ascending : defaultAscending;
                if (sortState.useClient) {
                    dispatch('sort', columnName, ascending, multiple);
                }
                else {
                    // @TODO: apply multi sort to dataSource
                    dataProvider.sort(columnName, ascending, true);
                }
            };
            return _this;
        }
        SortingButtonComp.prototype.render = function () {
            var _a = this.props, active = _a.active, ascending = _a.ascending;
            return (preact_1.h("a", { class: dom_1.cls('btn-sorting', [active, ascending ? 'btn-sorting-up' : 'btn-sorting-down']), onClick: this.handleClick }));
        };
        return SortingButtonComp;
    }(preact_1.Component));
    exports.SortingButton = hoc_1.connect(function (store, props) {
        var sortState = store.data.sortState, id = store.id;
        var columnName = props.columnName, _a = props.sortingType, sortingType = _a === void 0 ? 'asc' : _a;
        var columns = sortState.columns;
        var index = common_1.findPropIndex('columnName', columnName, columns);
        var ascending = index !== -1 ? columns[index].ascending : true;
        return {
            sortState: sortState,
            ascending: ascending,
            dataProvider: instance_1.getDataProvider(id),
            defaultAscending: sortingType === 'asc',
            active: index !== -1,
        };
    })(SortingButtonComp);


    /***/ }),
    /* 92 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SortingOrder = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var hoc_1 = __webpack_require__(4);
    var common_1 = __webpack_require__(0);
    var SortingOrderComp = /** @class */ (function (_super) {
        tslib_1.__extends(SortingOrderComp, _super);
        function SortingOrderComp() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SortingOrderComp.prototype.render = function () {
            var _a = this.props, order = _a.order, showOrder = _a.showOrder;
            return showOrder && preact_1.h("span", { style: { color: '#bbb', fontWeight: 100 } }, order);
        };
        return SortingOrderComp;
    }(preact_1.Component));
    exports.SortingOrder = hoc_1.connect(function (store, props) {
        var columns = store.data.sortState.columns;
        var columnName = props.columnName;
        var order = common_1.findPropIndex('columnName', columnName, columns) + 1;
        var showOrder = !!order && columns.length > 1;
        return {
            order: order,
            showOrder: showOrder,
        };
    })(SortingOrderComp);


    /***/ }),
    /* 93 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FilterButton = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var dom_1 = __webpack_require__(2);
    var hoc_1 = __webpack_require__(4);
    var common_1 = __webpack_require__(0);
    var DISTANCE_FROM_ICON_TO_LAYER = 9;
    var FilterButtonComp = /** @class */ (function (_super) {
        tslib_1.__extends(FilterButtonComp, _super);
        function FilterButtonComp() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.isActiveFilter = function () {
                var _a = _this.props, filters = _a.filters, columnName = _a.columnName;
                return filters ? common_1.someProp('columnName', columnName, filters) : false;
            };
            _this.handleClick = function (ev) {
                var target = ev.target;
                if (!dom_1.hasClass(target, 'btn-filter')) {
                    return;
                }
                var _a = _this.props, activeColumnAddress = _a.activeColumnAddress, columnName = _a.columnName, dispatch = _a.dispatch, offsetLeft = _a.offsetLeft;
                if (!activeColumnAddress || activeColumnAddress.name !== columnName) {
                    var left = target.getBoundingClientRect().left - offsetLeft - DISTANCE_FROM_ICON_TO_LAYER;
                    dispatch('setActiveColumnAddress', { name: columnName, left: left });
                }
            };
            return _this;
        }
        FilterButtonComp.prototype.render = function () {
            return (preact_1.h("a", { class: dom_1.cls('btn-filter', [this.isActiveFilter(), 'btn-filter-active']), onClick: this.handleClick }));
        };
        return FilterButtonComp;
    }(preact_1.Component));
    exports.FilterButton = hoc_1.connect(function (store, _a) {
        var columnName = _a.columnName;
        return ({
            activeColumnAddress: store.filterLayerState.activeColumnAddress,
            filters: store.data.filters,
            columnName: columnName,
            offsetLeft: store.dimension.offsetLeft,
        });
    })(FilterButtonComp);


    /***/ }),
    /* 94 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getResolvedOffsets = exports.createFloatingLine = exports.getMovedPosAndIndex = exports.createDraggableInfo = void 0;
    var common_1 = __webpack_require__(0);
    var dom_1 = __webpack_require__(2);
    var data_1 = __webpack_require__(6);
    var EXCEED_RATIO = 0.8;
    var ADDITIONAL_HEIGHT = 10;
    function createRow(height) {
        var row = document.createElement('div');
        row.className = dom_1.cls('floating-row');
        row.style.height = height;
        row.style.lineHeight = height;
        row.style.width = 'auto';
        return row;
    }
    function createCells(cell) {
        var childLen = cell.childNodes.length;
        var el = document.createElement('div');
        el.className = dom_1.cls('floating-cell');
        el.style.width = window.getComputedStyle(cell).width;
        for (var i = 0; i < childLen; i += 1) {
            // the cell is not complex structure, so there is no the performance problem
            el.appendChild(cell.childNodes[i].cloneNode(true));
        }
        return el;
    }
    function createTreeCell(treeColumnName, viewRow) {
        var cell = document.createElement('div');
        var iconStyle = viewRow.treeInfo.leaf ? '' : 'background-position: -39px -35px';
        var span = document.createElement('span');
        span.className = dom_1.cls('floating-tree-cell-content');
        span.textContent = String(viewRow.valueMap[treeColumnName].value);
        cell.className = dom_1.cls('floating-tree-cell');
        cell.innerHTML = "\n    <span class=\"" + dom_1.cls('tree-icon') + "\">\n      <i style=\"" + iconStyle + "\"></i>\n    </span>\n  ";
        cell.appendChild(span);
        return cell;
    }
    function createFloatingDraggableRow(store, rowKey, offsetLeft, offsetTop, posInfo) {
        var data = store.data, column = store.column, id = store.id;
        var treeColumnName = column.treeColumnName;
        var cells = common_1.fromArray(posInfo.container.querySelectorAll("[data-row-key=\"" + rowKey + "\"]"));
        // get original table row height
        var height = cells[0].parentElement.clientHeight + "px";
        var row = createRow(height);
        row.style.left = offsetLeft + "px";
        row.style.top = offsetTop + "px";
        if (treeColumnName) {
            var index = data_1.findIndexByRowKey(data, column, id, rowKey);
            var viewRow = data.viewData[index];
            row.appendChild(createTreeCell(treeColumnName, viewRow));
        }
        else {
            cells.forEach(function (cell) {
                row.appendChild(createCells(cell));
            });
        }
        return row;
    }
    function createDraggableInfo(store, posInfo) {
        var data = store.data, dimension = store.dimension;
        var rawData = data.rawData, filters = data.filters;
        // if there is any filter condition, cannot drag the row
        if (!rawData.length || (filters === null || filters === void 0 ? void 0 : filters.length)) {
            return null;
        }
        var _a = getMovedPosAndIndex(store, posInfo), offsetLeft = _a.offsetLeft, offsetTop = _a.offsetTop, index = _a.index;
        var _b = rawData[index], rowKey = _b.rowKey, _attributes = _b._attributes;
        var row = createFloatingDraggableRow(store, rowKey, offsetLeft, offsetTop, posInfo);
        return _attributes.disabled
            ? null
            : {
                row: row,
                rowKey: rowKey,
                line: createFloatingLine(dimension.scrollYWidth),
            };
    }
    exports.createDraggableInfo = createDraggableInfo;
    function getMovedPosAndIndex(store, _a) {
        var pageX = _a.pageX, pageY = _a.pageY, left = _a.left, top = _a.top, scrollTop = _a.scrollTop;
        var rowCoords = store.rowCoords, dimension = store.dimension, column = store.column, data = store.data;
        var heights = rowCoords.heights, offsets = rowCoords.offsets;
        var rawData = data.rawData;
        var headerHeight = dimension.headerHeight;
        var offsetLeft = pageX - left;
        var offsetTop = pageY - top + scrollTop;
        var index = common_1.findOffsetIndex(rowCoords.offsets, offsetTop);
        // move to next index when exceeding the height with ratio
        if (!column.treeColumnName) {
            if (index < rawData.length - 1 && offsetTop - offsets[index] > heights[index] * EXCEED_RATIO) {
                index += 1;
            }
        }
        var height = offsets[index] - scrollTop + headerHeight;
        var moveToLast = false;
        // resolve the height for moving to last index with tree data
        if (column.treeColumnName) {
            if (rawData.length - 1 === index && offsetTop > offsets[index] + heights[index]) {
                height += heights[index];
                moveToLast = true;
            }
        }
        return {
            index: index,
            height: height,
            offsetLeft: offsetLeft,
            offsetTop: offsetTop - scrollTop + headerHeight,
            targetRow: rawData[index],
            moveToLast: moveToLast,
        };
    }
    exports.getMovedPosAndIndex = getMovedPosAndIndex;
    function createFloatingLine(scrollYWidth) {
        var line = document.createElement('div');
        line.className = dom_1.cls('floating-line');
        line.style.width = "calc(100% - " + scrollYWidth + "px)";
        return line;
    }
    exports.createFloatingLine = createFloatingLine;
    function getResolvedOffsets(_a, _b, _c) {
        var dimension = _a.dimension;
        var offsetLeft = _b.offsetLeft, offsetTop = _b.offsetTop;
        var width = _c.width;
        var bodyWidth = dimension.width, bodyHeight = dimension.bodyHeight, scrollXHeight = dimension.scrollXHeight;
        return {
            offsetLeft: common_1.clamp(offsetLeft, 0, bodyWidth - width),
            offsetTop: common_1.clamp(offsetTop, 0, bodyHeight + scrollXHeight + ADDITIONAL_HEIGHT),
        };
    }
    exports.getResolvedOffsets = getResolvedOffsets;


    /***/ }),
    /* 95 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BodyRows = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var bodyRow_1 = __webpack_require__(96);
    var bodyDummyRow_1 = __webpack_require__(100);
    var common_1 = __webpack_require__(0);
    var hoc_1 = __webpack_require__(4);
    var BodyRowsComp = /** @class */ (function (_super) {
        tslib_1.__extends(BodyRowsComp, _super);
        function BodyRowsComp() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BodyRowsComp.prototype.shouldComponentUpdate = function (nextProps) {
            return !common_1.shallowEqual(nextProps, this.props);
        };
        BodyRowsComp.prototype.render = function (_a) {
            var rows = _a.rows, rowIndexOffset = _a.rowIndexOffset, columns = _a.columns, dummyRowCount = _a.dummyRowCount;
            var columnNames = columns.map(function (_a) {
                var name = _a.name;
                return name;
            });
            return (preact_1.h("tbody", null,
                rows.map(function (row, index) { return (preact_1.h(bodyRow_1.BodyRow, { key: row.uniqueKey, rowIndex: index + rowIndexOffset, viewRow: row, columns: columns })); }),
                common_1.range(dummyRowCount).map(function (index) { return (preact_1.h(bodyDummyRow_1.BodyDummyRow, { key: "dummy-" + index, index: rows.length + index, columnNames: columnNames })); })));
        };
        return BodyRowsComp;
    }(preact_1.Component));
    exports.BodyRows = hoc_1.connect(function (_a, _b) {
        var viewport = _a.viewport, column = _a.column, data = _a.data;
        var side = _b.side;
        return ({
            rowIndexOffset: viewport.rowRange[0] - data.pageRowRange[0],
            rows: viewport.rows,
            columns: side === 'L' ? column.visibleColumnsBySideWithRowHeader.L : viewport.columns,
            dummyRowCount: viewport.dummyRowCount,
        });
    })(BodyRowsComp);


    /***/ }),
    /* 96 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BodyRow = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var hoc_1 = __webpack_require__(4);
    var dom_1 = __webpack_require__(2);
    var common_1 = __webpack_require__(0);
    var rowSpanCell_1 = __webpack_require__(97);
    var ROW_HEIGHT_DEBOUNCE_TIME = 10;
    var BodyRowComp = /** @class */ (function (_super) {
        tslib_1.__extends(BodyRowComp, _super);
        function BodyRowComp() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            // This debounced function is aimed to wait until setTimeout(.., 0) calls
            // from the all child BodyCell components is made.
            // 10ms is just an approximate number. (smaller than 10ms might be safe enough)
            _this.updateRowHeightDebounced = common_1.debounce(function () {
                var _a = _this.props, dispatch = _a.dispatch, rowIndex = _a.rowIndex, rowHeight = _a.rowHeight;
                dispatch('refreshRowHeight', rowIndex, rowHeight);
            }, ROW_HEIGHT_DEBOUNCE_TIME);
            return _this;
        }
        BodyRowComp.prototype.componentWillUnmount = function () {
            var _a = this.props, rowIndex = _a.rowIndex, autoRowHeight = _a.autoRowHeight, dispatch = _a.dispatch;
            if (autoRowHeight) {
                dispatch('removeRowHeight', rowIndex);
            }
        };
        BodyRowComp.prototype.render = function (_a) {
            var _this = this;
            var rowIndex = _a.rowIndex, viewRow = _a.viewRow, columns = _a.columns, rowHeight = _a.rowHeight, autoRowHeight = _a.autoRowHeight, hoveredRowKey = _a.hoveredRowKey, focusedRowKey = _a.focusedRowKey;
            var isOddRow = rowIndex % 2 === 0;
            return (rowHeight > 0 && (preact_1.h("tr", { style: { height: rowHeight }, class: dom_1.cls([isOddRow, 'row-odd'], [!isOddRow, 'row-even'], [!common_1.isNull(hoveredRowKey) && hoveredRowKey === viewRow.rowKey, 'row-hover'], [!common_1.isNull(focusedRowKey) && focusedRowKey === viewRow.rowKey, 'cell-current-row']) }, columns.map(function (columnInfo) {
                // Pass row object directly instead of passing value of it only,
                // so that BodyCell component can watch the change of value using selector function.
                return (preact_1.h(rowSpanCell_1.RowSpanCell, { key: columnInfo.name, viewRow: viewRow, columnInfo: columnInfo, refreshRowHeight: autoRowHeight ? _this.updateRowHeightDebounced : null, rowIndex: rowIndex }));
            }))));
        };
        return BodyRowComp;
    }(preact_1.Component));
    exports.BodyRow = hoc_1.connect(function (_a, _b) {
        var rowCoords = _a.rowCoords, dimension = _a.dimension, renderState = _a.renderState, focus = _a.focus;
        var rowIndex = _b.rowIndex;
        return ({
            rowHeight: rowCoords.heights[rowIndex],
            autoRowHeight: dimension.autoRowHeight,
            cellBorderWidth: dimension.cellBorderWidth,
            hoveredRowKey: renderState.hoveredRowKey,
            focusedRowKey: focus.rowKey,
        });
    })(BodyRowComp);


    /***/ }),
    /* 97 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RowSpanCell = exports.RowSpanCellComp = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var hoc_1 = __webpack_require__(4);
    var bodyCell_1 = __webpack_require__(98);
    var RowSpanCellComp = /** @class */ (function (_super) {
        tslib_1.__extends(RowSpanCellComp, _super);
        function RowSpanCellComp() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        RowSpanCellComp.prototype.render = function () {
            var _a = this.props, columnInfo = _a.columnInfo, refreshRowHeight = _a.refreshRowHeight, rowSpan = _a.rowSpan, enableRowSpan = _a.enableRowSpan, viewRow = _a.viewRow, rowIndex = _a.rowIndex;
            var rowSpanAttr = null;
            if (enableRowSpan && rowSpan) {
                if (!rowSpan.mainRow) {
                    return null;
                }
                rowSpanAttr = { rowSpan: rowSpan.spanCount };
            }
            return (preact_1.h(bodyCell_1.BodyCell, { viewRow: viewRow, columnInfo: columnInfo, refreshRowHeight: refreshRowHeight, rowSpanAttr: rowSpanAttr, rowIndex: rowIndex }));
        };
        return RowSpanCellComp;
    }(preact_1.Component));
    exports.RowSpanCellComp = RowSpanCellComp;
    exports.RowSpanCell = hoc_1.connect(function (_a, _b) {
        var data = _a.data;
        var viewRow = _b.viewRow, columnInfo = _b.columnInfo;
        var sortState = data.sortState;
        var rowSpan = (viewRow.rowSpanMap && viewRow.rowSpanMap[columnInfo.name]) || null;
        var enableRowSpan = sortState.columns[0].columnName === 'sortKey';
        return { rowSpan: rowSpan, enableRowSpan: enableRowSpan };
    })(RowSpanCellComp);


    /***/ }),
    /* 98 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BodyCell = exports.BodyCellComp = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var treeCellContents_1 = __webpack_require__(99);
    var dom_1 = __webpack_require__(2);
    var hoc_1 = __webpack_require__(4);
    var instance_1 = __webpack_require__(7);
    var column_1 = __webpack_require__(10);
    var common_1 = __webpack_require__(0);
    var BodyCellComp = /** @class */ (function (_super) {
        tslib_1.__extends(BodyCellComp, _super);
        function BodyCellComp() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.handleMouseMove = function (ev) {
                var _a = dom_1.getCoordinateWithOffset(ev.pageX, ev.pageY), pageX = _a[0], pageY = _a[1];
                _this.props.dispatch('dragMoveRowHeader', { pageX: pageX, pageY: pageY });
            };
            _this.handleMouseDown = function (name, rowKey) {
                if (!column_1.isRowNumColumn(name)) {
                    return;
                }
                _this.props.dispatch('mouseDownRowHeader', rowKey);
                document.addEventListener('mousemove', _this.handleMouseMove);
                document.addEventListener('mouseup', _this.clearDocumentEvents);
                document.addEventListener('selectstart', _this.handleSelectStart);
            };
            _this.clearDocumentEvents = function () {
                _this.props.dispatch('dragEnd');
                dom_1.setCursorStyle('');
                document.removeEventListener('mousemove', _this.handleMouseMove);
                document.removeEventListener('mouseup', _this.clearDocumentEvents);
                document.removeEventListener('selectstart', _this.handleSelectStart);
            };
            _this.handleSelectStart = function (ev) {
                ev.preventDefault();
            };
            return _this;
        }
        BodyCellComp.prototype.componentDidMount = function () {
            var _a = this.props, grid = _a.grid, rowKey = _a.rowKey, renderData = _a.renderData, columnInfo = _a.columnInfo;
            // eslint-disable-next-line new-cap
            this.renderer = new columnInfo.renderer.type(tslib_1.__assign({ grid: grid,
                rowKey: rowKey,
                columnInfo: columnInfo }, renderData));
            var rendererEl = this.renderer.getElement();
            this.el.appendChild(rendererEl);
            if (this.renderer.mounted) {
                this.renderer.mounted(this.el);
            }
            this.calculateRowHeight(this.props);
        };
        BodyCellComp.prototype.shouldComponentUpdate = function (nextProps) {
            return !common_1.shallowEqual(this.props, nextProps);
        };
        BodyCellComp.prototype.componentWillReceiveProps = function (nextProps) {
            var viewRow = nextProps.viewRow, renderData = nextProps.renderData, columnInfo = nextProps.columnInfo, rowKey = nextProps.rowKey, grid = nextProps.grid, columnWidths = nextProps.columnWidths;
            var _a = this.props, prevViewRow = _a.viewRow, prevRenderData = _a.renderData, prevColumnWidth = _a.columnWidths;
            if ((prevRenderData !== renderData ||
                viewRow.uniqueKey !== prevViewRow.uniqueKey ||
                columnWidths !== prevColumnWidth) &&
                this.renderer &&
                common_1.isFunction(this.renderer.render)) {
                this.renderer.render(tslib_1.__assign({ grid: grid,
                    rowKey: rowKey,
                    columnInfo: columnInfo }, renderData));
                this.calculateRowHeight(nextProps);
            }
        };
        BodyCellComp.prototype.componentWillUnmount = function () {
            if (this.renderer && common_1.isFunction(this.renderer.beforeDestroy)) {
                this.renderer.beforeDestroy();
            }
        };
        BodyCellComp.prototype.calculateRowHeight = function (props) {
            var _this = this;
            var rowIndex = props.rowIndex, columnInfo = props.columnInfo, refreshRowHeight = props.refreshRowHeight, defaultRowHeight = props.defaultRowHeight, dispatch = props.dispatch, cellBorderWidth = props.cellBorderWidth;
            if (refreshRowHeight) {
                // In Preact, the componentDidMount is called before the DOM elements are actually mounted.
                // https://github.com/preactjs/preact/issues/648
                // Use setTimeout to wait until the DOM element is actually mounted
                //  - If the width of grid is 'auto' actual width of grid is calculated from the
                //    Container component using setTimeout(fn, 0)
                //  - Delay 16ms for defer the function call later than the Container component.
                window.setTimeout(function () {
                    var height = _this.renderer.getElement().clientHeight + cellBorderWidth;
                    dispatch('setCellHeight', columnInfo.name, rowIndex, height, defaultRowHeight);
                    refreshRowHeight(height);
                }, 16);
            }
        };
        BodyCellComp.prototype.render = function () {
            var _a;
            var _this = this;
            var _b = this.props, rowKey = _b.rowKey, _c = _b.renderData, disabled = _c.disabled, editable = _c.editable, invalidStates = _c.invalidStates, className = _c.className, _d = _b.columnInfo, align = _d.align, valign = _d.valign, name = _d.name, _e = _d.validation, validation = _e === void 0 ? {} : _e, treeInfo = _b.treeInfo, selectedRow = _b.selectedRow, rowSpanAttr = _b.rowSpanAttr;
            var style = {
                textAlign: align,
                verticalAlign: valign,
            };
            var attrs = (_a = {},
                _a[dom_1.dataAttr.ROW_KEY] = String(rowKey),
                _a[dom_1.dataAttr.COLUMN_NAME] = name,
                _a);
            var classNames = dom_1.cls('cell', 'cell-has-input', [editable, 'cell-editable'], [column_1.isRowHeader(name), 'cell-row-header'], [validation.required || false, 'cell-required'], [!!invalidStates.length, 'cell-invalid'], [disabled, 'cell-disabled'], [!!treeInfo, 'cell-has-tree'], [column_1.isRowHeader(name) && selectedRow, 'cell-selected']) + " " + className;
            return treeInfo ? (preact_1.h("td", tslib_1.__assign({}, attrs, { style: style, class: classNames }),
                preact_1.h("div", { class: dom_1.cls('tree-wrapper-relative') },
                    preact_1.h("div", { class: dom_1.cls('tree-wrapper-valign-center'), style: { paddingLeft: treeInfo.indentWidth }, ref: function (el) {
                            _this.el = el;
                        } },
                        preact_1.h(treeCellContents_1.TreeCellContents, { treeInfo: treeInfo, rowKey: rowKey }))))) : (preact_1.h("td", tslib_1.__assign({}, attrs, rowSpanAttr, { style: style, class: classNames, ref: function (el) {
                    _this.el = el;
                }, onMouseDown: function () { return _this.handleMouseDown(name, rowKey); } })));
        };
        return BodyCellComp;
    }(preact_1.Component));
    exports.BodyCellComp = BodyCellComp;
    exports.BodyCell = hoc_1.connect(function (_a, _b) {
        var id = _a.id, column = _a.column, selection = _a.selection, dimension = _a.dimension, columnCoords = _a.columnCoords;
        var viewRow = _b.viewRow, columnInfo = _b.columnInfo, rowIndex = _b.rowIndex;
        var rowKey = viewRow.rowKey, valueMap = viewRow.valueMap, treeInfo = viewRow.treeInfo;
        var treeColumnName = column.treeColumnName;
        var grid = instance_1.getInstance(id);
        var range = selection.range;
        var columnName = columnInfo.name;
        var defaultRowHeight = dimension.rowHeight, cellBorderWidth = dimension.cellBorderWidth;
        return tslib_1.__assign(tslib_1.__assign({ grid: grid,
            rowKey: rowKey,
            columnInfo: columnInfo, columnWidths: columnCoords.widths, defaultRowHeight: defaultRowHeight, renderData: (valueMap && valueMap[columnName]) || { invalidStates: [] } }, (columnName === treeColumnName ? { treeInfo: treeInfo } : null)), { selectedRow: range ? rowIndex >= range.row[0] && rowIndex <= range.row[1] : false, cellBorderWidth: cellBorderWidth });
    })(BodyCellComp);


    /***/ }),
    /* 99 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TreeCellContents = exports.TreeCellContentsComp = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var dom_1 = __webpack_require__(2);
    var hoc_1 = __webpack_require__(4);
    var constant_1 = __webpack_require__(14);
    var TreeCellContentsComp = /** @class */ (function (_super) {
        tslib_1.__extends(TreeCellContentsComp, _super);
        function TreeCellContentsComp() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.handleClick = function (ev) {
                ev.stopPropagation();
                var _a = _this.props, dispatch = _a.dispatch, rowKey = _a.rowKey;
                var target = ev.target;
                if (dom_1.findParent(target, 'tree-button-collapse')) {
                    dispatch('expandByRowKey', rowKey, false);
                }
                else if (dom_1.findParent(target, 'tree-button-expand')) {
                    dispatch('collapseByRowKey', rowKey, false);
                }
            };
            return _this;
        }
        TreeCellContentsComp.prototype.getIndentComponent = function (depth, leaf) {
            var indentItem = [];
            for (var i = 0, len = depth; i < len; i += 1) {
                indentItem.push(preact_1.h("span", { class: dom_1.cls('tree-depth') }, i === len - 1 && !leaf && (preact_1.h("button", { class: dom_1.cls('btn-tree'), style: { left: i * constant_1.TREE_INDENT_WIDTH }, onClick: this.handleClick },
                    preact_1.h("i", null)))));
            }
            return indentItem;
        };
        TreeCellContentsComp.prototype.render = function () {
            var _a = this.props, depth = _a.depth, indentWidth = _a.indentWidth, leaf = _a.leaf, expanded = _a.expanded, useIcon = _a.useIcon;
            return (preact_1.h("div", { class: dom_1.cls('tree-extra-content', [!leaf && expanded, 'tree-button-expand'], [!leaf && !expanded, 'tree-button-collapse']) },
                this.getIndentComponent(depth, leaf),
                useIcon && (preact_1.h("span", { class: dom_1.cls('tree-icon'), style: { left: indentWidth - constant_1.TREE_INDENT_WIDTH } },
                    preact_1.h("i", null)))));
        };
        return TreeCellContentsComp;
    }(preact_1.Component));
    exports.TreeCellContentsComp = TreeCellContentsComp;
    exports.TreeCellContents = hoc_1.connect(function (_a, _b) {
        var column = _a.column;
        var treeInfo = _b.treeInfo, rowKey = _b.rowKey;
        var _c = column.treeIcon, useIcon = _c === void 0 ? true : _c;
        var depth = treeInfo.depth, indentWidth = treeInfo.indentWidth, leaf = treeInfo.leaf, _d = treeInfo.expanded, expanded = _d === void 0 ? false : _d;
        return {
            rowKey: rowKey,
            depth: depth,
            indentWidth: indentWidth,
            leaf: leaf,
            expanded: expanded,
            useIcon: useIcon,
        };
    })(TreeCellContentsComp);


    /***/ }),
    /* 100 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BodyDummyRow = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var hoc_1 = __webpack_require__(4);
    var dom_1 = __webpack_require__(2);
    var column_1 = __webpack_require__(10);
    var BodyDummyRowComp = function (_a) {
        var columnNames = _a.columnNames, rowHeight = _a.rowHeight, index = _a.index;
        var isOddRow = index % 2 === 0;
        return (preact_1.h("tr", { style: { height: rowHeight }, class: dom_1.cls([isOddRow, 'row-odd'], [!isOddRow, 'row-even']) }, columnNames.map(function (name) {
            var _a;
            var attrs = (_a = {}, _a[dom_1.dataAttr.COLUMN_NAME] = name, _a);
            return (preact_1.h("td", tslib_1.__assign({}, attrs, { key: name + "-" + index, class: dom_1.cls('cell', 'cell-dummy', [column_1.isRowHeader(name), 'cell-row-header']) })));
        })));
    };
    exports.BodyDummyRow = hoc_1.connect(function (_a) {
        var rowHeight = _a.dimension.rowHeight;
        return ({
            rowHeight: rowHeight,
        });
    })(BodyDummyRowComp);


    /***/ }),
    /* 101 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FocusLayer = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var dom_1 = __webpack_require__(2);
    var hoc_1 = __webpack_require__(4);
    var FocusLayerComp = /** @class */ (function (_super) {
        tslib_1.__extends(FocusLayerComp, _super);
        function FocusLayerComp() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FocusLayerComp.prototype.render = function () {
            var _a = this.props, active = _a.active, cellPosRect = _a.cellPosRect, cellBorderWidth = _a.cellBorderWidth;
            if (cellPosRect === null) {
                return null;
            }
            var top = cellPosRect.top, left = cellPosRect.left, right = cellPosRect.right, bottom = cellPosRect.bottom;
            var height = bottom - top;
            var width = right - left;
            var leftStyle = {
                top: top,
                left: left,
                width: cellBorderWidth,
                height: height + cellBorderWidth,
            };
            var topStyle = {
                top: top === 0 ? cellBorderWidth : top,
                left: left,
                width: width + cellBorderWidth,
                height: cellBorderWidth,
            };
            var rightStyle = {
                top: top,
                left: left + width,
                width: cellBorderWidth,
                height: height + cellBorderWidth,
            };
            var bottomStyle = {
                top: top + height,
                left: left,
                width: width + cellBorderWidth,
                height: cellBorderWidth,
            };
            return (preact_1.h("div", { class: dom_1.cls('layer-focus', [!active, 'layer-focus-deactive']) },
                preact_1.h("div", { class: dom_1.cls('layer-focus-border'), style: leftStyle }),
                preact_1.h("div", { class: dom_1.cls('layer-focus-border'), style: topStyle }),
                preact_1.h("div", { class: dom_1.cls('layer-focus-border'), style: rightStyle }),
                preact_1.h("div", { class: dom_1.cls('layer-focus-border'), style: bottomStyle })));
        };
        return FocusLayerComp;
    }(preact_1.Component));
    exports.FocusLayer = hoc_1.connect(function (_a, _b) {
        var focus = _a.focus, dimension = _a.dimension;
        var side = _b.side;
        var cellPosRect = focus.cellPosRect, editingAddress = focus.editingAddress, navigating = focus.navigating;
        return {
            active: !!editingAddress || navigating,
            cellPosRect: side === focus.side ? cellPosRect : null,
            cellBorderWidth: dimension.cellBorderWidth,
        };
    })(FocusLayerComp);


    /***/ }),
    /* 102 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SelectionLayer = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var dom_1 = __webpack_require__(2);
    var hoc_1 = __webpack_require__(4);
    var SelectionLayerComp = /** @class */ (function (_super) {
        tslib_1.__extends(SelectionLayerComp, _super);
        function SelectionLayerComp() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.handleMouseMove = function (ev) {
                var dispatch = _this.props.dispatch;
                var pageX = ev.pageX, pageY = ev.pageY;
                dispatch('setHoveredRowKeyByPosition', { pageX: pageX, pageY: pageY });
            };
            return _this;
        }
        SelectionLayerComp.prototype.render = function () {
            var styles = this.props.styles;
            return (preact_1.h("div", { onMouseMove: this.handleMouseMove }, !!styles && preact_1.h("div", { class: dom_1.cls('layer-selection'), style: styles })));
        };
        return SelectionLayerComp;
    }(preact_1.Component));
    exports.SelectionLayer = hoc_1.connect(function (_a, _b) {
        var rangeAreaInfo = _a.selection.rangeAreaInfo;
        var side = _b.side;
        var styles = rangeAreaInfo && rangeAreaInfo[side];
        return { styles: styles };
    })(SelectionLayerComp);


    /***/ }),
    /* 103 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EditingLayer = exports.EditingLayerComp = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var hoc_1 = __webpack_require__(4);
    var dom_1 = __webpack_require__(2);
    var keyboard_1 = __webpack_require__(17);
    var common_1 = __webpack_require__(0);
    var instance_1 = __webpack_require__(7);
    var EditingLayerComp = /** @class */ (function (_super) {
        tslib_1.__extends(EditingLayerComp, _super);
        function EditingLayerComp() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.handleKeyDown = function (ev) {
                var keyName = keyboard_1.getKeyStrokeString(ev);
                switch (keyName) {
                    case 'enter':
                        _this.saveAndFinishEditing(true);
                        break;
                    case 'esc':
                        _this.cancelEditing();
                        break;
                    case 'tab':
                        _this.moveTabFocus(ev, 'nextCell');
                        break;
                    case 'shift-tab':
                        _this.moveTabFocus(ev, 'prevCell');
                        break;
                    // do nothing;
                }
            };
            return _this;
        }
        EditingLayerComp.prototype.moveTabFocus = function (ev, command) {
            var dispatch = this.props.dispatch;
            ev.preventDefault();
            dispatch('moveTabFocus', command);
            dispatch('setScrollToFocus');
        };
        EditingLayerComp.prototype.getEditingCellInfo = function () {
            var _a = this.props.editingAddress, rowKey = _a.rowKey, columnName = _a.columnName;
            var value = this.editor.getValue();
            return { rowKey: rowKey, columnName: columnName, value: value };
        };
        EditingLayerComp.prototype.cancelEditing = function () {
            var _a, _b;
            var _c = this.getEditingCellInfo(), rowKey = _c.rowKey, columnName = _c.columnName, value = _c.value;
            // eslint-disable-next-line no-unused-expressions
            (_b = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.beforeDestroy) === null || _b === void 0 ? void 0 : _b.call(_a);
            this.props.dispatch('finishEditing', rowKey, columnName, value, {
                save: false,
                triggeredByKey: true,
            });
        };
        EditingLayerComp.prototype.saveAndFinishEditing = function (triggeredByKey) {
            var _a, _b;
            if (triggeredByKey === void 0) { triggeredByKey = false; }
            var _c = this.props, dispatch = _c.dispatch, active = _c.active;
            if (this.editor && active) {
                var _d = this.getEditingCellInfo(), rowKey = _d.rowKey, columnName = _d.columnName, value = _d.value;
                dispatch('setValue', rowKey, columnName, value);
                // eslint-disable-next-line no-unused-expressions
                (_b = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.beforeDestroy) === null || _b === void 0 ? void 0 : _b.call(_a);
                dispatch('finishEditing', rowKey, columnName, value, { save: true, triggeredByKey: triggeredByKey });
            }
        };
        EditingLayerComp.prototype.createEditor = function () {
            var _a = this.props, allColumnMap = _a.allColumnMap, filteredViewData = _a.filteredViewData, editingAddress = _a.editingAddress, grid = _a.grid, cellPosRect = _a.cellPosRect;
            var _b = editingAddress, rowKey = _b.rowKey, columnName = _b.columnName;
            var _c = cellPosRect, right = _c.right, left = _c.left;
            var columnInfo = allColumnMap[columnName];
            var _d = common_1.findProp('rowKey', rowKey, filteredViewData).valueMap[columnName], value = _d.value, formattedValue = _d.formattedValue;
            var EditorClass = columnInfo.editor.type;
            var editorProps = {
                grid: grid,
                rowKey: rowKey,
                columnInfo: columnInfo,
                value: value,
                formattedValue: formattedValue,
                width: right - left,
                portalEditingKeydown: this.handleKeyDown,
            };
            var cellEditor = new EditorClass(editorProps);
            var editorEl = cellEditor.getElement();
            if (editorEl && this.contentEl) {
                this.contentEl.appendChild(editorEl);
                this.editor = cellEditor;
                if (cellEditor.mounted) {
                    // To access the actual mounted DOM elements
                    setTimeout(function () {
                        cellEditor.mounted();
                    });
                }
            }
        };
        EditingLayerComp.prototype.componentDidUpdate = function (prevProps) {
            var _a;
            if (!prevProps.active &&
                this.props.active &&
                ((_a = this.props.editingAddress) === null || _a === void 0 ? void 0 : _a.columnName) === this.props.focusedColumnName) {
                this.createEditor();
            }
        };
        EditingLayerComp.prototype.componentWillReceiveProps = function (nextProps) {
            var _a = this.props, prevFocusedColumnName = _a.focusedColumnName, prevFocusedRowKey = _a.focusedRowKey, prevActive = _a.active;
            var focusedColumnName = nextProps.focusedColumnName, focusedRowKey = nextProps.focusedRowKey, active = nextProps.active, forcedDestroyEditing = nextProps.forcedDestroyEditing;
            if ((prevActive && !active && forcedDestroyEditing) ||
                (prevActive &&
                    (focusedColumnName !== prevFocusedColumnName || focusedRowKey !== prevFocusedRowKey))) {
                this.saveAndFinishEditing();
            }
        };
        EditingLayerComp.prototype.render = function (_a) {
            var _this = this;
            var active = _a.active, cellPosRect = _a.cellPosRect, cellBorderWidth = _a.cellBorderWidth;
            if (!active) {
                return null;
            }
            var _b = cellPosRect, top = _b.top, left = _b.left, right = _b.right, bottom = _b.bottom;
            var height = bottom - top;
            var width = right - left;
            var editorStyles = {
                top: top ? top : cellBorderWidth,
                left: left,
                width: width + cellBorderWidth,
                height: top ? height + cellBorderWidth : height,
                lineHeight: top ? height - cellBorderWidth + "px" : height - cellBorderWidth * 2 + "px",
            };
            return (preact_1.h("div", { style: editorStyles, className: dom_1.cls('layer-editing', 'cell-content', 'cell-content-editor'), onKeyDown: this.handleKeyDown, ref: function (el) {
                    _this.contentEl = el;
                } }));
        };
        return EditingLayerComp;
    }(preact_1.Component));
    exports.EditingLayerComp = EditingLayerComp;
    exports.EditingLayer = hoc_1.connect(function (store, _a) {
        var side = _a.side;
        var data = store.data, column = store.column, id = store.id, focus = store.focus, dimension = store.dimension;
        var editingAddress = focus.editingAddress, focusSide = focus.side, focusedRowKey = focus.rowKey, focusedColumnName = focus.columnName, forcedDestroyEditing = focus.forcedDestroyEditing, cellPosRect = focus.cellPosRect;
        return {
            grid: instance_1.getInstance(id),
            active: side === focusSide && !common_1.isNull(editingAddress),
            focusedRowKey: focusedRowKey,
            focusedColumnName: focusedColumnName,
            forcedDestroyEditing: forcedDestroyEditing,
            cellPosRect: cellPosRect,
            cellBorderWidth: dimension.cellBorderWidth,
            editingAddress: editingAddress,
            filteredViewData: data.filteredViewData,
            allColumnMap: column.allColumnMap,
        };
    }, true)(EditingLayerComp);


    /***/ }),
    /* 104 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SummaryBodyRow = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var summaryBodyCell_1 = __webpack_require__(105);
    var common_1 = __webpack_require__(0);
    var SummaryBodyRow = /** @class */ (function (_super) {
        tslib_1.__extends(SummaryBodyRow, _super);
        function SummaryBodyRow() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SummaryBodyRow.prototype.shouldComponentUpdate = function (nextProps) {
            return !common_1.shallowEqual(nextProps, this.props);
        };
        SummaryBodyRow.prototype.render = function (_a) {
            var columns = _a.columns;
            var columnNames = columns.map(function (_a) {
                var name = _a.name;
                return name;
            });
            return (preact_1.h("tbody", null,
                preact_1.h("tr", null, columnNames.map(function (name) { return (preact_1.h(summaryBodyCell_1.SummaryBodyCell, { key: name, columnName: name })); }))));
        };
        return SummaryBodyRow;
    }(preact_1.Component));
    exports.SummaryBodyRow = SummaryBodyRow;


    /***/ }),
    /* 105 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SummaryBodyCell = exports.SummaryBodyCellComp = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var dom_1 = __webpack_require__(2);
    var common_1 = __webpack_require__(0);
    var hoc_1 = __webpack_require__(4);
    var column_1 = __webpack_require__(10);
    var SummaryBodyCellComp = /** @class */ (function (_super) {
        tslib_1.__extends(SummaryBodyCellComp, _super);
        function SummaryBodyCellComp() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.getTemplate = function () {
                var _a = _this.props, content = _a.content, summaryValue = _a.summaryValue, columnName = _a.columnName;
                if (!content || column_1.isRowHeader(columnName)) {
                    return '';
                }
                var template = content.template;
                return typeof template === 'string' ? template : template(summaryValue);
            };
            return _this;
        }
        SummaryBodyCellComp.prototype.shouldComponentUpdate = function (nextProps) {
            return !common_1.shallowEqual(nextProps, this.props);
        };
        SummaryBodyCellComp.prototype.render = function () {
            var _a;
            var columnName = this.props.columnName;
            var attrs = (_a = {}, _a[dom_1.dataAttr.COLUMN_NAME] = columnName, _a);
            var template = this.getTemplate();
            return (preact_1.h("td", tslib_1.__assign({ class: dom_1.cls('cell', 'cell-summary'), dangerouslySetInnerHTML: { __html: template } }, attrs)));
        };
        return SummaryBodyCellComp;
    }(preact_1.Component));
    exports.SummaryBodyCellComp = SummaryBodyCellComp;
    exports.SummaryBodyCell = hoc_1.connect(function (_a, _b) {
        var summary = _a.summary;
        var columnName = _b.columnName;
        var summaryColumnContents = summary.summaryColumnContents, summaryValues = summary.summaryValues;
        var content = summaryColumnContents[columnName];
        var summaryValue = summaryValues[columnName];
        return { content: content, summaryValue: summaryValue };
    })(SummaryBodyCellComp);


    /***/ }),
    /* 106 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RightSide = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var dom_1 = __webpack_require__(2);
    var bodyArea_1 = __webpack_require__(49);
    var headerArea_1 = __webpack_require__(47);
    var summaryArea_1 = __webpack_require__(50);
    var hoc_1 = __webpack_require__(4);
    var RightSideComp = /** @class */ (function (_super) {
        tslib_1.__extends(RightSideComp, _super);
        function RightSideComp() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        RightSideComp.prototype.renderScrollbarYInnerBorder = function () {
            var _a = this.props, cornerTopHeight = _a.cornerTopHeight, bodyHeight = _a.bodyHeight, scrollXHeight = _a.scrollXHeight;
            var style = {
                top: cornerTopHeight,
                height: bodyHeight - scrollXHeight,
            };
            return preact_1.h("div", { class: dom_1.cls('scrollbar-y-inner-border'), style: style });
        };
        RightSideComp.prototype.renderScrollbarRightTop = function () {
            var style = { height: this.props.cornerTopHeight };
            return preact_1.h("div", { class: dom_1.cls('scrollbar-right-top'), style: style });
        };
        RightSideComp.prototype.renderScrollbarYOuterBorder = function () {
            return preact_1.h("div", { class: dom_1.cls('scrollbar-y-outer-border') });
        };
        RightSideComp.prototype.renderScrollbarRightBottom = function () {
            var style = { height: this.props.cornerBottomHeight };
            return preact_1.h("div", { class: dom_1.cls('scrollbar-right-bottom'), style: style });
        };
        RightSideComp.prototype.renderScrollbarFrozenBorder = function () {
            var _a = this.props, scrollXHeight = _a.scrollXHeight, frozenBorderWidth = _a.frozenBorderWidth, cellBorderWidth = _a.cellBorderWidth;
            var style = {
                height: scrollXHeight,
                width: frozenBorderWidth,
                marginLeft: frozenBorderWidth ? -(frozenBorderWidth + cellBorderWidth) : 0,
            };
            return preact_1.h("div", { class: dom_1.cls('scrollbar-frozen-border'), style: style });
        };
        RightSideComp.prototype.renderFrozenBorder = function () {
            var frozenBorderWidth = this.props.frozenBorderWidth;
            var style = {
                marginLeft: -frozenBorderWidth,
                width: frozenBorderWidth,
            };
            return preact_1.h("div", { class: dom_1.cls('frozen-border'), style: style });
        };
        RightSideComp.prototype.render = function () {
            var _a = this.props, marginLeft = _a.marginLeft, width = _a.width, summaryPosition = _a.summaryPosition, scrollY = _a.scrollY, scrollX = _a.scrollX, frozenBorderWidth = _a.frozenBorderWidth;
            var style = {
                display: 'block',
                marginLeft: marginLeft,
                width: width,
            };
            return (preact_1.h("div", { class: dom_1.cls('rside-area'), style: style },
                preact_1.h(headerArea_1.HeaderArea, { side: "R" }),
                summaryPosition === 'top' && preact_1.h(summaryArea_1.SummaryArea, { side: "R" }),
                preact_1.h(bodyArea_1.BodyArea, { side: "R" }),
                summaryPosition === 'bottom' && preact_1.h(summaryArea_1.SummaryArea, { side: "R" }),
                scrollY && this.renderScrollbarYInnerBorder(),
                scrollY && this.renderScrollbarYOuterBorder(),
                scrollY && this.renderScrollbarRightTop(),
                scrollX && this.renderScrollbarFrozenBorder(),
                (scrollX || scrollY) && this.renderScrollbarRightBottom(),
                !!frozenBorderWidth && this.renderFrozenBorder()));
        };
        return RightSideComp;
    }(preact_1.Component));
    exports.RightSide = hoc_1.connect(function (_a) {
        var dimension = _a.dimension, columnCoords = _a.columnCoords;
        var scrollbarWidth = dimension.scrollbarWidth, scrollX = dimension.scrollX, scrollY = dimension.scrollY, summaryHeight = dimension.summaryHeight, headerHeight = dimension.headerHeight, cellBorderWidth = dimension.cellBorderWidth, tableBorderWidth = dimension.tableBorderWidth, bodyHeight = dimension.bodyHeight, summaryPosition = dimension.summaryPosition, frozenBorderWidth = dimension.frozenBorderWidth;
        var cornerTopHeight = headerHeight;
        var cornerBottomHeight = scrollX ? scrollbarWidth : 0;
        if (scrollY && summaryHeight) {
            if (summaryPosition === 'top') {
                cornerTopHeight += summaryHeight + tableBorderWidth;
            }
            else {
                cornerBottomHeight += summaryHeight;
            }
        }
        var scrollXHeight = scrollX ? scrollbarWidth : 0;
        var width = columnCoords.areaWidth.R;
        var marginLeft = columnCoords.areaWidth.L + frozenBorderWidth;
        if (marginLeft && !frozenBorderWidth) {
            marginLeft -= cellBorderWidth;
            width += cellBorderWidth;
        }
        return {
            width: width,
            marginLeft: marginLeft,
            cornerTopHeight: cornerTopHeight,
            cornerBottomHeight: cornerBottomHeight,
            scrollXHeight: scrollXHeight,
            bodyHeight: bodyHeight,
            cellBorderWidth: cellBorderWidth,
            frozenBorderWidth: frozenBorderWidth,
            summaryPosition: summaryPosition,
            scrollX: scrollX,
            scrollY: scrollY,
        };
    })(RightSideComp);


    /***/ }),
    /* 107 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StateLayer = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var dom_1 = __webpack_require__(2);
    var hoc_1 = __webpack_require__(4);
    var i18n_1 = tslib_1.__importDefault(__webpack_require__(19));
    var StateLayerComp = /** @class */ (function (_super) {
        tslib_1.__extends(StateLayerComp, _super);
        function StateLayerComp() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        StateLayerComp.prototype.render = function (_a) {
            var loadingState = _a.loadingState, top = _a.top, height = _a.height, left = _a.left, right = _a.right;
            var display = loadingState === 'DONE' ? 'none' : 'block';
            var layerStyle = { display: display, top: top, height: height, left: left, right: right };
            var message = null;
            if (loadingState === 'EMPTY') {
                message = i18n_1.default.get('display.noData');
            }
            else if (loadingState === 'LOADING') {
                message = i18n_1.default.get('display.loadingData');
            }
            return (preact_1.h("div", { class: dom_1.cls('layer-state'), style: layerStyle },
                preact_1.h("div", { class: dom_1.cls('layer-state-content') },
                    preact_1.h("p", null, message),
                    loadingState === 'LOADING' && preact_1.h("div", { class: dom_1.cls('layer-state-loading') }))));
        };
        return StateLayerComp;
    }(preact_1.Component));
    exports.StateLayer = hoc_1.connect(function (_a) {
        var data = _a.data, dimension = _a.dimension;
        var headerHeight = dimension.headerHeight, bodyHeight = dimension.bodyHeight, cellBorderWidth = dimension.cellBorderWidth, tableBorderWidth = dimension.tableBorderWidth, scrollXHeight = dimension.scrollXHeight, scrollYWidth = dimension.scrollYWidth;
        return {
            loadingState: data.loadingState,
            top: headerHeight + cellBorderWidth,
            height: bodyHeight - scrollXHeight - tableBorderWidth,
            left: 0,
            right: scrollYWidth + tableBorderWidth,
        };
    })(StateLayerComp);


    /***/ }),
    /* 108 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FilterLayer = exports.FilterLayerComp = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var hoc_1 = __webpack_require__(4);
    var filterLayerInner_1 = __webpack_require__(109);
    var FilterLayerComp = /** @class */ (function (_super) {
        tslib_1.__extends(FilterLayerComp, _super);
        function FilterLayerComp() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FilterLayerComp.prototype.render = function (_a) {
            var activeColumnAddress = _a.activeColumnAddress, activeFilterState = _a.activeFilterState;
            return (activeColumnAddress &&
                activeFilterState && (preact_1.h(filterLayerInner_1.FilterLayerInner, { columnAddress: activeColumnAddress, filterState: activeFilterState })));
        };
        return FilterLayerComp;
    }(preact_1.Component));
    exports.FilterLayerComp = FilterLayerComp;
    exports.FilterLayer = hoc_1.connect(function (_a) {
        var filterLayerState = _a.filterLayerState;
        var activeColumnAddress = filterLayerState.activeColumnAddress, activeFilterState = filterLayerState.activeFilterState;
        return { activeColumnAddress: activeColumnAddress, activeFilterState: activeFilterState };
    })(FilterLayerComp);


    /***/ }),
    /* 109 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FilterLayerInner = exports.FilterLayerInnerComp = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var hoc_1 = __webpack_require__(4);
    var dom_1 = __webpack_require__(2);
    var textFilter_1 = __webpack_require__(110);
    var datePickerFilter_1 = __webpack_require__(111);
    var filterOperator_1 = __webpack_require__(112);
    var selectFilter_1 = __webpack_require__(113);
    var common_1 = __webpack_require__(0);
    var i18n_1 = tslib_1.__importDefault(__webpack_require__(19));
    var FilterLayerInnerComp = /** @class */ (function (_super) {
        tslib_1.__extends(FilterLayerInnerComp, _super);
        function FilterLayerInnerComp() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.state = { left: _this.props.columnAddress.left };
            _this.renderFilter = function (index) {
                var _a = _this.props, columnAddress = _a.columnAddress, filterState = _a.filterState, columnInfo = _a.columnInfo;
                var type = columnInfo.filter.type;
                switch (type) {
                    case 'text':
                    case 'number':
                        return (preact_1.h(textFilter_1.TextFilter, { columnAddress: columnAddress, filterState: filterState, filterIndex: index }));
                    case 'date':
                        return (preact_1.h(datePickerFilter_1.DatePickerFilter, { columnAddress: columnAddress, filterState: filterState, filterIndex: index }));
                    case 'select':
                        return preact_1.h(selectFilter_1.SelectFilter, { columnAddress: columnAddress, filterState: filterState });
                    default:
                        return null;
                }
            };
            return _this;
        }
        FilterLayerInnerComp.prototype.componentDidMount = function () {
            var left = this.el.getBoundingClientRect().left;
            var clientWidth = this.el.clientWidth;
            var innerWidth = window.innerWidth;
            if (innerWidth < left + clientWidth) {
                var orgLeft = this.state.left;
                this.setState({ left: orgLeft - (left + clientWidth - innerWidth) });
            }
        };
        FilterLayerInnerComp.prototype.render = function () {
            var _this = this;
            var _a = this.props, columnInfo = _a.columnInfo, renderSecondFilter = _a.renderSecondFilter, dispatch = _a.dispatch, currentColumnActive = _a.currentColumnActive, filterState = _a.filterState;
            var _b = columnInfo.filter, showApplyBtn = _b.showApplyBtn, showClearBtn = _b.showClearBtn;
            var left = this.state.left;
            return (preact_1.h("div", { className: dom_1.cls('filter-container'), style: { left: left }, ref: function (el) {
                    _this.el = el;
                } },
                preact_1.h("div", null,
                    preact_1.h("span", { className: dom_1.cls('btn-filter', [currentColumnActive, 'btn-filter-active'], 'filter-icon') }),
                    preact_1.h("a", { className: dom_1.cls('btn-close'), onClick: function () {
                            dispatch('setActiveColumnAddress', null);
                        } })),
                this.renderFilter(0),
                renderSecondFilter && preact_1.h(filterOperator_1.FilterOperator, { filterState: filterState }),
                renderSecondFilter && this.renderFilter(1),
                preact_1.h("div", { className: dom_1.cls('filter-btn-container') },
                    showClearBtn && (preact_1.h("button", { className: dom_1.cls('filter-btn', 'filter-btn-clear'), onClick: function () {
                            dispatch('clearActiveFilterState');
                        } }, i18n_1.default.get('filter.clear'))),
                    showApplyBtn && (preact_1.h("button", { className: dom_1.cls('filter-btn', 'filter-btn-apply'), onClick: function () {
                            dispatch('applyActiveFilterState');
                        } }, i18n_1.default.get('filter.apply'))))));
        };
        return FilterLayerInnerComp;
    }(preact_1.Component));
    exports.FilterLayerInnerComp = FilterLayerInnerComp;
    exports.FilterLayerInner = hoc_1.connect(function (store, _a) {
        var columnAddress = _a.columnAddress, filterState = _a.filterState;
        var data = store.data, column = store.column;
        var filters = data.filters;
        var allColumnMap = column.allColumnMap;
        var currentColumnActive = !!filters && common_1.some(function (item) { return item.columnName === columnAddress.name; }, filters);
        var renderSecondFilter = !!(filterState.type !== 'select' &&
            filterState.operator &&
            filterState.state[0] &&
            filterState.state[0].value.length);
        return {
            columnInfo: allColumnMap[columnAddress.name],
            columnAddress: columnAddress,
            filters: filters,
            renderSecondFilter: renderSecondFilter,
            currentColumnActive: currentColumnActive,
        };
    })(FilterLayerInnerComp);


    /***/ }),
    /* 110 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TextFilter = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var hoc_1 = __webpack_require__(4);
    var dom_1 = __webpack_require__(2);
    var filter_1 = __webpack_require__(29);
    var common_1 = __webpack_require__(0);
    var keyboard_1 = __webpack_require__(17);
    var constant_1 = __webpack_require__(14);
    var TextFilterComp = /** @class */ (function (_super) {
        tslib_1.__extends(TextFilterComp, _super);
        function TextFilterComp() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.getPreviousValue = function () {
                var _a = _this.props, filterIndex = _a.filterIndex, filterState = _a.filterState;
                var state = filterState.state;
                var code = 'eq';
                var value = '';
                if (state.length && state[filterIndex]) {
                    var _b = state[filterIndex], prevCode = _b.code, prevValue = _b.value;
                    code = prevCode;
                    value = String(prevValue);
                }
                return { value: value, code: code };
            };
            _this.handleChange = common_1.debounce(function (ev) {
                var dispatch = _this.props.dispatch;
                var keyCode = ev.keyCode;
                if (keyboard_1.isNonPrintableKey(keyCode)) {
                    return;
                }
                var keyName = keyboard_1.keyNameMap[keyCode];
                if (keyName === 'enter') {
                    dispatch('applyActiveFilterState');
                }
                else {
                    var filterIndex = _this.props.filterIndex;
                    var value = _this.inputEl.value;
                    var code = _this.selectEl.value;
                    dispatch('setActiveFilterState', { value: value, code: code }, filterIndex);
                }
            }, constant_1.FILTER_DEBOUNCE_TIME);
            return _this;
        }
        TextFilterComp.prototype.render = function () {
            var _this = this;
            var columnInfo = this.props.columnInfo;
            var _a = this.getPreviousValue(), code = _a.code, value = _a.value;
            var filterSelectOptions = filter_1.createFilterSelectOption();
            var selectOption = filterSelectOptions[columnInfo.filter.type];
            return (preact_1.h("div", null,
                preact_1.h("div", { className: dom_1.cls('filter-dropdown') },
                    preact_1.h("select", { ref: function (ref) {
                            _this.selectEl = ref;
                        }, onChange: this.handleChange }, Object.keys(selectOption).map(function (key) {
                        return (preact_1.h("option", { value: key, key: key, selected: code === key }, selectOption[key]));
                    }))),
                preact_1.h("input", { ref: function (ref) {
                        _this.inputEl = ref;
                    }, type: "text", className: dom_1.cls('filter-input'), onInput: this.handleChange, value: value })));
        };
        return TextFilterComp;
    }(preact_1.Component));
    exports.TextFilter = hoc_1.connect(function (store, _a) {
        var filterIndex = _a.filterIndex, columnAddress = _a.columnAddress, filterState = _a.filterState;
        var column = store.column, data = store.data;
        var allColumnMap = column.allColumnMap;
        var filters = data.filters;
        return {
            columnInfo: allColumnMap[columnAddress.name],
            columnAddress: columnAddress,
            filterIndex: filterIndex,
            filters: filters,
            filterState: filterState,
        };
    })(TextFilterComp);


    /***/ }),
    /* 111 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DatePickerFilter = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var tui_date_picker_1 = tslib_1.__importDefault(__webpack_require__(40));
    var hoc_1 = __webpack_require__(4);
    var instance_1 = __webpack_require__(7);
    var dom_1 = __webpack_require__(2);
    var filter_1 = __webpack_require__(29);
    var common_1 = __webpack_require__(0);
    var keyboard_1 = __webpack_require__(17);
    var constant_1 = __webpack_require__(14);
    var DatePickerFilterComp = /** @class */ (function (_super) {
        tslib_1.__extends(DatePickerFilterComp, _super);
        function DatePickerFilterComp() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.createDatePicker = function () {
                var _a = _this.props, columnInfo = _a.columnInfo, grid = _a.grid;
                var _b = columnInfo.filter.options, options = _b === void 0 ? {} : _b;
                var usageStatistics = grid.usageStatistics;
                var value = _this.getPreviousValue().value;
                var date;
                if (!options.format) {
                    options.format = 'yyyy/MM/dd';
                }
                if (common_1.isString(value) && value.length) {
                    date = new Date(value);
                }
                var defaultOptions = {
                    date: date,
                    type: 'date',
                    input: {
                        element: _this.inputEl,
                        format: options.format,
                    },
                    usageStatistics: usageStatistics,
                };
                _this.datePickerEl = new tui_date_picker_1.default(_this.calendarWrapper, common_1.deepMergedCopy(defaultOptions, options || {}));
                _this.datePickerEl.on('change', _this.handleChange);
            };
            _this.handleKeyUp = common_1.debounce(function (ev) {
                var keyCode = ev.keyCode;
                var keyName = keyboard_1.keyNameMap[keyCode];
                var dispatch = _this.props.dispatch;
                if (keyboard_1.isNonPrintableKey(keyCode)) {
                    return;
                }
                if (keyName === 'enter') {
                    dispatch('applyActiveFilterState');
                }
                else {
                    _this.handleChange();
                }
            }, constant_1.FILTER_DEBOUNCE_TIME);
            _this.handleChange = function () {
                var dispatch = _this.props.dispatch;
                var filterIndex = _this.props.filterIndex;
                var value = _this.inputEl.value;
                var code = _this.selectEl.value;
                dispatch('setActiveFilterState', { value: value, code: code }, filterIndex);
            };
            _this.getPreviousValue = function () {
                var _a = _this.props, filterIndex = _a.filterIndex, filterState = _a.filterState;
                var state = filterState.state;
                var code = 'eq';
                var value = '';
                if (state.length && state[filterIndex]) {
                    var _b = state[filterIndex], prevCode = _b.code, prevValue = _b.value;
                    code = prevCode;
                    value = String(prevValue);
                }
                return { value: value, code: code };
            };
            _this.openDatePicker = function () {
                _this.datePickerEl.open();
            };
            return _this;
        }
        DatePickerFilterComp.prototype.componentDidMount = function () {
            this.createDatePicker();
        };
        DatePickerFilterComp.prototype.componentWillUnmount = function () {
            this.datePickerEl.destroy();
        };
        DatePickerFilterComp.prototype.render = function () {
            var _this = this;
            var columnInfo = this.props.columnInfo;
            var options = columnInfo.filter.options;
            var showIcon = !(options && options.showIcon === false);
            var filterSelectOptions = filter_1.createFilterSelectOption();
            var selectOption = filterSelectOptions.date;
            var _a = this.getPreviousValue(), value = _a.value, code = _a.code;
            return (preact_1.h("div", null,
                preact_1.h("div", { className: dom_1.cls('filter-dropdown') },
                    preact_1.h("select", { ref: function (ref) {
                            _this.selectEl = ref;
                        }, onChange: this.handleChange }, Object.keys(selectOption).map(function (key) {
                        return (preact_1.h("option", { value: key, key: key, selected: code === key }, selectOption[key]));
                    }))),
                preact_1.h("div", { className: dom_1.cls('datepicker-input-container') },
                    preact_1.h("input", { ref: function (ref) {
                            _this.inputEl = ref;
                        }, type: "text", className: dom_1.cls('filter-input', [showIcon, 'datepicker-input']), onKeyUp: this.handleKeyUp, value: value }),
                    showIcon && preact_1.h("i", { className: dom_1.cls('date-icon'), onClick: this.openDatePicker })),
                preact_1.h("div", { ref: function (ref) {
                        _this.calendarWrapper = ref;
                    }, style: { marginTop: '-4px' } })));
        };
        return DatePickerFilterComp;
    }(preact_1.Component));
    exports.DatePickerFilter = hoc_1.connect(function (store, _a) {
        var filterIndex = _a.filterIndex, columnAddress = _a.columnAddress, filterState = _a.filterState;
        var column = store.column, id = store.id, data = store.data;
        var allColumnMap = column.allColumnMap;
        var filters = data.filters;
        return {
            grid: instance_1.getInstance(id),
            columnInfo: allColumnMap[columnAddress.name],
            columnAddress: columnAddress,
            filterIndex: filterIndex,
            filters: filters,
            filterState: filterState,
        };
    })(DatePickerFilterComp);


    /***/ }),
    /* 112 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FilterOperator = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var hoc_1 = __webpack_require__(4);
    var dom_1 = __webpack_require__(2);
    var FilterOperatorComp = /** @class */ (function (_super) {
        tslib_1.__extends(FilterOperatorComp, _super);
        function FilterOperatorComp() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.handleChangeOperator = function (ev) {
                var value = ev.target.value;
                _this.props.dispatch('setActiveFilterOperator', value);
            };
            return _this;
        }
        FilterOperatorComp.prototype.render = function () {
            var _this = this;
            var operator = this.props.operator;
            return (preact_1.h("div", { className: dom_1.cls('filter-comparator-container') }, ['AND', 'OR'].map(function (operatorType) {
                var checked = operator === operatorType;
                return (preact_1.h("div", { key: operatorType, className: dom_1.cls('filter-comparator', [checked, 'filter-comparator-checked']) },
                    preact_1.h("label", null,
                        preact_1.h("input", { type: "radio", name: "filterOperator", value: operatorType, checked: checked, onChange: _this.handleChangeOperator }),
                        preact_1.h("span", null, operatorType))));
            })));
        };
        return FilterOperatorComp;
    }(preact_1.Component));
    exports.FilterOperator = hoc_1.connect(function (_, _a) {
        var filterState = _a.filterState;
        return ({
            operator: filterState.operator || 'AND',
        });
    })(FilterOperatorComp);


    /***/ }),
    /* 113 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SelectFilter = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var hoc_1 = __webpack_require__(4);
    var instance_1 = __webpack_require__(7);
    var dom_1 = __webpack_require__(2);
    var common_1 = __webpack_require__(0);
    var data_1 = __webpack_require__(6);
    var constant_1 = __webpack_require__(14);
    var i18n_1 = tslib_1.__importDefault(__webpack_require__(19));
    var SelectFilterComp = /** @class */ (function (_super) {
        tslib_1.__extends(SelectFilterComp, _super);
        function SelectFilterComp() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.state = {
                searchInput: '',
            };
            _this.handleChange = common_1.debounce(function (ev, value) {
                var dispatch = _this.props.dispatch;
                var checked = ev.target.checked;
                dispatch('setActiveSelectFilterState', value, checked);
            }, constant_1.FILTER_DEBOUNCE_TIME);
            _this.toggleAllColumnCheckbox = common_1.debounce(function (ev) {
                var checked = ev.target.checked;
                _this.props.dispatch('toggleSelectAllCheckbox', checked);
            }, constant_1.FILTER_DEBOUNCE_TIME);
            _this.searchColumnData = common_1.debounce(function (ev) {
                var value = ev.target.value;
                _this.setState({ searchInput: value });
            }, constant_1.FILTER_DEBOUNCE_TIME);
            return _this;
        }
        SelectFilterComp.prototype.render = function () {
            var _this = this;
            var _a = this.props, columnData = _a.columnData, isAllSelected = _a.isAllSelected;
            var searchInput = this.state.searchInput;
            var data = searchInput.length
                ? columnData.filter(function (item) { return String(item.value).indexOf(searchInput) !== -1; })
                : columnData;
            return (preact_1.h("div", { className: dom_1.cls('filter-list-container') },
                preact_1.h("input", { type: "text", className: dom_1.cls('filter-input'), placeholder: "Search...", onKeyUp: this.searchColumnData, value: searchInput ? String(searchInput) : '' }),
                preact_1.h("li", { className: dom_1.cls('filter-list-item', [isAllSelected, 'filter-list-item-checked']) },
                    preact_1.h("label", null,
                        preact_1.h("input", { type: "checkbox", onChange: this.toggleAllColumnCheckbox, checked: isAllSelected }),
                        preact_1.h("span", null, i18n_1.default.get('filter.selectAll')))),
                preact_1.h("ul", { className: dom_1.cls('filter-list') }, data.map(function (item) {
                    var value = item.value, text = item.text, checked = item.checked;
                    return (preact_1.h("li", { className: dom_1.cls('filter-list-item', [checked, 'filter-list-item-checked']), key: text },
                        preact_1.h("label", null,
                            preact_1.h("input", { type: "checkbox", checked: checked, onChange: function (ev) { return _this.handleChange(ev, value); } }),
                            preact_1.h("span", null, text))));
                }))));
        };
        return SelectFilterComp;
    }(preact_1.Component));
    exports.SelectFilter = hoc_1.connect(function (store, _a) {
        var columnAddress = _a.columnAddress, filterState = _a.filterState;
        var column = store.column, id = store.id, data = store.data;
        var filters = data.filters, rawData = data.rawData;
        var allColumnMap = column.allColumnMap;
        var state = filterState.state;
        var columnName = columnAddress.name;
        var uniqueColumnData = data_1.getUniqColumnData(rawData, column, columnName);
        var columnData = uniqueColumnData
            .filter(function (value) { return value; })
            .map(function (value) { return ({
            value: value,
            text: String(value),
            checked: common_1.some(function (item) { return value === item.value; }, state),
        }); });
        var isExistEmptyValue = uniqueColumnData.some(function (value) { return common_1.isBlank(value); });
        if (isExistEmptyValue) {
            columnData.push({
                value: '',
                text: i18n_1.default.get('filter.emptyValue'),
                checked: common_1.some(function (_a) {
                    var value = _a.value;
                    return common_1.isBlank(value);
                }, state),
            });
        }
        return {
            grid: instance_1.getInstance(id),
            columnData: columnData,
            columnInfo: allColumnMap[columnName],
            columnAddress: columnAddress,
            filters: filters,
            isAllSelected: state.length === uniqueColumnData.length,
        };
    })(SelectFilterComp);


    /***/ }),
    /* 114 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContextMenuItem = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var hoc_1 = __webpack_require__(4);
    var common_1 = __webpack_require__(0);
    var contextMenu_1 = __webpack_require__(51);
    var ContextMenuItemComp = /** @class */ (function (_super) {
        tslib_1.__extends(ContextMenuItemComp, _super);
        function ContextMenuItemComp() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.showSubMenu = function (ev) {
                var _a;
                var menuItem = _this.props.menuItem;
                if ((_a = menuItem.subMenu) === null || _a === void 0 ? void 0 : _a.length) {
                    var offsetWidth = ev.target.offsetWidth;
                    var pos = { top: -6, left: offsetWidth };
                    var subMenuInfo = { menuItems: menuItem.subMenu, pos: pos };
                    _this.setState({ subMenuInfo: subMenuInfo });
                }
            };
            _this.hideSubMenu = function () {
                _this.setState({ subMenuInfo: null });
            };
            _this.execAction = function (ev) {
                var _a = _this.props, menuItem = _a.menuItem, dispatch = _a.dispatch;
                var action = menuItem.action;
                if (common_1.isString(action)) {
                    _this.props.dispatch(action);
                }
                else if (action) {
                    action();
                }
                ev.stopPropagation();
                dispatch('hideContextMenu');
            };
            return _this;
        }
        ContextMenuItemComp.prototype.createClassNames = function () {
            var _a = this.props.menuItem, subMenu = _a.subMenu, disabled = _a.disabled, _b = _a.classNames, classNames = _b === void 0 ? [] : _b;
            var classList = classNames.concat('menu-item');
            if (subMenu) {
                classList.push('has-submenu');
            }
            if (disabled) {
                classList.push('disabled');
            }
            return classList.join(' ');
        };
        ContextMenuItemComp.prototype.render = function (_a) {
            var menuItem = _a.menuItem;
            var name = menuItem.name, _b = menuItem.label, label = _b === void 0 ? '' : _b, disabled = menuItem.disabled;
            if (name === 'separator') {
                return preact_1.h("li", { class: "menu-item separator" });
            }
            // eslint-disable-next-line no-undefined
            var getListener = function (listener) { return (disabled ? undefined : listener); };
            var classNames = this.createClassNames();
            var subMenuInfo = this.state.subMenuInfo;
            return (preact_1.h("li", { class: classNames, onClick: getListener(this.execAction), onMouseEnter: getListener(this.showSubMenu), onMouseLeave: getListener(this.hideSubMenu) },
                preact_1.h("span", { dangerouslySetInnerHTML: { __html: label } }),
                subMenuInfo && preact_1.h(contextMenu_1.ContextMenu, { menuItems: subMenuInfo.menuItems, pos: subMenuInfo.pos })));
        };
        return ContextMenuItemComp;
    }(preact_1.Component));
    exports.ContextMenuItem = hoc_1.connect()(ContextMenuItemComp);


    /***/ }),
    /* 115 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HeightResizeHandle = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var hoc_1 = __webpack_require__(4);
    var dom_1 = __webpack_require__(2);
    var HeightResizeHandleComp = /** @class */ (function (_super) {
        tslib_1.__extends(HeightResizeHandleComp, _super);
        function HeightResizeHandleComp() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.dragStartY = -1;
            _this.dragStartBodyHeight = -1;
            _this.handleMouseDown = function (ev) {
                _this.dragStartY = ev.pageY;
                _this.dragStartBodyHeight = _this.props.bodyHeight;
                dom_1.setCursorStyle('row-resize');
                document.addEventListener('mousemove', _this.handleMouseMove);
                document.addEventListener('mouseup', _this.clearDocumentEvents);
                document.addEventListener('selectstart', _this.handleSelectStart);
            };
            _this.handleSelectStart = function (ev) {
                ev.preventDefault();
            };
            _this.handleMouseMove = function (ev) {
                var distance = ev.pageY - _this.dragStartY;
                _this.props.dispatch('setBodyHeight', _this.dragStartBodyHeight + distance);
            };
            _this.clearDocumentEvents = function () {
                dom_1.setCursorStyle('');
                document.removeEventListener('mousemove', _this.handleMouseMove);
                document.removeEventListener('mouseup', _this.clearDocumentEvents);
                document.removeEventListener('selectstart', _this.handleSelectStart);
            };
            return _this;
        }
        HeightResizeHandleComp.prototype.render = function () {
            return (preact_1.h("div", { class: dom_1.cls('height-resize-handle'), onMouseDown: this.handleMouseDown },
                preact_1.h("button", null,
                    preact_1.h("span", null))));
        };
        return HeightResizeHandleComp;
    }(preact_1.Component));
    exports.HeightResizeHandle = hoc_1.connect(function (_a) {
        var dimension = _a.dimension;
        return ({
            bodyHeight: dimension.bodyHeight,
        });
    })(HeightResizeHandleComp);


    /***/ }),
    /* 116 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Clipboard = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var hoc_1 = __webpack_require__(4);
    var dom_1 = __webpack_require__(2);
    var keyboard_1 = __webpack_require__(17);
    var browser_1 = __webpack_require__(52);
    var clipboard_1 = __webpack_require__(37);
    var common_1 = __webpack_require__(0);
    var gridEvent_1 = tslib_1.__importDefault(__webpack_require__(9));
    var eventBus_1 = __webpack_require__(8);
    var KEYDOWN_LOCK_TIME = 10;
    var ClipboardComp = /** @class */ (function (_super) {
        tslib_1.__extends(ClipboardComp, _super);
        function ClipboardComp() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.isLocked = false;
            _this.lock = function () {
                _this.isLocked = true;
                setTimeout(_this.unlock.bind(_this), KEYDOWN_LOCK_TIME);
            };
            /**
             * Unlock
             * @private
             */
            _this.unlock = function () {
                _this.isLocked = false;
            };
            _this.onBlur = function () {
                _this.props.dispatch('setNavigating', false);
            };
            _this.dispatchKeyboardEvent = function (type, command) {
                var dispatch = _this.props.dispatch;
                switch (type) {
                    case 'move':
                        dispatch('selectionEnd');
                        dispatch('moveFocus', command);
                        dispatch('setScrollToFocus');
                        break;
                    case 'edit':
                        dispatch('editFocus', command);
                        dispatch('setScrollToFocus');
                        break;
                    case 'select':
                        dispatch('moveSelection', command);
                        dispatch('setScrollToSelection');
                        break;
                    case 'remove':
                        dispatch('removeContent');
                        break;
                    /*
                     * Call directly because of timing issues
                     * - Step 1: When the keys(ctrl+c) are downed on grid, 'clipboard' is triggered.
                     * - Step 2: When 'clipboard' event is fired,
                     *           all browsers append copied data and focus to contenteditable element and
                     *           IE browsers set selection for triggering 'copy' event.
                     * - Step 3: Finally, when 'copy' event is fired on browsers,
                     *           setting copied data to ClipboardEvent.clipboardData or window.clipboardData(IE).
                     */
                    case 'clipboard': {
                        if (!_this.el) {
                            return;
                        }
                        var store = _this.context.store;
                        _this.el.textContent = clipboard_1.getText(store);
                        if (dom_1.isSupportWindowClipboardData()) {
                            dom_1.setClipboardSelection(_this.el.childNodes[0]);
                        }
                        break;
                    }
                }
            };
            /**
             * Event handler for the keydown event
             * @param {Event} ev - Event
             * @private
             */
            _this.onKeyDown = function (ev) {
                if (_this.isLocked) {
                    ev.preventDefault();
                    return;
                }
                var _a = keyboard_1.keyEventGenerate(ev), type = _a.type, command = _a.command;
                if (!type) {
                    return;
                }
                _this.lock();
                if (type !== 'clipboard') {
                    ev.preventDefault();
                }
                if (!(type === 'clipboard' && command === 'paste')) {
                    var _b = _this.props, rowKey = _b.rowKey, columnName = _b.columnName;
                    var gridEvent = new gridEvent_1.default({ keyboardEvent: ev, rowKey: rowKey, columnName: columnName });
                    /**
                     * Occurs when key down event is triggered.
                     * @event Grid#keydown
                     * @property {Grid} instance - Current grid instance
                     * @property {Object} keyboardEvent - Keyboard Event
                     * @property {Object} rowKey - Focused rowKey
                     * @property {Object} columnName - Focused column name
                     */
                    _this.props.eventBus.trigger('keydown', gridEvent);
                    if (!gridEvent.isStopped()) {
                        _this.dispatchKeyboardEvent(type, command);
                    }
                }
            };
            _this.onCopy = function (ev) {
                if (!_this.el) {
                    return;
                }
                var text = _this.el.textContent;
                if (dom_1.isSupportWindowClipboardData()) {
                    window.clipboardData.setData('Text', text);
                }
                else if (ev.clipboardData) {
                    ev.clipboardData.setData('text/plain', text);
                }
                ev.preventDefault();
            };
            _this.onPaste = function (ev) {
                var clipboardData = ev.clipboardData || window.clipboardData;
                if (!clipboardData) {
                    return;
                }
                if (!browser_1.isEdge() && !dom_1.isSupportWindowClipboardData()) {
                    ev.preventDefault();
                    _this.pasteInOtherBrowsers(clipboardData);
                }
                else {
                    _this.pasteInMSBrowser(clipboardData);
                }
            };
            return _this;
        }
        ClipboardComp.prototype.isClipboardFocused = function () {
            return document.hasFocus() && document.activeElement === this.el;
        };
        /**
         * Paste copied data in other browsers (chrome, safari, firefox)
         * [if] condition is copying from ms-excel,
         * [else] condition is copying from the grid or the copied data is plain text.
         */
        ClipboardComp.prototype.pasteInOtherBrowsers = function (clipboardData) {
            if (!this.el) {
                return;
            }
            var el = this.el;
            var html = clipboardData.getData('text/html');
            var data;
            if (html && html.indexOf('table') !== -1) {
                // step 1: Append copied data on contenteditable element to parsing correctly table data.
                el.innerHTML = html;
                // step 2: Make grid data from cell data of appended table element.
                var rows = el.querySelector('tbody').rows;
                data = dom_1.convertTableToData(rows);
                // step 3: Empty contenteditable element to reset.
                el.innerHTML = '';
            }
            else {
                data = common_1.convertTextToData(clipboardData.getData('text/plain'));
            }
            this.props.dispatch('paste', data);
        };
        /**
         * Paste copied data in MS-browsers (IE, edge)
         */
        ClipboardComp.prototype.pasteInMSBrowser = function (clipboardData) {
            var _this = this;
            var data = common_1.convertTextToData(clipboardData.getData('Text'));
            setTimeout(function () {
                if (!_this.el) {
                    return;
                }
                var el = _this.el;
                if (el.querySelector('table')) {
                    var rows = el.querySelector('tbody').rows;
                    data = dom_1.convertTableToData(rows);
                }
                _this.props.dispatch('paste', data);
                el.innerHTML = '';
            }, 0);
        };
        ClipboardComp.prototype.componentDidUpdate = function () {
            var _this = this;
            setTimeout(function () {
                var _a = _this.props, navigating = _a.navigating, editing = _a.editing, filtering = _a.filtering;
                if (_this.el &&
                    navigating &&
                    !filtering &&
                    !editing &&
                    !_this.isClipboardFocused() &&
                    !browser_1.isMobile()) {
                    // @TODO: apply polifyll or alternative for IE, safari
                    _this.el.focus({ preventScroll: true });
                }
            });
        };
        ClipboardComp.prototype.render = function () {
            var _this = this;
            return (preact_1.h("div", { class: dom_1.cls('clipboard'), onBlur: this.onBlur, onKeyDown: this.onKeyDown, onCopy: this.onCopy, onPaste: this.onPaste, contentEditable: true, ref: function (el) {
                    _this.el = el;
                } }));
        };
        return ClipboardComp;
    }(preact_1.Component));
    exports.Clipboard = hoc_1.connect(function (_a) {
        var focus = _a.focus, filterLayerState = _a.filterLayerState, id = _a.id;
        return ({
            navigating: focus.navigating,
            rowKey: focus.rowKey,
            columnName: focus.columnName,
            editing: !!focus.editingAddress,
            filtering: !!filterLayerState.activeColumnAddress,
            eventBus: eventBus_1.getEventBus(id),
        });
    })(ClipboardComp);


    /***/ }),
    /* 117 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Pagination = void 0;
    var tslib_1 = __webpack_require__(1);
    var preact_1 = __webpack_require__(3);
    var tui_pagination_1 = tslib_1.__importDefault(__webpack_require__(118));
    var hoc_1 = __webpack_require__(4);
    var dom_1 = __webpack_require__(2);
    var common_1 = __webpack_require__(0);
    var instance_1 = __webpack_require__(7);
    var eventBus_1 = __webpack_require__(8);
    var gridEvent_1 = tslib_1.__importDefault(__webpack_require__(9));
    var PaginationComp = /** @class */ (function (_super) {
        tslib_1.__extends(PaginationComp, _super);
        function PaginationComp() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PaginationComp.prototype.shouldComponentUpdate = function (nextProps) {
            return !common_1.shallowEqual(this.props.pageOptions, nextProps.pageOptions);
        };
        PaginationComp.prototype.componentDidMount = function () {
            this.createPagination();
        };
        PaginationComp.prototype.componentWillReceiveProps = function (nextProps) {
            if (!this.el || !this.tuiPagination) {
                return;
            }
            var pageOptions = nextProps.pageOptions;
            var totalCount = pageOptions.totalCount, page = pageOptions.page, perPage = pageOptions.perPage;
            if (!common_1.isNumber(totalCount) || !common_1.isNumber(page) || !common_1.isNumber(perPage)) {
                return;
            }
            if (this.props.pageOptions.perPage !== perPage ||
                this.props.pageOptions.totalCount !== totalCount) {
                this.tuiPagination.setItemsPerPage(perPage);
                this.tuiPagination.reset(totalCount);
            }
            if (this.tuiPagination.getCurrentPage() !== page) {
                this.removeEventListener();
                this.tuiPagination.movePageTo(page);
                this.addEventListener();
            }
        };
        PaginationComp.prototype.componentWillUnmount = function () {
            if (this.tuiPagination) {
                this.removeEventListener();
            }
        };
        PaginationComp.prototype.createPagination = function () {
            var _a = this.props, pageOptions = _a.pageOptions, paginationHolder = _a.paginationHolder, usageStatistics = _a.grid.usageStatistics;
            var totalCount = pageOptions.totalCount, perPage = pageOptions.perPage;
            var options = tslib_1.__assign(tslib_1.__assign({}, pageOptions), { totalItems: totalCount, itemsPerPage: perPage, usageStatistics: usageStatistics });
            this.tuiPagination = new tui_pagination_1.default(this.el, options);
            this.addEventListener();
            paginationHolder.setPagination(this.tuiPagination);
        };
        PaginationComp.prototype.addEventListener = function () {
            var _a = this.props, dataProvider = _a.dataProvider, pageOptions = _a.pageOptions, dispatch = _a.dispatch, eventBus = _a.eventBus;
            this.tuiPagination.on('beforeMove', function (ev) {
                var page = ev.page;
                var gridEvent = new gridEvent_1.default({ page: page });
                /**
                 * Occurs before moving the page.
                 * @event Grid#beforePageMove
                 * @property {number} page - Target page number
                 * @property {Grid} instance - Current grid instance
                 */
                eventBus.trigger('beforePageMove', gridEvent);
                if (!gridEvent.isStopped()) {
                    if (pageOptions.useClient) {
                        dispatch('movePage', page);
                    }
                    else {
                        dataProvider.readData(page);
                    }
                }
            });
            this.tuiPagination.on('afterMove', function (ev) {
                var gridEvent = new gridEvent_1.default({ page: ev.page });
                /**
                 * Occurs after moving the page.
                 * @event Grid#afterPageMove
                 * @property {number} page - Target page number
                 * @property {Grid} instance - Current grid instance
                 */
                eventBus.trigger('afterPageMove', gridEvent);
            });
        };
        PaginationComp.prototype.removeEventListener = function () {
            this.tuiPagination.off('beforeMove');
            this.tuiPagination.off('afterMove');
        };
        PaginationComp.prototype.render = function () {
            var _this = this;
            return (preact_1.h("div", { ref: function (el) {
                    _this.el = el;
                }, class: "tui-pagination " + dom_1.cls('pagination') }));
        };
        return PaginationComp;
    }(preact_1.Component));
    exports.Pagination = hoc_1.connect(function (_a) {
        var id = _a.id, data = _a.data;
        return ({
            pageOptions: data.pageOptions,
            dataProvider: instance_1.getDataProvider(id),
            paginationHolder: instance_1.getPaginationManager(id),
            grid: instance_1.getInstance(id),
            eventBus: eventBus_1.getEventBus(id),
        });
    })(PaginationComp);


    /***/ }),
    /* 118 */
    /***/ (function(module, exports) {

    module.exports = __WEBPACK_EXTERNAL_MODULE__118__;

    /***/ }),
    /* 119 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDispatcher = void 0;
    var tslib_1 = __webpack_require__(1);
    var viewport = tslib_1.__importStar(__webpack_require__(23));
    var dimension = tslib_1.__importStar(__webpack_require__(46));
    var data = tslib_1.__importStar(__webpack_require__(13));
    var column = tslib_1.__importStar(__webpack_require__(31));
    var keyboard = tslib_1.__importStar(__webpack_require__(120));
    var mouse = tslib_1.__importStar(__webpack_require__(122));
    var focus = tslib_1.__importStar(__webpack_require__(18));
    var summary = tslib_1.__importStar(__webpack_require__(24));
    var selection = tslib_1.__importStar(__webpack_require__(16));
    var renderState = tslib_1.__importStar(__webpack_require__(123));
    var tree = tslib_1.__importStar(__webpack_require__(30));
    var sort = tslib_1.__importStar(__webpack_require__(28));
    var filter = tslib_1.__importStar(__webpack_require__(34));
    var pagination = tslib_1.__importStar(__webpack_require__(35));
    var contextMenu = tslib_1.__importStar(__webpack_require__(124));
    var dispatchMap = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, viewport), dimension), data), column), mouse), focus), keyboard), summary), selection), renderState), tree), sort), filter), pagination), contextMenu);
    function createDispatcher(store) {
        return function dispatch(fname) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            // @ts-ignore
            dispatchMap[fname].apply(dispatchMap, tslib_1.__spreadArrays([store], args));
        };
    }
    exports.createDispatcher = createDispatcher;


    /***/ }),
    /* 120 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.updateDataByKeyMap = exports.paste = exports.removeContent = exports.moveSelection = exports.moveTabFocus = exports.editFocus = exports.moveFocus = void 0;
    var tslib_1 = __webpack_require__(1);
    var keyboard_1 = __webpack_require__(121);
    var focus_1 = __webpack_require__(18);
    var selection_1 = __webpack_require__(16);
    var column_1 = __webpack_require__(10);
    var rowSpan_1 = __webpack_require__(11);
    var instance_1 = __webpack_require__(7);
    var eventBus_1 = __webpack_require__(8);
    var gridEvent_1 = tslib_1.__importDefault(__webpack_require__(9));
    var data_1 = __webpack_require__(6);
    var validation_1 = __webpack_require__(25);
    var clipboard_1 = __webpack_require__(37);
    var common_1 = __webpack_require__(0);
    var summary_1 = __webpack_require__(24);
    var data_2 = __webpack_require__(13);
    function moveFocus(store, command) {
        var focus = store.focus, data = store.data, visibleColumnsWithRowHeader = store.column.visibleColumnsWithRowHeader, id = store.id;
        var rowIndex = focus.rowIndex, columnIndex = focus.totalColumnIndex;
        if (rowIndex === null || columnIndex === null) {
            return;
        }
        var _a = keyboard_1.getNextCellIndex(store, command, [rowIndex, columnIndex]), nextRowIndex = _a[0], nextColumnIndex = _a[1];
        var nextColumnName = visibleColumnsWithRowHeader[nextColumnIndex].name;
        if (!column_1.isRowHeader(nextColumnName)) {
            focus.navigating = true;
            focus_1.changeFocus(store, data_1.getRowKeyByIndexWithPageRange(data, nextRowIndex), nextColumnName, id);
        }
    }
    exports.moveFocus = moveFocus;
    function editFocus(store, command) {
        var _a = store.focus, rowKey = _a.rowKey, columnName = _a.columnName;
        if (rowKey === null || columnName === null) {
            return;
        }
        if (command === 'currentCell') {
            focus_1.startEditing(store, rowKey, columnName);
        }
        else if (command === 'nextCell' || command === 'prevCell') {
            // move prevCell or nextCell by tab keyMap
            moveTabFocus(store, command);
        }
    }
    exports.editFocus = editFocus;
    function moveTabFocus(store, command) {
        var focus = store.focus, data = store.data, column = store.column, id = store.id;
        var visibleColumnsWithRowHeader = column.visibleColumnsWithRowHeader;
        var rowKey = focus.rowKey, columnName = focus.columnName, rowIndex = focus.rowIndex, columnIndex = focus.totalColumnIndex;
        if (rowKey === null || columnName === null || rowIndex === null || columnIndex === null) {
            return;
        }
        var _a = keyboard_1.getNextCellIndex(store, command, [rowIndex, columnIndex]), nextRowIndex = _a[0], nextColumnIndex = _a[1];
        var nextRowKey = data_1.getRowKeyByIndexWithPageRange(data, nextRowIndex);
        var nextColumnName = visibleColumnsWithRowHeader[nextColumnIndex].name;
        if (!column_1.isRowHeader(nextColumnName)) {
            focus.navigating = true;
            focus_1.changeFocus(store, nextRowKey, nextColumnName, id);
            if (focus.tabMode === 'moveAndEdit' &&
                focus.rowKey === nextRowKey &&
                focus.columnName === nextColumnName) {
                setTimeout(function () {
                    focus_1.startEditing(store, nextRowKey, nextColumnName);
                });
            }
        }
    }
    exports.moveTabFocus = moveTabFocus;
    function moveSelection(store, command) {
        var _a;
        var selection = store.selection, focus = store.focus, data = store.data, _b = store.column, visibleColumnsWithRowHeader = _b.visibleColumnsWithRowHeader, rowHeaderCount = _b.rowHeaderCount, id = store.id;
        var filteredViewData = data.filteredViewData, sortState = data.sortState;
        var focusRowIndex = focus.rowIndex, totalFocusColumnIndex = focus.totalColumnIndex;
        var currentInputRange = selection.inputRange;
        if (focusRowIndex === null || totalFocusColumnIndex === null) {
            return;
        }
        if (!currentInputRange) {
            currentInputRange = selection.inputRange = {
                row: [focusRowIndex, focusRowIndex],
                column: [totalFocusColumnIndex, totalFocusColumnIndex],
            };
        }
        var rowLength = filteredViewData.length;
        var columnLength = visibleColumnsWithRowHeader.length;
        var rowStartIndex = currentInputRange.row[0];
        var rowIndex = currentInputRange.row[1];
        var columnStartIndex = currentInputRange.column[0];
        var columnIndex = currentInputRange.column[1];
        var nextCellIndexes;
        if (command === 'all') {
            rowStartIndex = 0;
            columnStartIndex = rowHeaderCount;
            nextCellIndexes = [rowLength - 1, columnLength - 1];
        }
        else {
            nextCellIndexes = keyboard_1.getNextCellIndex(store, command, [rowIndex, columnIndex]);
            if (rowSpan_1.isRowSpanEnabled(sortState)) {
                nextCellIndexes = keyboard_1.getNextCellIndexWithRowSpan(store, command, rowIndex, [columnStartIndex, columnIndex], nextCellIndexes);
            }
        }
        var nextRowIndex = nextCellIndexes[0], nextColumnIndex = nextCellIndexes[1];
        var nextColumnName = visibleColumnsWithRowHeader[nextColumnIndex].name;
        var startRowIndex = rowStartIndex;
        var endRowIndex = nextRowIndex;
        if (command !== 'all') {
            _a = rowSpan_1.getRowRangeWithRowSpan([startRowIndex, endRowIndex], [columnStartIndex, nextColumnIndex], visibleColumnsWithRowHeader, focus.rowIndex, data), startRowIndex = _a[0], endRowIndex = _a[1];
        }
        if (!column_1.isRowHeader(nextColumnName)) {
            var inputRange = {
                row: [startRowIndex, endRowIndex],
                column: [columnStartIndex, nextColumnIndex],
            };
            selection_1.changeSelectionRange(selection, inputRange, id);
        }
    }
    exports.moveSelection = moveSelection;
    function removeContent(store) {
        var column = store.column, data = store.data;
        var range = keyboard_1.getRemoveRange(store);
        if (!range) {
            return;
        }
        var _a = range.column, columnStart = _a[0], columnEnd = _a[1], _b = range.row, rowStart = _b[0], rowEnd = _b[1];
        var changeValueFns = [];
        var prevChanges = [];
        var nextChanges = [];
        data.filteredRawData.slice(rowStart, rowEnd + 1).forEach(function (row, index) {
            column.visibleColumnsWithRowHeader.slice(columnStart, columnEnd + 1).forEach(function (_a) {
                var name = _a.name;
                var rowIndex = index + rowStart;
                if (data_1.isEditableCell(store, rowIndex, name)) {
                    var _b = data_1.createChangeInfo(store, row, name, '', rowIndex), prevChange = _b.prevChange, nextChange = _b.nextChange, changeValue = _b.changeValue;
                    prevChanges.push(prevChange);
                    nextChanges.push(nextChange);
                    changeValueFns.push(changeValue);
                }
            });
        });
        updateDataByKeyMap(store, 'delete', { prevChanges: prevChanges, nextChanges: nextChanges, changeValueFns: changeValueFns });
    }
    exports.removeContent = removeContent;
    function applyCopiedData(store, copiedData, range) {
        var data = store.data, column = store.column;
        var filteredRawData = data.filteredRawData, filteredViewData = data.filteredViewData;
        var visibleColumnsWithRowHeader = column.visibleColumnsWithRowHeader;
        var _a = range.row, startRowIndex = _a[0], endRowIndex = _a[1], _b = range.column, startColumnIndex = _b[0], endColumnIndex = _b[1];
        var columnNames = common_1.mapProp('name', visibleColumnsWithRowHeader);
        var changeValueFns = [];
        var prevChanges = [];
        var nextChanges = [];
        for (var rowIndex = 0; rowIndex + startRowIndex <= endRowIndex; rowIndex += 1) {
            var rawRowIndex = rowIndex + startRowIndex;
            for (var columnIndex = 0; columnIndex + startColumnIndex <= endColumnIndex; columnIndex += 1) {
                var name = columnNames[columnIndex + startColumnIndex];
                if (filteredViewData.length && data_1.isEditableCell(store, rawRowIndex, name)) {
                    var targetRow = filteredRawData[rawRowIndex];
                    var _c = data_1.createChangeInfo(store, targetRow, name, copiedData[rowIndex][columnIndex], rawRowIndex), prevChange = _c.prevChange, nextChange = _c.nextChange, changeValue = _c.changeValue;
                    prevChanges.push(prevChange);
                    nextChanges.push(nextChange);
                    changeValueFns.push(changeValue);
                    summary_1.updateSummaryValueByCell(store, name, {
                        orgValue: targetRow[name],
                        value: copiedData[rowIndex][columnIndex],
                    });
                }
            }
        }
        updateDataByKeyMap(store, 'paste', { prevChanges: prevChanges, nextChanges: nextChanges, changeValueFns: changeValueFns });
    }
    function paste(store, copiedData) {
        var selection = store.selection, id = store.id;
        var originalRange = selection.originalRange;
        if (originalRange) {
            copiedData = clipboard_1.copyDataToRange(originalRange, copiedData);
        }
        var rangeToPaste = clipboard_1.getRangeToPaste(store, copiedData);
        applyCopiedData(store, copiedData, rangeToPaste);
        selection_1.changeSelectionRange(selection, rangeToPaste, id);
    }
    exports.paste = paste;
    function updateDataByKeyMap(store, origin, changeInfo) {
        var id = store.id, data = store.data, column = store.column;
        var rawData = data.rawData, filteredRawData = data.filteredRawData;
        var prevChanges = changeInfo.prevChanges, nextChanges = changeInfo.nextChanges, changeValueFns = changeInfo.changeValueFns;
        var eventBus = eventBus_1.getEventBus(id);
        var manager = instance_1.getDataManager(id);
        var gridEvent = new gridEvent_1.default({ origin: origin, changes: prevChanges });
        /**
         * Occurs before one or more cells is changed
         * @event Grid#beforeChange
         * @property {string} origin - The type of change('paste', 'delete', 'cell')
         * @property {Array.<object>} changes - rowKey, column name, original values and next values before changing the values
         * @property {Grid} instance - Current grid instance
         */
        eventBus.trigger('beforeChange', gridEvent);
        if (gridEvent.isStopped()) {
            return;
        }
        var index = null;
        changeValueFns.forEach(function (changeValue) {
            var targetRowIndex = changeValue();
            if (index !== targetRowIndex) {
                index = targetRowIndex;
                manager.push('UPDATE', filteredRawData[index]);
            }
        });
        validation_1.forceValidateUniquenessOfColumns(rawData, column);
        data_2.updateHeights(store);
        gridEvent = new gridEvent_1.default({ origin: origin, changes: nextChanges });
        /**
         * Occurs after one or more cells is changed
         * @event Grid#afterChange
         * @property {string} origin - The type of change('paste', 'delete', 'cell')
         * @property {Array.<object>} changes - rowKey, column name, previous values and changed values after changing the values
         * @property {Grid} instance - Current grid instance
         */
        eventBus.trigger('afterChange', gridEvent);
    }
    exports.updateDataByKeyMap = updateDataByKeyMap;


    /***/ }),
    /* 121 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getNextCellIndexWithRowSpan = exports.getRemoveRange = exports.getNextCellIndex = void 0;
    var common_1 = __webpack_require__(0);
    var rowSpan_1 = __webpack_require__(11);
    var selection_1 = __webpack_require__(20);
    var data_1 = __webpack_require__(6);
    function getPrevRowIndex(rowIndex, heights) {
        var index = rowIndex;
        while (index > 0) {
            index -= 1;
            if (heights[index]) {
                break;
            }
        }
        return index;
    }
    function getNextRowIndex(rowIndex, heights) {
        var index = rowIndex;
        while (index < heights.length - 1) {
            index += 1;
            if (heights[index]) {
                break;
            }
        }
        return index;
    }
    function getNextCellIndex(store, command, _a) {
        var rowIndex = _a[0], columnIndex = _a[1];
        var data = store.data, _b = store.column, visibleColumnsWithRowHeader = _b.visibleColumnsWithRowHeader, rowHeaderCount = _b.rowHeaderCount, heights = store.rowCoords.heights;
        var sortState = data.sortState, filteredRawData = data.filteredRawData, pageRowRange = data.pageRowRange;
        var lastRowIndex = (data_1.isClientPagination(data) ? pageRowRange[1] - pageRowRange[0] : filteredRawData.length) - 1;
        var columnName = visibleColumnsWithRowHeader[columnIndex].name;
        var lastRow = lastRowIndex === rowIndex;
        var lastColumn = visibleColumnsWithRowHeader.length - 1 === columnIndex;
        var firstRow = rowIndex === 0;
        var firstColumn = columnIndex === rowHeaderCount;
        switch (command) {
            case 'up':
                if (rowSpan_1.isRowSpanEnabled(sortState)) {
                    rowIndex = rowSpan_1.getRowSpanTopIndex(rowIndex, columnName, filteredRawData);
                }
                rowIndex = getPrevRowIndex(rowIndex, heights);
                break;
            case 'down':
                if (rowSpan_1.isRowSpanEnabled(sortState)) {
                    rowIndex = rowSpan_1.getRowSpanBottomIndex(rowIndex, columnName, filteredRawData);
                }
                rowIndex = getNextRowIndex(rowIndex, heights);
                break;
            case 'left':
                columnIndex -= 1;
                break;
            case 'right':
                columnIndex += 1;
                break;
            case 'firstCell':
                columnIndex = rowHeaderCount;
                rowIndex = 0;
                break;
            case 'lastCell':
                columnIndex = visibleColumnsWithRowHeader.length - 1;
                rowIndex = lastRowIndex;
                break;
            case 'pageUp': {
                rowIndex = 0;
                break;
            }
            case 'pageDown': {
                rowIndex = lastRowIndex;
                break;
            }
            case 'firstColumn':
                columnIndex = rowHeaderCount;
                break;
            case 'lastColumn':
                columnIndex = visibleColumnsWithRowHeader.length - 1;
                break;
            case 'nextCell':
                if (lastRow && lastColumn) {
                    break;
                }
                if (lastColumn) {
                    if (rowSpan_1.isRowSpanEnabled(sortState)) {
                        rowIndex = rowSpan_1.getRowSpanBottomIndex(rowIndex, columnName, filteredRawData);
                    }
                    rowIndex = getNextRowIndex(rowIndex, heights);
                    columnIndex = rowHeaderCount;
                }
                else {
                    columnIndex += 1;
                }
                break;
            case 'prevCell':
                if (firstRow && firstColumn) {
                    break;
                }
                if (firstColumn) {
                    if (rowSpan_1.isRowSpanEnabled(sortState)) {
                        rowIndex = rowSpan_1.getRowSpanTopIndex(rowIndex, columnName, filteredRawData);
                    }
                    rowIndex = getPrevRowIndex(rowIndex, heights);
                    columnIndex = visibleColumnsWithRowHeader.length - 1;
                }
                else {
                    columnIndex -= 1;
                }
                break;
        }
        rowIndex = common_1.clamp(rowIndex, 0, lastRowIndex);
        columnIndex = common_1.clamp(columnIndex, 0, visibleColumnsWithRowHeader.length - 1);
        return [rowIndex, columnIndex];
    }
    exports.getNextCellIndex = getNextCellIndex;
    function getRemoveRange(store) {
        var focus = store.focus, selection = store.selection;
        var totalColumnIndex = focus.totalColumnIndex, originalRowIndex = focus.originalRowIndex;
        var originalRange = selection.originalRange;
        if (originalRange) {
            return originalRange;
        }
        if (!common_1.isNull(totalColumnIndex) && !common_1.isNull(originalRowIndex)) {
            return {
                column: [totalColumnIndex, totalColumnIndex],
                row: [originalRowIndex, originalRowIndex],
            };
        }
        return null;
    }
    exports.getRemoveRange = getRemoveRange;
    function getNextCellIndexWithRowSpan(store, command, currentRowIndex, columnRange, cellIndexes) {
        var rowIndex = cellIndexes[0];
        var columnIndex = cellIndexes[1];
        var _a = selection_1.getSortedRange(columnRange), startColumnIndex = _a[0], endColumnIndex = _a[1];
        for (var index = startColumnIndex; index <= endColumnIndex; index += 1) {
            var nextRowIndex = getNextCellIndex(store, command, [currentRowIndex, index])[0];
            if ((command === 'up' && nextRowIndex < rowIndex) ||
                (command === 'down' && nextRowIndex > rowIndex)) {
                rowIndex = nextRowIndex;
            }
        }
        return [rowIndex, columnIndex];
    }
    exports.getNextCellIndexWithRowSpan = getNextCellIndexWithRowSpan;


    /***/ }),
    /* 122 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dragMoveRowHeader = exports.mouseDownRowHeader = exports.dragMoveHeader = exports.mouseDownHeader = exports.mouseDownBody = exports.dragEnd = exports.dragMoveBody = exports.selectionEnd = exports.setNavigating = void 0;
    var common_1 = __webpack_require__(0);
    var column_1 = __webpack_require__(10);
    var focus_1 = __webpack_require__(18);
    var selection_1 = __webpack_require__(16);
    var rowSpan_1 = __webpack_require__(11);
    var selection_2 = __webpack_require__(20);
    var data_1 = __webpack_require__(6);
    var mouse_1 = __webpack_require__(53);
    function stopAutoScroll(selection) {
        var intervalIdForAutoScroll = selection.intervalIdForAutoScroll;
        if (intervalIdForAutoScroll !== null) {
            clearInterval(intervalIdForAutoScroll);
            selection.intervalIdForAutoScroll = null;
        }
    }
    function isAutoScrollable(overflowX, overflowY) {
        return !(overflowX === 0 && overflowY === 0);
    }
    function adjustScrollLeft(overflowX, viewport) {
        var scrollPixelScale = viewport.scrollPixelScale, scrollLeft = viewport.scrollLeft, maxScrollLeft = viewport.maxScrollLeft;
        if (overflowX < 0) {
            viewport.scrollLeft = Math.max(0, scrollLeft - scrollPixelScale);
        }
        else if (overflowX > 0) {
            viewport.scrollLeft = Math.min(maxScrollLeft, scrollLeft + scrollPixelScale);
        }
    }
    function adjustScrollTop(overflowY, viewport) {
        var scrollTop = viewport.scrollTop, maxScrollTop = viewport.maxScrollTop, scrollPixelScale = viewport.scrollPixelScale;
        if (overflowY < 0) {
            viewport.scrollTop = Math.max(0, scrollTop - scrollPixelScale);
        }
        else if (overflowY > 0) {
            viewport.scrollTop = Math.min(maxScrollTop, scrollTop + scrollPixelScale);
        }
    }
    function adjustScroll(viewport, overflow) {
        if (overflow.x) {
            adjustScrollLeft(overflow.x, viewport);
        }
        if (overflow.y) {
            adjustScrollTop(overflow.y, viewport);
        }
    }
    function setScrolling(_a, bodyWidth, selection, dimension, viewport) {
        var pageX = _a.pageX, pageY = _a.pageY;
        var overflow = mouse_1.getOverflowFromMousePosition(pageX, pageY, bodyWidth, dimension);
        stopAutoScroll(selection);
        if (isAutoScrollable(overflow.x, overflow.y)) {
            selection.intervalIdForAutoScroll = setInterval(adjustScroll.bind(null, viewport, overflow));
        }
    }
    function setNavigating(_a, navigating) {
        var focus = _a.focus;
        focus.navigating = navigating;
    }
    exports.setNavigating = setNavigating;
    function selectionEnd(_a) {
        var selection = _a.selection;
        selection.inputRange = null;
    }
    exports.selectionEnd = selectionEnd;
    function updateSelection(store, dragData) {
        var _a;
        var viewport = store.viewport, selection = store.selection, column = store.column, id = store.id, data = store.data, focus = store.focus;
        var scrollTop = viewport.scrollTop, scrollLeft = viewport.scrollLeft;
        var pageX = dragData.pageX, pageY = dragData.pageY;
        var curInputRange = selection.inputRange;
        var visibleColumnsWithRowHeader = column.visibleColumnsWithRowHeader;
        var startRowIndex, startColumnIndex, endRowIndex;
        var viewInfo = { pageX: pageX, pageY: pageY, scrollTop: scrollTop, scrollLeft: scrollLeft };
        var endColumnIndex = mouse_1.findColumnIndexByPosition(store, viewInfo);
        endRowIndex = mouse_1.findRowIndexByPosition(store, viewInfo);
        if (curInputRange === null) {
            var totalColumnIndex = focus.totalColumnIndex, rowIndex = focus.rowIndex;
            startColumnIndex = totalColumnIndex;
            startRowIndex = rowIndex;
        }
        else {
            startRowIndex = curInputRange.row[0];
            startColumnIndex = curInputRange.column[0];
        }
        if (startColumnIndex < 0 || endColumnIndex < 0 || startRowIndex < 0 || endRowIndex < 0) {
            return;
        }
        _a = rowSpan_1.getRowRangeWithRowSpan([startRowIndex, endRowIndex], [startColumnIndex, endColumnIndex], visibleColumnsWithRowHeader, store.focus.rowIndex, data), startRowIndex = _a[0], endRowIndex = _a[1];
        var inputRange = {
            row: [startRowIndex, endRowIndex],
            column: [startColumnIndex, endColumnIndex],
        };
        selection_1.changeSelectionRange(selection, inputRange, id);
    }
    function finishEditingByHeaderSelection(store, rowKey, columnName) {
        var editingAddress = store.focus.editingAddress;
        if (editingAddress) {
            if (editingAddress.rowKey === rowKey && editingAddress.columnName === columnName) {
                focus_1.saveAndFinishEditing(store);
            }
        }
    }
    function dragMoveBody(store, dragStartData, dragData, elementInfo) {
        var dimension = store.dimension, columnCoords = store.columnCoords, selection = store.selection, viewport = store.viewport;
        var areaWidth = columnCoords.areaWidth;
        var _a = mouse_1.getColumnNameRange(store, dragStartData, dragData, elementInfo), startColumnName = _a[0], endColumnName = _a[1];
        if (!column_1.isRowHeader(startColumnName) && !column_1.isRowHeader(endColumnName)) {
            updateSelection(store, dragData);
            setScrolling(dragData, areaWidth.L + areaWidth.R, selection, dimension, viewport);
        }
    }
    exports.dragMoveBody = dragMoveBody;
    function dragEnd(_a) {
        var selection = _a.selection;
        stopAutoScroll(selection);
    }
    exports.dragEnd = dragEnd;
    function mouseDownBody(store, elementInfo, eventInfo) {
        var data = store.data, column = store.column, columnCoords = store.columnCoords, rowCoords = store.rowCoords, id = store.id;
        var filteredRawData = data.filteredRawData;
        if (!filteredRawData.length) {
            return;
        }
        var pageX = eventInfo.pageX, pageY = eventInfo.pageY, shiftKey = eventInfo.shiftKey;
        var visibleColumnsBySideWithRowHeader = column.visibleColumnsBySideWithRowHeader;
        var side = elementInfo.side, scrollLeft = elementInfo.scrollLeft, scrollTop = elementInfo.scrollTop, left = elementInfo.left, top = elementInfo.top;
        var offsetLeft = pageX - left + scrollLeft;
        var offsetTop = pageY - top + scrollTop;
        var columnIndex = common_1.findOffsetIndex(columnCoords.offsets[side], offsetLeft);
        var columnName = visibleColumnsBySideWithRowHeader[side][columnIndex].name;
        if (!column_1.isRowHeader(columnName)) {
            if (shiftKey) {
                var dragData = { pageX: pageX, pageY: pageY };
                updateSelection(store, dragData);
            }
            else {
                var rowIndex = common_1.findOffsetIndex(rowCoords.offsets, offsetTop);
                selectionEnd(store);
                focus_1.changeFocus(store, data_1.getRowKeyByIndexWithPageRange(data, rowIndex), columnName, id);
            }
        }
    }
    exports.mouseDownBody = mouseDownBody;
    function mouseDownHeader(store, name, parentHeader) {
        var _a;
        var data = store.data, selection = store.selection, id = store.id, column = store.column, rowCoords = store.rowCoords;
        var filteredRawData = data.filteredRawData;
        if (!filteredRawData.length) {
            return;
        }
        var visibleColumnsWithRowHeader = column.visibleColumnsWithRowHeader, complexColumnHeaders = column.complexColumnHeaders;
        var endRowIndex = rowCoords.heights.length - 1;
        var startColumnIndex, endColumnIndex, columnName;
        if (parentHeader) {
            _a = selection_2.getChildColumnRange(visibleColumnsWithRowHeader, complexColumnHeaders, name), startColumnIndex = _a[0], endColumnIndex = _a[1];
            columnName = visibleColumnsWithRowHeader[startColumnIndex].name;
        }
        else {
            startColumnIndex = endColumnIndex = common_1.findPropIndex('name', name, visibleColumnsWithRowHeader);
            columnName = name;
        }
        var inputRange = {
            row: [0, endRowIndex],
            column: [startColumnIndex, endColumnIndex],
        };
        var rowKey = data_1.getRowKeyByIndexWithPageRange(data, 0);
        finishEditingByHeaderSelection(store, rowKey, columnName);
        focus_1.changeFocus(store, rowKey, columnName, id);
        selection_1.changeSelectionRange(selection, inputRange, id);
    }
    exports.mouseDownHeader = mouseDownHeader;
    function dragMoveHeader(store, dragData, startSelectedName) {
        var dimension = store.dimension, viewport = store.viewport, columnCoords = store.columnCoords, selection = store.selection, column = store.column, id = store.id;
        var scrollTop = viewport.scrollTop, scrollLeft = viewport.scrollLeft;
        var areaWidth = columnCoords.areaWidth;
        var visibleColumnsWithRowHeader = column.visibleColumnsWithRowHeader, complexColumnHeaders = column.complexColumnHeaders;
        var pageX = dragData.pageX, pageY = dragData.pageY;
        var curInputRange = selection.inputRange;
        if (common_1.isNull(curInputRange)) {
            return;
        }
        var _a = selection_2.getChildColumnRange(visibleColumnsWithRowHeader, complexColumnHeaders, startSelectedName), startColumnIdx = _a[0], endColumnIdx = _a[1];
        var viewInfo = { pageX: pageX, pageY: pageY, scrollTop: scrollTop, scrollLeft: scrollLeft };
        var columnIndex = mouse_1.findColumnIndexByPosition(store, viewInfo);
        var rowIndex = curInputRange.row[1];
        if (columnIndex < startColumnIdx) {
            startColumnIdx = columnIndex;
        }
        if (columnIndex > endColumnIdx) {
            endColumnIdx = columnIndex;
        }
        if (columnIndex >= 0) {
            var inputRange = {
                row: [0, rowIndex],
                column: [startColumnIdx, endColumnIdx],
            };
            selection_1.changeSelectionRange(selection, inputRange, id);
            setScrolling(dragData, areaWidth.L + areaWidth.R, selection, dimension, viewport);
        }
    }
    exports.dragMoveHeader = dragMoveHeader;
    function mouseDownRowHeader(store, rowKey) {
        var selection = store.selection, id = store.id, column = store.column, data = store.data;
        var visibleColumnsWithRowHeader = column.visibleColumnsWithRowHeader, rowHeaderCount = column.rowHeaderCount;
        var rowIndex = data_1.findIndexByRowKey(data, column, id, rowKey);
        var rowIndexPerPage = data_1.getRowIndexPerPage(data, rowIndex);
        var endColumnIndex = visibleColumnsWithRowHeader.length - 1;
        var _a = rowSpan_1.getRowRangeWithRowSpan([rowIndexPerPage, rowIndexPerPage], [rowHeaderCount, endColumnIndex], visibleColumnsWithRowHeader, null, data), startRowIndex = _a[0], endRowIndex = _a[1];
        var inputRange = {
            row: [startRowIndex, endRowIndex],
            column: [rowHeaderCount, endColumnIndex],
        };
        var editingRowKey = data.filteredRawData[rowIndex].rowKey;
        var editingColumnName = visibleColumnsWithRowHeader[rowHeaderCount].name;
        finishEditingByHeaderSelection(store, editingRowKey, editingColumnName);
        focus_1.changeFocus(store, editingRowKey, editingColumnName, id);
        selection_1.changeSelectionRange(selection, inputRange, id);
    }
    exports.mouseDownRowHeader = mouseDownRowHeader;
    function dragMoveRowHeader(store, dragData) {
        var _a;
        var viewport = store.viewport, selection = store.selection, id = store.id, data = store.data, column = store.column;
        var scrollTop = viewport.scrollTop, scrollLeft = viewport.scrollLeft;
        var visibleColumnsWithRowHeader = column.visibleColumnsWithRowHeader, rowHeaderCount = column.rowHeaderCount;
        var pageX = dragData.pageX, pageY = dragData.pageY;
        var curInputRange = selection.inputRange;
        if (curInputRange === null) {
            return;
        }
        var viewInfo = { pageX: pageX, pageY: pageY, scrollTop: scrollTop, scrollLeft: scrollLeft };
        var columnIndex = curInputRange.column[1];
        var startRowIndex = curInputRange.row[0];
        var endRowIndex = mouse_1.findRowIndexByPosition(store, viewInfo);
        _a = rowSpan_1.getRowRangeWithRowSpan([startRowIndex, endRowIndex], [rowHeaderCount, columnIndex], visibleColumnsWithRowHeader, null, data), startRowIndex = _a[0], endRowIndex = _a[1];
        var inputRange = {
            row: [startRowIndex, endRowIndex],
            column: [rowHeaderCount, columnIndex],
        };
        selection_1.changeSelectionRange(selection, inputRange, id);
    }
    exports.dragMoveRowHeader = dragMoveRowHeader;


    /***/ }),
    /* 123 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.refreshRowHeight = exports.removeRowHeight = exports.setCellHeight = exports.setHoveredRowKeyByPosition = exports.setHoveredRowKey = void 0;
    var tslib_1 = __webpack_require__(1);
    var observable_1 = __webpack_require__(5);
    var mouse_1 = __webpack_require__(53);
    var common_1 = __webpack_require__(0);
    function setHoveredRowKey(_a, rowKey) {
        var renderState = _a.renderState;
        renderState.hoveredRowKey = rowKey;
    }
    exports.setHoveredRowKey = setHoveredRowKey;
    function setHoveredRowKeyByPosition(store, viewInfo) {
        var renderState = store.renderState, data = store.data, viewport = store.viewport;
        var scrollLeft = viewport.scrollLeft, scrollTop = viewport.scrollTop;
        var rowIndex = mouse_1.findRowIndexByPosition(store, tslib_1.__assign(tslib_1.__assign({}, viewInfo), { scrollLeft: scrollLeft, scrollTop: scrollTop }));
        var rowKey = data.filteredRawData[rowIndex].rowKey;
        if (renderState.hoveredRowKey !== rowKey) {
            setHoveredRowKey(store, rowKey);
        }
    }
    exports.setHoveredRowKeyByPosition = setHoveredRowKeyByPosition;
    function setCellHeight(_a, columnName, rowIndex, height, defaultRowHeight) {
        var renderState = _a.renderState;
        var cellHeightMap = renderState.cellHeightMap;
        if (!cellHeightMap[rowIndex]) {
            cellHeightMap[rowIndex] = {};
        }
        cellHeightMap[rowIndex][columnName] = Math.max(height, defaultRowHeight);
    }
    exports.setCellHeight = setCellHeight;
    function removeRowHeight(_a, rowIndex) {
        var renderState = _a.renderState;
        var cellHeightMap = renderState.cellHeightMap;
        delete cellHeightMap[rowIndex];
    }
    exports.removeRowHeight = removeRowHeight;
    function refreshRowHeight(store, rowIndex, rowHeight) {
        var data = store.data, rowCoords = store.rowCoords, renderState = store.renderState;
        var cellHeightMap = renderState.cellHeightMap;
        var cellHeights = cellHeightMap[rowIndex];
        if (common_1.isUndefined(cellHeights)) {
            return;
        }
        var highestHeight = Object.keys(cellHeights).reduce(function (acc, columnName) { return Math.max(acc, cellHeights[columnName]); }, -1);
        if (rowHeight !== highestHeight) {
            data.rawData[rowIndex]._attributes.height = highestHeight;
            rowCoords.heights[rowIndex] = highestHeight;
            observable_1.notify(rowCoords, 'heights');
        }
    }
    exports.refreshRowHeight = refreshRowHeight;


    /***/ }),
    /* 124 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.copyRows = exports.copyColumns = exports.copy = exports.hideContextMenu = exports.showContextMenu = void 0;
    var clipboard_1 = __webpack_require__(54);
    var common_1 = __webpack_require__(0);
    var data_1 = __webpack_require__(6);
    function showContextMenu(_a, pos, elementInfo, eventInfo) {
        var contextMenu = _a.contextMenu, data = _a.data, column = _a.column, columnCoords = _a.columnCoords, rowCoords = _a.rowCoords;
        var pageX = eventInfo.pageX, pageY = eventInfo.pageY;
        var visibleColumnsBySideWithRowHeader = column.visibleColumnsBySideWithRowHeader;
        var side = elementInfo.side, scrollLeft = elementInfo.scrollLeft, scrollTop = elementInfo.scrollTop, left = elementInfo.left, top = elementInfo.top;
        var offsetLeft = pageX - left + scrollLeft;
        var offsetTop = pageY - top + scrollTop;
        var columnIndex = common_1.findOffsetIndex(columnCoords.offsets[side], offsetLeft);
        var columnName = visibleColumnsBySideWithRowHeader[side][columnIndex].name;
        var rowIndex = common_1.findOffsetIndex(rowCoords.offsets, offsetTop);
        var rowKey = data_1.getRowKeyByIndexWithPageRange(data, rowIndex);
        contextMenu.posInfo = { pos: pos, rowKey: rowKey, columnName: columnName };
    }
    exports.showContextMenu = showContextMenu;
    function hideContextMenu(_a) {
        var contextMenu = _a.contextMenu;
        contextMenu.posInfo = null;
    }
    exports.hideContextMenu = hideContextMenu;
    function copy(store) {
        clipboard_1.execCopy(store);
    }
    exports.copy = copy;
    function copyColumns(store) {
        var data = store.data, selection = store.selection, focus = store.focus;
        var originalRange = selection.originalRange;
        var columnRange = originalRange
            ? [originalRange.column[0], originalRange.column[1]]
            : [focus.totalColumnIndex, focus.totalColumnIndex];
        var rowRange = [0, data.filteredRawData.length - 1];
        clipboard_1.execCopy(store, { rowRange: rowRange, columnRange: columnRange });
    }
    exports.copyColumns = copyColumns;
    function copyRows(store) {
        var selection = store.selection, focus = store.focus, column = store.column;
        var originalRange = selection.originalRange;
        var columnRange = [0, column.visibleColumnsWithRowHeader.length - 1];
        var rowRange = originalRange
            ? [originalRange.row[0], originalRange.row[1]]
            : [focus.originalRowIndex, focus.originalRowIndex];
        clipboard_1.execCopy(store, { rowRange: rowRange, columnRange: columnRange });
    }
    exports.copyRows = copyRows;


    /***/ }),
    /* 125 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(1);
    var preset_1 = __webpack_require__(126);
    var common_1 = __webpack_require__(0);
    var dom_1 = __webpack_require__(2);
    var styleGen = tslib_1.__importStar(__webpack_require__(127));
    var STYLE_ELEMENT_ID = 'tui-grid-theme-style';
    var presetOptions = {
        default: preset_1.presetDefault,
        striped: preset_1.striped,
        clean: preset_1.clean,
    };
    var styleGenMethodMap = {
        outline: styleGen.outline,
        frozenBorder: styleGen.frozenBorder,
        scrollbar: styleGen.scrollbar,
        heightResizeHandle: styleGen.heightResizeHandle,
        pagination: styleGen.pagination,
        selection: styleGen.selection,
    };
    var styleGenAreaMethodMap = {
        header: styleGen.headerArea,
        body: styleGen.bodyArea,
        summary: styleGen.summaryArea,
    };
    var styleGenRowMethodMap = {
        odd: styleGen.rowOdd,
        even: styleGen.rowEven,
        dummy: styleGen.rowDummy,
        hover: styleGen.rowHover,
    };
    var styleGenCellMethodMap = {
        normal: styleGen.cell,
        editable: styleGen.cellEditable,
        header: styleGen.cellHeader,
        rowHeader: styleGen.cellRowHeader,
        summary: styleGen.cellSummary,
        required: styleGen.cellRequired,
        disabled: styleGen.cellDisabled,
        invalid: styleGen.cellInvalid,
        selectedHeader: styleGen.cellSelectedHeader,
        selectedRowHeader: styleGen.cellSelectedRowHeader,
        focused: styleGen.cellFocused,
        focusedInactive: styleGen.cellFocusedInactive,
        // deprecate
        oddRow: styleGen.rowOdd,
        evenRow: styleGen.rowEven,
        currentRow: styleGen.cellCurrentRow,
        dummy: styleGen.rowDummy,
    };
    function buildCssString(options) {
        var area = options.area, cell = options.cell, row = options.row;
        var styles = [];
        Object.keys(styleGenMethodMap).forEach(function (key) {
            var keyWithType = key;
            var value = options[keyWithType];
            if (value) {
                var fn = styleGen[keyWithType];
                styles.push(fn(value));
            }
        });
        if (area) {
            Object.keys(styleGenAreaMethodMap).forEach(function (key) {
                var keyWithType = key;
                var value = area[keyWithType];
                if (value) {
                    var fn = styleGenAreaMethodMap[keyWithType];
                    styles.push(fn(value));
                }
            });
        }
        if (cell) {
            Object.keys(styleGenCellMethodMap).forEach(function (key) {
                var keyWithType = key;
                var value = cell[keyWithType];
                if (value) {
                    var fn = styleGenCellMethodMap[keyWithType];
                    styles.push(fn(value));
                }
            });
        }
        if (row) {
            // Written later to override the row style in cell style
            Object.keys(styleGenRowMethodMap).forEach(function (key) {
                var keyWithType = key;
                var value = row[keyWithType];
                if (value) {
                    var fn = styleGenRowMethodMap[keyWithType];
                    styles.push(fn(value));
                }
            });
        }
        return styles.join('');
    }
    function setDocumentStyle(options) {
        var cssString = buildCssString(options);
        var elem = document.getElementById(STYLE_ELEMENT_ID);
        if (elem && elem.parentNode) {
            elem.parentNode.removeChild(elem);
        }
        dom_1.appendStyleElement(STYLE_ELEMENT_ID, cssString);
    }
    exports.default = {
        /**
         * Creates a style element using theme options identified by given name,
         * and appends it to the document.
         * @param themeName - preset theme name
         * @param extOptions - if exist, extend preset theme options with it.
         */
        apply: function (themeName, extOptions) {
            var options = presetOptions[themeName];
            if (!options) {
                options = presetOptions['default'];
            }
            if (extOptions) {
                options = common_1.deepMergedCopy(options, extOptions);
            }
            setDocumentStyle(options);
        },
        /**
         * Returns whether the style of a theme is applied.
         */
        isApplied: function () {
            return !!document.getElementById(STYLE_ELEMENT_ID);
        },
    };


    /***/ }),
    /* 126 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.striped = exports.clean = exports.presetDefault = void 0;
    var common_1 = __webpack_require__(0);
    exports.presetDefault = {
        selection: {
            background: '#00A9ff',
            border: '#00a9ff',
        },
        heightResizeHandle: {
            border: '#fff',
            background: '#fff',
        },
        pagination: {
            border: 'transparent',
            background: 'transparent',
        },
        scrollbar: {
            border: '#eee',
            background: '#fff',
            emptySpace: '#f9f9f9',
            thumb: '#ddd',
            active: '#ddd',
        },
        outline: {
            border: '#aaa',
            showVerticalBorder: false,
        },
        frozenBorder: {
            border: '#aaa',
        },
        area: {
            header: {
                border: '#ccc',
                background: '#fff',
            },
            body: {
                background: '#fff',
            },
            summary: {
                border: '#eee',
                background: '#fff',
            },
        },
        cell: {
            normal: {
                background: '#f4f4f4',
                border: '#eee',
                text: '#333',
                showVerticalBorder: false,
                showHorizontalBorder: true,
            },
            header: {
                background: '#fff',
                border: '#eee',
                text: '#222',
                showVerticalBorder: true,
                showHorizontalBorder: true,
            },
            rowHeader: {
                background: '#fff',
                border: '#eee',
                text: '#333',
                showVerticalBorder: false,
                showHorizontalBorder: true,
            },
            summary: {
                background: '#fff',
                border: '#eee',
                text: '#333',
                showVerticalBorder: false,
            },
            selectedHeader: {
                background: '#e5f6ff',
            },
            selectedRowHeader: {
                background: '#e5f6ff',
            },
            focused: {
                border: '#00a9ff',
            },
            focusedInactive: {
                border: '#aaa',
            },
            required: {
                background: '#fffdeb',
            },
            editable: {
                background: '#fff',
            },
            disabled: {
                background: '#f9f9f9',
                text: '#c1c1c1',
            },
            dummy: {
                background: '#fff',
            },
            invalid: {
                background: '#ffe5e5',
            },
            evenRow: {},
            oddRow: {},
            currentRow: {},
        },
        rowHover: {
            background: 'none',
        },
    };
    exports.clean = common_1.deepMergedCopy(exports.presetDefault, {
        outline: {
            border: '#eee',
            showVerticalBorder: false,
        },
        frozenBorder: {
            border: '#ddd',
        },
        area: {
            header: {
                border: '#eee',
                background: '#f9f9f9',
            },
            body: {
                background: '#fff',
            },
            summary: {
                border: '#fff',
                background: '#fff',
            },
        },
        cell: {
            normal: {
                background: '#fff',
                border: '#eee',
                showVerticalBorder: false,
                showHorizontalBorder: false,
            },
            header: {
                background: '#f9f9f9',
                border: '#eee',
                showVerticalBorder: true,
                showHorizontalBorder: true,
            },
            rowHeader: {
                border: '#eee',
                showVerticalBorder: false,
                showHorizontalBorder: false,
            },
        },
    });
    exports.striped = common_1.deepMergedCopy(exports.presetDefault, {
        outline: {
            border: '#eee',
            showVerticalBorder: false,
        },
        frozenBorder: {
            border: '#ccc',
        },
        area: {
            header: {
                border: '#fff',
                background: '#eee',
            },
            body: {
                background: '#fff',
            },
            summary: {
                border: '#fff',
                background: '#fff',
            },
        },
        cell: {
            normal: {
                background: '#fff',
                border: '#fff',
                showVerticalBorder: false,
                showHorizontalBorder: false,
            },
            header: {
                background: '#eee',
                border: '#fff',
                showVerticalBorder: true,
                showHorizontalBorder: true,
            },
            rowHeader: {
                border: '#fff',
                showVerticalBorder: false,
                showHorizontalBorder: false,
            },
            oddRow: {
                background: '#fff',
            },
            evenRow: {
                background: '#f4f4f4',
            },
        },
    });


    /***/ }),
    /* 127 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cellCurrentRow = exports.cellInvalid = exports.cellDisabled = exports.cellRequired = exports.cellEditable = exports.cellFocusedInactive = exports.cellFocused = exports.cellSelectedRowHeader = exports.cellSelectedHeader = exports.rowDummy = exports.rowHover = exports.rowOdd = exports.rowEven = exports.cellSummary = exports.cellRowHeader = exports.cellHeader = exports.cell = exports.summaryArea = exports.bodyArea = exports.headerArea = exports.selection = exports.pagination = exports.heightResizeHandle = exports.scrollbar = exports.frozenBorder = exports.outline = void 0;
    var tslib_1 = __webpack_require__(1);
    var dom_1 = __webpack_require__(2);
    var cssRuleBuilder_1 = __webpack_require__(128);
    function bgTextRuleString(className, options) {
        var background = options.background, text = options.text;
        return cssRuleBuilder_1.createClassRule(className).bg(background).text(text).build();
    }
    function bgBorderRuleString(className, options) {
        var background = options.background, border = options.border;
        return cssRuleBuilder_1.createClassRule(className).bg(background).border(border).build();
    }
    function outline(options) {
        var border = options.border, showVerticalBorder = options.showVerticalBorder;
        var borderTopRule = cssRuleBuilder_1.createClassRule('border-line-top').add('border-top', "1px solid " + border);
        var borderBottomRule = cssRuleBuilder_1.createNestedClassRule(' .', ['no-scroll-x', 'border-line-bottom']).add('border-bottom', "1px solid " + border);
        var rules = [borderTopRule, borderBottomRule];
        var borderLeftRule, borderRightRule;
        if (showVerticalBorder) {
            borderLeftRule = cssRuleBuilder_1.createClassRule('border-line-left').add('border-left', "1px solid " + border);
            borderRightRule = cssRuleBuilder_1.createNestedClassRule(' .', ['no-scroll-y', 'border-line-right']).add('border-right', "1px solid " + border);
            rules = rules.concat([borderLeftRule, borderRightRule]);
        }
        return cssRuleBuilder_1.buildAll(rules);
    }
    exports.outline = outline;
    function frozenBorder(options) {
        return cssRuleBuilder_1.createClassRule('frozen-border').bg(options.border).build();
    }
    exports.frozenBorder = frozenBorder;
    function scrollbar(options) {
        var border = options.border, emptySpace = options.emptySpace;
        var webkitScrollbarRules = cssRuleBuilder_1.createWebkitScrollbarRules("." + dom_1.cls('container'), options);
        var ieScrollbarRule = cssRuleBuilder_1.createIEScrollbarRule("." + dom_1.cls('container'), options);
        var xInnerBorderRule = cssRuleBuilder_1.createClassRule('border-line-bottom').add('border-bottom', "1px solid " + border);
        var xOuterBorderRule = cssRuleBuilder_1.createClassRule('content-area').border(border);
        var yInnerBorderRule = cssRuleBuilder_1.createClassRule('scrollbar-y-inner-border').bg(border);
        var yOuterBorderRule = cssRuleBuilder_1.createClassRule('scrollbar-y-outer-border').bg(border);
        var spaceRightTopRule = cssRuleBuilder_1.createClassRule('scrollbar-right-top').bg(emptySpace).border(border);
        var spaceRightBottomRule = cssRuleBuilder_1.createClassRule('scrollbar-right-bottom')
            .bg(emptySpace)
            .border(border);
        var spaceLeftBottomRule = cssRuleBuilder_1.createClassRule('scrollbar-left-bottom')
            .bg(emptySpace)
            .border(border);
        var frozenBorderRule = cssRuleBuilder_1.createClassRule('scrollbar-frozen-border').bg(emptySpace).border(border);
        return cssRuleBuilder_1.buildAll(tslib_1.__spreadArrays(webkitScrollbarRules, [
            ieScrollbarRule,
            xInnerBorderRule,
            xOuterBorderRule,
            yInnerBorderRule,
            yOuterBorderRule,
            spaceRightTopRule,
            spaceRightBottomRule,
            spaceLeftBottomRule,
            frozenBorderRule,
        ]));
    }
    exports.scrollbar = scrollbar;
    function heightResizeHandle(options) {
        return bgBorderRuleString('height-resize-handle', options);
    }
    exports.heightResizeHandle = heightResizeHandle;
    function pagination(options) {
        return bgBorderRuleString('pagination', options);
    }
    exports.pagination = pagination;
    function selection(options) {
        return bgBorderRuleString('layer-selection', options);
    }
    exports.selection = selection;
    function headerArea(options) {
        return cssRuleBuilder_1.createClassRule('header-area').bg(options.background).border(options.border).build();
    }
    exports.headerArea = headerArea;
    function bodyArea(options) {
        return cssRuleBuilder_1.createClassRule('body-area').bg(options.background).build();
    }
    exports.bodyArea = bodyArea;
    function summaryArea(options) {
        var border = options.border, background = options.background;
        var contentAreaRule = cssRuleBuilder_1.createClassRule('summary-area').bg(background).border(border);
        var bodyAreaRule = cssRuleBuilder_1.createNestedClassRule(' .', ['has-summary-top', 'body-area']).border(border);
        return cssRuleBuilder_1.buildAll([contentAreaRule, bodyAreaRule]);
    }
    exports.summaryArea = summaryArea;
    function cell(options) {
        return cssRuleBuilder_1.createClassRule('cell')
            .bg(options.background)
            .border(options.border)
            .borderWidth(options)
            .text(options.text)
            .build();
    }
    exports.cell = cell;
    function cellHeader(options) {
        var background = options.background, border = options.border, text = options.text;
        var tableRule = cssRuleBuilder_1.createNestedClassRule(' .', [
            'show-lside-area',
            'lside-area',
            'header-area',
            'table',
        ]).verticalBorderStyle(options, 'right');
        var cellRule = cssRuleBuilder_1.createClassRule('cell-header')
            .bg(background)
            .border(border)
            .borderWidth(options)
            .text(text);
        return cssRuleBuilder_1.buildAll([tableRule, cellRule]);
    }
    exports.cellHeader = cellHeader;
    function cellRowHeader(options) {
        var background = options.background, border = options.border, text = options.text;
        var tableRule = cssRuleBuilder_1.createNestedClassRule(' .', [
            'show-lside-area',
            'lside-area',
            'body-area',
            'table',
        ]).verticalBorderStyle(options, 'right');
        var cellRule = cssRuleBuilder_1.createClassRule('cell-row-header')
            .bg(background)
            .border(border)
            .borderWidth(options)
            .text(text);
        return cssRuleBuilder_1.buildAll([tableRule, cellRule]);
    }
    exports.cellRowHeader = cellRowHeader;
    function cellSummary(options) {
        var background = options.background, border = options.border, text = options.text;
        var tableRule = cssRuleBuilder_1.createNestedClassRule(' .', [
            'show-lside-area',
            'lside-area',
            'summary-area',
            'table',
        ]).verticalBorderStyle(options, 'right');
        var cellRule = cssRuleBuilder_1.createClassRule('cell-summary')
            .bg(background)
            .border(border)
            .borderWidth(options)
            .text(text);
        return cssRuleBuilder_1.buildAll([tableRule, cellRule]);
    }
    exports.cellSummary = cellSummary;
    function rowEven(options) {
        return cssRuleBuilder_1.create('.tui-grid-row-even>td').bg(options.background).build();
    }
    exports.rowEven = rowEven;
    function rowOdd(options) {
        return cssRuleBuilder_1.create('.tui-grid-row-odd>td').bg(options.background).build();
    }
    exports.rowOdd = rowOdd;
    function rowHover(options) {
        return cssRuleBuilder_1.create('.tui-grid-row-hover>.tui-grid-cell').bg(options.background).build();
    }
    exports.rowHover = rowHover;
    function rowDummy(options) {
        return bgTextRuleString('cell-dummy', options);
    }
    exports.rowDummy = rowDummy;
    function cellSelectedHeader(options) {
        return cssRuleBuilder_1.createNestedClassRule('.', ['cell-header', 'cell-selected'])
            .bg(options.background)
            .text(options.text)
            .build();
    }
    exports.cellSelectedHeader = cellSelectedHeader;
    function cellSelectedRowHeader(options) {
        return cssRuleBuilder_1.createNestedClassRule('.', ['cell-row-header', 'cell-selected'])
            .bg(options.background)
            .text(options.text)
            .build();
    }
    exports.cellSelectedRowHeader = cellSelectedRowHeader;
    function cellFocused(options) {
        var border = options.border;
        var focusLayerRule = cssRuleBuilder_1.createClassRule('layer-focus-border').bg(border);
        var editingLayerRule = cssRuleBuilder_1.createClassRule('layer-editing').border(border);
        return cssRuleBuilder_1.buildAll([focusLayerRule, editingLayerRule]);
    }
    exports.cellFocused = cellFocused;
    function cellFocusedInactive(options) {
        return cssRuleBuilder_1.createNestedClassRule(' .', ['layer-focus-deactive', 'layer-focus-border'])
            .bg(options.border)
            .build();
    }
    exports.cellFocusedInactive = cellFocusedInactive;
    function cellEditable(options) {
        return bgTextRuleString('cell-editable', options);
    }
    exports.cellEditable = cellEditable;
    function cellRequired(options) {
        return bgTextRuleString('cell-required', options);
    }
    exports.cellRequired = cellRequired;
    function cellDisabled(options) {
        return bgTextRuleString('cell-disabled', options);
    }
    exports.cellDisabled = cellDisabled;
    function cellInvalid(options) {
        var background = options.background, text = options.text;
        return cssRuleBuilder_1.createNestedClassRule('.', ['cell-invalid', 'cell']).bg(background).text(text).build();
    }
    exports.cellInvalid = cellInvalid;
    function cellCurrentRow(options) {
        return bgTextRuleString('cell-current-row', options);
    }
    exports.cellCurrentRow = cellCurrentRow;


    /***/ }),
    /* 128 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildAll = exports.createIEScrollbarRule = exports.createWebkitScrollbarRules = exports.createNestedClassRule = exports.createClassRule = exports.create = void 0;
    var dom_1 = __webpack_require__(2);
    var common_1 = __webpack_require__(0);
    /**
     * create css rule string and returns it
     * @module {theme/cssBuilder}
     * @param selector - css selector
     * @param property - css property
     * @param  value - css value
     * @ignore
     */
    var CSSRuleBuilder = /** @class */ (function () {
        function CSSRuleBuilder(selector) {
            this.selector = '';
            this.propValues = [];
            this.init(selector);
        }
        CSSRuleBuilder.prototype.init = function (selector) {
            if (!(typeof selector === 'string') || !selector) {
                throw new Error('The Selector must be a string and not be empty.');
            }
            this.selector = selector;
            this.propValues = [];
        };
        /**
         * Add a set of css property and value.
         * @param property - css property
         * @param  value - css value
         */
        CSSRuleBuilder.prototype.add = function (property, value) {
            if (value) {
                this.propValues.push(property + ":" + value);
            }
            return this;
        };
        /**
         * Shortcut for add('border-color', value)
         */
        CSSRuleBuilder.prototype.border = function (value) {
            return this.add('border-color', value);
        };
        /**
         * Add a border-width style to the rule.
         * @param options - visible options
         * @param [options.showVerticalBorder] - whether the vertical border is visible
         * @param [options.showHorizontalBorder] - whether the horizontal border is visible
         */
        CSSRuleBuilder.prototype.borderWidth = function (options) {
            var vertical = options.showVerticalBorder;
            var horizontal = options.showHorizontalBorder;
            var value;
            if (common_1.isBoolean(vertical)) {
                value = vertical ? '1px' : '0';
                this.add('border-left-width', value).add('border-right-width', value);
            }
            if (common_1.isBoolean(horizontal)) {
                value = horizontal ? '1px' : '0';
                this.add('border-top-width', value).add('border-bottom-width', value);
            }
            return this;
        };
        /**
         * Add a vertical border style to the rule.
         * @param options - visible options
         * @param [options.showVerticalBorder] - whether the vertical border is visible
         * @param position - Position of the vertical border ('right' or 'left')
         */
        CSSRuleBuilder.prototype.verticalBorderStyle = function (options, position) {
            var vertical = options.showVerticalBorder;
            var value;
            if (common_1.isBoolean(vertical) && position) {
                value = vertical ? 'solid' : 'hidden';
                this.add("border-" + position + "-style", value);
            }
            return this;
        };
        /**
         * Shortcut for add('background-color', value)
         */
        CSSRuleBuilder.prototype.bg = function (value) {
            return this.add('background-color', value);
        };
        /**
         * Shortcut for add('color', value)
         */
        CSSRuleBuilder.prototype.text = function (value) {
            return this.add('color', value);
        };
        /**
         * Create a CSS rule string with a selector and prop-values.
         */
        CSSRuleBuilder.prototype.build = function () {
            var result = '';
            if (this.propValues.length) {
                result = this.selector + "{" + this.propValues.join(';') + "}";
            }
            return result;
        };
        return CSSRuleBuilder;
    }());
    /**
     * Creates new Builder instance.
     */
    function create(selector) {
        return new CSSRuleBuilder(selector);
    }
    exports.create = create;
    /**
     * Creates a new Builder instance with a class name selector.
     */
    function createClassRule(className) {
        return create("." + dom_1.cls(className));
    }
    exports.createClassRule = createClassRule;
    /**
     * Creates a new Builder instance with a nested class name.
     * @param selector - selector to compose class names
     * @param classNames - classNames
     */
    function createNestedClassRule(selector, classNames) {
        return create("." + classNames.map(function (className) { return dom_1.cls(className); }).join(selector));
    }
    exports.createNestedClassRule = createNestedClassRule;
    /**
     * Creates an array of new Builder instances for the -webkit-scrollbar styles.
     */
    function createWebkitScrollbarRules(selector, options) {
        return [
            create(selector + " ::-webkit-scrollbar").bg(options.background),
            create(selector + " ::-webkit-scrollbar-thumb").bg(options.thumb),
            create(selector + " ::-webkit-scrollbar-thumb:hover").bg(options.active),
        ];
    }
    exports.createWebkitScrollbarRules = createWebkitScrollbarRules;
    /**
     * Creates a builder instance for the IE scrollbar styles.
     */
    function createIEScrollbarRule(selector, options) {
        var bgProps = [
            'scrollbar-3dlight-color',
            'scrollbar-darkshadow-color',
            'scrollbar-track-color',
            'scrollbar-shadow-color',
        ];
        var thumbProps = ['scrollbar-face-color', 'scrollbar-highlight-color'];
        var ieScrollbarRule = create(selector);
        bgProps.forEach(function (prop) {
            ieScrollbarRule.add(prop, options.background);
        });
        thumbProps.forEach(function (prop) {
            ieScrollbarRule.add(prop, options.thumb);
        });
        ieScrollbarRule.add('scrollbar-arrow-color', options.active);
        return ieScrollbarRule;
    }
    exports.createIEScrollbarRule = createIEScrollbarRule;
    /**
     * Build all rules and returns the concatenated string.
     */
    function buildAll(rules) {
        return rules
            .map(function (rule) {
            return rule.build();
        })
            .join('');
    }
    exports.buildAll = buildAll;


    /***/ }),
    /* 129 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getInvalidRows = void 0;
    var lazyObservable_1 = __webpack_require__(27);
    function getInvalidRows(store) {
        // @TODO: find more practical way to make observable
        lazyObservable_1.createObservableData(store, true);
        var data = store.data, column = store.column;
        var invalidRows = [];
        data.viewData.forEach(function (_a) {
            var rowKey = _a.rowKey, valueMap = _a.valueMap;
            var invalidColumns = column.validationColumns.filter(function (_a) {
                var name = _a.name;
                return !!valueMap[name].invalidStates.length;
            });
            if (invalidColumns.length) {
                var errors = invalidColumns.map(function (_a) {
                    var name = _a.name;
                    var invalidStates = valueMap[name].invalidStates;
                    return {
                        columnName: name,
                        errorInfo: invalidStates,
                        errorCode: invalidStates.map(function (_a) {
                            var code = _a.code;
                            return code;
                        }),
                    };
                });
                invalidRows.push({ rowKey: rowKey, errors: errors });
            }
        });
        return invalidRows;
    }
    exports.getInvalidRows = getInvalidRows;


    /***/ }),
    /* 130 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createProvider = void 0;
    var common_1 = __webpack_require__(0);
    var mutationRequest_1 = __webpack_require__(131);
    var getterRequest_1 = __webpack_require__(134);
    var ajaxConfig_1 = __webpack_require__(38);
    function createConfig(store, dispatch, dataSource) {
        var lastRequiredData = { perPage: store.data.pageOptions.perPage };
        var requestParams = {};
        var api = dataSource.api, _a = dataSource.hideLoadingBar, hideLoadingBar = _a === void 0 ? false : _a;
        var ajaxConfig = ajaxConfig_1.createAjaxConfig(dataSource);
        Object.keys(api).forEach(function (key) {
            api[key] = common_1.deepMergedCopy(ajaxConfig, api[key]);
        });
        var getLastRequiredData = function () { return lastRequiredData; };
        var setLastRequiredData = function (params) {
            lastRequiredData = params;
        };
        var getRequestParams = function () { return requestParams; };
        var setRequestParams = function (params) {
            requestParams = params;
        };
        return {
            api: api,
            hideLoadingBar: hideLoadingBar,
            store: store,
            dispatch: dispatch,
            setLastRequiredData: setLastRequiredData,
            getLastRequiredData: getLastRequiredData,
            setRequestParams: setRequestParams,
            getRequestParams: getRequestParams,
        };
    }
    function createFallbackProvider() {
        // dummy function
        var errorFn = function () {
            throw new Error('Cannot execute server side API. To use this API, DataSource should be set');
        };
        return {
            request: errorFn,
            readData: errorFn,
            reloadData: errorFn,
            setRequestParams: errorFn,
            sort: errorFn,
            unsort: errorFn,
        };
    }
    function createProvider(store, dispatch, data) {
        var provider = createFallbackProvider();
        if (!Array.isArray(data) && common_1.isObject(data)) {
            var api = data.api, _a = data.initialRequest, initialRequest = _a === void 0 ? true : _a;
            if (!common_1.isObject(api === null || api === void 0 ? void 0 : api.readData)) {
                throw new Error('GET API should be configured in DataSource to get data');
            }
            var config = createConfig(store, dispatch, data);
            // set curried function
            provider.request = mutationRequest_1.request.bind(null, config);
            provider.readData = getterRequest_1.readData.bind(null, config);
            provider.reloadData = getterRequest_1.reloadData.bind(null, config);
            provider.sort = getterRequest_1.sort.bind(null, config);
            provider.unsort = getterRequest_1.unsort.bind(null, config);
            provider.setRequestParams = config.setRequestParams;
            if (initialRequest) {
                getterRequest_1.readData(config, 1, api.readData.initParams);
            }
        }
        return provider;
    }
    exports.createProvider = createProvider;


    /***/ }),
    /* 131 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.request = void 0;
    var tslib_1 = __webpack_require__(1);
    var common_1 = __webpack_require__(0);
    var gridAjax_1 = __webpack_require__(55);
    var eventBus_1 = __webpack_require__(8);
    var instance_1 = __webpack_require__(7);
    var modifiedDataManager_1 = __webpack_require__(56);
    var data_1 = __webpack_require__(6);
    var confirm_1 = __webpack_require__(133);
    var ajaxConfig_1 = __webpack_require__(38);
    var requestTypeCodeMap = {
        createData: 'CREATE',
        updateData: 'UPDATE',
        deleteData: 'DELETE',
        modifyData: 'MODIFY',
    };
    function createRequestParams(store, type, requestOptions) {
        var column = store.column, data = store.data, id = store.id;
        var checkedOnly = requestOptions.checkedOnly, modifiedOnly = requestOptions.modifiedOnly;
        var modifiedOptions = { checkedOnly: checkedOnly, ignoredColumns: column.ignoredColumns };
        if (modifiedOnly) {
            var manager = instance_1.getDataManager(id);
            return type === 'MODIFY'
                ? manager.getAllModifiedData(modifiedOptions)
                : manager.getModifiedData(type, modifiedOptions);
        }
        return { rows: modifiedDataManager_1.getDataWithOptions(data.rawData, modifiedOptions) };
    }
    function createRequestOptions(ajaxConfig, requestOptions) {
        if (requestOptions === void 0) { requestOptions = {}; }
        var defaultOptions = {
            checkedOnly: false,
            modifiedOnly: true,
            showConfirm: true,
            withCredentials: ajaxConfig.withCredentials,
        };
        return tslib_1.__assign(tslib_1.__assign({}, defaultOptions), requestOptions);
    }
    function send(config, sendOptions) {
        var store = config.store, dispatch = config.dispatch, hideLoadingBar = config.hideLoadingBar, getRequestParams = config.getRequestParams;
        var id = store.id;
        var commonRequestParams = getRequestParams();
        var manager = instance_1.getDataManager(id);
        var url = sendOptions.url, method = sendOptions.method, options = sendOptions.options, params = sendOptions.params, requestTypeCode = sendOptions.requestTypeCode, ajaxConfig = sendOptions.ajaxConfig;
        var showConfirm = options.showConfirm, withCredentials = options.withCredentials;
        if (!showConfirm || confirm_1.confirmMutation(requestTypeCode, params)) {
            var callback = function () { return dispatch('setLoadingState', data_1.getLoadingState(store.data.rawData)); };
            if (!hideLoadingBar) {
                dispatch('setLoadingState', 'LOADING');
            }
            gridAjax_1.gridAjax(tslib_1.__assign(tslib_1.__assign({ method: method, url: common_1.isFunction(url) ? url() : url, params: tslib_1.__assign(tslib_1.__assign({}, commonRequestParams), params), success: function () { return manager.clearSpecificRows(params); }, preCallback: callback, postCallback: callback, eventBus: eventBus_1.getEventBus(id) }, ajaxConfig), { withCredentials: common_1.isUndefined(withCredentials) ? ajaxConfig.withCredentials : withCredentials }));
        }
    }
    function request(config, requestType, requestOptions) {
        var _a, _b;
        var store = config.store, api = config.api;
        var url = requestOptions.url || ((_a = api[requestType]) === null || _a === void 0 ? void 0 : _a.url);
        var method = requestOptions.method || ((_b = api[requestType]) === null || _b === void 0 ? void 0 : _b.method);
        if (!url || !method) {
            throw new Error('url and method should be essential for request.');
        }
        var requestTypeCode = requestTypeCodeMap[requestType];
        var ajaxConfig = ajaxConfig_1.createAjaxConfig(api[requestType] || {});
        var options = createRequestOptions(ajaxConfig, requestOptions);
        var params = createRequestParams(store, requestTypeCode, options);
        send(config, { url: url, method: method, options: options, params: params, requestTypeCode: requestTypeCode, ajaxConfig: ajaxConfig });
    }
    exports.request = request;


    /***/ }),
    /* 132 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serialize = void 0;
    var common_1 = __webpack_require__(0);
    /**
     * 1. Array format
     *
     * The default array format to serialize is 'bracket'.
     * However in case of nested array, only the deepest format follows the 'bracket', the rest follow 'indice' format.
     *
     * - basic
     *   { a: [1, 2, 3] } => a[]=1&a[]=2&a[]=3
     * - nested
     *   { a: [1, 2, [3]] } => a[]=1&a[]=2&a[2][]=3
     *
     * 2. Object format
     *
     * The default object format to serialize is 'bracket' notation and doesn't allow the 'dot' notation.
     *
     * - basic
     *   { a: { b: 1, c: 2 } } => a[b]=1&a[c]=2
     */
    function encodePairs(key, value) {
        return encodeURIComponent(key) + "=" + encodeURIComponent(common_1.isNil(value) ? '' : value);
    }
    function serializeParams(key, value, serializedList) {
        if (Array.isArray(value)) {
            value.forEach(function (arrVal, index) {
                serializeParams(key + "[" + (common_1.isObject(arrVal) ? index : '') + "]", arrVal, serializedList);
            });
        }
        else if (common_1.isObject(value)) {
            Object.keys(value).forEach(function (objKey) {
                serializeParams(key + "[" + objKey + "]", value[objKey], serializedList);
            });
        }
        else {
            serializedList.push(encodePairs(key, value));
        }
    }
    function serialize(params) {
        if (!params || common_1.isEmpty(params)) {
            return '';
        }
        var serializedList = [];
        Object.keys(params).forEach(function (key) {
            serializeParams(key, params[key], serializedList);
        });
        return serializedList.join('&');
    }
    exports.serialize = serialize;


    /***/ }),
    /* 133 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.confirmMutation = void 0;
    var message_1 = __webpack_require__(57);
    function confirmMutation(type, params) {
        var count = Object.keys(params).reduce(function (acc, key) { return acc + params[key].length; }, 0);
        return count ? confirm(message_1.getConfirmMessage(type, count)) : alert(message_1.getAlertMessage(type));
    }
    exports.confirmMutation = confirmMutation;


    /***/ }),
    /* 134 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unsort = exports.sort = exports.reloadData = exports.readData = void 0;
    var tslib_1 = __webpack_require__(1);
    var tree_1 = __webpack_require__(30);
    var tree_2 = __webpack_require__(22);
    var common_1 = __webpack_require__(0);
    var gridAjax_1 = __webpack_require__(55);
    var eventBus_1 = __webpack_require__(8);
    var data_1 = __webpack_require__(6);
    var ajaxConfig_1 = __webpack_require__(38);
    var sort_1 = __webpack_require__(28);
    var sort_2 = __webpack_require__(42);
    function validateResponse(responseData) {
        if (common_1.isUndefined(responseData)) {
            throw new Error('The response data is empty to rerender grid');
        }
    }
    function handleSuccessReadData(config, response) {
        var dispatch = config.dispatch, getLastRequiredData = config.getLastRequiredData, store = config.store;
        var responseData = response.data;
        var _a = getLastRequiredData(), perPage = _a.perPage, _b = _a.sortColumn, sortColumn = _b === void 0 ? 'sortKey' : _b, _c = _a.sortAscending, sortAscending = _c === void 0 ? true : _c;
        validateResponse(responseData);
        var contents = responseData.contents, pagination = responseData.pagination;
        if (data_1.isScrollPagination(store.data)) {
            dispatch('appendRows', contents);
        }
        else {
            var options = {};
            if (sortColumn !== 'sortKey') {
                options.sortState = { columnName: sortColumn, ascending: sortAscending, multiple: true };
            }
            dispatch('resetData', contents, options);
        }
        if (pagination) {
            dispatch('updatePageOptions', tslib_1.__assign(tslib_1.__assign({}, pagination), { perPage: perPage }));
        }
    }
    function handleSuccessReadTreeData(config, response) {
        var dispatch = config.dispatch, store = config.store, getLastRequiredData = config.getLastRequiredData;
        var responseData = response.data;
        validateResponse(responseData);
        var parentRowKey = getLastRequiredData().parentRowKey;
        var column = store.column, id = store.id, data = store.data;
        responseData.contents.forEach(function (row) { return dispatch('appendTreeRow', row, { parentRowKey: parentRowKey }); });
        var row = data_1.findRowByRowKey(data, column, id, parentRowKey);
        if (row && !tree_2.getChildRowKeys(row).length) {
            tree_1.removeExpandedAttr(row);
        }
    }
    function readData(config, page, data, resetData) {
        if (data === void 0) { data = {}; }
        if (resetData === void 0) { resetData = false; }
        var store = config.store, getLastRequiredData = config.getLastRequiredData;
        var lastRequiredData = getLastRequiredData();
        var treeColumnName = store.column.treeColumnName;
        var perPage = store.data.pageOptions.perPage;
        var params = resetData ? tslib_1.__assign(tslib_1.__assign({ perPage: perPage }, data), { page: page }) : tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, lastRequiredData), data), { page: page });
        var successCallback = handleSuccessReadData;
        if (treeColumnName && !common_1.isUndefined(data.parentRowKey)) {
            successCallback = handleSuccessReadTreeData;
            delete params.page;
            delete params.perPage;
        }
        sendRequest(config, params, successCallback);
    }
    exports.readData = readData;
    function reloadData(config) {
        readData(config, config.getLastRequiredData().page || 1);
    }
    exports.reloadData = reloadData;
    function sort(config, sortColumn, sortAscending, cancelable) {
        var store = config.store;
        var cancelSort = sort_2.isCancelSort(store, sortColumn, sortAscending, cancelable);
        var gridEvent = sort_1.emitBeforeSort(store, cancelSort, {
            columnName: sortColumn,
            ascending: sortAscending,
            multiple: false,
        });
        if (gridEvent.isStopped()) {
            return;
        }
        var params = { perPage: store.data.pageOptions.perPage, page: 1 };
        if (!cancelSort) {
            params.sortColumn = sortColumn;
            params.sortAscending = sortAscending;
        }
        var successCallback = function (successConfig, response) {
            handleSuccessReadData(successConfig, response);
            sort_1.emitAfterSort(store, cancelSort, sortColumn);
        };
        sendRequest(config, params, successCallback);
    }
    exports.sort = sort;
    function unsort(config, sortColumn) {
        if (sortColumn === void 0) { sortColumn = 'sortKey'; }
        var store = config.store;
        var gridEvent = sort_1.emitBeforeSort(store, true, {
            columnName: sortColumn,
            multiple: false,
        });
        if (gridEvent.isStopped()) {
            return;
        }
        var params = { perPage: store.data.pageOptions.perPage, page: 1 };
        var successCallback = function (successConfig, response) {
            handleSuccessReadData(successConfig, response);
            sort_1.emitAfterSort(store, true, sortColumn);
        };
        sendRequest(config, params, successCallback);
    }
    exports.unsort = unsort;
    function sendRequest(config, params, successCallback) {
        var store = config.store, dispatch = config.dispatch, api = config.api, setLastRequiredData = config.setLastRequiredData, hideLoadingBar = config.hideLoadingBar, getRequestParams = config.getRequestParams;
        var commonRequestParams = getRequestParams();
        var ajaxConfig = ajaxConfig_1.createAjaxConfig(api.readData);
        var _a = api.readData, method = _a.method, url = _a.url;
        var callback = function () { return dispatch('setLoadingState', data_1.getLoadingState(store.data.rawData)); };
        setLastRequiredData(params);
        if (!hideLoadingBar) {
            dispatch('setLoadingState', 'LOADING');
        }
        gridAjax_1.gridAjax(tslib_1.__assign({ method: method, url: common_1.isFunction(url) ? url() : url, params: tslib_1.__assign(tslib_1.__assign({}, commonRequestParams), params), success: successCallback.bind(null, config), preCallback: callback, postCallback: callback, eventBus: eventBus_1.getEventBus(store.id) }, ajaxConfig));
    }


    /***/ }),
    /* 135 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createPaginationManager = void 0;
    function createPaginationManager() {
        var pagination = null;
        return {
            setPagination: function (targetPagination) {
                pagination = targetPagination;
            },
            getPagination: function () {
                return pagination;
            },
        };
    }
    exports.createPaginationManager = createPaginationManager;


    /***/ }),
    /* 136 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sendHostname = void 0;
    var MS_7_DAYS = 7 * 24 * 60 * 60 * 1000;
    function isExpired(date) {
        var now = new Date().getTime();
        return now - date > MS_7_DAYS;
    }
    function imagePing(url, trackingInfo) {
        var queryString = Object.keys(trackingInfo)
            .map(function (id, index) {
            var idWithType = id;
            return "" + (index ? '&' : '') + idWithType + "=" + trackingInfo[idWithType];
        })
            .join('');
        var trackingElement = document.createElement('img');
        trackingElement.src = url + "?" + queryString;
        trackingElement.style.display = 'none';
        document.body.appendChild(trackingElement);
        document.body.removeChild(trackingElement);
        return trackingElement;
    }
    function sendHostname() {
        var hostname = location.hostname;
        var applicationKeyForStorage = "TOAST UI grid for " + hostname + ": Statistics";
        var date = window.localStorage.getItem(applicationKeyForStorage);
        if (date && !isExpired(Number(date))) {
            return;
        }
        window.localStorage.setItem(applicationKeyForStorage, String(new Date().getTime()));
        setTimeout(function () {
            if (document.readyState === 'interactive' || document.readyState === 'complete') {
                imagePing('https://www.google-analytics.com/collect', {
                    v: 1,
                    t: 'event',
                    tid: 'UA-129951906-1',
                    cid: hostname,
                    dp: hostname,
                    dh: 'grid',
                    el: 'grid',
                    ec: 'use',
                });
            }
        }, 1000);
    }
    exports.sendHostname = sendHostname;


    /***/ }),
    /* 137 */
    /***/ (function(module, exports, __webpack_require__) {

    // extracted by mini-css-extract-plugin

    /***/ })
    /******/ ]);
    });
    }(tuiGrid));

    var Grid = /*@__PURE__*/getDefaultExportFromCjs(tuiGrid.exports);

    const findIndex = findIndex$5(propEq$1('active', true));
    function useDataTypeHint(props, ctx) {
        const contextRef = useContext(ctx);
        const { unmountedGroup } = useUnmounted();
        const state = observable$1({
            hints: [],
            isFilter: true,
        });
        const getDataTypeHints = () => {
            const { store: { canvasState }, } = contextRef.value.api;
            const databaseHint = databaseHints.find(databaseHint => databaseHint.database === canvasState.database);
            return databaseHint ? databaseHint.dataTypeHints : [];
        };
        const getActiveIndex = () => findIndex(state.hints);
        const setHints = () => {
            if (!state.isFilter)
                return;
            const dataTypeHints = getDataTypeHints();
            state.hints =
                props.value.trim() === ''
                    ? dataTypeHints.map(dataTypeHint => ({
                        name: dataTypeHint.name,
                        html: dataTypeHint.name,
                        active: false,
                    }))
                    : dataTypeHints
                        .filter(dataTypeHint => dataTypeHint.name
                        .toLowerCase()
                        .indexOf(props.value.toLowerCase()) !== -1)
                        .map(dataTypeHint => {
                        return {
                            name: dataTypeHint.name,
                            html: markToHTML('vuerd-grid-column-data-type-hint-mark', dataTypeHint.name, props.value),
                            active: false,
                        };
                    });
        };
        const activeEnd = () => {
            state.hints.forEach(hint => (hint.active = false));
        };
        const onSelectHint = (hint) => {
            activeEnd();
            state.isFilter = false;
            props.value = hint.name;
        };
        const onArrowUp = (event) => {
            state.hints.length !== 0 && event.preventDefault();
            const index = getActiveIndex();
            if (index > 0) {
                state.hints[index].active = false;
                state.hints[index - 1].active = true;
            }
            else if (state.hints.length) {
                index === 0 && (state.hints[index].active = false);
                state.hints[state.hints.length - 1].active = true;
            }
        };
        const onArrowDown = (event) => {
            state.hints.length !== 0 && event.preventDefault();
            const index = getActiveIndex();
            if (index !== -1 && index !== state.hints.length - 1) {
                state.hints[index].active = false;
                state.hints[index + 1].active = true;
            }
            else if (state.hints.length) {
                index === state.hints.length - 1 && (state.hints[index].active = false);
                state.hints[0].active = true;
            }
        };
        const onArrowLeft = () => activeEnd();
        const onArrowRight = (event) => {
            const index = getActiveIndex();
            if (index < 0)
                return;
            event.preventDefault();
            state.isFilter = false;
            props.value = state.hints[index].name;
        };
        const arrowMap = {
            ArrowUp: onArrowUp,
            ArrowDown: onArrowDown,
            ArrowLeft: onArrowLeft,
            ArrowRight: onArrowRight,
        };
        const onKeydown = (event) => {
            switch (event.key) {
                case 'ArrowUp':
                case 'ArrowDown':
                case 'ArrowLeft':
                case 'ArrowRight':
                    arrowMap[event.key](event);
                    break;
            }
        };
        const onInput = (event) => {
            const el = event.target;
            props.value = el.value;
            state.isFilter = true;
        };
        beforeMount(() => {
            const { store: { canvasState }, } = contextRef.value.api;
            unmountedGroup.push(watch(props, propName => {
                if (propName !== 'value')
                    return;
                setHints();
            }), watch(canvasState, propName => {
                if (propName !== 'database')
                    return;
                state.isFilter = true;
                setHints();
            }));
        });
        return {
            hintState: state,
            onSelectHint,
            onKeydown,
            onInput,
        };
    }

    const ColumnDataTypeEditor = (props, ctx) => {
        const { hintState, onSelectHint, onKeydown, onInput } = useDataTypeHint(props, ctx);
        const { unmountedGroup } = useUnmounted();
        const inputRef = query('.vuerd-grid-input');
        useFlipAnimation(ctx, '.vuerd-grid-data-type-hint', 'vuerd-grid-data-type-hint-move');
        const onFocus = () => {
            inputRef.value.focus();
        };
        const onBlur = () => {
            setTimeout(lastCursorFocus, 0, inputRef.value);
        };
        const onMousedown = (event) => {
            const el = event.target;
            if (el.closest('.vuerd-grid-column-data-type-editor'))
                return;
            ctx.dispatchEvent(new Event('blur'));
        };
        const onMousedownEditor = (event) => {
            const el = event.target;
            el.closest('vuerd-menubar') && ctx.dispatchEvent(new Event('blur'));
        };
        beforeMount(() => {
            const editor = closestElement('.vuerd-editor', ctx);
            const gridEditor = closestElement('.vuerd-grid-editor', ctx);
            unmountedGroup.push(fromEvent(gridEditor, 'mousedown').subscribe(onMousedown), fromEvent(editor, 'mousedown').subscribe(onMousedownEditor));
        });
        mounted(() => onFocus());
        return () => html `
    <div class="vuerd-grid-column-data-type-editor">
      <input
        class="vuerd-grid-input"
        type="text"
        spellcheck="false"
        placeholder="dataType"
        .value=${props.value}
        @keydown=${onKeydown}
        @input=${onInput}
        @blur=${onBlur}
      />
      <ul class="vuerd-grid-column-data-type-hint">
        ${repeat(hintState.hints, hint => hint.name, hint => {
        return html `
              <li
                class=${classMap({
            'vuerd-grid-data-type-hint': true,
            active: hint.active,
        })}
                @click=${() => onSelectHint(hint)}
              >
                ${unsafeHTML(hint.html)}
              </li>
            `;
    })}
      </ul>
    </div>
  `;
    };
    defineComponent('vuerd-grid-column-data-type-editor', {
        observedProps: ['value'],
        shadow: false,
        render: ColumnDataTypeEditor,
    });

    class GridColumnDataTypeEditor {
        constructor(props) {
            this.onBlur = () => {
                this.props.grid.finishEditing(this.props.rowKey, this.el.value);
            };
            this.props = props;
            this.el = document.createElement('vuerd-grid-column-data-type-editor');
            this.el.value = String(props.value);
            this.el.addEventListener('blur', this.onBlur);
        }
        getElement() {
            return this.el;
        }
        getValue() {
            return this.el.value;
        }
        beforeDestroy() {
            this.el.removeEventListener('blur', this.onBlur);
        }
    }

    const ColumnOptionEditor = (props, ctx) => {
        const state = observable$1({
            activeIndex: 0,
            options: [
                {
                    name: 'Primary Key',
                    simpleOption: 'PK',
                    checked: false,
                },
                {
                    name: 'Not Null',
                    simpleOption: 'NN',
                    checked: false,
                },
                {
                    name: 'Unique',
                    simpleOption: 'UQ',
                    checked: false,
                },
                {
                    name: 'Auto Increment',
                    simpleOption: 'AI',
                    checked: false,
                },
            ],
        });
        const contextRef = useContext(ctx);
        const { unmountedGroup } = useUnmounted();
        const checkboxesRef = queryAll('input');
        Object.defineProperty(ctx, 'value', {
            get() {
                return state.options
                    .filter(option => option.checked)
                    .map(option => option.simpleOption)
                    .join(',');
            },
            set(simpleString) {
                simpleString.split(',').forEach(simple => {
                    const option = state.options.find(option => option.simpleOption === simple);
                    if (!option)
                        return;
                    option.checked = true;
                });
            },
        });
        const onFocus = () => {
            const checkboxes = checkboxesRef.value;
            checkboxes[state.activeIndex].focus();
        };
        const onChecked = (simpleOption) => {
            state.options.forEach(option => {
                if (option.simpleOption === simpleOption) {
                    option.checked = !option.checked;
                }
            });
        };
        const onChange = (event, simpleOption) => {
            const el = event.target;
            state.options.forEach(option => {
                if (option.simpleOption === simpleOption) {
                    option.checked = el.checked;
                }
            });
        };
        const onActiveIndex = (index) => (state.activeIndex = index);
        const onKeydown = (event) => {
            if (moveKeys.includes(event.key)) {
                event.preventDefault();
                const move = event.key === 'ArrowUp' || event.key === 'ArrowLeft' ? -1 : 1;
                let index = state.activeIndex + move;
                if (index < 0) {
                    index = state.options.length - 1;
                }
                else if (index > state.options.length - 1) {
                    index = 0;
                }
                onActiveIndex(index);
            }
        };
        const onMousedown = (event) => {
            const el = event.target;
            if (el.closest('.vuerd-grid-column-option-editor'))
                return;
            ctx.dispatchEvent(new Event('blur'));
        };
        firstUpdated(onFocus);
        updated(onFocus);
        beforeMount(() => {
            const { keydown$ } = contextRef.value;
            const gridEditor = closestElement('.vuerd-grid-editor', ctx);
            unmountedGroup.push(keydown$.subscribe(onKeydown), fromEvent(gridEditor, 'mousedown').subscribe(onMousedown));
        });
        return () => html `
    <ul class="vuerd-grid-column-option-editor">
      ${state.options.map((option, index) => html `
          <li
            class=${classMap({
        active: index === state.activeIndex,
    })}
            @click=${() => onChecked(option.simpleOption)}
            @mouseover=${() => onActiveIndex(index)}
          >
            <input
              type="checkbox"
              .checked=${option.checked}
              @change=${(event) => onChange(event, option.simpleOption)}
            />
            <span>${option.name}</span>
          </li>
        `)}
    </ul>
  `;
    };
    defineComponent('vuerd-grid-column-option-editor', {
        shadow: false,
        render: ColumnOptionEditor,
    });

    class GridColumnOptionEditor {
        constructor(props) {
            this.onBlur = () => {
                this.props.grid.finishEditing(this.props.rowKey, this.el.value);
            };
            this.onKeydown = (event) => {
                this.props.portalEditingKeydown(event);
            };
            this.props = props;
            this.el = document.createElement('vuerd-grid-column-option-editor');
            this.el.value = String(props.value);
            this.el.addEventListener('blur', this.onBlur);
            this.el.addEventListener('keydown', this.onKeydown);
        }
        getElement() {
            return this.el;
        }
        getValue() {
            return this.el.value;
        }
        beforeDestroy() {
            this.el.removeEventListener('blur', this.onBlur);
            this.el.removeEventListener('keydown', this.onKeydown);
        }
    }

    class GridTextEditor {
        constructor(props) {
            this.onBlur = () => {
                this.props.grid.finishEditing(this.props.rowKey, this.el.value);
            };
            const { placeholder } = props.columnInfo.renderer.options;
            this.props = props;
            this.el = document.createElement('input');
            this.el.classList.add('vuerd-grid-input');
            this.el.type = 'text';
            this.el.spellcheck = false;
            this.el.value = String(props.value);
            this.el.addEventListener('blur', this.onBlur);
            if (placeholder) {
                this.el.placeholder = placeholder;
            }
        }
        getElement() {
            return this.el;
        }
        getValue() {
            return this.el.value;
        }
        mounted() {
            this.el.focus();
        }
        beforeDestroy() {
            this.el.removeEventListener('blur', this.onBlur);
        }
    }

    class GridTextRender {
        constructor(props) {
            this.el = document.createElement('div');
            this.el.classList.add('vuerd-grid-text');
            this.render(props);
        }
        getElement() {
            return this.el;
        }
        render(props) {
            this.el.innerText = this.getValue(props);
        }
        getValue(props) {
            const { placeholder } = props.columnInfo.renderer.options;
            const value = String(props.value);
            if (value.trim() === '') {
                this.el.classList.add('placeholder');
                return placeholder;
            }
            else {
                this.el.classList.remove('placeholder');
                return value;
            }
        }
    }

    const gridColumns = [
        {
            header: 'Table Name',
            name: 'tableName',
            renderer: { type: GridTextRender, options: { placeholder: 'table' } },
            editor: { type: GridTextEditor, options: { placeholder: 'table' } },
        },
        {
            header: 'Table Comment',
            name: 'tableComment',
            renderer: { type: GridTextRender, options: { placeholder: 'comment' } },
            editor: { type: GridTextEditor, options: { placeholder: 'comment' } },
        },
        {
            header: 'Option',
            name: 'option',
            minWidth: 100,
            renderer: { type: GridTextRender, options: { placeholder: 'option' } },
            editor: { type: GridColumnOptionEditor },
        },
        {
            header: 'Name',
            name: 'name',
            renderer: { type: GridTextRender, options: { placeholder: 'column' } },
            editor: { type: GridTextEditor, options: { placeholder: 'column' } },
        },
        {
            header: 'DataType',
            name: 'dataType',
            minWidth: 200,
            renderer: { type: GridTextRender, options: { placeholder: 'dataType' } },
            editor: { type: GridColumnDataTypeEditor },
        },
        {
            header: 'Default',
            name: 'default',
            renderer: { type: GridTextRender, options: { placeholder: 'default' } },
            editor: { type: GridTextEditor, options: { placeholder: 'default' } },
        },
        {
            header: 'Comment',
            name: 'comment',
            renderer: { type: GridTextRender, options: { placeholder: 'comment' } },
            editor: { type: GridTextEditor, options: { placeholder: 'comment' } },
        },
    ].map((gridColumn) => (Object.assign(Object.assign({}, gridColumn), { sortingType: 'asc', sortable: true })));

    function createGridData(store) {
        const rows = [];
        const tables = orderByNameASC(store.tableState.tables);
        tables.forEach(table => table.columns.forEach(column => rows.push({
            tableId: table.id,
            columnId: column.id,
            tableName: table.name,
            tableComment: table.comment,
            option: columnOptionToSimpleKeyToString(column.option),
            name: column.name,
            dataType: column.dataType,
            default: column.default,
            comment: column.comment,
        })));
        return rows;
    }
    function columnOptionToSimpleKeyToString(option) {
        const keys = [];
        if (option.primaryKey) {
            keys.push('PK');
        }
        if (option.notNull) {
            keys.push('NN');
        }
        if (option.unique) {
            keys.push('UQ');
        }
        if (option.autoIncrement) {
            keys.push('AI');
        }
        return keys.join(',');
    }
    function changeColumnOptionList(oldValue, newValue) {
        const changeSimpleOptions = [];
        const oldSimpleOptions = oldValue.split(',');
        const newSimpleOptions = newValue.split(',');
        oldSimpleOptions.forEach(oldValue => {
            if (newSimpleOptions.includes(oldValue))
                return;
            changeSimpleOptions.push(oldValue);
        });
        newSimpleOptions.forEach(newValue => {
            if (oldSimpleOptions.includes(newValue))
                return;
            changeSimpleOptions.push(newValue);
        });
        return changeSimpleOptions;
    }
    function currentColumnOptionList(columnOption) {
        const currentSimpleOptions = [];
        if (columnOption.primaryKey) {
            currentSimpleOptions.push('PK');
        }
        if (columnOption.notNull) {
            currentSimpleOptions.push('NN');
        }
        if (columnOption.unique) {
            currentSimpleOptions.push('UQ');
        }
        if (columnOption.autoIncrement) {
            currentSimpleOptions.push('AI');
        }
        return currentSimpleOptions;
    }
    function filterGridData(store) {
        const { filters, operatorType } = store.editorState.filterState;
        const rows = createGridData(store);
        const activeFilterStateList = filters.filter(filter => filter.value !== '');
        return activeFilterStateList.length
            ? rows.filter(row => filterMatch(row, activeFilterStateList, operatorType))
            : rows;
    }
    const filterMatch = (row, filters, operatorType) => operatorType === 'OR'
        ? filters.some(filter => filterValueMatch(row[filter.columnType], filter))
        : !filters.some(filter => !filterValueMatch(row[filter.columnType], filter));
    function filterValueMatch(value, filter) {
        let result = false;
        switch (filter.filterCode) {
            case 'eq':
                result = value === filter.value;
                break;
            case 'ne':
                result = value !== filter.value;
                break;
            case 'contain':
                result = value.indexOf(filter.value) !== -1;
                break;
            case 'start':
                result = value.indexOf(filter.value) === 0;
                break;
            case 'end':
                const lastIndex = value.lastIndexOf(filter.value);
                result = value.length === lastIndex + filter.value.length;
                break;
        }
        return result;
    }

    const GRID_HEADER_HEIGHT = 40;
    function useGrid(props, ctx, keydown$) {
        const containerRef = query('.vuerd-grid-container');
        const gridRef = { value: null };
        const { unmountedGroup } = useUnmounted();
        const filter$ = new Subject();
        const subscriptionHelper = createSubscriptionHelper();
        let deleteBatchExecuting = false;
        let changeBatchExecuting = false;
        let deleteDataTypeSyncExecuting = false;
        let changeDataTypeSyncExecuting = false;
        let edit = false;
        const getHeight = () => props.height - GRID_HEADER_HEIGHT;
        const batchCommandColumnOption = (batchCommand, changeOptions, tableId, columnId) => {
            const { store, command } = ctx.api;
            const { changeColumnPrimaryKey, changeColumnNotNull, changeColumnUnique, changeColumnAutoIncrement, } = command.column;
            changeOptions.forEach(simpleOption => {
                switch (simpleOption) {
                    case 'PK':
                        batchCommand.push(changeColumnPrimaryKey(store, tableId, columnId));
                        break;
                    case 'NN':
                        batchCommand.push(changeColumnNotNull(store, tableId, columnId));
                        break;
                    case 'UQ':
                        batchCommand.push(changeColumnUnique(store, tableId, columnId));
                        break;
                    case 'AI':
                        batchCommand.push(changeColumnAutoIncrement(store, tableId, columnId));
                        break;
                }
            });
        };
        const onAfterChange = (event) => {
            if (!gridRef.value)
                return;
            const grid = gridRef.value;
            const { store, helper, command } = ctx.api;
            const { changeTableName, changeTableComment } = command.table;
            const { changeColumnName, changeColumnDataType, changeColumnDefault, changeColumnComment, } = command.column;
            const { canvasState: { setting }, tableState: { tables }, relationshipState: { relationships }, } = store;
            const { value, prevValue, rowKey } = event;
            const row = grid.getRow(rowKey);
            if (row) {
                const { tableId, columnId } = row;
                switch (event.columnName) {
                    case 'tableName':
                        if (!deleteBatchExecuting && !changeBatchExecuting) {
                            changeBatchExecuting = true;
                            store.dispatch(changeTableName(helper, tableId, value));
                            grid
                                .findRows((row) => row.tableId === tableId && row.rowKey !== rowKey)
                                .forEach(row => {
                                grid.setValue(row.rowKey, 'tableName', value);
                            });
                            changeBatchExecuting = false;
                        }
                        break;
                    case 'tableComment':
                        if (!deleteBatchExecuting && !changeBatchExecuting) {
                            changeBatchExecuting = true;
                            store.dispatch(changeTableComment(helper, tableId, value));
                            grid
                                .findRows((row) => row.tableId === tableId && row.rowKey !== rowKey)
                                .forEach(row => {
                                grid.setValue(row.rowKey, 'tableComment', value);
                            });
                            changeBatchExecuting = false;
                        }
                        break;
                    case 'option':
                        const changeOptions = changeColumnOptionList(prevValue, value);
                        const batchCommand = [];
                        batchCommandColumnOption(batchCommand, changeOptions, tableId, columnId);
                        if (batchCommand.length !== 0) {
                            store.dispatch(...batchCommand);
                        }
                        break;
                    case 'name':
                        store.dispatch(changeColumnName(helper, tableId, columnId, value));
                        break;
                    case 'dataType':
                        if (!deleteDataTypeSyncExecuting && !changeDataTypeSyncExecuting) {
                            changeDataTypeSyncExecuting = true;
                            const column = getColumn(tables, tableId, columnId);
                            if (column) {
                                store.dispatch(changeColumnDataType(helper, tableId, columnId, value));
                                if (setting.relationshipDataTypeSync) {
                                    // DataTypeSync
                                    const columnIds = getDataTypeSyncColumns([column], tables, relationships).map(column => column.id);
                                    grid
                                        .findRows((row) => columnIds.some(columnId => columnId === row.columnId) &&
                                        row.rowKey !== rowKey)
                                        .forEach(row => {
                                        grid.setValue(row.rowKey, 'dataType', value);
                                    });
                                }
                            }
                            changeDataTypeSyncExecuting = false;
                        }
                        break;
                    case 'default':
                        store.dispatch(changeColumnDefault(helper, tableId, columnId, value));
                        break;
                    case 'comment':
                        store.dispatch(changeColumnComment(helper, tableId, columnId, value));
                        break;
                }
            }
            grid.clearModifiedData();
        };
        const isCommandTable = (batchCommand, commandName, tableId) => !batchCommand.some(command => {
            if (command.name === commandName) {
                const data = command.data;
                return data.tableId === tableId;
            }
            return false;
        });
        const onKeydown = (event) => {
            if (!gridRef.value)
                return;
            const grid = gridRef.value;
            const { store, helper, command } = ctx.api;
            const { canvasState: { setting }, tableState: { tables }, relationshipState: { relationships }, } = store;
            const { changeTableName, changeTableComment } = command.table;
            const { changeColumnName, changeColumnDataType, changeColumnDefault, changeColumnComment, } = command.column;
            if (!edit && (event.key === 'Delete' || event.key === 'Backspace')) {
                const updatedRows = grid.getModifiedRows().updatedRows;
                if (!updatedRows)
                    return;
                const batchCommand = [];
                const batchGridDataType = [];
                const batchGridTableName = [];
                const batchGridTableComment = [];
                updatedRows.forEach((row) => {
                    const { rowKey, tableId, columnId, tableName, tableComment, option, name, dataType, comment, } = row;
                    const table = getData(tables, tableId);
                    const column = getColumn(tables, tableId, columnId);
                    if (table && column) {
                        if (tableName === '' && tableName !== table.name) {
                            if (isCommandTable(batchCommand, 'table.changeName', tableId)) {
                                batchCommand.push(changeTableName(helper, tableId, ''));
                                batchGridTableName.push({
                                    tableId,
                                    rowKey,
                                });
                            }
                        }
                        if (tableComment === '' && tableComment !== table.comment) {
                            if (isCommandTable(batchCommand, 'table.changeComment', tableId)) {
                                batchCommand.push(changeTableComment(helper, tableId, ''));
                                batchGridTableComment.push({
                                    tableId,
                                    rowKey,
                                });
                            }
                        }
                        if (option === '') {
                            const changeOptions = currentColumnOptionList(column.option);
                            batchCommandColumnOption(batchCommand, changeOptions, tableId, columnId);
                        }
                        if (name === '' && name !== column.name) {
                            batchCommand.push(changeColumnName(helper, tableId, columnId, ''));
                        }
                        if (dataType === '' && dataType !== column.dataType) {
                            batchCommand.push(changeColumnDataType(helper, tableId, columnId, ''));
                            if (setting.relationshipDataTypeSync) {
                                // DataTypeSync
                                const columnIds = getDataTypeSyncColumns([column], tables, relationships).map(column => column.id);
                                batchGridDataType.push(grid.findRows((row) => columnIds.some(columnId => columnId === row.columnId) &&
                                    row.rowKey !== rowKey));
                            }
                        }
                        if (row.default === '' && row.default !== column.default) {
                            batchCommand.push(changeColumnDefault(helper, tableId, columnId, ''));
                        }
                        if (comment === '' && row.comment !== column.comment) {
                            batchCommand.push(changeColumnComment(helper, tableId, columnId, ''));
                        }
                    }
                });
                store.dispatch(...batchCommand);
                deleteDataTypeSyncExecuting = true;
                batchGridDataType.forEach((rows) => {
                    rows.forEach(row => {
                        grid.setValue(row.rowKey, 'dataType', '');
                    });
                });
                deleteDataTypeSyncExecuting = false;
                deleteBatchExecuting = true;
                batchGridTableName.forEach(({ tableId, rowKey }) => {
                    grid
                        .findRows((row) => row.tableId === tableId && row.rowKey !== rowKey)
                        .forEach(row => {
                        grid.setValue(row.rowKey, 'tableName', '');
                    });
                });
                batchGridTableComment.forEach(({ tableId, rowKey }) => {
                    grid
                        .findRows((row) => row.tableId === tableId && row.rowKey !== rowKey)
                        .forEach(row => {
                        grid.setValue(row.rowKey, 'tableComment', '');
                    });
                });
                deleteBatchExecuting = false;
                grid.clearModifiedData();
            }
        };
        const observeFilters = () => {
            const { filters } = ctx.api.store.editorState.filterState;
            subscriptionHelper.push(...filters.map(filter => watch(filter, () => filter$.next(null))));
        };
        const unobserveFilters = () => subscriptionHelper.destroy();
        const onFilter = () => {
            if (!gridRef.value)
                return;
            const { store } = ctx.api;
            gridRef.value.resetData(filterGridData(store));
        };
        const onEditingStart = () => (edit = true);
        const onEditingFinish = () => (edit = false);
        const onGridEvent = () => {
            if (!gridRef.value)
                return;
            gridRef.value.on('editingStart', onEditingStart);
            gridRef.value.on('editingFinish', onEditingFinish);
        };
        const offGridEvent = () => {
            if (!gridRef.value)
                return;
            gridRef.value.off('editingStart', onEditingStart);
            gridRef.value.off('editingFinish', onEditingFinish);
        };
        mounted(() => {
            const { filterState } = ctx.api.store.editorState;
            gridRef.value = new Grid({
                el: containerRef.value,
                usageStatistics: false,
                bodyHeight: getHeight(),
                columnOptions: {
                    frozenCount: 1,
                    frozenBorderWidth: 0,
                    minWidth: 300,
                },
                columns: gridColumns.map((gridColumn) => (Object.assign(Object.assign({}, gridColumn), { onAfterChange }))),
                data: [],
            });
            onGridEvent();
            onFilter();
            unmountedGroup.push(keydown$.subscribe(onKeydown), filter$.pipe(debounceTime(200)).subscribe(onFilter), watch(props, propName => {
                if (propName !== 'height' || !gridRef.value)
                    return;
                gridRef.value.setBodyHeight(getHeight());
            }), watch(filterState, propName => {
                if (propName !== 'filterOperatorType')
                    return;
                filter$.next(null);
            }), watch(filterState.filters, () => {
                unobserveFilters();
                observeFilters();
                filter$.next(null);
            }));
        });
        unmounted(() => {
            if (!gridRef.value)
                return;
            offGridEvent();
            gridRef.value.destroy();
        });
        return gridRef;
    }

    function useEditorElement(ctx) {
        const ref = { value: null };
        beforeMount(() => {
            const el = closestElement('.vuerd-editor', ctx);
            if (!el)
                return;
            ref.value = el;
        });
        return ref;
    }

    function useKeydown(ctx) {
        const editorRef = useEditorElement(ctx);
        const keydown$ = new Subject();
        const { unmountedGroup } = useUnmounted();
        beforeMount(() => unmountedGroup.push(fromEvent(editorRef.value, 'keydown')
            .pipe(ignoreEnterProcess)
            .subscribe(event => keydown$.next(event))));
        return { keydown$ };
    }

    function useGridKeymap(ctx) {
        const { unmountedGroup } = useUnmounted();
        const { keydown$ } = useKeydown(ctx);
        const onFocusEditor = () => {
            const vEditor = closestElement('vuerd-editor', ctx);
            const eEditor = closestElement('erd-editor', ctx);
            vEditor === null || vEditor === void 0 ? void 0 : vEditor.focus();
            eEditor === null || eEditor === void 0 ? void 0 : eEditor.focus();
        };
        const onKeydown = (event) => {
            const { keymap, store, command } = ctx.api;
            const { filterState } = store.editorState;
            const { editFilterEnd, editFilter, focusMoveFilter, focusMoveFilter$, addFilter$, selectAllFilter, removeFilter$, } = command.editor;
            if (!filterState.focus || !filterState.focus.edit) {
                if (keymapMatchAndStop(event, keymap.find)) {
                    if (filterState.active) {
                        store.dispatch(command.editor.filterActiveEnd$());
                        ctx.focus();
                    }
                    else {
                        store.dispatch(command.editor.filterActive$());
                    }
                }
                filterState.active &&
                    keymapMatchAndStop(event, keymap.addColumn) &&
                    store.dispatch(addFilter$());
            }
            if (filterState.active) {
                if (filterState.active && filterState.focus && !filterState.focus.edit) {
                    keymapMatchAndStop(event, keymap.selectAllColumn) &&
                        store.dispatch(selectAllFilter());
                    filterState.focus.selectFilterIds.length &&
                        keymapMatchAndStop(event, keymap.removeColumn) &&
                        store.dispatch(removeFilter$(store, filterState.focus.selectFilterIds));
                    event.key !== 'Tab' &&
                        moveKeys.includes(event.key) &&
                        store.dispatch(focusMoveFilter(event.key, event.shiftKey));
                }
                if (filterState.focus && event.key === 'Tab') {
                    event.preventDefault();
                    store.dispatch(focusMoveFilter$(store, event.key, event.shiftKey));
                    setTimeout(() => store.dispatch(editFilter()), 0);
                }
                if (filterState.focus && keymapMatchAndStop(event, keymap.edit)) {
                    const focus = filterState.focus;
                    focus.edit
                        ? store.dispatch(editFilterEnd())
                        : store.dispatch(editFilter());
                }
                if (keymapMatchAndStop(event, keymap.stop)) {
                    store.dispatch(command.editor.filterActiveEnd$());
                    if (filterState.active) {
                        ctx.focus();
                    }
                }
            }
        };
        beforeMount(() => {
            const { filterState } = ctx.api.store.editorState;
            unmountedGroup.push(keydown$.subscribe(onKeydown), watch(filterState, propName => {
                if (propName !== 'active')
                    return;
                filterState.active && onFocusEditor();
            }));
        });
    }

    /**
     * https://uicdn.toast.com/grid/latest/tui-grid.css
     */
    const TuiGridStyle = css `
  /*!
 * TOAST UI Grid
 * @version 4.18.1 | Wed Jul 14 2021
 * @author NHN. FE Development Lab
 * @license MIT
 */
  /*!
 * TOAST UI Select Box
 * @version 1.0.0 | Thu Oct 24 2019
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
  .tui-select-box {
    position: relative;
  }

  .tui-select-box-input,
  .tui-select-box-dropdown,
  .tui-select-box-item-group-label,
  .tui-select-box-item {
    box-sizing: border-box;
  }

  .tui-select-box-input {
    border: 1px solid #ddd;
  }

  .tui-select-box-input.tui-select-box-open,
  .tui-select-box-dropdown {
    border: 1px solid #aaa;
  }

  .tui-select-box-input,
  .tui-select-box-dropdown {
    background: #fff;
  }

  .tui-select-box-input,
  .tui-select-box-item-group-label,
  .tui-select-box-item {
    padding: 0 8px;
    height: 29px;
    font-size: 13px;
    color: #333;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    cursor: pointer;
  }

  .tui-select-box-placeholder,
  .tui-select-box-item-group-label,
  .tui-select-box-item {
    line-height: 29px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .tui-select-box-placeholder,
  .tui-select-box-icon {
    height: 100%;
  }

  .tui-select-box-placeholder {
    display: inline-block;
    margin: 0;
    width: 80%;
    width: calc(100% - 12px);
    vertical-align: sub;
  }

  .tui-select-box-icon {
    display: block;
    float: right;
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAECAYAAACHtL/sAAAAAXNSR0IArs4c6QAABBFpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDUuNC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iCiAgICAgICAgICAgIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIgogICAgICAgICAgICB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIj4KICAgICAgICAgPHhtcE1NOkRlcml2ZWRGcm9tIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgPHN0UmVmOmluc3RhbmNlSUQ+eG1wLmlpZDozOTU0MDZFM0JEQjExMUU2OEQ1MkUyN0M0NDdEMkIxMTwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDozOTU0MDZFNEJEQjExMUU2OEQ1MkUyN0M0NDdEMkIxMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgPC94bXBNTTpEZXJpdmVkRnJvbT4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDozOTU0MDZFNkJEQjExMUU2OEQ1MkUyN0M0NDdEMkIxMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOkluc3RhbmNlSUQ+eG1wLmlpZDozOTU0MDZFNUJEQjExMUU2OEQ1MkUyN0M0NDdEMkIxMTwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwveG1wOkNyZWF0b3JUb29sPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4K/ZqkVgAAAERJREFUGBljNDY2/s+AA5w9e5YRXQqqXgAo9xEkB1aAzRA8mmFmgg1hgvIEYKIgmgjNIGUfQATciUBX8IMEidQM0gsGAPabHJ7Zbgx5AAAAAElFTkSuQmCC)
      left center no-repeat;
    width: 7px;
    overflow: hidden;
    text-indent: 100%;
  }

  .tui-select-box-open > .tui-select-box-icon {
    background-position: right center;
  }

  .tui-select-box-dropdown,
  .tui-select-box-item-group {
    margin: 0;
    padding: 0;
    list-style-type: none;
  }

  .tui-select-box-dropdown {
    position: absolute;
    border-top: none;
    /* max-height: 145px; */
    overflow: auto;
    z-index: 1;
    width: 100%;
    overflow-x: hidden;
  }

  .tui-select-box-item-group-label {
    display: block;
    font-weight: bold;
    cursor: default;
  }

  .tui-select-box-item-group > .tui-select-box-item {
    padding-left: 20px;
  }

  .tui-select-box-selected {
    background: #f4f4f4;
  }

  .tui-select-box-highlight {
    background: #e5f6ff;
    outline: none;
  }

  .tui-select-box-disabled {
    background: #f9f9f9;
    color: #c8c8c8;
    cursor: default;
  }

  .tui-select-box-hidden {
    display: none; /* for test */
  }
  .tui-grid-container {
    width: 100%;
    position: relative;
    border-width: 0;
    clear: both;
    font-size: 13px;
    font-family: Arial, '\B3CB\C6C0', Dotum, sans-serif;
  }
  .tui-grid-container ::-webkit-scrollbar {
    -webkit-appearance: none;
    width: 17px;
    height: 17px;
  }
  .tui-grid-container ::-webkit-scrollbar-thumb {
    border: 4px solid transparent;
    background-clip: content-box;
  }
  .tui-grid-container * {
    box-sizing: content-box;
  }
  .tui-grid-container p,
  .tui-grid-container input,
  .tui-grid-container textarea {
    margin: 0;
    padding: 0;
    font-size: 13px;
    font-family: Arial, '\B3CB\C6C0', Dotum, sans-serif;
  }
  .tui-grid-container fieldset {
    margin: 0;
    padding: 0;
    border: 0;
    display: inline;
    white-space: nowrap;
  }
  .tui-grid-container input[type='text'],
  .tui-grid-container input[type='password'] {
    outline: none;
    box-sizing: border-box;
    line-height: normal;
  }
  .tui-grid-container ul,
  .tui-grid-container li {
    list-style: none;
    padding: 0;
    margin: 0;
  }
  .tui-grid-container strong,
  .tui-grid-container em {
    font-style: normal;
  }
  .tui-grid-container .tui-grid-pagination {
    margin-top: 20px;
  }
  .tui-grid-clipboard {
    position: fixed;
    top: 0px;
    left: -9999px;
    width: 100px;
    height: 100px;
  }
  .tui-grid-btn-text {
    display: inline-block;
    text-decoration: none;
  }
  .tui-grid-btn-text span {
    display: inline-block;
    position: relative;
    font-size: 11px;
    color: #333;
    padding-left: 17px;
    letter-spacing: -1px;
    line-height: 23px;
    white-space: nowrap;
    cursor: pointer;
    margin-left: 8px;
    padding-right: 7px;
  }
  .tui-grid-btn-text em {
    position: absolute;
    left: 0;
    top: 5px;
    width: 17px;
    height: 12px;
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACMCAYAAACeTFAfAAAAAXNSR0IArs4c6QAAC/tJREFUeAHtnX9oVtcZx899kzhrNaTSaDeIdrpCayy1xoBdZJh2CPljbmiT4EQNG/jHwG2MMgcDkxTi5hilVrY/xA2rbpJk+of7IyjrXMEaWI2zjNjBqtRGRtXRlMRm3aJ5931u7jE3N/fe9/58k/f6vXBzznnOc55zzuc+Oefc8977vkrxIAESIAESIAESIAESIAESIAESIAESIAESIIG5T8CY+00sbgvzDQ2L7g0Pv5LP5zcDzlek9rxSHxiGcab8scd+abzzzmhxW1SatdGxbNdtvLb2xfzExG9VPr/cJp6KGsYNI5f7TsXg4J+nhIy5EaBjWVTEqdT9+3/C6OTLBJl5VVb29TjOtW3btsfv3bt3rLy8fOfJkyf/7XZhwsrSsHnp0qXHMVIfw+i9c926daHamQvbgSzqy/QnI5XTqSref1/JaT9Ex9RFGbs8aLy5ufkRONUZ6DdJKOmgZb300rA5NDT0iEz/cKomCSXtVb+bnI4FKrKm8pz+3KhhqjTLuOX5yDo6OoT3CZwvWGoSnrDklihckIZNOFPu9u3bJxCa7ZTQSgf2l8CK4bpbWtoYgb4ZtsWAvTlsmcHBwddQZouj3BZL7hAHS6Zh8/Lly6+hf9PaKWmRB2tVgfWEl5Genh7MCNGPlpYW33WMtrx3795Y9Rw4cCBQPePPPDMKcAt1vTrU0yDytehBiOnhLvIjTYcPjGQ4Egh8hvtvdo2OlfwVLo9iMmsjFobFD8BhjZOF20ildawyOsnQQYAjFoCMr1rViXXWPgebB3eEbg6G/axXK65ebXeWYXqSAEcscJAd9fFPPtkV+M4QG6VSJqwTYVvgdZT5gUu5g729vT90kRcUDQwMvI714QybWAMerKuri2QziXZyxLIuXTE2SGVrAHdxvajSfsd1ura2thl5EwW9yEUBTpXD3Vqv3LXpbDjV6bVr1zYjjGQziXbSsfTVQFiMj3SsDdG3UJ3sEfXjfAmj1X8QRj5k8xL7TG/BuV6AM/UvWbLkpZqamlg247aT+1i2yykf01QsXvysrJ8gfg8X6a6cyjCumGsq5MX5KEeqEifCRzmyB9YnYVynEpviRHCqzWhrn4RxnUpsptFOscuDBEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEITiPzYDF5m9H3R4c6dO39pampqDN0ie4HuvHsdOdWimg15rimZ4/vn3esxjBZ1cGNy9aC1eKx7IZ5C+HFZWVnL/fv3l0sHEL+BeA+eTPgFXjS5G6dTadsP2rbUHOv69etq0aJF8ZzLy7EMdQcdrFUthoTxDy/HUrD/aK5W/exridSDi/4inOh3eKylauXKlfMrKyvNto+MjKhr1659jueqPoWDbYdzRXqFP237YUCn+jzW6Ojoxr6+vvNhGhRIN6+qoferQLqxlPLVamwikXrkos+bN+/Mhg0bnqivr5+/ePFiheexzFPiIpM80RHdsM1O237Y9qQ6YunGRB65vEYsbdgrbDXC9curno8+VGoIp9fxRmOgenDRF2Kk+qc4Dp7u9LJmyvEkqLpw4cLHGLmeCjotpm3ft8EemamNWCtWrFD6rK6u3uhR/9wWL3sSj2fijHnImkqmP+1U/8OT6D/5u1Jf+uPkKXGRySE6oitlJiWF/zrt+5WIYt/PnldepLd0vIxlUi7OJafb8YabcKYMo1WrrKl0zr5BpQ7YvmtEx3/+7KSG6N68ebMFqX26jF/otO+nK3lh7Rey55af2ojlVtnDKsO0tkwv1IXBsQ9nkrDLRBdlls/Ucpc47btrTUnD2p8qGTxGxwrOipohCNCxQsCKqoqp6oZsKehj55M6NhXaZaIrZaZy/WNO+/7aSoW1X8ieWz4dy41KwjJMVT2yT6XNvlqr1F58gc0X8VVmckpcZPoQXSmj04VCp/1C+mHtF7Lnlk/HcqOSsEx21GXzU7YS5JgH6rJQ/9c3Jk+Ji0wO0RFdKTMpKfzXad+vRBT7fva88uhYXmQSlMt+FEaV7f39/Z9p53IzL3miI7pB97DETtr23dpaSBZog8/NSKHPCp1l8OWo4evy2rh0Gnemk9ogddp1pkPWI7vjWA89FB/phL/YFlw6FkCEdCxBJ7vk1ofQrRiZlolMFt+yTkr4Q+hU7Et7eZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZBAJgjgS+1n/JBSJjqWwU6UlVKfVq9e/RF+HiTX0NBwEb8hY70wVUo9eHjaGvmxGRPR6fxzaly9i3iFD7Jx5NarLcZ7PjqBsjBi5S3FK7lcrq27uzu2zUAVp6S0Z8+eL9y6des3S5cu/e6hQ4f+m1I1s2I23nuF4iy9+S41oTo8W59TXUk4lcP+Gjy79C6enOyqqqraf/jw4XFHfuQkbP4etrc5DeAZqpN4lurbTnmcNJyqC3VtR/gx7LwSx9ZcKxv/0eQvq/3KUFdcOyZyyU/hwAWpwNkxPDz819bW1ueSqmLBggXfgxMN2e1JWuR2Wdw4HLgR7f+R2JFQ0nFtzqXy8R1rnTGuylUbOuUcNSblkp/usWZiYuIipslVSVRz9OjRT2FnF0497Uq4y5InUYVqa2urgqE3ceqliIRvWvJE6phtI/EdS3ogU6JMefYjnSnQXoMZx2gi66wG/FrV1RmZEQWY8s7DrvmL7RJKOqIp12JjY2O/xihVY8+UtMjtslKOx1tj2XsuU9519S38n68xp8aUpkBdJS64jIT7scbqSnKNpe1jQf1TrH2ekFDLkgqttVqi67Wk2paUHT0UJ2NP7hLvqYuYGr+awoJd6btCGaXwH96GUcp9bZdMb2glBoFkpkLdgMkthUS2FrRJeyijFM5OjFL1dCo7GcZjEeDOeyx8LEwCJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACpUYg2bd00Hv9Jk0hEHgZIvG6p9UZ9Hd4IvxsybR6AiZ27969AK+pjTnVveROvVJLJ/uWDnovb9EUghBEp5CNAPkF2wEbQXQCVOWvgtfnza8CwD9dtV1T0vIVAZJvl2chnrhj4WXMDj/HkTzRSR1eqyF1+DlOJ35kKfV27Nix41G8A/ky2iI/dXleO5cVyhvWtZIvIxfimTmMtHoi/4UA1m63XzSnslfane9Aclo7kC6KU+lm2J0IskF818TL+BqmPyAuzobftFeNWBrcQZiZIzXHEkJ255oVp9KXabpzFdWpdBMcziU/4zsfZyadSvqcqmNJBQCalzD1xbpU4nfoxXyRFutuTdm6devTGKn+hjxxqs8xcj1/6tSpf7jplros8TVWqQNJq/0yYlnTn+lUqGe+pK2RLK1qZ80uHasI6B3ToKyxnke1Mg1OW9AXoSlFq4KOlTJquStEFebdH0JzTWVNf41W2nSurN0VFsOx3sZvHgvE2T0M9Ta+HK7o7Th+/PhnuHGRO8BpC3XrLtB0Lsl32zydXWCsvSQIeI1I1ohWEn1gI0mABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABIpPwIhSJV44Nd+8CVsWr4MFqi9t+2HbTf3wBCL/dC9eEAhVGx7FDaWftv26urpQ/xwDAwOB/ilCdTLDysV45j3D+Ng1LwKpOdbIyIg6d+6cV72UZ5xA5KnQj4s4VWdnpxoaGjLVNm3a5Kc+a3lBp7ew0+asdWgOVRx7xJJRSRxJH3anqqmpUevXr9dZDB8iArEcS5zqyJEj5ugkDuV0qvb2dlVZWVkyOGVk0qOTPV4yHZhDDY01FcpodPbsWXPKk6lPDpn+ZKQqNaeaQ9ckE02J5VgyGokD2ddTpexU9jWXPZ6JK13kTsSaCqWt2rnEoUrRqexTnle8yNckE9XFGrE0Ae1cki6lNZVuP8PkCSTiWNKsUnUo+5TnFU8ee/YtJuZYpYhK3wGWYtvnepsjO1bYz/7Cgkjbvn10Cts26pMACZAACZAACZAACZAACZAACZAACZAACZAACWSDwP8B9X0BfshR6QsAAAAASUVORK5CYII=)
      no-repeat;
  }
  .tui-grid-btn-sorting {
    display: inline-block;
    overflow: hidden;
    margin-left: 6px;
    height: 16px;
    width: 11px;
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACMCAYAAACeTFAfAAAAAXNSR0IArs4c6QAAC/tJREFUeAHtnX9oVtcZx899kzhrNaTSaDeIdrpCayy1xoBdZJh2CPljbmiT4EQNG/jHwG2MMgcDkxTi5hilVrY/xA2rbpJk+of7IyjrXMEaWI2zjNjBqtRGRtXRlMRm3aJ5931u7jE3N/fe9/58k/f6vXBzznnOc55zzuc+Oefc8977vkrxIAESIAESIAESIAESIAESIAESIAESIAESIIG5T8CY+00sbgvzDQ2L7g0Pv5LP5zcDzlek9rxSHxiGcab8scd+abzzzmhxW1SatdGxbNdtvLb2xfzExG9VPr/cJp6KGsYNI5f7TsXg4J+nhIy5EaBjWVTEqdT9+3/C6OTLBJl5VVb29TjOtW3btsfv3bt3rLy8fOfJkyf/7XZhwsrSsHnp0qXHMVIfw+i9c926daHamQvbgSzqy/QnI5XTqSref1/JaT9Ex9RFGbs8aLy5ufkRONUZ6DdJKOmgZb300rA5NDT0iEz/cKomCSXtVb+bnI4FKrKm8pz+3KhhqjTLuOX5yDo6OoT3CZwvWGoSnrDklihckIZNOFPu9u3bJxCa7ZTQSgf2l8CK4bpbWtoYgb4ZtsWAvTlsmcHBwddQZouj3BZL7hAHS6Zh8/Lly6+hf9PaKWmRB2tVgfWEl5Genh7MCNGPlpYW33WMtrx3795Y9Rw4cCBQPePPPDMKcAt1vTrU0yDytehBiOnhLvIjTYcPjGQ4Egh8hvtvdo2OlfwVLo9iMmsjFobFD8BhjZOF20ildawyOsnQQYAjFoCMr1rViXXWPgebB3eEbg6G/axXK65ebXeWYXqSAEcscJAd9fFPPtkV+M4QG6VSJqwTYVvgdZT5gUu5g729vT90kRcUDQwMvI714QybWAMerKuri2QziXZyxLIuXTE2SGVrAHdxvajSfsd1ura2thl5EwW9yEUBTpXD3Vqv3LXpbDjV6bVr1zYjjGQziXbSsfTVQFiMj3SsDdG3UJ3sEfXjfAmj1X8QRj5k8xL7TG/BuV6AM/UvWbLkpZqamlg247aT+1i2yykf01QsXvysrJ8gfg8X6a6cyjCumGsq5MX5KEeqEifCRzmyB9YnYVynEpviRHCqzWhrn4RxnUpsptFOscuDBEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEITiPzYDF5m9H3R4c6dO39pampqDN0ie4HuvHsdOdWimg15rimZ4/vn3esxjBZ1cGNy9aC1eKx7IZ5C+HFZWVnL/fv3l0sHEL+BeA+eTPgFXjS5G6dTadsP2rbUHOv69etq0aJF8ZzLy7EMdQcdrFUthoTxDy/HUrD/aK5W/exridSDi/4inOh3eKylauXKlfMrKyvNto+MjKhr1659jueqPoWDbYdzRXqFP237YUCn+jzW6Ojoxr6+vvNhGhRIN6+qoferQLqxlPLVamwikXrkos+bN+/Mhg0bnqivr5+/ePFiheexzFPiIpM80RHdsM1O237Y9qQ6YunGRB65vEYsbdgrbDXC9curno8+VGoIp9fxRmOgenDRF2Kk+qc4Dp7u9LJmyvEkqLpw4cLHGLmeCjotpm3ft8EemamNWCtWrFD6rK6u3uhR/9wWL3sSj2fijHnImkqmP+1U/8OT6D/5u1Jf+uPkKXGRySE6oitlJiWF/zrt+5WIYt/PnldepLd0vIxlUi7OJafb8YabcKYMo1WrrKl0zr5BpQ7YvmtEx3/+7KSG6N68ebMFqX26jF/otO+nK3lh7Rey55af2ojlVtnDKsO0tkwv1IXBsQ9nkrDLRBdlls/Ucpc47btrTUnD2p8qGTxGxwrOipohCNCxQsCKqoqp6oZsKehj55M6NhXaZaIrZaZy/WNO+/7aSoW1X8ieWz4dy41KwjJMVT2yT6XNvlqr1F58gc0X8VVmckpcZPoQXSmj04VCp/1C+mHtF7Lnlk/HcqOSsEx21GXzU7YS5JgH6rJQ/9c3Jk+Ji0wO0RFdKTMpKfzXad+vRBT7fva88uhYXmQSlMt+FEaV7f39/Z9p53IzL3miI7pB97DETtr23dpaSBZog8/NSKHPCp1l8OWo4evy2rh0Gnemk9ogddp1pkPWI7vjWA89FB/phL/YFlw6FkCEdCxBJ7vk1ofQrRiZlolMFt+yTkr4Q+hU7Et7eZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZBAJgjgS+1n/JBSJjqWwU6UlVKfVq9e/RF+HiTX0NBwEb8hY70wVUo9eHjaGvmxGRPR6fxzaly9i3iFD7Jx5NarLcZ7PjqBsjBi5S3FK7lcrq27uzu2zUAVp6S0Z8+eL9y6des3S5cu/e6hQ4f+m1I1s2I23nuF4iy9+S41oTo8W59TXUk4lcP+Gjy79C6enOyqqqraf/jw4XFHfuQkbP4etrc5DeAZqpN4lurbTnmcNJyqC3VtR/gx7LwSx9ZcKxv/0eQvq/3KUFdcOyZyyU/hwAWpwNkxPDz819bW1ueSqmLBggXfgxMN2e1JWuR2Wdw4HLgR7f+R2JFQ0nFtzqXy8R1rnTGuylUbOuUcNSblkp/usWZiYuIipslVSVRz9OjRT2FnF0497Uq4y5InUYVqa2urgqE3ceqliIRvWvJE6phtI/EdS3ogU6JMefYjnSnQXoMZx2gi66wG/FrV1RmZEQWY8s7DrvmL7RJKOqIp12JjY2O/xihVY8+UtMjtslKOx1tj2XsuU9519S38n68xp8aUpkBdJS64jIT7scbqSnKNpe1jQf1TrH2ekFDLkgqttVqi67Wk2paUHT0UJ2NP7hLvqYuYGr+awoJd6btCGaXwH96GUcp9bZdMb2glBoFkpkLdgMkthUS2FrRJeyijFM5OjFL1dCo7GcZjEeDOeyx8LEwCJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACpUYg2bd00Hv9Jk0hEHgZIvG6p9UZ9Hd4IvxsybR6AiZ27969AK+pjTnVveROvVJLJ/uWDnovb9EUghBEp5CNAPkF2wEbQXQCVOWvgtfnza8CwD9dtV1T0vIVAZJvl2chnrhj4WXMDj/HkTzRSR1eqyF1+DlOJ35kKfV27Nix41G8A/ky2iI/dXleO5cVyhvWtZIvIxfimTmMtHoi/4UA1m63XzSnslfane9Aclo7kC6KU+lm2J0IskF818TL+BqmPyAuzobftFeNWBrcQZiZIzXHEkJ255oVp9KXabpzFdWpdBMcziU/4zsfZyadSvqcqmNJBQCalzD1xbpU4nfoxXyRFutuTdm6devTGKn+hjxxqs8xcj1/6tSpf7jplros8TVWqQNJq/0yYlnTn+lUqGe+pK2RLK1qZ80uHasI6B3ToKyxnke1Mg1OW9AXoSlFq4KOlTJquStEFebdH0JzTWVNf41W2nSurN0VFsOx3sZvHgvE2T0M9Ta+HK7o7Th+/PhnuHGRO8BpC3XrLtB0Lsl32zydXWCsvSQIeI1I1ohWEn1gI0mABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABIpPwIhSJV44Nd+8CVsWr4MFqi9t+2HbTf3wBCL/dC9eEAhVGx7FDaWftv26urpQ/xwDAwOB/ilCdTLDysV45j3D+Ng1LwKpOdbIyIg6d+6cV72UZ5xA5KnQj4s4VWdnpxoaGjLVNm3a5Kc+a3lBp7ew0+asdWgOVRx7xJJRSRxJH3anqqmpUevXr9dZDB8iArEcS5zqyJEj5ugkDuV0qvb2dlVZWVkyOGVk0qOTPV4yHZhDDY01FcpodPbsWXPKk6lPDpn+ZKQqNaeaQ9ckE02J5VgyGokD2ddTpexU9jWXPZ6JK13kTsSaCqWt2rnEoUrRqexTnle8yNckE9XFGrE0Ae1cki6lNZVuP8PkCSTiWNKsUnUo+5TnFU8ee/YtJuZYpYhK3wGWYtvnepsjO1bYz/7Cgkjbvn10Cts26pMACZAACZAACZAACZAACZAACZAACZAACZAACWSDwP8B9X0BfshR6QsAAAAASUVORK5CYII=) -91px -10px
      no-repeat;
    vertical-align: middle;
    cursor: pointer;
  }
  .tui-grid-btn-sorting-down {
    background-position: -133px -8px;
  }
  .tui-grid-btn-sorting-up {
    background-position: -112px -8px;
  }
  .tui-grid-btn-close {
    display: inline-block;
    overflow: hidden;
    height: 24px;
    width: 24px;
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACMCAYAAACeTFAfAAAAAXNSR0IArs4c6QAAC/1JREFUeAHtnV9sFMcdx2fPNiEEqGPFkFYFUkilhiMKwfghNarspC9+KK0gtkUQYLUSD6loqyoqlSoRE8m0VFUUgsoDUisCtMh24YE++KWJE4lgqcGUqDKpVEAhRlXAVZxi4ib1n+v3d7eD1+vdvf179p6/I61n9je/+c3MZ3+emZ3bvVOKgQRIgARIgARIgARIgARIgARIgARIgARIgATmPwFj/jextC3MNTQsmxgZeSmXy20FnMel9pxS1wzDOF/58MO/Md59d7S0LUpnbXQsy3Ubz2afzU1N/V7lcmss4umkYdw0MpnvVw0OvjUtZMqJAB3LpCJOpSYn/4LRyZMJMnOqouLbUZxrx44dj0xMTJysrKzcfebMmX87XZigsiRsXrp06RGM1Ccxeu/evHlzoHZmgnagHPVl+pORyu5UVR98oOSwBtHJ66KMVe433dLS8iCc6jz0myWWc79l3fSSsDk0NPSgTP9wqmaJ5dytfic5HQtUZE3lOv05UcNUmS/jlOch6+joEN6ncTxjqkl82pSbomBREjbhTJk7d+6cRpxvp8TmuW9/8a0YrLvp0sYI9N2gLQbsrUHLDA4Ovooy22zltplym9jfaRI2L1++/Cr6N6Odci5yf60qsp5wM9Ld3Y0ZIXxobW31XMdoy/v3749Uz+HDh33VM/7EE6MAt1TXq2M9DSJfi+7HmB7uIT/UdHjfSBknfIEv4/7nu0bHiv8KV4YxWW4jFobFa+Cw0c7CaaTSOmYZfcrYRoAjFoCMr19/EOusAzY29+8InRwM+1mvVF29+rK9DM8LBDhigYPsqI9/8ske33eG2CiVMkGdCNsCr6HMjx3KHenp6fmJg7yoaGBg4DWsD2fZxBrwSF1dXSibcbSTI5Z56UqxQSpbA7iL60GV1juuc9lstgV5U0W9yEEBTpXB3VqP3LXpbDjVuU2bNrUgDmUzjnbSsfTVQFyKj3TMDdE3UZ3sEfXjeA6j1X8Rhw6yeYl9pjfhXM/AmfpXrFjx3KpVqyLZjNpO7mNZLqd8TFNVU/OkrJ8gfh8X6Z4cyjCu5NdUyIvyUY5UJU6Ej3JkD6xX4qhOJTbFieBUW9HWXomjOpXYTKKdYpeBBEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABAITCP3YDF5m9HzRYXh4+O3m5uamwC2yFujKOdeRUa2qxZDnmuIJP+pzrscwWtWRxvjqQWvxWPdSPIXws4qKitbJyck10gGkbyLdjScTfo0XTe5F6VTS9v22LTHHunHjhlq2bFk053JzLEMNo4NZ1WpIHD24OZaC/YcyWfXLb8VSDy76s3CiP+Cxlup169YtXr58eb7td+/eVdevX/8cz1V9CgfbCecK9Qp/0vaDgE70eazR0dHG3t7eviAN8qWbU7XQ+60v3UhKuVo1NhVLPXLRFy1adH7Lli2P1tfXL66pqVF4Hit/SFpkkic6ohu02UnbD9qeREcs3ZjQI5fbiKUNu8VtRrB+udXz0YdKDeFwC683+aoHF30pRqp/iuPg6U43a3k5ngRVFy5c+Bgj19f9TotJ2/dssEtmYiPW2rVrlT5qa2sbXeqf3+LVj+HxTBwRg6ypZPrTTvU/PIn+878r9ZU/Fw5Ji0yC6IiulClIiv+12/cqEca+lz23vFBv6bgZK0u5OJccTuF1J+FsGUarNllT6ZwDg0odtnzXiE7/6smChujeunWrFWcHdBmv2G7fS1fygtovZs8pP7ERy6myhSrDtLZaL9SFwckPZ5OwykQXZdbM1nKW2O07a01Lg9qfLuk/Rcfyz4qaAQjQsQLACquKqeqmbCnosPsxnZqOrTLRlTLTud4pu31vbaWC2i9mzymfjuVEJWYZpqpu2afSZl/JKrUfX2DzZXyVmRySFpkOoitl9Hmx2G6/mH5Q+8XsOeXTsZyoxCyTHXXZ/JStBAmLQF0W6v/6TuGQtMgkiI7oSpmCpPhfu32vEmHse9lzy6NjuZGJUS77URhVdvb393+mncvJvOSJjuj63cMSO0nbd2prMZmvDT4nI8U+K7SXwZejBq/LbePSbtx+HtcGqd2u/TxgPbI7jvXQgvhIJ/jFNuHSsQAioGMJOtklNz+EbsPItFpksviWdVLMH0InYl/ay0ACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACZUEAX2o/64eUyqJjZdiJijT1acOGDR/h50EyDQ0NF/EbMuYLU2nqwcJpa+jHZvKIzuWeUuPqPaSrPJCNI7debTPe99DxlYURK2cqXslkMu1dXV2RbfqqOCGlffv2PXD79u3frVy58gdHjx79IqFq5sRstPcKxVl6cp1qSnW4tj6jOuNwKpv9jXh26T08OdlZXV196Pjx4+O2/NCnsPlH2N5hN4BnqM7gWaoX7PIo53CqTtS1E/HHsPNSFFvzrWz0R5O/pg4pQ11x7JjIJT+BgAtShaNjZGTkr21tbU/FVcWSJUtehBMNWe3JucitsqhpOHAT2v9TsSOxnEe1OZ/KR3eszca4qlTt6JR91CjIJT/ZsHFqauoipsn1cVRz4sSJT2FnDw497Uq8x5THUYVqb2+vhqE3cOiliMRvmPJY6phrI9EdS3ogU6JMedaQzBRorSGfxmgi66wG/FrV1VmZIQWY8vpgN/+L7RLLeUhTjsXGxsaOYZRaZc2Uc5FbZWlOR1tjWXsuU94N9T38n2/MT40JTYG6SlxwGQkPYY3VGecaS9vHgvoXWPs8KrGWxRWba7VY12txtS0uO3oojsee3CVOqIuYGr+ZwIJd6btCGaXwH96OUcp5bRdPb2glAoF4pkLdgMKWQixbC9qkNZZRCsdBjFL1dCorGaYjEeDOeyR8LEwCJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACaSMQ71s66L1+k6YYCLwMEXvdM+r0+zs8IX62ZEY9Pk/27t27BK+pjdnV3eR2vbSdx/uWDnovb9EUg+BHp5gNH/lF2wEbfnR8VOWtgtfn818FgH+6WqumnMtXBEi+VV4O6dgdCy9jdng5juSJTuLw2gypw8txDuJHlhJvx65dux7CO5DPoy3yU5d92rnMWN6wzkq+jFxIl00wkuqJ/BcC2MtW+yVzKmulXbkOnM5oB85L4lS6GVYngmwQ3zXxPL6G6U9Ii7PhN+1VE5YGw4jLJiTmWELI6lxz4lT6Ms10rpI6lW6CzbnkZ3wX4yhLp5I+J+pYUgGA5iROfLEulXgFvZgv0WLdqSnbt2//BkaqvyFPnOpzjFxPnz179h9OummXxb7GSjuQpNovI5Y5/eWdCvUslnNzJEuq2jmzS8cqAXrbNChrrKdRrUyDMxb0JWhKyaqgYyWMWu4KUUX+7g9xfk1lTn9N5nneucrtrrAUjvUOfvNYIM5tMNQ7+HK4krfj1KlTn+HGRe4AZyzUzbvAvHNJvtPm6dwCY+2pIOA2IpkjWir6wEaSAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmUnoARpkq8cJp/8yZoWbwO5qu+pO0HbTf1gxMI/dO9eEEgUG14FDeQftL26+rqAv1zDAwM+PqnCNTJMlYuxTPvZYyPXXMjkJhjDX+h1LHrbtVSXu4EQk+FXmDEqZrexmsp/ylovbjOS3vu8vxOb0Gnzbnr0fypOfKIJaOSOJIOVqfKfgmv2H9V5zBeSAQiOZY41Q8HCqOTOJTdqfoalap9ID04ZWTSo5M1nZ4ezJ+WRpoKZTQ6dq0w5cnUJ0GmPxmp0uZUhdbzb1wEIjmWjEbiQNb1VJqdyrrmsqbjgr2Q7ESaCgWUONdbjYVRKo1OZZ3y3NILySHi6mukEUs3YoXpXLKDmKY1lW4/4/gJxOJY0ixxrjQG65Tnlk5jv+a6zbE51lx3JEz9+g4wTFmW8SYQ2rGCfvbn3YzZuUnbt45Os2unhARIgARIgARIgARIgARIgARIgARIgARIgARIYCEQ+D9RZOqPG2fqIQAAAABJRU5ErkJggg==) -81px -84px
      no-repeat;
    vertical-align: middle;
    cursor: pointer;
    float: right;
  }
  .tui-grid-btn-filter {
    display: inline-block;
    overflow: hidden;
    height: 24px;
    width: 24px;
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACMCAYAAACeTFAfAAAAAXNSR0IArs4c6QAAC/1JREFUeAHtnV9sFMcdx2fPNiEEqGPFkFYFUkilhiMKwfghNarspC9+KK0gtkUQYLUSD6loqyoqlSoRE8m0VFUUgsoDUisCtMh24YE++KWJE4lgqcGUqDKpVEAhRlXAVZxi4ib1n+v3d7eD1+vdvf179p6/I61n9je/+c3MZ3+emZ3bvVOKgQRIgARIgARIgARIgARIgARIgARIgARIgATmPwFj/jextC3MNTQsmxgZeSmXy20FnMel9pxS1wzDOF/58MO/Md59d7S0LUpnbXQsy3Ubz2afzU1N/V7lcmss4umkYdw0MpnvVw0OvjUtZMqJAB3LpCJOpSYn/4LRyZMJMnOqouLbUZxrx44dj0xMTJysrKzcfebMmX87XZigsiRsXrp06RGM1Ccxeu/evHlzoHZmgnagHPVl+pORyu5UVR98oOSwBtHJ66KMVe433dLS8iCc6jz0myWWc79l3fSSsDk0NPSgTP9wqmaJ5dytfic5HQtUZE3lOv05UcNUmS/jlOch6+joEN6ncTxjqkl82pSbomBREjbhTJk7d+6cRpxvp8TmuW9/8a0YrLvp0sYI9N2gLQbsrUHLDA4Ovooy22zltplym9jfaRI2L1++/Cr6N6Odci5yf60qsp5wM9Ld3Y0ZIXxobW31XMdoy/v3749Uz+HDh33VM/7EE6MAt1TXq2M9DSJfi+7HmB7uIT/UdHjfSBknfIEv4/7nu0bHiv8KV4YxWW4jFobFa+Cw0c7CaaTSOmYZfcrYRoAjFoCMr19/EOusAzY29+8InRwM+1mvVF29+rK9DM8LBDhigYPsqI9/8ske33eG2CiVMkGdCNsCr6HMjx3KHenp6fmJg7yoaGBg4DWsD2fZxBrwSF1dXSibcbSTI5Z56UqxQSpbA7iL60GV1juuc9lstgV5U0W9yEEBTpXB3VqP3LXpbDjVuU2bNrUgDmUzjnbSsfTVQFyKj3TMDdE3UZ3sEfXjeA6j1X8Rhw6yeYl9pjfhXM/AmfpXrFjx3KpVqyLZjNpO7mNZLqd8TFNVU/OkrJ8gfh8X6Z4cyjCu5NdUyIvyUY5UJU6Ej3JkD6xX4qhOJTbFieBUW9HWXomjOpXYTKKdYpeBBEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABAITCP3YDF5m9HzRYXh4+O3m5uamwC2yFujKOdeRUa2qxZDnmuIJP+pzrscwWtWRxvjqQWvxWPdSPIXws4qKitbJyck10gGkbyLdjScTfo0XTe5F6VTS9v22LTHHunHjhlq2bFk053JzLEMNo4NZ1WpIHD24OZaC/YcyWfXLb8VSDy76s3CiP+Cxlup169YtXr58eb7td+/eVdevX/8cz1V9CgfbCecK9Qp/0vaDgE70eazR0dHG3t7eviAN8qWbU7XQ+60v3UhKuVo1NhVLPXLRFy1adH7Lli2P1tfXL66pqVF4Hit/SFpkkic6ohu02UnbD9qeREcs3ZjQI5fbiKUNu8VtRrB+udXz0YdKDeFwC683+aoHF30pRqp/iuPg6U43a3k5ngRVFy5c+Bgj19f9TotJ2/dssEtmYiPW2rVrlT5qa2sbXeqf3+LVj+HxTBwRg6ypZPrTTvU/PIn+878r9ZU/Fw5Ji0yC6IiulClIiv+12/cqEca+lz23vFBv6bgZK0u5OJccTuF1J+FsGUarNllT6ZwDg0odtnzXiE7/6smChujeunWrFWcHdBmv2G7fS1fygtovZs8pP7ERy6myhSrDtLZaL9SFwckPZ5OwykQXZdbM1nKW2O07a01Lg9qfLuk/Rcfyz4qaAQjQsQLACquKqeqmbCnosPsxnZqOrTLRlTLTud4pu31vbaWC2i9mzymfjuVEJWYZpqpu2afSZl/JKrUfX2DzZXyVmRySFpkOoitl9Hmx2G6/mH5Q+8XsOeXTsZyoxCyTHXXZ/JStBAmLQF0W6v/6TuGQtMgkiI7oSpmCpPhfu32vEmHse9lzy6NjuZGJUS77URhVdvb393+mncvJvOSJjuj63cMSO0nbd2prMZmvDT4nI8U+K7SXwZejBq/LbePSbtx+HtcGqd2u/TxgPbI7jvXQgvhIJ/jFNuHSsQAioGMJOtklNz+EbsPItFpksviWdVLMH0InYl/ay0ACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACZUEAX2o/64eUyqJjZdiJijT1acOGDR/h50EyDQ0NF/EbMuYLU2nqwcJpa+jHZvKIzuWeUuPqPaSrPJCNI7debTPe99DxlYURK2cqXslkMu1dXV2RbfqqOCGlffv2PXD79u3frVy58gdHjx79IqFq5sRstPcKxVl6cp1qSnW4tj6jOuNwKpv9jXh26T08OdlZXV196Pjx4+O2/NCnsPlH2N5hN4BnqM7gWaoX7PIo53CqTtS1E/HHsPNSFFvzrWz0R5O/pg4pQ11x7JjIJT+BgAtShaNjZGTkr21tbU/FVcWSJUtehBMNWe3JucitsqhpOHAT2v9TsSOxnEe1OZ/KR3eszca4qlTt6JR91CjIJT/ZsHFqauoipsn1cVRz4sSJT2FnDw497Uq8x5THUYVqb2+vhqE3cOiliMRvmPJY6phrI9EdS3ogU6JMedaQzBRorSGfxmgi66wG/FrV1VmZIQWY8vpgN/+L7RLLeUhTjsXGxsaOYZRaZc2Uc5FbZWlOR1tjWXsuU94N9T38n2/MT40JTYG6SlxwGQkPYY3VGecaS9vHgvoXWPs8KrGWxRWba7VY12txtS0uO3oojsee3CVOqIuYGr+ZwIJd6btCGaXwH96OUcp5bRdPb2glAoF4pkLdgMKWQixbC9qkNZZRCsdBjFL1dCorGaYjEeDOeyR8LEwCJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACaSMQ71s66L1+k6YYCLwMEXvdM+r0+zs8IX62ZEY9Pk/27t27BK+pjdnV3eR2vbSdx/uWDnovb9EUg+BHp5gNH/lF2wEbfnR8VOWtgtfn818FgH+6WqumnMtXBEi+VV4O6dgdCy9jdng5juSJTuLw2gypw8txDuJHlhJvx65dux7CO5DPoy3yU5d92rnMWN6wzkq+jFxIl00wkuqJ/BcC2MtW+yVzKmulXbkOnM5oB85L4lS6GVYngmwQ3zXxPL6G6U9Ii7PhN+1VE5YGw4jLJiTmWELI6lxz4lT6Ms10rpI6lW6CzbnkZ3wX4yhLp5I+J+pYUgGA5iROfLEulXgFvZgv0WLdqSnbt2//BkaqvyFPnOpzjFxPnz179h9OummXxb7GSjuQpNovI5Y5/eWdCvUslnNzJEuq2jmzS8cqAXrbNChrrKdRrUyDMxb0JWhKyaqgYyWMWu4KUUX+7g9xfk1lTn9N5nneucrtrrAUjvUOfvNYIM5tMNQ7+HK4krfj1KlTn+HGRe4AZyzUzbvAvHNJvtPm6dwCY+2pIOA2IpkjWir6wEaSAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmUnoARpkq8cJp/8yZoWbwO5qu+pO0HbTf1gxMI/dO9eEEgUG14FDeQftL26+rqAv1zDAwM+PqnCNTJMlYuxTPvZYyPXXMjkJhjDX+h1LHrbtVSXu4EQk+FXmDEqZrexmsp/ylovbjOS3vu8vxOb0Gnzbnr0fypOfKIJaOSOJIOVqfKfgmv2H9V5zBeSAQiOZY41Q8HCqOTOJTdqfoalap9ID04ZWTSo5M1nZ4ezJ+WRpoKZTQ6dq0w5cnUJ0GmPxmp0uZUhdbzb1wEIjmWjEbiQNb1VJqdyrrmsqbjgr2Q7ESaCgWUONdbjYVRKo1OZZ3y3NILySHi6mukEUs3YoXpXLKDmKY1lW4/4/gJxOJY0ixxrjQG65Tnlk5jv+a6zbE51lx3JEz9+g4wTFmW8SYQ2rGCfvbn3YzZuUnbt45Os2unhARIgARIgARIgARIgARIgARIgARIgARIgARIYCEQ+D9RZOqPG2fqIQAAAABJRU5ErkJggg==) -13px -84px
      no-repeat;
    vertical-align: middle;
    cursor: pointer;
  }
  .tui-grid-btn-filter-active {
    background-position: -47px -84px;
  }

  .tui-grid-filter-icon {
    cursor: default;
  }

  .tui-grid-layer-state {
    position: absolute;
    background: #fff;
    text-align: center;
    z-index: 15;
  }
  .tui-grid-layer-state p {
    position: absolute;
    top: 50%;
    left: 0;
    right: 0;
    margin-top: -7px;
    font-size: 14px;
    color: #ccc;
  }
  .tui-grid-layer-state-content {
    padding-top: 50px;
  }
  .tui-grid-layer-state-loading {
    display: block;
    margin: 10px auto 0;
    background: url(data:image/gif;base64,R0lGODlhlgANAKIHAMzi5FnYeeXw8czh5Nnp67/a3f///////yH/C05FVFNDQVBFMi4wAwEAAAAh+QQFFAAHACwAAAAAlgANAAADXnh60v4wykmrvTjrHdfiYCiOZNkpZqquLIg6RizPdG3feK7vfO//swcDBiwaj8ik0iBZOp/QaC8irVqvSSp2y+3Smt6wGCp8jM9ooHDYarvfpg98Tq9LPC+7fq/yJAAAIfkEBQAABwAsAAAAAJYADQAAA2V4etT+MMpJq7046x3X4mAojmTZKWaqriyIOl4sz3Rt33iu77z9MLCecEgsGo9AyCLAbDqfT6R0Sh2eDtBstsrtej9KhXbc/JrPRgl6zT7/fu24PB1s2e94FTjP7/uve3+CgykeCQAh+QQFAAAHACwAAAAAlgANAAADa3h6MP4wykmrvTjrzSFYSyeOZGmeUoiubOt2CgTOdG3feK7vfO/jMtlvSCwaj8jDBBloOp9QaHJKpaaO0Wy2yu3+rkat2Oktm23Ls3rNVjmUj7Z8bo3DX/i8HuXe+/+AETQNEoSBh4gcHwsJACH5BAUAAAcALAAAAACWAA0AAANseHrV/jDKSau9OOsd1+JgKI5k2Slmqq4siDpGLM90bd94ru987/+zBwMGLBqPyKTSIFEGntCodEqtRpfYbC3itHq/Vq04y02Cz+jAeJ1sst/wuE74kNvvb+Gwxe/7TR9/goOEEh4vhYmKKh4JACH5BAUAAAcALBoABQA8AAMAAAMUaLrcHTDKSauVLufLO9fg4o1kkAAAIfkEBQAABwAsLgAFADwAAwAAAxRoutwdMMpJq5Uu58s71+DijWSQAAAh+QQFAAAHACxCAAUAPAADAAADFGi63B0wykmrlS7nyzvX4OKNZJAAACH5BAUAAAcALAAAAACWAA0AAAN0eHow/jDKSau9OOvNIVhLJ45kaZ5SiK5s63YKZMx0bd94ru987//AYA1ykAmPyKRyyTRMmtBoNECtWq/YrNZKk0i/YOF2TB53I+G0OlduuwNn9HpOr8cHxYd9z48S8y+BgoMoKoSHiIkpIAwTDYqQkR0fCwkAIfkEBQAABwAsAAAAAJYADQAAA2Z4etT+MMpJq7046x3X4mAojmTZKWaqriyIOl4sz3Rt33iu77z9MLCecEgsGo9ACHLJZBqe0KhUejw1r9jddLutKrPg8IxLhnq/4rR6/WokCey4nPl7t+74POmj7/v/EjKAg4QsHgkAIfkEBSgABwAsAAAAAJYADQAAA154etL+MMpJq7046x3X4mAojmTZKWaqriyIOkYsz3Rt33iu73zv/7MHAwYsGo/IpNIgWTqf0GgvIq1ar0kqdsvt0presBgqfIzPaKBw2Gq736YPfE6vSzwvu36v8iQAACH5BAUAAAcALAAAAACWAA0AAANjeHrU/jDKSau9OOsd1+JgKI5k2Slmqq4siDpeLM90bd94ru+8/TCwnnBILBqPQAhyyWwiA9CodPpROq/Y7GzKlVZ/2rCY2S1/weO0WvtDr99wIrhFr9tV57t+z3e/+oCBeAsJACH5BAUAAAcALAAAAACWAA0AAANpeHow/jDKSau9OOvNIVhLJ45kaZ5SiK5s63YKBM50bd94ru987+My2W9ILBqPyMMkyWw6QYGodEqlDlPPrHZY7Xavka14jPOapeAwec1mBx/tuLwpfNnveJYqz+/7sSANEoJ/hYYcHwsJACH5BAUAAAcALAAAAACWAA0AAANteHrV/jDKSau9OOsd1+JgKI5k2Slmqq4siDpGLM90bd94ru987/+zBwMGLBqPyKTSIFk6n7yAdEqtWq9Y6i8C7Xpn2bA4vIV8z9Cxeh0om9HwuNwmfMzveK9w2Or7/yYfgIOEhRIeL4aKiyoeCQAh+QQFAAAHACxHAAUAPAADAAADFBi63P6QmUmrtTHrfHvfYBh4JJUAACH5BAUAAAcALDMABQA8AAMAAAMUGLrc/pCZSau1Met8e99gGHgklQAAIfkEBQAABwAsHwAFADwAAwAAAxQYutz+kJlJq7Ux63x732AYeCSVAAAh+QQFAAAHACwAAAAAlgANAAADdHh6MP4wykmrvTjrzSFYSyeOZGmeUoiubOt2CmTMdG3feK7vfO//wGANcpAJj8ikcsk0THKBqHRKrVqv06Z2q5RAseAwlksu97w4sXodMLvftCd8Tq/HH8WHfc/fEvMvgYKDKCqEh4iJKSAMEw2KkJEdHwsJACH5BAUAAAcALAAAAACWAA0AAANqeHrU/jDKSau9OOsd1+JgKI5k2Slmqq4siDpGLM90bd94ru987/+zBwMGLBqPyKTSIJEFntCodBpdWq/YXsRJ7Xqz4DB4G/Oap+K0+thcu99v4QNOr1+Fw5Z+zzd9+oCBghIeL4OHiCoeCQAh+QQFFAAHACwAAAAAlgANAAADXnh60v4wykmrvTjrHdfiYCiOZNkpZqquLIg6RizPdG3feK7vfO//swcDBiwaj8ik0iBZOp/QaC8irVqvSSp2y+3Smt6wGCp8jM9ooHDYarvfpg98Tq9LPC+7fq/yJAAAOw==);
    border: 0;
    width: 150px;
    height: 13px;
  }
  .tui-grid-layer-editing {
    position: absolute;
    background: #fff;
    z-index: 15;
    padding: 0 4px;
    border-style: solid;
    border-width: 1px;
    white-space: nowrap;
    box-sizing: border-box;
  }
  .tui-grid-layer-editing textarea {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    padding: 3px 10px;
    box-sizing: border-box;
    white-space: normal;
    word-break: break-all;
    overflow: hidden;
  }
  .tui-grid-layer-focus-border {
    position: absolute;
    overflow: hidden;
    z-index: 15;
  }
  .tui-grid-layer-selection {
    position: absolute;
    top: 0;
    width: 0;
    height: 0;
    border-style: solid;
    border-width: 1px;
    opacity: 0.1;
    filter: alpha(opacity=10);
  }

  .tui-grid-table {
    margin: 0;
    width: 1px;
    box-sizing: border-box;
    table-layout: fixed;
    border-collapse: collapse;
    border: 1px hidden transparent;
    border-bottom: none;
  }
  .tui-grid-lside-area .tui-grid-table {
    width: 100%;
  }
  .tui-grid-cell {
    border-width: 1px;
    border-style: solid;
    white-space: nowrap;
    padding: 0;
    overflow: hidden;
  }
  .tui-grid-cell .tui-grid-cell-content {
    padding: 12px 12px 11px;
    overflow: hidden;
    box-sizing: border-box;
    word-break: break-all;
  }
  .tui-grid-cell img {
    vertical-align: middle;
  }
  .tui-grid-cell-header {
    padding: 4px 5px;
    text-align: center;
    /* @TODO: box-sizing standardize required */
    box-sizing: border-box;
  }
  .tui-grid-cell-summary {
    padding: 0 12px;
  }
  .tui-grid-cell-disabled input[type='text'],
  .tui-grid-cell-disabled input[type='password'] {
    opacity: 0.3;
    filter: alpha(opacity=30);
  }
  .tui-grid-cell-ellipsis .tui-grid-cell-content {
    text-overflow: ellipsis;
  }
  .tui-grid-cell-has-input .tui-grid-cell-content {
    padding: 4px 5px;
  }
  .tui-grid-cell-has-tree {
    height: inherit;
    box-sizing: border-box;
  }
  .tui-grid-cell-has-tree .tui-grid-cell-content {
    padding-left: 14px;
  }
  .tui-grid-cell-content .tui-grid-content-before {
    float: left;
    margin-right: 2px;
    line-height: 1.5;
  }
  .tui-grid-cell-content .tui-grid-content-after {
    float: right;
    margin-left: 2px;
    line-height: 1.5;
  }
  .tui-grid-cell-content .tui-grid-content-input {
    display: block;
    overflow: hidden;
    line-height: 1.5;
    *margin-left: -2px;
    *padding-left: 2px;
  }
  .tui-grid-cell-content input[type='text'],
  .tui-grid-cell-content input[type='password'] {
    width: 100%;
    padding: 6px 7px;
    border: solid 1px #ddd;
  }
  .tui-grid-cell-content label + input {
    margin-left: 10px;
  }
  .tui-grid-cell-content select:not(.tui-time-picker-select) {
    box-sizing: border-box;
  }
  .tui-grid-column-resize-container {
    display: none;
    position: relative;
    width: 0;
  }
  .tui-grid-column-resize-handle {
    float: left;
    position: absolute;
    bottom: 1px;
    left: -99px;
    width: 7px;
    background: #000;
    opacity: 0;
    filter: alpha(opacity=0);
    cursor: col-resize;
  }
  .tui-grid-column-resize-handle-last {
    width: 3px;
  }
  .tui-grid-border-line {
    position: absolute;
    z-index: 15;
  }
  .tui-grid-border-line-top {
    top: 0;
    left: 0;
    right: 0;
    height: 1px;
  }
  .tui-grid-border-line-left {
    top: 0;
    bottom: 17px;
    left: 0;
    width: 1px;
  }
  .tui-grid-border-line-right {
    top: 0;
    bottom: 0;
    right: 0;
    width: 1px;
  }
  .tui-grid-border-line-bottom {
    bottom: 0;
    left: 0;
    right: 17px;
    height: 1px;
    z-index: 10;
  }
  .tui-grid-no-scroll-x .tui-grid-border-line-left {
    bottom: 0;
    right: 0;
  }
  .tui-grid-no-scroll-y .tui-grid-border-line-bottom {
    right: 0;
  }
  .tui-grid-content-area {
    position: relative;
    border-style: solid;
    border-width: 0 0 1px;
  }
  .tui-grid-content-area.tui-grid-no-scroll-x {
    border-bottom-width: 0;
  }
  .tui-grid-header-area {
    border-style: solid;
    border-width: 0 0 1px;
    position: relative;
    overflow: hidden;
  }
  .tui-grid-header-area .tui-grid-table {
    border-top-style: solid;
  }
  .tui-grid-body-area {
    border-style: solid;
    border-width: 0;
    position: relative;
    overflow: scroll;
  }
  .tui-grid-has-summary-top .tui-grid-body-area {
    margin-top: -17px;
    border-top-width: 1px;
  }
  .tui-grid-no-scroll-x.tui-grid-has-summary-top .tui-grid-body-area {
    margin-top: 0;
  }
  .tui-grid-summary-area {
    position: relative;
    margin-top: -18px;
    border-top: 1px solid;
    overflow-y: hidden;
    overflow-x: scroll;
  }
  .tui-grid-no-scroll-x .tui-grid-summary-area {
    margin-top: -1px;
    margin-bottom: 1px;
    overflow-x: hidden;
  }
  .tui-grid-no-scroll-x .tui-grid-summary-area-right {
    bottom: 0;
  }
  .tui-grid-no-scroll-x.tui-grid-has-summary-top {
    margin-top: 0;
  }
  .tui-grid-has-summary-top .tui-grid-summary-area {
    margin-top: 0;
    border-top-style: hidden;
    margin-bottom: 0;
  }
  .tui-grid-lside-area {
    display: none;
    position: absolute;
    top: 0;
    left: 0;
    overflow: hidden;
    z-index: 5;
  }
  .tui-grid-lside-area .tui-grid-body-area {
    margin-right: -17px;
  }
  .tui-grid-lside-area .tui-grid-body-area .tui-grid-selection-layer {
    left: 1px;
  }
  .tui-grid-rside-area {
    display: none;
    overflow: hidden;
  }
  .tui-grid-rside-area .tui-grid-header-area,
  .tui-grid-rside-area .tui-grid-summary-area {
    margin-right: 17px;
  }
  .tui-grid-rside-area .tui-grid-frozen-border-top {
    position: absolute;
    top: 0;
  }
  .tui-grid-rside-area
    .tui-grid-frozen-border-top
    .tui-grid-column-resize-handle {
    top: 0;
  }
  .tui-grid-rside-area .tui-grid-frozen-border-bottom {
    position: absolute;
    bottom: 0;
    height: 17px;
  }
  .tui-grid-no-scroll-y .tui-grid-rside-area .tui-grid-header-area,
  .tui-grid-no-scroll-y .tui-grid-rside-area .tui-grid-summary-area {
    margin-right: 0;
  }
  .tui-grid-body-container {
    position: relative;
    margin-top: -1px;
  }
  .tui-grid-table-container {
    position: absolute;
  }
  .tui-grid-scrollbar-right-top {
    display: block;
    position: absolute;
    top: 0;
    right: 0;
    width: 16px;
    border-style: solid;
    border-width: 0 1px 1px 1px;
    z-index: 10;
  }
  .tui-grid-scrollbar-left-bottom {
    position: absolute;
    left: 0;
    right: 0;
    bottom: 0;
    height: 17px;
    border-style: solid;
    border-width: 0 1px;
    z-index: 10;
  }
  .tui-grid-scrollbar-right-bottom {
    position: absolute;
    bottom: 0;
    right: 0;
    width: 16px;
    border-style: solid;
    border-width: 1px 1px 0 1px;
    z-index: 10;
  }
  .tui-grid-no-scroll-x .tui-grid-scrollbar-right-bottom {
    height: 0;
  }
  .tui-grid-no-scroll-x.tui-grid-has-summary-bottom
    .tui-grid-scrollbar-right-bottom {
    border-bottom-width: 1px;
  }
  .tui-grid-no-scroll-y .tui-grid-scrollbar-right-bottom {
    width: 0;
    height: 16px;
    border-left: 0;
  }
  .tui-grid-scrollbar-y-inner-border {
    display: block;
    position: absolute;
    right: 17px;
    width: 1px;
    z-index: 10;
  }
  .tui-grid-scrollbar-y-outer-border {
    display: block;
    position: absolute;
    top: 0;
    bottom: 0;
    right: 0;
    width: 1px;
    z-index: 10;
  }
  .tui-grid-scrollbar-frozen-border {
    position: absolute;
    bottom: 0;
    width: 0;
    height: 17px;
    border-style: solid;
    border-width: 0 1px 0 0;
    z-index: 10;
  }
  .tui-grid-frozen-border {
    position: absolute;
    top: 0;
    bottom: 0;
    z-index: 5;
  }
  .tui-grid-height-resize-handle {
    overflow: hidden;
    background-color: #fff;
    cursor: row-resize;
    height: 17px;
    border-style: solid;
    border-width: 0 1px 1px;
    border-color: #fff;
    font-size: 0;
    text-align: center;
  }
  .tui-grid-height-resize-handle button {
    display: block;
    width: 100%;
    cursor: row-resize;
    padding: 0;
    margin: 0;
    outline: 0;
    border: 0;
    background: transparent;
  }
  .tui-grid-height-resize-handle button span {
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACMCAYAAACeTFAfAAAAAXNSR0IArs4c6QAAC/tJREFUeAHtnX9oVtcZx899kzhrNaTSaDeIdrpCayy1xoBdZJh2CPljbmiT4EQNG/jHwG2MMgcDkxTi5hilVrY/xA2rbpJk+of7IyjrXMEaWI2zjNjBqtRGRtXRlMRm3aJ5931u7jE3N/fe9/58k/f6vXBzznnOc55zzuc+Oefc8977vkrxIAESIAESIAESIAESIAESIAESIAESIAESIIG5T8CY+00sbgvzDQ2L7g0Pv5LP5zcDzlek9rxSHxiGcab8scd+abzzzmhxW1SatdGxbNdtvLb2xfzExG9VPr/cJp6KGsYNI5f7TsXg4J+nhIy5EaBjWVTEqdT9+3/C6OTLBJl5VVb29TjOtW3btsfv3bt3rLy8fOfJkyf/7XZhwsrSsHnp0qXHMVIfw+i9c926daHamQvbgSzqy/QnI5XTqSref1/JaT9Ex9RFGbs8aLy5ufkRONUZ6DdJKOmgZb300rA5NDT0iEz/cKomCSXtVb+bnI4FKrKm8pz+3KhhqjTLuOX5yDo6OoT3CZwvWGoSnrDklihckIZNOFPu9u3bJxCa7ZTQSgf2l8CK4bpbWtoYgb4ZtsWAvTlsmcHBwddQZouj3BZL7hAHS6Zh8/Lly6+hf9PaKWmRB2tVgfWEl5Genh7MCNGPlpYW33WMtrx3795Y9Rw4cCBQPePPPDMKcAt1vTrU0yDytehBiOnhLvIjTYcPjGQ4Egh8hvtvdo2OlfwVLo9iMmsjFobFD8BhjZOF20ildawyOsnQQYAjFoCMr1rViXXWPgebB3eEbg6G/axXK65ebXeWYXqSAEcscJAd9fFPPtkV+M4QG6VSJqwTYVvgdZT5gUu5g729vT90kRcUDQwMvI714QybWAMerKuri2QziXZyxLIuXTE2SGVrAHdxvajSfsd1ura2thl5EwW9yEUBTpXD3Vqv3LXpbDjV6bVr1zYjjGQziXbSsfTVQFiMj3SsDdG3UJ3sEfXjfAmj1X8QRj5k8xL7TG/BuV6AM/UvWbLkpZqamlg247aT+1i2yykf01QsXvysrJ8gfg8X6a6cyjCumGsq5MX5KEeqEifCRzmyB9YnYVynEpviRHCqzWhrn4RxnUpsptFOscuDBEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEITiPzYDF5m9H3R4c6dO39pampqDN0ie4HuvHsdOdWimg15rimZ4/vn3esxjBZ1cGNy9aC1eKx7IZ5C+HFZWVnL/fv3l0sHEL+BeA+eTPgFXjS5G6dTadsP2rbUHOv69etq0aJF8ZzLy7EMdQcdrFUthoTxDy/HUrD/aK5W/exridSDi/4inOh3eKylauXKlfMrKyvNto+MjKhr1659jueqPoWDbYdzRXqFP237YUCn+jzW6Ojoxr6+vvNhGhRIN6+qoferQLqxlPLVamwikXrkos+bN+/Mhg0bnqivr5+/ePFiheexzFPiIpM80RHdsM1O237Y9qQ6YunGRB65vEYsbdgrbDXC9curno8+VGoIp9fxRmOgenDRF2Kk+qc4Dp7u9LJmyvEkqLpw4cLHGLmeCjotpm3ft8EemamNWCtWrFD6rK6u3uhR/9wWL3sSj2fijHnImkqmP+1U/8OT6D/5u1Jf+uPkKXGRySE6oitlJiWF/zrt+5WIYt/PnldepLd0vIxlUi7OJafb8YabcKYMo1WrrKl0zr5BpQ7YvmtEx3/+7KSG6N68ebMFqX26jF/otO+nK3lh7Rey55af2ojlVtnDKsO0tkwv1IXBsQ9nkrDLRBdlls/Ucpc47btrTUnD2p8qGTxGxwrOipohCNCxQsCKqoqp6oZsKehj55M6NhXaZaIrZaZy/WNO+/7aSoW1X8ieWz4dy41KwjJMVT2yT6XNvlqr1F58gc0X8VVmckpcZPoQXSmj04VCp/1C+mHtF7Lnlk/HcqOSsEx21GXzU7YS5JgH6rJQ/9c3Jk+Ji0wO0RFdKTMpKfzXad+vRBT7fva88uhYXmQSlMt+FEaV7f39/Z9p53IzL3miI7pB97DETtr23dpaSBZog8/NSKHPCp1l8OWo4evy2rh0Gnemk9ogddp1pkPWI7vjWA89FB/phL/YFlw6FkCEdCxBJ7vk1ofQrRiZlolMFt+yTkr4Q+hU7Et7eZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZBAJgjgS+1n/JBSJjqWwU6UlVKfVq9e/RF+HiTX0NBwEb8hY70wVUo9eHjaGvmxGRPR6fxzaly9i3iFD7Jx5NarLcZ7PjqBsjBi5S3FK7lcrq27uzu2zUAVp6S0Z8+eL9y6des3S5cu/e6hQ4f+m1I1s2I23nuF4iy9+S41oTo8W59TXUk4lcP+Gjy79C6enOyqqqraf/jw4XFHfuQkbP4etrc5DeAZqpN4lurbTnmcNJyqC3VtR/gx7LwSx9ZcKxv/0eQvq/3KUFdcOyZyyU/hwAWpwNkxPDz819bW1ueSqmLBggXfgxMN2e1JWuR2Wdw4HLgR7f+R2JFQ0nFtzqXy8R1rnTGuylUbOuUcNSblkp/usWZiYuIipslVSVRz9OjRT2FnF0497Uq4y5InUYVqa2urgqE3ceqliIRvWvJE6phtI/EdS3ogU6JMefYjnSnQXoMZx2gi66wG/FrV1RmZEQWY8s7DrvmL7RJKOqIp12JjY2O/xihVY8+UtMjtslKOx1tj2XsuU9519S38n68xp8aUpkBdJS64jIT7scbqSnKNpe1jQf1TrH2ekFDLkgqttVqi67Wk2paUHT0UJ2NP7hLvqYuYGr+awoJd6btCGaXwH96GUcp9bZdMb2glBoFkpkLdgMkthUS2FrRJeyijFM5OjFL1dCo7GcZjEeDOeyx8LEwCJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACpUYg2bd00Hv9Jk0hEHgZIvG6p9UZ9Hd4IvxsybR6AiZ27969AK+pjTnVveROvVJLJ/uWDnovb9EUghBEp5CNAPkF2wEbQXQCVOWvgtfnza8CwD9dtV1T0vIVAZJvl2chnrhj4WXMDj/HkTzRSR1eqyF1+DlOJ35kKfV27Nix41G8A/ky2iI/dXleO5cVyhvWtZIvIxfimTmMtHoi/4UA1m63XzSnslfane9Aclo7kC6KU+lm2J0IskF818TL+BqmPyAuzobftFeNWBrcQZiZIzXHEkJ255oVp9KXabpzFdWpdBMcziU/4zsfZyadSvqcqmNJBQCalzD1xbpU4nfoxXyRFutuTdm6devTGKn+hjxxqs8xcj1/6tSpf7jplros8TVWqQNJq/0yYlnTn+lUqGe+pK2RLK1qZ80uHasI6B3ToKyxnke1Mg1OW9AXoSlFq4KOlTJquStEFebdH0JzTWVNf41W2nSurN0VFsOx3sZvHgvE2T0M9Ta+HK7o7Th+/PhnuHGRO8BpC3XrLtB0Lsl32zydXWCsvSQIeI1I1ohWEn1gI0mABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABIpPwIhSJV44Nd+8CVsWr4MFqi9t+2HbTf3wBCL/dC9eEAhVGx7FDaWftv26urpQ/xwDAwOB/ilCdTLDysV45j3D+Ng1LwKpOdbIyIg6d+6cV72UZ5xA5KnQj4s4VWdnpxoaGjLVNm3a5Kc+a3lBp7ew0+asdWgOVRx7xJJRSRxJH3anqqmpUevXr9dZDB8iArEcS5zqyJEj5ugkDuV0qvb2dlVZWVkyOGVk0qOTPV4yHZhDDY01FcpodPbsWXPKk6lPDpn+ZKQqNaeaQ9ckE02J5VgyGokD2ddTpexU9jWXPZ6JK13kTsSaCqWt2rnEoUrRqexTnle8yNckE9XFGrE0Ae1cki6lNZVuP8PkCSTiWNKsUnUo+5TnFU8ee/YtJuZYpYhK3wGWYtvnepsjO1bYz/7Cgkjbvn10Cts26pMACZAACZAACZAACZAACZAACZAACZAACZAACWSDwP8B9X0BfshR6QsAAAAASUVORK5CYII=)
      no-repeat -39px -10px;
    display: inline-block;
    width: 16px;
    height: 17px;
  }
  .tui-grid-btn-tree {
    position: absolute;
    padding: 0;
    padding-left: 4px;
    margin-top: -8px;
    top: 50%;
    width: 15px;
    height: 15px;
    background: transparent;
    border: none;
    outline: none;
    font-size: 0;
    vertical-align: middle;
    cursor: pointer;
  }
  .tui-grid-tree-icon {
    position: absolute;
    margin-top: -7px;
    top: 50%;
    width: 22px;
    height: 14px;
    font-size: 0;
    vertical-align: middle;
  }
  .tui-grid-tree-icon i {
    display: inline-block;
    margin-left: 5px;
    width: 14px;
    height: 14px;
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACMCAYAAACeTFAfAAAAAXNSR0IArs4c6QAAC/tJREFUeAHtnX9oVtcZx899kzhrNaTSaDeIdrpCayy1xoBdZJh2CPljbmiT4EQNG/jHwG2MMgcDkxTi5hilVrY/xA2rbpJk+of7IyjrXMEaWI2zjNjBqtRGRtXRlMRm3aJ5931u7jE3N/fe9/58k/f6vXBzznnOc55zzuc+Oefc8977vkrxIAESIAESIAESIAESIAESIAESIAESIAESIIG5T8CY+00sbgvzDQ2L7g0Pv5LP5zcDzlek9rxSHxiGcab8scd+abzzzmhxW1SatdGxbNdtvLb2xfzExG9VPr/cJp6KGsYNI5f7TsXg4J+nhIy5EaBjWVTEqdT9+3/C6OTLBJl5VVb29TjOtW3btsfv3bt3rLy8fOfJkyf/7XZhwsrSsHnp0qXHMVIfw+i9c926daHamQvbgSzqy/QnI5XTqSref1/JaT9Ex9RFGbs8aLy5ufkRONUZ6DdJKOmgZb300rA5NDT0iEz/cKomCSXtVb+bnI4FKrKm8pz+3KhhqjTLuOX5yDo6OoT3CZwvWGoSnrDklihckIZNOFPu9u3bJxCa7ZTQSgf2l8CK4bpbWtoYgb4ZtsWAvTlsmcHBwddQZouj3BZL7hAHS6Zh8/Lly6+hf9PaKWmRB2tVgfWEl5Genh7MCNGPlpYW33WMtrx3795Y9Rw4cCBQPePPPDMKcAt1vTrU0yDytehBiOnhLvIjTYcPjGQ4Egh8hvtvdo2OlfwVLo9iMmsjFobFD8BhjZOF20ildawyOsnQQYAjFoCMr1rViXXWPgebB3eEbg6G/axXK65ebXeWYXqSAEcscJAd9fFPPtkV+M4QG6VSJqwTYVvgdZT5gUu5g729vT90kRcUDQwMvI714QybWAMerKuri2QziXZyxLIuXTE2SGVrAHdxvajSfsd1ura2thl5EwW9yEUBTpXD3Vqv3LXpbDjV6bVr1zYjjGQziXbSsfTVQFiMj3SsDdG3UJ3sEfXjfAmj1X8QRj5k8xL7TG/BuV6AM/UvWbLkpZqamlg247aT+1i2yykf01QsXvysrJ8gfg8X6a6cyjCumGsq5MX5KEeqEifCRzmyB9YnYVynEpviRHCqzWhrn4RxnUpsptFOscuDBEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEITiPzYDF5m9H3R4c6dO39pampqDN0ie4HuvHsdOdWimg15rimZ4/vn3esxjBZ1cGNy9aC1eKx7IZ5C+HFZWVnL/fv3l0sHEL+BeA+eTPgFXjS5G6dTadsP2rbUHOv69etq0aJF8ZzLy7EMdQcdrFUthoTxDy/HUrD/aK5W/exridSDi/4inOh3eKylauXKlfMrKyvNto+MjKhr1659jueqPoWDbYdzRXqFP237YUCn+jzW6Ojoxr6+vvNhGhRIN6+qoferQLqxlPLVamwikXrkos+bN+/Mhg0bnqivr5+/ePFiheexzFPiIpM80RHdsM1O237Y9qQ6YunGRB65vEYsbdgrbDXC9curno8+VGoIp9fxRmOgenDRF2Kk+qc4Dp7u9LJmyvEkqLpw4cLHGLmeCjotpm3ft8EemamNWCtWrFD6rK6u3uhR/9wWL3sSj2fijHnImkqmP+1U/8OT6D/5u1Jf+uPkKXGRySE6oitlJiWF/zrt+5WIYt/PnldepLd0vIxlUi7OJafb8YabcKYMo1WrrKl0zr5BpQ7YvmtEx3/+7KSG6N68ebMFqX26jF/otO+nK3lh7Rey55af2ojlVtnDKsO0tkwv1IXBsQ9nkrDLRBdlls/Ucpc47btrTUnD2p8qGTxGxwrOipohCNCxQsCKqoqp6oZsKehj55M6NhXaZaIrZaZy/WNO+/7aSoW1X8ieWz4dy41KwjJMVT2yT6XNvlqr1F58gc0X8VVmckpcZPoQXSmj04VCp/1C+mHtF7Lnlk/HcqOSsEx21GXzU7YS5JgH6rJQ/9c3Jk+Ji0wO0RFdKTMpKfzXad+vRBT7fva88uhYXmQSlMt+FEaV7f39/Z9p53IzL3miI7pB97DETtr23dpaSBZog8/NSKHPCp1l8OWo4evy2rh0Gnemk9ogddp1pkPWI7vjWA89FB/phL/YFlw6FkCEdCxBJ7vk1ofQrRiZlolMFt+yTkr4Q+hU7Et7eZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZBAJgjgS+1n/JBSJjqWwU6UlVKfVq9e/RF+HiTX0NBwEb8hY70wVUo9eHjaGvmxGRPR6fxzaly9i3iFD7Jx5NarLcZ7PjqBsjBi5S3FK7lcrq27uzu2zUAVp6S0Z8+eL9y6des3S5cu/e6hQ4f+m1I1s2I23nuF4iy9+S41oTo8W59TXUk4lcP+Gjy79C6enOyqqqraf/jw4XFHfuQkbP4etrc5DeAZqpN4lurbTnmcNJyqC3VtR/gx7LwSx9ZcKxv/0eQvq/3KUFdcOyZyyU/hwAWpwNkxPDz819bW1ueSqmLBggXfgxMN2e1JWuR2Wdw4HLgR7f+R2JFQ0nFtzqXy8R1rnTGuylUbOuUcNSblkp/usWZiYuIipslVSVRz9OjRT2FnF0497Uq4y5InUYVqa2urgqE3ceqliIRvWvJE6phtI/EdS3ogU6JMefYjnSnQXoMZx2gi66wG/FrV1RmZEQWY8s7DrvmL7RJKOqIp12JjY2O/xihVY8+UtMjtslKOx1tj2XsuU9519S38n68xp8aUpkBdJS64jIT7scbqSnKNpe1jQf1TrH2ekFDLkgqttVqi67Wk2paUHT0UJ2NP7hLvqYuYGr+awoJd6btCGaXwH96GUcp9bZdMb2glBoFkpkLdgMkthUS2FrRJeyijFM5OjFL1dCo7GcZjEeDOeyx8LEwCJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACpUYg2bd00Hv9Jk0hEHgZIvG6p9UZ9Hd4IvxsybR6AiZ27969AK+pjTnVveROvVJLJ/uWDnovb9EUghBEp5CNAPkF2wEbQXQCVOWvgtfnza8CwD9dtV1T0vIVAZJvl2chnrhj4WXMDj/HkTzRSR1eqyF1+DlOJ35kKfV27Nix41G8A/ky2iI/dXleO5cVyhvWtZIvIxfimTmMtHoi/4UA1m63XzSnslfane9Aclo7kC6KU+lm2J0IskF818TL+BqmPyAuzobftFeNWBrcQZiZIzXHEkJ255oVp9KXabpzFdWpdBMcziU/4zsfZyadSvqcqmNJBQCalzD1xbpU4nfoxXyRFutuTdm6devTGKn+hjxxqs8xcj1/6tSpf7jplros8TVWqQNJq/0yYlnTn+lUqGe+pK2RLK1qZ80uHasI6B3ToKyxnke1Mg1OW9AXoSlFq4KOlTJquStEFebdH0JzTWVNf41W2nSurN0VFsOx3sZvHgvE2T0M9Ta+HK7o7Th+/PhnuHGRO8BpC3XrLtB0Lsl32zydXWCsvSQIeI1I1ohWEn1gI0mABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABIpPwIhSJV44Nd+8CVsWr4MFqi9t+2HbTf3wBCL/dC9eEAhVGx7FDaWftv26urpQ/xwDAwOB/ilCdTLDysV45j3D+Ng1LwKpOdbIyIg6d+6cV72UZ5xA5KnQj4s4VWdnpxoaGjLVNm3a5Kc+a3lBp7ew0+asdWgOVRx7xJJRSRxJH3anqqmpUevXr9dZDB8iArEcS5zqyJEj5ugkDuV0qvb2dlVZWVkyOGVk0qOTPV4yHZhDDY01FcpodPbsWXPKk6lPDpn+ZKQqNaeaQ9ckE02J5VgyGokD2ddTpexU9jWXPZ6JK13kTsSaCqWt2rnEoUrRqexTnle8yNckE9XFGrE0Ae1cki6lNZVuP8PkCSTiWNKsUnUo+5TnFU8ee/YtJuZYpYhK3wGWYtvnepsjO1bYz/7Cgkjbvn10Cts26pMACZAACZAACZAACZAACZAACZAACZAACZAACWSDwP8B9X0BfshR6QsAAAAASUVORK5CYII=)
      no-repeat -14px -35px;
  }
  .tui-grid-tree-button-collapse .tui-grid-btn-tree i {
    background-position: -43px -61px;
    width: 8px;
    height: 11px;
  }
  .tui-grid-tree-button-collapse .tui-grid-tree-icon i {
    margin-left: 4px;
    background-position: -39px -35px;
    width: 14px;
    height: 14px;
  }
  .tui-grid-tree-button-expand .tui-grid-btn-tree i {
    margin-top: 2px;
    background-position: -15px -63px;
    width: 11px;
    height: 8px;
  }
  .tui-grid-tree-button-expand .tui-grid-tree-icon i {
    margin-left: 4px;
    background-position: -65px -35px;
    height: 14px;
    width: 14px;
  }
  .tui-grid-tree-wrapper-relative {
    position: relative;
    margin: -1px 0;
  }
  .tui-grid-tree-wrapper-valign-center {
    vertical-align: middle;
  }
  .tui-grid-tree-extra-content {
    position: absolute;
    margin-left: 4px;
    top: 0;
    left: 0;
    bottom: 0;
  }
  .tui-grid-tree-depth {
    display: inline-block;
    position: absolute;
    width: 22px;
    top: 0;
    bottom: 0;
  }
  .tui-grid-tree-depth i {
    display: inline-block;
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACMCAYAAACeTFAfAAAAAXNSR0IArs4c6QAAC/tJREFUeAHtnX9oVtcZx899kzhrNaTSaDeIdrpCayy1xoBdZJh2CPljbmiT4EQNG/jHwG2MMgcDkxTi5hilVrY/xA2rbpJk+of7IyjrXMEaWI2zjNjBqtRGRtXRlMRm3aJ5931u7jE3N/fe9/58k/f6vXBzznnOc55zzuc+Oefc8977vkrxIAESIAESIAESIAESIAESIAESIAESIAESIIG5T8CY+00sbgvzDQ2L7g0Pv5LP5zcDzlek9rxSHxiGcab8scd+abzzzmhxW1SatdGxbNdtvLb2xfzExG9VPr/cJp6KGsYNI5f7TsXg4J+nhIy5EaBjWVTEqdT9+3/C6OTLBJl5VVb29TjOtW3btsfv3bt3rLy8fOfJkyf/7XZhwsrSsHnp0qXHMVIfw+i9c926daHamQvbgSzqy/QnI5XTqSref1/JaT9Ex9RFGbs8aLy5ufkRONUZ6DdJKOmgZb300rA5NDT0iEz/cKomCSXtVb+bnI4FKrKm8pz+3KhhqjTLuOX5yDo6OoT3CZwvWGoSnrDklihckIZNOFPu9u3bJxCa7ZTQSgf2l8CK4bpbWtoYgb4ZtsWAvTlsmcHBwddQZouj3BZL7hAHS6Zh8/Lly6+hf9PaKWmRB2tVgfWEl5Genh7MCNGPlpYW33WMtrx3795Y9Rw4cCBQPePPPDMKcAt1vTrU0yDytehBiOnhLvIjTYcPjGQ4Egh8hvtvdo2OlfwVLo9iMmsjFobFD8BhjZOF20ildawyOsnQQYAjFoCMr1rViXXWPgebB3eEbg6G/axXK65ebXeWYXqSAEcscJAd9fFPPtkV+M4QG6VSJqwTYVvgdZT5gUu5g729vT90kRcUDQwMvI714QybWAMerKuri2QziXZyxLIuXTE2SGVrAHdxvajSfsd1ura2thl5EwW9yEUBTpXD3Vqv3LXpbDjV6bVr1zYjjGQziXbSsfTVQFiMj3SsDdG3UJ3sEfXjfAmj1X8QRj5k8xL7TG/BuV6AM/UvWbLkpZqamlg247aT+1i2yykf01QsXvysrJ8gfg8X6a6cyjCumGsq5MX5KEeqEifCRzmyB9YnYVynEpviRHCqzWhrn4RxnUpsptFOscuDBEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEITiPzYDF5m9H3R4c6dO39pampqDN0ie4HuvHsdOdWimg15rimZ4/vn3esxjBZ1cGNy9aC1eKx7IZ5C+HFZWVnL/fv3l0sHEL+BeA+eTPgFXjS5G6dTadsP2rbUHOv69etq0aJF8ZzLy7EMdQcdrFUthoTxDy/HUrD/aK5W/exridSDi/4inOh3eKylauXKlfMrKyvNto+MjKhr1659jueqPoWDbYdzRXqFP237YUCn+jzW6Ojoxr6+vvNhGhRIN6+qoferQLqxlPLVamwikXrkos+bN+/Mhg0bnqivr5+/ePFiheexzFPiIpM80RHdsM1O237Y9qQ6YunGRB65vEYsbdgrbDXC9curno8+VGoIp9fxRmOgenDRF2Kk+qc4Dp7u9LJmyvEkqLpw4cLHGLmeCjotpm3ft8EemamNWCtWrFD6rK6u3uhR/9wWL3sSj2fijHnImkqmP+1U/8OT6D/5u1Jf+uPkKXGRySE6oitlJiWF/zrt+5WIYt/PnldepLd0vIxlUi7OJafb8YabcKYMo1WrrKl0zr5BpQ7YvmtEx3/+7KSG6N68ebMFqX26jF/otO+nK3lh7Rey55af2ojlVtnDKsO0tkwv1IXBsQ9nkrDLRBdlls/Ucpc47btrTUnD2p8qGTxGxwrOipohCNCxQsCKqoqp6oZsKehj55M6NhXaZaIrZaZy/WNO+/7aSoW1X8ieWz4dy41KwjJMVT2yT6XNvlqr1F58gc0X8VVmckpcZPoQXSmj04VCp/1C+mHtF7Lnlk/HcqOSsEx21GXzU7YS5JgH6rJQ/9c3Jk+Ji0wO0RFdKTMpKfzXad+vRBT7fva88uhYXmQSlMt+FEaV7f39/Z9p53IzL3miI7pB97DETtr23dpaSBZog8/NSKHPCp1l8OWo4evy2rh0Gnemk9ogddp1pkPWI7vjWA89FB/phL/YFlw6FkCEdCxBJ7vk1ofQrRiZlolMFt+yTkr4Q+hU7Et7eZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZBAJgjgS+1n/JBSJjqWwU6UlVKfVq9e/RF+HiTX0NBwEb8hY70wVUo9eHjaGvmxGRPR6fxzaly9i3iFD7Jx5NarLcZ7PjqBsjBi5S3FK7lcrq27uzu2zUAVp6S0Z8+eL9y6des3S5cu/e6hQ4f+m1I1s2I23nuF4iy9+S41oTo8W59TXUk4lcP+Gjy79C6enOyqqqraf/jw4XFHfuQkbP4etrc5DeAZqpN4lurbTnmcNJyqC3VtR/gx7LwSx9ZcKxv/0eQvq/3KUFdcOyZyyU/hwAWpwNkxPDz819bW1ueSqmLBggXfgxMN2e1JWuR2Wdw4HLgR7f+R2JFQ0nFtzqXy8R1rnTGuylUbOuUcNSblkp/usWZiYuIipslVSVRz9OjRT2FnF0497Uq4y5InUYVqa2urgqE3ceqliIRvWvJE6phtI/EdS3ogU6JMefYjnSnQXoMZx2gi66wG/FrV1RmZEQWY8s7DrvmL7RJKOqIp12JjY2O/xihVY8+UtMjtslKOx1tj2XsuU9519S38n68xp8aUpkBdJS64jIT7scbqSnKNpe1jQf1TrH2ekFDLkgqttVqi67Wk2paUHT0UJ2NP7hLvqYuYGr+awoJd6btCGaXwH96GUcp9bZdMb2glBoFkpkLdgMkthUS2FrRJeyijFM5OjFL1dCo7GcZjEeDOeyx8LEwCJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACpUYg2bd00Hv9Jk0hEHgZIvG6p9UZ9Hd4IvxsybR6AiZ27969AK+pjTnVveROvVJLJ/uWDnovb9EUghBEp5CNAPkF2wEbQXQCVOWvgtfnza8CwD9dtV1T0vIVAZJvl2chnrhj4WXMDj/HkTzRSR1eqyF1+DlOJ35kKfV27Nix41G8A/ky2iI/dXleO5cVyhvWtZIvIxfimTmMtHoi/4UA1m63XzSnslfane9Aclo7kC6KU+lm2J0IskF818TL+BqmPyAuzobftFeNWBrcQZiZIzXHEkJ255oVp9KXabpzFdWpdBMcziU/4zsfZyadSvqcqmNJBQCalzD1xbpU4nfoxXyRFutuTdm6devTGKn+hjxxqs8xcj1/6tSpf7jplros8TVWqQNJq/0yYlnTn+lUqGe+pK2RLK1qZ80uHasI6B3ToKyxnke1Mg1OW9AXoSlFq4KOlTJquStEFebdH0JzTWVNf41W2nSurN0VFsOx3sZvHgvE2T0M9Ta+HK7o7Th+/PhnuHGRO8BpC3XrLtB0Lsl32zydXWCsvSQIeI1I1ohWEn1gI0mABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABIpPwIhSJV44Nd+8CVsWr4MFqi9t+2HbTf3wBCL/dC9eEAhVGx7FDaWftv26urpQ/xwDAwOB/ilCdTLDysV45j3D+Ng1LwKpOdbIyIg6d+6cV72UZ5xA5KnQj4s4VWdnpxoaGjLVNm3a5Kc+a3lBp7ew0+asdWgOVRx7xJJRSRxJH3anqqmpUevXr9dZDB8iArEcS5zqyJEj5ugkDuV0qvb2dlVZWVkyOGVk0qOTPV4yHZhDDY01FcpodPbsWXPKk6lPDpn+ZKQqNaeaQ9ckE02J5VgyGokD2ddTpexU9jWXPZ6JK13kTsSaCqWt2rnEoUrRqexTnle8yNckE9XFGrE0Ae1cki6lNZVuP8PkCSTiWNKsUnUo+5TnFU8ee/YtJuZYpYhK3wGWYtvnepsjO1bYz/7Cgkjbvn10Cts26pMACZAACZAACZAACZAACZAACZAACZAACZAACWSDwP8B9X0BfshR6QsAAAAASUVORK5CYII=)
      no-repeat;
  }

  .tui-grid-row-hidden .tui-grid-cell {
    display: none;
  }

  .tui-grid-row-header-checkbox {
    padding: 4px 5px;
  }

  .tui-grid-filter-container {
    width: 220px;
    padding: 8px;
    border: 1px solid #ccc;
    box-sizing: border-box;
    background-color: #fff;
    position: absolute;
    top: 0;
    z-index: 100;
    left: 68px;
    box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.08);
  }

  .tui-grid-filter-container .tui-grid-btn-filter,
  .tui-grid-btn-close {
    margin-bottom: 6px;
  }

  .tui-grid-filter-dropdown {
    box-sizing: border-box;
    margin: 2px 7px;
    height: 29px;
    width: 190px;
    border: 1px solid #ddd;
  }

  .tui-grid-filter-dropdown select {
    height: 100%;
    width: 100%;
    font-size: 13px;
    color: #333;
    border: none;
    background-color: #fff;
    cursor: pointer;
  }

  .tui-grid-filter-dropdown select:focus {
    outline: none;
  }

  .tui-grid-filter-container .tui-grid-filter-input {
    margin: 2px 7px;
    padding: 8px 7px;
    font-size: 13px;
    color: #333;
    border: 1px solid #ddd;
    width: 190px;
    height: 29px;
  }

  .tui-grid-filter-input::placeholder {
    color: rgba(51, 51, 51, 0.3);
  }

  .tui-grid-filter-comparator-container {
    margin: 2px 0;
    padding: 8px;
  }

  .tui-grid-filter-comparator {
    display: inline-block;
    margin-right: 8px;
  }

  .tui-grid-filter-comparator label {
    cursor: pointer;
  }

  .tui-grid-filter-comparator span {
    font-size: 12px;
    color: #333;
    vertical-align: middle;
  }

  .tui-grid-filter-comparator label::before {
    content: ' ';
    margin-right: 4px;
    display: inline-block;
    width: 14px;
    height: 14px;
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACMCAYAAACeTFAfAAAAAXNSR0IArs4c6QAAC/1JREFUeAHtnV9sFMcdx2fPNiEEqGPFkFYFUkilhiMKwfghNarspC9+KK0gtkUQYLUSD6loqyoqlSoRE8m0VFUUgsoDUisCtMh24YE++KWJE4lgqcGUqDKpVEAhRlXAVZxi4ib1n+v3d7eD1+vdvf179p6/I61n9je/+c3MZ3+emZ3bvVOKgQRIgARIgARIgARIgARIgARIgARIgARIgATmPwFj/jextC3MNTQsmxgZeSmXy20FnMel9pxS1wzDOF/58MO/Md59d7S0LUpnbXQsy3Ubz2afzU1N/V7lcmss4umkYdw0MpnvVw0OvjUtZMqJAB3LpCJOpSYn/4LRyZMJMnOqouLbUZxrx44dj0xMTJysrKzcfebMmX87XZigsiRsXrp06RGM1Ccxeu/evHlzoHZmgnagHPVl+pORyu5UVR98oOSwBtHJ66KMVe433dLS8iCc6jz0myWWc79l3fSSsDk0NPSgTP9wqmaJ5dytfic5HQtUZE3lOv05UcNUmS/jlOch6+joEN6ncTxjqkl82pSbomBREjbhTJk7d+6cRpxvp8TmuW9/8a0YrLvp0sYI9N2gLQbsrUHLDA4Ovooy22zltplym9jfaRI2L1++/Cr6N6Odci5yf60qsp5wM9Ld3Y0ZIXxobW31XMdoy/v3749Uz+HDh33VM/7EE6MAt1TXq2M9DSJfi+7HmB7uIT/UdHjfSBknfIEv4/7nu0bHiv8KV4YxWW4jFobFa+Cw0c7CaaTSOmYZfcrYRoAjFoCMr19/EOusAzY29+8InRwM+1mvVF29+rK9DM8LBDhigYPsqI9/8ske33eG2CiVMkGdCNsCr6HMjx3KHenp6fmJg7yoaGBg4DWsD2fZxBrwSF1dXSibcbSTI5Z56UqxQSpbA7iL60GV1juuc9lstgV5U0W9yEEBTpXB3VqP3LXpbDjVuU2bNrUgDmUzjnbSsfTVQFyKj3TMDdE3UZ3sEfXjeA6j1X8Rhw6yeYl9pjfhXM/AmfpXrFjx3KpVqyLZjNpO7mNZLqd8TFNVU/OkrJ8gfh8X6Z4cyjCu5NdUyIvyUY5UJU6Ej3JkD6xX4qhOJTbFieBUW9HWXomjOpXYTKKdYpeBBEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABAITCP3YDF5m9HzRYXh4+O3m5uamwC2yFujKOdeRUa2qxZDnmuIJP+pzrscwWtWRxvjqQWvxWPdSPIXws4qKitbJyck10gGkbyLdjScTfo0XTe5F6VTS9v22LTHHunHjhlq2bFk053JzLEMNo4NZ1WpIHD24OZaC/YcyWfXLb8VSDy76s3CiP+Cxlup169YtXr58eb7td+/eVdevX/8cz1V9CgfbCecK9Qp/0vaDgE70eazR0dHG3t7eviAN8qWbU7XQ+60v3UhKuVo1NhVLPXLRFy1adH7Lli2P1tfXL66pqVF4Hit/SFpkkic6ohu02UnbD9qeREcs3ZjQI5fbiKUNu8VtRrB+udXz0YdKDeFwC683+aoHF30pRqp/iuPg6U43a3k5ngRVFy5c+Bgj19f9TotJ2/dssEtmYiPW2rVrlT5qa2sbXeqf3+LVj+HxTBwRg6ypZPrTTvU/PIn+878r9ZU/Fw5Ji0yC6IiulClIiv+12/cqEca+lz23vFBv6bgZK0u5OJccTuF1J+FsGUarNllT6ZwDg0odtnzXiE7/6smChujeunWrFWcHdBmv2G7fS1fygtovZs8pP7ERy6myhSrDtLZaL9SFwckPZ5OwykQXZdbM1nKW2O07a01Lg9qfLuk/Rcfyz4qaAQjQsQLACquKqeqmbCnosPsxnZqOrTLRlTLTud4pu31vbaWC2i9mzymfjuVEJWYZpqpu2afSZl/JKrUfX2DzZXyVmRySFpkOoitl9Hmx2G6/mH5Q+8XsOeXTsZyoxCyTHXXZ/JStBAmLQF0W6v/6TuGQtMgkiI7oSpmCpPhfu32vEmHse9lzy6NjuZGJUS77URhVdvb393+mncvJvOSJjuj63cMSO0nbd2prMZmvDT4nI8U+K7SXwZejBq/LbePSbtx+HtcGqd2u/TxgPbI7jvXQgvhIJ/jFNuHSsQAioGMJOtklNz+EbsPItFpksviWdVLMH0InYl/ay0ACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACZUEAX2o/64eUyqJjZdiJijT1acOGDR/h50EyDQ0NF/EbMuYLU2nqwcJpa+jHZvKIzuWeUuPqPaSrPJCNI7debTPe99DxlYURK2cqXslkMu1dXV2RbfqqOCGlffv2PXD79u3frVy58gdHjx79IqFq5sRstPcKxVl6cp1qSnW4tj6jOuNwKpv9jXh26T08OdlZXV196Pjx4+O2/NCnsPlH2N5hN4BnqM7gWaoX7PIo53CqTtS1E/HHsPNSFFvzrWz0R5O/pg4pQ11x7JjIJT+BgAtShaNjZGTkr21tbU/FVcWSJUtehBMNWe3JucitsqhpOHAT2v9TsSOxnEe1OZ/KR3eszca4qlTt6JR91CjIJT/ZsHFqauoipsn1cVRz4sSJT2FnDw497Uq8x5THUYVqb2+vhqE3cOiliMRvmPJY6phrI9EdS3ogU6JMedaQzBRorSGfxmgi66wG/FrV1VmZIQWY8vpgN/+L7RLLeUhTjsXGxsaOYZRaZc2Uc5FbZWlOR1tjWXsuU94N9T38n2/MT40JTYG6SlxwGQkPYY3VGecaS9vHgvoXWPs8KrGWxRWba7VY12txtS0uO3oojsee3CVOqIuYGr+ZwIJd6btCGaXwH96OUcp5bRdPb2glAoF4pkLdgMKWQixbC9qkNZZRCsdBjFL1dCorGaYjEeDOeyR8LEwCJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACaSMQ71s66L1+k6YYCLwMEXvdM+r0+zs8IX62ZEY9Pk/27t27BK+pjdnV3eR2vbSdx/uWDnovb9EUg+BHp5gNH/lF2wEbfnR8VOWtgtfn818FgH+6WqumnMtXBEi+VV4O6dgdCy9jdng5juSJTuLw2gypw8txDuJHlhJvx65dux7CO5DPoy3yU5d92rnMWN6wzkq+jFxIl00wkuqJ/BcC2MtW+yVzKmulXbkOnM5oB85L4lS6GVYngmwQ3zXxPL6G6U9Ii7PhN+1VE5YGw4jLJiTmWELI6lxz4lT6Ms10rpI6lW6CzbnkZ3wX4yhLp5I+J+pYUgGA5iROfLEulXgFvZgv0WLdqSnbt2//BkaqvyFPnOpzjFxPnz179h9OummXxb7GSjuQpNovI5Y5/eWdCvUslnNzJEuq2jmzS8cqAXrbNChrrKdRrUyDMxb0JWhKyaqgYyWMWu4KUUX+7g9xfk1lTn9N5nneucrtrrAUjvUOfvNYIM5tMNQ7+HK4krfj1KlTn+HGRe4AZyzUzbvAvHNJvtPm6dwCY+2pIOA2IpkjWir6wEaSAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmUnoARpkq8cJp/8yZoWbwO5qu+pO0HbTf1gxMI/dO9eEEgUG14FDeQftL26+rqAv1zDAwM+PqnCNTJMlYuxTPvZYyPXXMjkJhjDX+h1LHrbtVSXu4EQk+FXmDEqZrexmsp/ylovbjOS3vu8vxOb0Gnzbnr0fypOfKIJaOSOJIOVqfKfgmv2H9V5zBeSAQiOZY41Q8HCqOTOJTdqfoalap9ID04ZWTSo5M1nZ4ezJ+WRpoKZTQ6dq0w5cnUJ0GmPxmp0uZUhdbzb1wEIjmWjEbiQNb1VJqdyrrmsqbjgr2Q7ESaCgWUONdbjYVRKo1OZZ3y3NILySHi6mukEUs3YoXpXLKDmKY1lW4/4/gJxOJY0ixxrjQG65Tnlk5jv+a6zbE51lx3JEz9+g4wTFmW8SYQ2rGCfvbn3YzZuUnbt45Os2unhARIgARIgARIgARIgARIgARIgARIgARIgARIYCEQ+D9RZOqPG2fqIQAAAABJRU5ErkJggg==)
      no-repeat -113px -35px;
    vertical-align: middle;
  }

  .tui-grid-filter-comparator-checked label::before {
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACMCAYAAACeTFAfAAAAAXNSR0IArs4c6QAAC/1JREFUeAHtnV9sFMcdx2fPNiEEqGPFkFYFUkilhiMKwfghNarspC9+KK0gtkUQYLUSD6loqyoqlSoRE8m0VFUUgsoDUisCtMh24YE++KWJE4lgqcGUqDKpVEAhRlXAVZxi4ib1n+v3d7eD1+vdvf179p6/I61n9je/+c3MZ3+emZ3bvVOKgQRIgARIgARIgARIgARIgARIgARIgARIgATmPwFj/jextC3MNTQsmxgZeSmXy20FnMel9pxS1wzDOF/58MO/Md59d7S0LUpnbXQsy3Ubz2afzU1N/V7lcmss4umkYdw0MpnvVw0OvjUtZMqJAB3LpCJOpSYn/4LRyZMJMnOqouLbUZxrx44dj0xMTJysrKzcfebMmX87XZigsiRsXrp06RGM1Ccxeu/evHlzoHZmgnagHPVl+pORyu5UVR98oOSwBtHJ66KMVe433dLS8iCc6jz0myWWc79l3fSSsDk0NPSgTP9wqmaJ5dytfic5HQtUZE3lOv05UcNUmS/jlOch6+joEN6ncTxjqkl82pSbomBREjbhTJk7d+6cRpxvp8TmuW9/8a0YrLvp0sYI9N2gLQbsrUHLDA4Ovooy22zltplym9jfaRI2L1++/Cr6N6Odci5yf60qsp5wM9Ld3Y0ZIXxobW31XMdoy/v3749Uz+HDh33VM/7EE6MAt1TXq2M9DSJfi+7HmB7uIT/UdHjfSBknfIEv4/7nu0bHiv8KV4YxWW4jFobFa+Cw0c7CaaTSOmYZfcrYRoAjFoCMr19/EOusAzY29+8InRwM+1mvVF29+rK9DM8LBDhigYPsqI9/8ske33eG2CiVMkGdCNsCr6HMjx3KHenp6fmJg7yoaGBg4DWsD2fZxBrwSF1dXSibcbSTI5Z56UqxQSpbA7iL60GV1juuc9lstgV5U0W9yEEBTpXB3VqP3LXpbDjVuU2bNrUgDmUzjnbSsfTVQFyKj3TMDdE3UZ3sEfXjeA6j1X8Rhw6yeYl9pjfhXM/AmfpXrFjx3KpVqyLZjNpO7mNZLqd8TFNVU/OkrJ8gfh8X6Z4cyjCu5NdUyIvyUY5UJU6Ej3JkD6xX4qhOJTbFieBUW9HWXomjOpXYTKKdYpeBBEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABAITCP3YDF5m9HzRYXh4+O3m5uamwC2yFujKOdeRUa2qxZDnmuIJP+pzrscwWtWRxvjqQWvxWPdSPIXws4qKitbJyck10gGkbyLdjScTfo0XTe5F6VTS9v22LTHHunHjhlq2bFk053JzLEMNo4NZ1WpIHD24OZaC/YcyWfXLb8VSDy76s3CiP+Cxlup169YtXr58eb7td+/eVdevX/8cz1V9CgfbCecK9Qp/0vaDgE70eazR0dHG3t7eviAN8qWbU7XQ+60v3UhKuVo1NhVLPXLRFy1adH7Lli2P1tfXL66pqVF4Hit/SFpkkic6ohu02UnbD9qeREcs3ZjQI5fbiKUNu8VtRrB+udXz0YdKDeFwC683+aoHF30pRqp/iuPg6U43a3k5ngRVFy5c+Bgj19f9TotJ2/dssEtmYiPW2rVrlT5qa2sbXeqf3+LVj+HxTBwRg6ypZPrTTvU/PIn+878r9ZU/Fw5Ji0yC6IiulClIiv+12/cqEca+lz23vFBv6bgZK0u5OJccTuF1J+FsGUarNllT6ZwDg0odtnzXiE7/6smChujeunWrFWcHdBmv2G7fS1fygtovZs8pP7ERy6myhSrDtLZaL9SFwckPZ5OwykQXZdbM1nKW2O07a01Lg9qfLuk/Rcfyz4qaAQjQsQLACquKqeqmbCnosPsxnZqOrTLRlTLTud4pu31vbaWC2i9mzymfjuVEJWYZpqpu2afSZl/JKrUfX2DzZXyVmRySFpkOoitl9Hmx2G6/mH5Q+8XsOeXTsZyoxCyTHXXZ/JStBAmLQF0W6v/6TuGQtMgkiI7oSpmCpPhfu32vEmHse9lzy6NjuZGJUS77URhVdvb393+mncvJvOSJjuj63cMSO0nbd2prMZmvDT4nI8U+K7SXwZejBq/LbePSbtx+HtcGqd2u/TxgPbI7jvXQgvhIJ/jFNuHSsQAioGMJOtklNz+EbsPItFpksviWdVLMH0InYl/ay0ACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACZUEAX2o/64eUyqJjZdiJijT1acOGDR/h50EyDQ0NF/EbMuYLU2nqwcJpa+jHZvKIzuWeUuPqPaSrPJCNI7debTPe99DxlYURK2cqXslkMu1dXV2RbfqqOCGlffv2PXD79u3frVy58gdHjx79IqFq5sRstPcKxVl6cp1qSnW4tj6jOuNwKpv9jXh26T08OdlZXV196Pjx4+O2/NCnsPlH2N5hN4BnqM7gWaoX7PIo53CqTtS1E/HHsPNSFFvzrWz0R5O/pg4pQ11x7JjIJT+BgAtShaNjZGTkr21tbU/FVcWSJUtehBMNWe3JucitsqhpOHAT2v9TsSOxnEe1OZ/KR3eszca4qlTt6JR91CjIJT/ZsHFqauoipsn1cVRz4sSJT2FnDw497Uq8x5THUYVqb2+vhqE3cOiliMRvmPJY6phrI9EdS3ogU6JMedaQzBRorSGfxmgi66wG/FrV1VmZIQWY8vpgN/+L7RLLeUhTjsXGxsaOYZRaZc2Uc5FbZWlOR1tjWXsuU94N9T38n2/MT40JTYG6SlxwGQkPYY3VGecaS9vHgvoXWPs8KrGWxRWba7VY12txtS0uO3oojsee3CVOqIuYGr+ZwIJd6btCGaXwH96OUcp5bRdPb2glAoF4pkLdgMKWQixbC9qkNZZRCsdBjFL1dCorGaYjEeDOeyR8LEwCJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACaSMQ71s66L1+k6YYCLwMEXvdM+r0+zs8IX62ZEY9Pk/27t27BK+pjdnV3eR2vbSdx/uWDnovb9EUg+BHp5gNH/lF2wEbfnR8VOWtgtfn818FgH+6WqumnMtXBEi+VV4O6dgdCy9jdng5juSJTuLw2gypw8txDuJHlhJvx65dux7CO5DPoy3yU5d92rnMWN6wzkq+jFxIl00wkuqJ/BcC2MtW+yVzKmulXbkOnM5oB85L4lS6GVYngmwQ3zXxPL6G6U9Ii7PhN+1VE5YGw4jLJiTmWELI6lxz4lT6Ms10rpI6lW6CzbnkZ3wX4yhLp5I+J+pYUgGA5iROfLEulXgFvZgv0WLdqSnbt2//BkaqvyFPnOpzjFxPnz179h9OummXxb7GSjuQpNovI5Y5/eWdCvUslnNzJEuq2jmzS8cqAXrbNChrrKdRrUyDMxb0JWhKyaqgYyWMWu4KUUX+7g9xfk1lTn9N5nneucrtrrAUjvUOfvNYIM5tMNQ7+HK4krfj1KlTn+HGRe4AZyzUzbvAvHNJvtPm6dwCY+2pIOA2IpkjWir6wEaSAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmUnoARpkq8cJp/8yZoWbwO5qu+pO0HbTf1gxMI/dO9eEEgUG14FDeQftL26+rqAv1zDAwM+PqnCNTJMlYuxTPvZYyPXXMjkJhjDX+h1LHrbtVSXu4EQk+FXmDEqZrexmsp/ylovbjOS3vu8vxOb0Gnzbnr0fypOfKIJaOSOJIOVqfKfgmv2H9V5zBeSAQiOZY41Q8HCqOTOJTdqfoalap9ID04ZWTSo5M1nZ4ezJ+WRpoKZTQ6dq0w5cnUJ0GmPxmp0uZUhdbzb1wEIjmWjEbiQNb1VJqdyrrmsqbjgr2Q7ESaCgWUONdbjYVRKo1OZZ3y3NILySHi6mukEUs3YoXpXLKDmKY1lW4/4/gJxOJY0ixxrjQG65Tnlk5jv+a6zbE51lx3JEz9+g4wTFmW8SYQ2rGCfvbn3YzZuUnbt45Os2unhARIgARIgARIgARIgARIgARIgARIgARIgARIYCEQ+D9RZOqPG2fqIQAAAABJRU5ErkJggg==)
      no-repeat -89px -35px;
  }

  .tui-grid-filter-comparator input[type='radio'] {
    display: none;
  }

  .tui-grid-filter-list-container .tui-grid-filter-list {
    margin: 4px 0;
    border-top: 1px solid #eee;
    border-bottom: 1px solid #eee;
    max-height: 272px;
    overflow-y: scroll;
  }

  .tui-grid-filter-list-container .tui-grid-filter-list-item {
    color: #333;
  }

  .tui-grid-filter-list-item input[type='checkbox'] {
    display: none;
  }

  .tui-grid-filter-list-item label {
    cursor: pointer;
    display: block;
    padding: 9px 8px;
  }

  .tui-grid-filter-list-item label::before {
    content: ' ';
    margin-right: 6px;
    display: inline-block;
    width: 14px;
    height: 14px;
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACMCAYAAACeTFAfAAAAAXNSR0IArs4c6QAAC/1JREFUeAHtnV9sFMcdx2fPNiEEqGPFkFYFUkilhiMKwfghNarspC9+KK0gtkUQYLUSD6loqyoqlSoRE8m0VFUUgsoDUisCtMh24YE++KWJE4lgqcGUqDKpVEAhRlXAVZxi4ib1n+v3d7eD1+vdvf179p6/I61n9je/+c3MZ3+emZ3bvVOKgQRIgARIgARIgARIgARIgARIgARIgARIgATmPwFj/jextC3MNTQsmxgZeSmXy20FnMel9pxS1wzDOF/58MO/Md59d7S0LUpnbXQsy3Ubz2afzU1N/V7lcmss4umkYdw0MpnvVw0OvjUtZMqJAB3LpCJOpSYn/4LRyZMJMnOqouLbUZxrx44dj0xMTJysrKzcfebMmX87XZigsiRsXrp06RGM1Ccxeu/evHlzoHZmgnagHPVl+pORyu5UVR98oOSwBtHJ66KMVe433dLS8iCc6jz0myWWc79l3fSSsDk0NPSgTP9wqmaJ5dytfic5HQtUZE3lOv05UcNUmS/jlOch6+joEN6ncTxjqkl82pSbomBREjbhTJk7d+6cRpxvp8TmuW9/8a0YrLvp0sYI9N2gLQbsrUHLDA4Ovooy22zltplym9jfaRI2L1++/Cr6N6Odci5yf60qsp5wM9Ld3Y0ZIXxobW31XMdoy/v3749Uz+HDh33VM/7EE6MAt1TXq2M9DSJfi+7HmB7uIT/UdHjfSBknfIEv4/7nu0bHiv8KV4YxWW4jFobFa+Cw0c7CaaTSOmYZfcrYRoAjFoCMr19/EOusAzY29+8InRwM+1mvVF29+rK9DM8LBDhigYPsqI9/8ske33eG2CiVMkGdCNsCr6HMjx3KHenp6fmJg7yoaGBg4DWsD2fZxBrwSF1dXSibcbSTI5Z56UqxQSpbA7iL60GV1juuc9lstgV5U0W9yEEBTpXB3VqP3LXpbDjVuU2bNrUgDmUzjnbSsfTVQFyKj3TMDdE3UZ3sEfXjeA6j1X8Rhw6yeYl9pjfhXM/AmfpXrFjx3KpVqyLZjNpO7mNZLqd8TFNVU/OkrJ8gfh8X6Z4cyjCu5NdUyIvyUY5UJU6Ej3JkD6xX4qhOJTbFieBUW9HWXomjOpXYTKKdYpeBBEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABAITCP3YDF5m9HzRYXh4+O3m5uamwC2yFujKOdeRUa2qxZDnmuIJP+pzrscwWtWRxvjqQWvxWPdSPIXws4qKitbJyck10gGkbyLdjScTfo0XTe5F6VTS9v22LTHHunHjhlq2bFk053JzLEMNo4NZ1WpIHD24OZaC/YcyWfXLb8VSDy76s3CiP+Cxlup169YtXr58eb7td+/eVdevX/8cz1V9CgfbCecK9Qp/0vaDgE70eazR0dHG3t7eviAN8qWbU7XQ+60v3UhKuVo1NhVLPXLRFy1adH7Lli2P1tfXL66pqVF4Hit/SFpkkic6ohu02UnbD9qeREcs3ZjQI5fbiKUNu8VtRrB+udXz0YdKDeFwC683+aoHF30pRqp/iuPg6U43a3k5ngRVFy5c+Bgj19f9TotJ2/dssEtmYiPW2rVrlT5qa2sbXeqf3+LVj+HxTBwRg6ypZPrTTvU/PIn+878r9ZU/Fw5Ji0yC6IiulClIiv+12/cqEca+lz23vFBv6bgZK0u5OJccTuF1J+FsGUarNllT6ZwDg0odtnzXiE7/6smChujeunWrFWcHdBmv2G7fS1fygtovZs8pP7ERy6myhSrDtLZaL9SFwckPZ5OwykQXZdbM1nKW2O07a01Lg9qfLuk/Rcfyz4qaAQjQsQLACquKqeqmbCnosPsxnZqOrTLRlTLTud4pu31vbaWC2i9mzymfjuVEJWYZpqpu2afSZl/JKrUfX2DzZXyVmRySFpkOoitl9Hmx2G6/mH5Q+8XsOeXTsZyoxCyTHXXZ/JStBAmLQF0W6v/6TuGQtMgkiI7oSpmCpPhfu32vEmHse9lzy6NjuZGJUS77URhVdvb393+mncvJvOSJjuj63cMSO0nbd2prMZmvDT4nI8U+K7SXwZejBq/LbePSbtx+HtcGqd2u/TxgPbI7jvXQgvhIJ/jFNuHSsQAioGMJOtklNz+EbsPItFpksviWdVLMH0InYl/ay0ACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACZUEAX2o/64eUyqJjZdiJijT1acOGDR/h50EyDQ0NF/EbMuYLU2nqwcJpa+jHZvKIzuWeUuPqPaSrPJCNI7debTPe99DxlYURK2cqXslkMu1dXV2RbfqqOCGlffv2PXD79u3frVy58gdHjx79IqFq5sRstPcKxVl6cp1qSnW4tj6jOuNwKpv9jXh26T08OdlZXV196Pjx4+O2/NCnsPlH2N5hN4BnqM7gWaoX7PIo53CqTtS1E/HHsPNSFFvzrWz0R5O/pg4pQ11x7JjIJT+BgAtShaNjZGTkr21tbU/FVcWSJUtehBMNWe3JucitsqhpOHAT2v9TsSOxnEe1OZ/KR3eszca4qlTt6JR91CjIJT/ZsHFqauoipsn1cVRz4sSJT2FnDw497Uq8x5THUYVqb2+vhqE3cOiliMRvmPJY6phrI9EdS3ogU6JMedaQzBRorSGfxmgi66wG/FrV1VmZIQWY8vpgN/+L7RLLeUhTjsXGxsaOYZRaZc2Uc5FbZWlOR1tjWXsuU94N9T38n2/MT40JTYG6SlxwGQkPYY3VGecaS9vHgvoXWPs8KrGWxRWba7VY12txtS0uO3oojsee3CVOqIuYGr+ZwIJd6btCGaXwH96OUcp5bRdPb2glAoF4pkLdgMKWQixbC9qkNZZRCsdBjFL1dCorGaYjEeDOeyR8LEwCJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACaSMQ71s66L1+k6YYCLwMEXvdM+r0+zs8IX62ZEY9Pk/27t27BK+pjdnV3eR2vbSdx/uWDnovb9EUg+BHp5gNH/lF2wEbfnR8VOWtgtfn818FgH+6WqumnMtXBEi+VV4O6dgdCy9jdng5juSJTuLw2gypw8txDuJHlhJvx65dux7CO5DPoy3yU5d92rnMWN6wzkq+jFxIl00wkuqJ/BcC2MtW+yVzKmulXbkOnM5oB85L4lS6GVYngmwQ3zXxPL6G6U9Ii7PhN+1VE5YGw4jLJiTmWELI6lxz4lT6Ms10rpI6lW6CzbnkZ3wX4yhLp5I+J+pYUgGA5iROfLEulXgFvZgv0WLdqSnbt2//BkaqvyFPnOpzjFxPnz179h9OummXxb7GSjuQpNovI5Y5/eWdCvUslnNzJEuq2jmzS8cqAXrbNChrrKdRrUyDMxb0JWhKyaqgYyWMWu4KUUX+7g9xfk1lTn9N5nneucrtrrAUjvUOfvNYIM5tMNQ7+HK4krfj1KlTn+HGRe4AZyzUzbvAvHNJvtPm6dwCY+2pIOA2IpkjWir6wEaSAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmUnoARpkq8cJp/8yZoWbwO5qu+pO0HbTf1gxMI/dO9eEEgUG14FDeQftL26+rqAv1zDAwM+PqnCNTJMlYuxTPvZYyPXXMjkJhjDX+h1LHrbtVSXu4EQk+FXmDEqZrexmsp/ylovbjOS3vu8vxOb0Gnzbnr0fypOfKIJaOSOJIOVqfKfgmv2H9V5zBeSAQiOZY41Q8HCqOTOJTdqfoalap9ID04ZWTSo5M1nZ4ezJ+WRpoKZTQ6dq0w5cnUJ0GmPxmp0uZUhdbzb1wEIjmWjEbiQNb1VJqdyrrmsqbjgr2Q7ESaCgWUONdbjYVRKo1OZZ3y3NILySHi6mukEUs3YoXpXLKDmKY1lW4/4/gJxOJY0ixxrjQG65Tnlk5jv+a6zbE51lx3JEz9+g4wTFmW8SYQ2rGCfvbn3YzZuUnbt45Os2unhARIgARIgARIgARIgARIgARIgARIgARIgARIYCEQ+D9RZOqPG2fqIQAAAABJRU5ErkJggg==)
      no-repeat -37px -118px;
    vertical-align: middle;
  }

  .tui-grid-filter-list-item-checked label::before {
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACMCAYAAACeTFAfAAAAAXNSR0IArs4c6QAAC/1JREFUeAHtnV9sFMcdx2fPNiEEqGPFkFYFUkilhiMKwfghNarspC9+KK0gtkUQYLUSD6loqyoqlSoRE8m0VFUUgsoDUisCtMh24YE++KWJE4lgqcGUqDKpVEAhRlXAVZxi4ib1n+v3d7eD1+vdvf179p6/I61n9je/+c3MZ3+emZ3bvVOKgQRIgARIgARIgARIgARIgARIgARIgARIgATmPwFj/jextC3MNTQsmxgZeSmXy20FnMel9pxS1wzDOF/58MO/Md59d7S0LUpnbXQsy3Ubz2afzU1N/V7lcmss4umkYdw0MpnvVw0OvjUtZMqJAB3LpCJOpSYn/4LRyZMJMnOqouLbUZxrx44dj0xMTJysrKzcfebMmX87XZigsiRsXrp06RGM1Ccxeu/evHlzoHZmgnagHPVl+pORyu5UVR98oOSwBtHJ66KMVe433dLS8iCc6jz0myWWc79l3fSSsDk0NPSgTP9wqmaJ5dytfic5HQtUZE3lOv05UcNUmS/jlOch6+joEN6ncTxjqkl82pSbomBREjbhTJk7d+6cRpxvp8TmuW9/8a0YrLvp0sYI9N2gLQbsrUHLDA4Ovooy22zltplym9jfaRI2L1++/Cr6N6Odci5yf60qsp5wM9Ld3Y0ZIXxobW31XMdoy/v3749Uz+HDh33VM/7EE6MAt1TXq2M9DSJfi+7HmB7uIT/UdHjfSBknfIEv4/7nu0bHiv8KV4YxWW4jFobFa+Cw0c7CaaTSOmYZfcrYRoAjFoCMr19/EOusAzY29+8InRwM+1mvVF29+rK9DM8LBDhigYPsqI9/8ske33eG2CiVMkGdCNsCr6HMjx3KHenp6fmJg7yoaGBg4DWsD2fZxBrwSF1dXSibcbSTI5Z56UqxQSpbA7iL60GV1juuc9lstgV5U0W9yEEBTpXB3VqP3LXpbDjVuU2bNrUgDmUzjnbSsfTVQFyKj3TMDdE3UZ3sEfXjeA6j1X8Rhw6yeYl9pjfhXM/AmfpXrFjx3KpVqyLZjNpO7mNZLqd8TFNVU/OkrJ8gfh8X6Z4cyjCu5NdUyIvyUY5UJU6Ej3JkD6xX4qhOJTbFieBUW9HWXomjOpXYTKKdYpeBBEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABAITCP3YDF5m9HzRYXh4+O3m5uamwC2yFujKOdeRUa2qxZDnmuIJP+pzrscwWtWRxvjqQWvxWPdSPIXws4qKitbJyck10gGkbyLdjScTfo0XTe5F6VTS9v22LTHHunHjhlq2bFk053JzLEMNo4NZ1WpIHD24OZaC/YcyWfXLb8VSDy76s3CiP+Cxlup169YtXr58eb7td+/eVdevX/8cz1V9CgfbCecK9Qp/0vaDgE70eazR0dHG3t7eviAN8qWbU7XQ+60v3UhKuVo1NhVLPXLRFy1adH7Lli2P1tfXL66pqVF4Hit/SFpkkic6ohu02UnbD9qeREcs3ZjQI5fbiKUNu8VtRrB+udXz0YdKDeFwC683+aoHF30pRqp/iuPg6U43a3k5ngRVFy5c+Bgj19f9TotJ2/dssEtmYiPW2rVrlT5qa2sbXeqf3+LVj+HxTBwRg6ypZPrTTvU/PIn+878r9ZU/Fw5Ji0yC6IiulClIiv+12/cqEca+lz23vFBv6bgZK0u5OJccTuF1J+FsGUarNllT6ZwDg0odtnzXiE7/6smChujeunWrFWcHdBmv2G7fS1fygtovZs8pP7ERy6myhSrDtLZaL9SFwckPZ5OwykQXZdbM1nKW2O07a01Lg9qfLuk/Rcfyz4qaAQjQsQLACquKqeqmbCnosPsxnZqOrTLRlTLTud4pu31vbaWC2i9mzymfjuVEJWYZpqpu2afSZl/JKrUfX2DzZXyVmRySFpkOoitl9Hmx2G6/mH5Q+8XsOeXTsZyoxCyTHXXZ/JStBAmLQF0W6v/6TuGQtMgkiI7oSpmCpPhfu32vEmHse9lzy6NjuZGJUS77URhVdvb393+mncvJvOSJjuj63cMSO0nbd2prMZmvDT4nI8U+K7SXwZejBq/LbePSbtx+HtcGqd2u/TxgPbI7jvXQgvhIJ/jFNuHSsQAioGMJOtklNz+EbsPItFpksviWdVLMH0InYl/ay0ACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACZUEAX2o/64eUyqJjZdiJijT1acOGDR/h50EyDQ0NF/EbMuYLU2nqwcJpa+jHZvKIzuWeUuPqPaSrPJCNI7debTPe99DxlYURK2cqXslkMu1dXV2RbfqqOCGlffv2PXD79u3frVy58gdHjx79IqFq5sRstPcKxVl6cp1qSnW4tj6jOuNwKpv9jXh26T08OdlZXV196Pjx4+O2/NCnsPlH2N5hN4BnqM7gWaoX7PIo53CqTtS1E/HHsPNSFFvzrWz0R5O/pg4pQ11x7JjIJT+BgAtShaNjZGTkr21tbU/FVcWSJUtehBMNWe3JucitsqhpOHAT2v9TsSOxnEe1OZ/KR3eszca4qlTt6JR91CjIJT/ZsHFqauoipsn1cVRz4sSJT2FnDw497Uq8x5THUYVqb2+vhqE3cOiliMRvmPJY6phrI9EdS3ogU6JMedaQzBRorSGfxmgi66wG/FrV1VmZIQWY8vpgN/+L7RLLeUhTjsXGxsaOYZRaZc2Uc5FbZWlOR1tjWXsuU94N9T38n2/MT40JTYG6SlxwGQkPYY3VGecaS9vHgvoXWPs8KrGWxRWba7VY12txtS0uO3oojsee3CVOqIuYGr+ZwIJd6btCGaXwH96OUcp5bRdPb2glAoF4pkLdgMKWQixbC9qkNZZRCsdBjFL1dCorGaYjEeDOeyR8LEwCJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACaSMQ71s66L1+k6YYCLwMEXvdM+r0+zs8IX62ZEY9Pk/27t27BK+pjdnV3eR2vbSdx/uWDnovb9EUg+BHp5gNH/lF2wEbfnR8VOWtgtfn818FgH+6WqumnMtXBEi+VV4O6dgdCy9jdng5juSJTuLw2gypw8txDuJHlhJvx65dux7CO5DPoy3yU5d92rnMWN6wzkq+jFxIl00wkuqJ/BcC2MtW+yVzKmulXbkOnM5oB85L4lS6GVYngmwQ3zXxPL6G6U9Ii7PhN+1VE5YGw4jLJiTmWELI6lxz4lT6Ms10rpI6lW6CzbnkZ3wX4yhLp5I+J+pYUgGA5iROfLEulXgFvZgv0WLdqSnbt2//BkaqvyFPnOpzjFxPnz179h9OummXxb7GSjuQpNovI5Y5/eWdCvUslnNzJEuq2jmzS8cqAXrbNChrrKdRrUyDMxb0JWhKyaqgYyWMWu4KUUX+7g9xfk1lTn9N5nneucrtrrAUjvUOfvNYIM5tMNQ7+HK4krfj1KlTn+HGRe4AZyzUzbvAvHNJvtPm6dwCY+2pIOA2IpkjWir6wEaSAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmUnoARpkq8cJp/8yZoWbwO5qu+pO0HbTf1gxMI/dO9eEEgUG14FDeQftL26+rqAv1zDAwM+PqnCNTJMlYuxTPvZYyPXXMjkJhjDX+h1LHrbtVSXu4EQk+FXmDEqZrexmsp/ylovbjOS3vu8vxOb0Gnzbnr0fypOfKIJaOSOJIOVqfKfgmv2H9V5zBeSAQiOZY41Q8HCqOTOJTdqfoalap9ID04ZWTSo5M1nZ4ezJ+WRpoKZTQ6dq0w5cnUJ0GmPxmp0uZUhdbzb1wEIjmWjEbiQNb1VJqdyrrmsqbjgr2Q7ESaCgWUONdbjYVRKo1OZZ3y3NILySHi6mukEUs3YoXpXLKDmKY1lW4/4/gJxOJY0ixxrjQG65Tnlk5jv+a6zbE51lx3JEz9+g4wTFmW8SYQ2rGCfvbn3YzZuUnbt45Os2unhARIgARIgARIgARIgARIgARIgARIgARIgARIYCEQ+D9RZOqPG2fqIQAAAABJRU5ErkJggg==)
      no-repeat -13px -118px;
  }

  .tui-grid-filter-list-item label span {
    font-size: 13px;
    max-width: 152px;
    word-break: break-all;
    word-wrap: break-word;
    vertical-align: middle;
  }

  .tui-grid-filter-list .tui-grid-filter-list-item-checked {
    background-color: #e5f6ff;
  }

  .tui-grid-filter-btn-container {
    margin: 4px 5px;
    text-align: right;
  }

  .tui-grid-filter-btn {
    box-sizing: border-box;
    color: #fff;
    font-size: 13px;
    height: 29px;
    width: 50px;
    border-radius: 2px;
    margin-left: 4px;
    cursor: pointer;
  }

  .tui-grid-filter-btn-apply {
    background-color: #00a9ff;
    border: 1px solid #00a9ff;
  }

  .tui-grid-filter-btn-apply:hover {
    background-color: #0088d9;
    border: 1px solid #0088d9;
  }

  .tui-grid-filter-btn-clear {
    background-color: #777777;
    border: 1px solid #777777;
  }

  .tui-grid-filter-btn-clear:hover {
    background-color: #5a6268;
    border-color: #545b62;
  }

  /* input datepicker icon */
  .tui-grid-datepicker-input-container {
    position: relative;
  }

  .tui-grid-datepicker-input-container input.tui-grid-datepicker-input {
    padding: 6px 27px 6px 7px;
  }

  .tui-grid-date-icon {
    position: absolute;
    width: 14px;
    height: 14px;
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACMCAYAAACeTFAfAAAAAXNSR0IArs4c6QAAC/tJREFUeAHtnX9oVtcZx899kzhrNaTSaDeIdrpCayy1xoBdZJh2CPljbmiT4EQNG/jHwG2MMgcDkxTi5hilVrY/xA2rbpJk+of7IyjrXMEaWI2zjNjBqtRGRtXRlMRm3aJ5931u7jE3N/fe9/58k/f6vXBzznnOc55zzuc+Oefc8977vkrxIAESIAESIAESIAESIAESIAESIAESIAESIIG5T8CY+00sbgvzDQ2L7g0Pv5LP5zcDzlek9rxSHxiGcab8scd+abzzzmhxW1SatdGxbNdtvLb2xfzExG9VPr/cJp6KGsYNI5f7TsXg4J+nhIy5EaBjWVTEqdT9+3/C6OTLBJl5VVb29TjOtW3btsfv3bt3rLy8fOfJkyf/7XZhwsrSsHnp0qXHMVIfw+i9c926daHamQvbgSzqy/QnI5XTqSref1/JaT9Ex9RFGbs8aLy5ufkRONUZ6DdJKOmgZb300rA5NDT0iEz/cKomCSXtVb+bnI4FKrKm8pz+3KhhqjTLuOX5yDo6OoT3CZwvWGoSnrDklihckIZNOFPu9u3bJxCa7ZTQSgf2l8CK4bpbWtoYgb4ZtsWAvTlsmcHBwddQZouj3BZL7hAHS6Zh8/Lly6+hf9PaKWmRB2tVgfWEl5Genh7MCNGPlpYW33WMtrx3795Y9Rw4cCBQPePPPDMKcAt1vTrU0yDytehBiOnhLvIjTYcPjGQ4Egh8hvtvdo2OlfwVLo9iMmsjFobFD8BhjZOF20ildawyOsnQQYAjFoCMr1rViXXWPgebB3eEbg6G/axXK65ebXeWYXqSAEcscJAd9fFPPtkV+M4QG6VSJqwTYVvgdZT5gUu5g729vT90kRcUDQwMvI714QybWAMerKuri2QziXZyxLIuXTE2SGVrAHdxvajSfsd1ura2thl5EwW9yEUBTpXD3Vqv3LXpbDjV6bVr1zYjjGQziXbSsfTVQFiMj3SsDdG3UJ3sEfXjfAmj1X8QRj5k8xL7TG/BuV6AM/UvWbLkpZqamlg247aT+1i2yykf01QsXvysrJ8gfg8X6a6cyjCumGsq5MX5KEeqEifCRzmyB9YnYVynEpviRHCqzWhrn4RxnUpsptFOscuDBEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEITiPzYDF5m9H3R4c6dO39pampqDN0ie4HuvHsdOdWimg15rimZ4/vn3esxjBZ1cGNy9aC1eKx7IZ5C+HFZWVnL/fv3l0sHEL+BeA+eTPgFXjS5G6dTadsP2rbUHOv69etq0aJF8ZzLy7EMdQcdrFUthoTxDy/HUrD/aK5W/exridSDi/4inOh3eKylauXKlfMrKyvNto+MjKhr1659jueqPoWDbYdzRXqFP237YUCn+jzW6Ojoxr6+vvNhGhRIN6+qoferQLqxlPLVamwikXrkos+bN+/Mhg0bnqivr5+/ePFiheexzFPiIpM80RHdsM1O237Y9qQ6YunGRB65vEYsbdgrbDXC9curno8+VGoIp9fxRmOgenDRF2Kk+qc4Dp7u9LJmyvEkqLpw4cLHGLmeCjotpm3ft8EemamNWCtWrFD6rK6u3uhR/9wWL3sSj2fijHnImkqmP+1U/8OT6D/5u1Jf+uPkKXGRySE6oitlJiWF/zrt+5WIYt/PnldepLd0vIxlUi7OJafb8YabcKYMo1WrrKl0zr5BpQ7YvmtEx3/+7KSG6N68ebMFqX26jF/otO+nK3lh7Rey55af2ojlVtnDKsO0tkwv1IXBsQ9nkrDLRBdlls/Ucpc47btrTUnD2p8qGTxGxwrOipohCNCxQsCKqoqp6oZsKehj55M6NhXaZaIrZaZy/WNO+/7aSoW1X8ieWz4dy41KwjJMVT2yT6XNvlqr1F58gc0X8VVmckpcZPoQXSmj04VCp/1C+mHtF7Lnlk/HcqOSsEx21GXzU7YS5JgH6rJQ/9c3Jk+Ji0wO0RFdKTMpKfzXad+vRBT7fva88uhYXmQSlMt+FEaV7f39/Z9p53IzL3miI7pB97DETtr23dpaSBZog8/NSKHPCp1l8OWo4evy2rh0Gnemk9ogddp1pkPWI7vjWA89FB/phL/YFlw6FkCEdCxBJ7vk1ofQrRiZlolMFt+yTkr4Q+hU7Et7eZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZBAJgjgS+1n/JBSJjqWwU6UlVKfVq9e/RF+HiTX0NBwEb8hY70wVUo9eHjaGvmxGRPR6fxzaly9i3iFD7Jx5NarLcZ7PjqBsjBi5S3FK7lcrq27uzu2zUAVp6S0Z8+eL9y6des3S5cu/e6hQ4f+m1I1s2I23nuF4iy9+S41oTo8W59TXUk4lcP+Gjy79C6enOyqqqraf/jw4XFHfuQkbP4etrc5DeAZqpN4lurbTnmcNJyqC3VtR/gx7LwSx9ZcKxv/0eQvq/3KUFdcOyZyyU/hwAWpwNkxPDz819bW1ueSqmLBggXfgxMN2e1JWuR2Wdw4HLgR7f+R2JFQ0nFtzqXy8R1rnTGuylUbOuUcNSblkp/usWZiYuIipslVSVRz9OjRT2FnF0497Uq4y5InUYVqa2urgqE3ceqliIRvWvJE6phtI/EdS3ogU6JMefYjnSnQXoMZx2gi66wG/FrV1RmZEQWY8s7DrvmL7RJKOqIp12JjY2O/xihVY8+UtMjtslKOx1tj2XsuU9519S38n68xp8aUpkBdJS64jIT7scbqSnKNpe1jQf1TrH2ekFDLkgqttVqi67Wk2paUHT0UJ2NP7hLvqYuYGr+awoJd6btCGaXwH96GUcp9bZdMb2glBoFkpkLdgMkthUS2FrRJeyijFM5OjFL1dCo7GcZjEeDOeyx8LEwCJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACpUYg2bd00Hv9Jk0hEHgZIvG6p9UZ9Hd4IvxsybR6AiZ27969AK+pjTnVveROvVJLJ/uWDnovb9EUghBEp5CNAPkF2wEbQXQCVOWvgtfnza8CwD9dtV1T0vIVAZJvl2chnrhj4WXMDj/HkTzRSR1eqyF1+DlOJ35kKfV27Nix41G8A/ky2iI/dXleO5cVyhvWtZIvIxfimTmMtHoi/4UA1m63XzSnslfane9Aclo7kC6KU+lm2J0IskF818TL+BqmPyAuzobftFeNWBrcQZiZIzXHEkJ255oVp9KXabpzFdWpdBMcziU/4zsfZyadSvqcqmNJBQCalzD1xbpU4nfoxXyRFutuTdm6devTGKn+hjxxqs8xcj1/6tSpf7jplros8TVWqQNJq/0yYlnTn+lUqGe+pK2RLK1qZ80uHasI6B3ToKyxnke1Mg1OW9AXoSlFq4KOlTJquStEFebdH0JzTWVNf41W2nSurN0VFsOx3sZvHgvE2T0M9Ta+HK7o7Th+/PhnuHGRO8BpC3XrLtB0Lsl32zydXWCsvSQIeI1I1ohWEn1gI0mABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABIpPwIhSJV44Nd+8CVsWr4MFqi9t+2HbTf3wBCL/dC9eEAhVGx7FDaWftv26urpQ/xwDAwOB/ilCdTLDysV45j3D+Ng1LwKpOdbIyIg6d+6cV72UZ5xA5KnQj4s4VWdnpxoaGjLVNm3a5Kc+a3lBp7ew0+asdWgOVRx7xJJRSRxJH3anqqmpUevXr9dZDB8iArEcS5zqyJEj5ugkDuV0qvb2dlVZWVkyOGVk0qOTPV4yHZhDDY01FcpodPbsWXPKk6lPDpn+ZKQqNaeaQ9ckE02J5VgyGokD2ddTpexU9jWXPZ6JK13kTsSaCqWt2rnEoUrRqexTnle8yNckE9XFGrE0Ae1cki6lNZVuP8PkCSTiWNKsUnUo+5TnFU8ee/YtJuZYpYhK3wGWYtvnepsjO1bYz/7Cgkjbvn10Cts26pMACZAACZAACZAACZAACZAACZAACZAACZAACWSDwP8B9X0BfshR6QsAAAAASUVORK5CYII=)
      no-repeat -61px -118px;
    top: 45%;
    right: 10px;
    margin: -6px 0 0 0;
    cursor: pointer;
  }

  /* editor ui */
  .tui-grid-layer-editing-inner {
    box-sizing: border-box;
  }

  .tui-grid-editor-select-box-layer {
    position: absolute;
    z-index: 100;
  }

  .tui-grid-editor-select-box-layer * {
    box-sizing: border-box;
  }

  .tui-grid-editor-select-box-layer li {
    padding: 0 8px;
  }

  .tui-select-box-input {
    outline: none;
  }

  .tui-grid-container .tui-select-box-dropdown {
    max-height: 180px;
  }

  .tui-grid-editor-checkbox-list-layer {
    position: absolute;
    background-color: #fff;
    border: 1px solid #aaa;
    z-index: 100;
    max-height: 180px;
    overflow: hidden auto;
  }

  .tui-grid-editor-checkbox-list-layer * {
    box-sizing: border-box;
  }

  .tui-grid-editor-checkbox-list-layer .tui-grid-editor-checkbox {
    line-height: 32px;
    height: 32px;
  }

  .tui-grid-editor-checkbox-list-layer .tui-grid-editor-checkbox:last-child {
    margin-bottom: 1px;
  }

  .tui-grid-editor-checkbox-hovered {
    background-color: #e5f6ff;
  }

  .tui-grid-editor-checkbox input[type='checkbox'],
  .tui-grid-editor-checkbox input[type='radio'] {
    position: absolute;
    opacity: 0;
    cursor: pointer;
  }

  .tui-grid-editor-checkbox label {
    display: inline-block;
    cursor: pointer;
    width: 100%;
    height: 100%;
    margin: 0 7px;
  }

  .tui-grid-editor-checkbox label:before {
    content: ' ';
    margin-right: 6px;
    display: inline-block;
    width: 14px;
    height: 14px;
    vertical-align: middle;
  }

  .tui-grid-editor-checkbox label span {
    display: inline-block;
    font-size: 12px;
    color: #333;
    vertical-align: middle;
  }

  .tui-grid-editor-label-icon-checkbox::before {
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACMCAYAAACeTFAfAAAAAXNSR0IArs4c6QAAC/1JREFUeAHtnV9sFMcdx2fPNiEEqGPFkFYFUkilhiMKwfghNarspC9+KK0gtkUQYLUSD6loqyoqlSoRE8m0VFUUgsoDUisCtMh24YE++KWJE4lgqcGUqDKpVEAhRlXAVZxi4ib1n+v3d7eD1+vdvf179p6/I61n9je/+c3MZ3+emZ3bvVOKgQRIgARIgARIgARIgARIgARIgARIgARIgATmPwFj/jextC3MNTQsmxgZeSmXy20FnMel9pxS1wzDOF/58MO/Md59d7S0LUpnbXQsy3Ubz2afzU1N/V7lcmss4umkYdw0MpnvVw0OvjUtZMqJAB3LpCJOpSYn/4LRyZMJMnOqouLbUZxrx44dj0xMTJysrKzcfebMmX87XZigsiRsXrp06RGM1Ccxeu/evHlzoHZmgnagHPVl+pORyu5UVR98oOSwBtHJ66KMVe433dLS8iCc6jz0myWWc79l3fSSsDk0NPSgTP9wqmaJ5dytfic5HQtUZE3lOv05UcNUmS/jlOch6+joEN6ncTxjqkl82pSbomBREjbhTJk7d+6cRpxvp8TmuW9/8a0YrLvp0sYI9N2gLQbsrUHLDA4Ovooy22zltplym9jfaRI2L1++/Cr6N6Odci5yf60qsp5wM9Ld3Y0ZIXxobW31XMdoy/v3749Uz+HDh33VM/7EE6MAt1TXq2M9DSJfi+7HmB7uIT/UdHjfSBknfIEv4/7nu0bHiv8KV4YxWW4jFobFa+Cw0c7CaaTSOmYZfcrYRoAjFoCMr19/EOusAzY29+8InRwM+1mvVF29+rK9DM8LBDhigYPsqI9/8ske33eG2CiVMkGdCNsCr6HMjx3KHenp6fmJg7yoaGBg4DWsD2fZxBrwSF1dXSibcbSTI5Z56UqxQSpbA7iL60GV1juuc9lstgV5U0W9yEEBTpXB3VqP3LXpbDjVuU2bNrUgDmUzjnbSsfTVQFyKj3TMDdE3UZ3sEfXjeA6j1X8Rhw6yeYl9pjfhXM/AmfpXrFjx3KpVqyLZjNpO7mNZLqd8TFNVU/OkrJ8gfh8X6Z4cyjCu5NdUyIvyUY5UJU6Ej3JkD6xX4qhOJTbFieBUW9HWXomjOpXYTKKdYpeBBEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABAITCP3YDF5m9HzRYXh4+O3m5uamwC2yFujKOdeRUa2qxZDnmuIJP+pzrscwWtWRxvjqQWvxWPdSPIXws4qKitbJyck10gGkbyLdjScTfo0XTe5F6VTS9v22LTHHunHjhlq2bFk053JzLEMNo4NZ1WpIHD24OZaC/YcyWfXLb8VSDy76s3CiP+Cxlup169YtXr58eb7td+/eVdevX/8cz1V9CgfbCecK9Qp/0vaDgE70eazR0dHG3t7eviAN8qWbU7XQ+60v3UhKuVo1NhVLPXLRFy1adH7Lli2P1tfXL66pqVF4Hit/SFpkkic6ohu02UnbD9qeREcs3ZjQI5fbiKUNu8VtRrB+udXz0YdKDeFwC683+aoHF30pRqp/iuPg6U43a3k5ngRVFy5c+Bgj19f9TotJ2/dssEtmYiPW2rVrlT5qa2sbXeqf3+LVj+HxTBwRg6ypZPrTTvU/PIn+878r9ZU/Fw5Ji0yC6IiulClIiv+12/cqEca+lz23vFBv6bgZK0u5OJccTuF1J+FsGUarNllT6ZwDg0odtnzXiE7/6smChujeunWrFWcHdBmv2G7fS1fygtovZs8pP7ERy6myhSrDtLZaL9SFwckPZ5OwykQXZdbM1nKW2O07a01Lg9qfLuk/Rcfyz4qaAQjQsQLACquKqeqmbCnosPsxnZqOrTLRlTLTud4pu31vbaWC2i9mzymfjuVEJWYZpqpu2afSZl/JKrUfX2DzZXyVmRySFpkOoitl9Hmx2G6/mH5Q+8XsOeXTsZyoxCyTHXXZ/JStBAmLQF0W6v/6TuGQtMgkiI7oSpmCpPhfu32vEmHse9lzy6NjuZGJUS77URhVdvb393+mncvJvOSJjuj63cMSO0nbd2prMZmvDT4nI8U+K7SXwZejBq/LbePSbtx+HtcGqd2u/TxgPbI7jvXQgvhIJ/jFNuHSsQAioGMJOtklNz+EbsPItFpksviWdVLMH0InYl/ay0ACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACZUEAX2o/64eUyqJjZdiJijT1acOGDR/h50EyDQ0NF/EbMuYLU2nqwcJpa+jHZvKIzuWeUuPqPaSrPJCNI7debTPe99DxlYURK2cqXslkMu1dXV2RbfqqOCGlffv2PXD79u3frVy58gdHjx79IqFq5sRstPcKxVl6cp1qSnW4tj6jOuNwKpv9jXh26T08OdlZXV196Pjx4+O2/NCnsPlH2N5hN4BnqM7gWaoX7PIo53CqTtS1E/HHsPNSFFvzrWz0R5O/pg4pQ11x7JjIJT+BgAtShaNjZGTkr21tbU/FVcWSJUtehBMNWe3JucitsqhpOHAT2v9TsSOxnEe1OZ/KR3eszca4qlTt6JR91CjIJT/ZsHFqauoipsn1cVRz4sSJT2FnDw497Uq8x5THUYVqb2+vhqE3cOiliMRvmPJY6phrI9EdS3ogU6JMedaQzBRorSGfxmgi66wG/FrV1VmZIQWY8vpgN/+L7RLLeUhTjsXGxsaOYZRaZc2Uc5FbZWlOR1tjWXsuU94N9T38n2/MT40JTYG6SlxwGQkPYY3VGecaS9vHgvoXWPs8KrGWxRWba7VY12txtS0uO3oojsee3CVOqIuYGr+ZwIJd6btCGaXwH96OUcp5bRdPb2glAoF4pkLdgMKWQixbC9qkNZZRCsdBjFL1dCorGaYjEeDOeyR8LEwCJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACaSMQ71s66L1+k6YYCLwMEXvdM+r0+zs8IX62ZEY9Pk/27t27BK+pjdnV3eR2vbSdx/uWDnovb9EUg+BHp5gNH/lF2wEbfnR8VOWtgtfn818FgH+6WqumnMtXBEi+VV4O6dgdCy9jdng5juSJTuLw2gypw8txDuJHlhJvx65dux7CO5DPoy3yU5d92rnMWN6wzkq+jFxIl00wkuqJ/BcC2MtW+yVzKmulXbkOnM5oB85L4lS6GVYngmwQ3zXxPL6G6U9Ii7PhN+1VE5YGw4jLJiTmWELI6lxz4lT6Ms10rpI6lW6CzbnkZ3wX4yhLp5I+J+pYUgGA5iROfLEulXgFvZgv0WLdqSnbt2//BkaqvyFPnOpzjFxPnz179h9OummXxb7GSjuQpNovI5Y5/eWdCvUslnNzJEuq2jmzS8cqAXrbNChrrKdRrUyDMxb0JWhKyaqgYyWMWu4KUUX+7g9xfk1lTn9N5nneucrtrrAUjvUOfvNYIM5tMNQ7+HK4krfj1KlTn+HGRe4AZyzUzbvAvHNJvtPm6dwCY+2pIOA2IpkjWir6wEaSAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmUnoARpkq8cJp/8yZoWbwO5qu+pO0HbTf1gxMI/dO9eEEgUG14FDeQftL26+rqAv1zDAwM+PqnCNTJMlYuxTPvZYyPXXMjkJhjDX+h1LHrbtVSXu4EQk+FXmDEqZrexmsp/ylovbjOS3vu8vxOb0Gnzbnr0fypOfKIJaOSOJIOVqfKfgmv2H9V5zBeSAQiOZY41Q8HCqOTOJTdqfoalap9ID04ZWTSo5M1nZ4ezJ+WRpoKZTQ6dq0w5cnUJ0GmPxmp0uZUhdbzb1wEIjmWjEbiQNb1VJqdyrrmsqbjgr2Q7ESaCgWUONdbjYVRKo1OZZ3y3NILySHi6mukEUs3YoXpXLKDmKY1lW4/4/gJxOJY0ixxrjQG65Tnlk5jv+a6zbE51lx3JEz9+g4wTFmW8SYQ2rGCfvbn3YzZuUnbt45Os2unhARIgARIgARIgARIgARIgARIgARIgARIgARIYCEQ+D9RZOqPG2fqIQAAAABJRU5ErkJggg==)
      no-repeat -37px -118px;
  }

  .tui-grid-editor-label-icon-checkbox-checked::before {
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACMCAYAAACeTFAfAAAAAXNSR0IArs4c6QAAC/1JREFUeAHtnV9sFMcdx2fPNiEEqGPFkFYFUkilhiMKwfghNarspC9+KK0gtkUQYLUSD6loqyoqlSoRE8m0VFUUgsoDUisCtMh24YE++KWJE4lgqcGUqDKpVEAhRlXAVZxi4ib1n+v3d7eD1+vdvf179p6/I61n9je/+c3MZ3+emZ3bvVOKgQRIgARIgARIgARIgARIgARIgARIgARIgATmPwFj/jextC3MNTQsmxgZeSmXy20FnMel9pxS1wzDOF/58MO/Md59d7S0LUpnbXQsy3Ubz2afzU1N/V7lcmss4umkYdw0MpnvVw0OvjUtZMqJAB3LpCJOpSYn/4LRyZMJMnOqouLbUZxrx44dj0xMTJysrKzcfebMmX87XZigsiRsXrp06RGM1Ccxeu/evHlzoHZmgnagHPVl+pORyu5UVR98oOSwBtHJ66KMVe433dLS8iCc6jz0myWWc79l3fSSsDk0NPSgTP9wqmaJ5dytfic5HQtUZE3lOv05UcNUmS/jlOch6+joEN6ncTxjqkl82pSbomBREjbhTJk7d+6cRpxvp8TmuW9/8a0YrLvp0sYI9N2gLQbsrUHLDA4Ovooy22zltplym9jfaRI2L1++/Cr6N6Odci5yf60qsp5wM9Ld3Y0ZIXxobW31XMdoy/v3749Uz+HDh33VM/7EE6MAt1TXq2M9DSJfi+7HmB7uIT/UdHjfSBknfIEv4/7nu0bHiv8KV4YxWW4jFobFa+Cw0c7CaaTSOmYZfcrYRoAjFoCMr19/EOusAzY29+8InRwM+1mvVF29+rK9DM8LBDhigYPsqI9/8ske33eG2CiVMkGdCNsCr6HMjx3KHenp6fmJg7yoaGBg4DWsD2fZxBrwSF1dXSibcbSTI5Z56UqxQSpbA7iL60GV1juuc9lstgV5U0W9yEEBTpXB3VqP3LXpbDjVuU2bNrUgDmUzjnbSsfTVQFyKj3TMDdE3UZ3sEfXjeA6j1X8Rhw6yeYl9pjfhXM/AmfpXrFjx3KpVqyLZjNpO7mNZLqd8TFNVU/OkrJ8gfh8X6Z4cyjCu5NdUyIvyUY5UJU6Ej3JkD6xX4qhOJTbFieBUW9HWXomjOpXYTKKdYpeBBEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABAITCP3YDF5m9HzRYXh4+O3m5uamwC2yFujKOdeRUa2qxZDnmuIJP+pzrscwWtWRxvjqQWvxWPdSPIXws4qKitbJyck10gGkbyLdjScTfo0XTe5F6VTS9v22LTHHunHjhlq2bFk053JzLEMNo4NZ1WpIHD24OZaC/YcyWfXLb8VSDy76s3CiP+Cxlup169YtXr58eb7td+/eVdevX/8cz1V9CgfbCecK9Qp/0vaDgE70eazR0dHG3t7eviAN8qWbU7XQ+60v3UhKuVo1NhVLPXLRFy1adH7Lli2P1tfXL66pqVF4Hit/SFpkkic6ohu02UnbD9qeREcs3ZjQI5fbiKUNu8VtRrB+udXz0YdKDeFwC683+aoHF30pRqp/iuPg6U43a3k5ngRVFy5c+Bgj19f9TotJ2/dssEtmYiPW2rVrlT5qa2sbXeqf3+LVj+HxTBwRg6ypZPrTTvU/PIn+878r9ZU/Fw5Ji0yC6IiulClIiv+12/cqEca+lz23vFBv6bgZK0u5OJccTuF1J+FsGUarNllT6ZwDg0odtnzXiE7/6smChujeunWrFWcHdBmv2G7fS1fygtovZs8pP7ERy6myhSrDtLZaL9SFwckPZ5OwykQXZdbM1nKW2O07a01Lg9qfLuk/Rcfyz4qaAQjQsQLACquKqeqmbCnosPsxnZqOrTLRlTLTud4pu31vbaWC2i9mzymfjuVEJWYZpqpu2afSZl/JKrUfX2DzZXyVmRySFpkOoitl9Hmx2G6/mH5Q+8XsOeXTsZyoxCyTHXXZ/JStBAmLQF0W6v/6TuGQtMgkiI7oSpmCpPhfu32vEmHse9lzy6NjuZGJUS77URhVdvb393+mncvJvOSJjuj63cMSO0nbd2prMZmvDT4nI8U+K7SXwZejBq/LbePSbtx+HtcGqd2u/TxgPbI7jvXQgvhIJ/jFNuHSsQAioGMJOtklNz+EbsPItFpksviWdVLMH0InYl/ay0ACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACZUEAX2o/64eUyqJjZdiJijT1acOGDR/h50EyDQ0NF/EbMuYLU2nqwcJpa+jHZvKIzuWeUuPqPaSrPJCNI7debTPe99DxlYURK2cqXslkMu1dXV2RbfqqOCGlffv2PXD79u3frVy58gdHjx79IqFq5sRstPcKxVl6cp1qSnW4tj6jOuNwKpv9jXh26T08OdlZXV196Pjx4+O2/NCnsPlH2N5hN4BnqM7gWaoX7PIo53CqTtS1E/HHsPNSFFvzrWz0R5O/pg4pQ11x7JjIJT+BgAtShaNjZGTkr21tbU/FVcWSJUtehBMNWe3JucitsqhpOHAT2v9TsSOxnEe1OZ/KR3eszca4qlTt6JR91CjIJT/ZsHFqauoipsn1cVRz4sSJT2FnDw497Uq8x5THUYVqb2+vhqE3cOiliMRvmPJY6phrI9EdS3ogU6JMedaQzBRorSGfxmgi66wG/FrV1VmZIQWY8vpgN/+L7RLLeUhTjsXGxsaOYZRaZc2Uc5FbZWlOR1tjWXsuU94N9T38n2/MT40JTYG6SlxwGQkPYY3VGecaS9vHgvoXWPs8KrGWxRWba7VY12txtS0uO3oojsee3CVOqIuYGr+ZwIJd6btCGaXwH96OUcp5bRdPb2glAoF4pkLdgMKWQixbC9qkNZZRCsdBjFL1dCorGaYjEeDOeyR8LEwCJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACaSMQ71s66L1+k6YYCLwMEXvdM+r0+zs8IX62ZEY9Pk/27t27BK+pjdnV3eR2vbSdx/uWDnovb9EUg+BHp5gNH/lF2wEbfnR8VOWtgtfn818FgH+6WqumnMtXBEi+VV4O6dgdCy9jdng5juSJTuLw2gypw8txDuJHlhJvx65dux7CO5DPoy3yU5d92rnMWN6wzkq+jFxIl00wkuqJ/BcC2MtW+yVzKmulXbkOnM5oB85L4lS6GVYngmwQ3zXxPL6G6U9Ii7PhN+1VE5YGw4jLJiTmWELI6lxz4lT6Ms10rpI6lW6CzbnkZ3wX4yhLp5I+J+pYUgGA5iROfLEulXgFvZgv0WLdqSnbt2//BkaqvyFPnOpzjFxPnz179h9OummXxb7GSjuQpNovI5Y5/eWdCvUslnNzJEuq2jmzS8cqAXrbNChrrKdRrUyDMxb0JWhKyaqgYyWMWu4KUUX+7g9xfk1lTn9N5nneucrtrrAUjvUOfvNYIM5tMNQ7+HK4krfj1KlTn+HGRe4AZyzUzbvAvHNJvtPm6dwCY+2pIOA2IpkjWir6wEaSAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmUnoARpkq8cJp/8yZoWbwO5qu+pO0HbTf1gxMI/dO9eEEgUG14FDeQftL26+rqAv1zDAwM+PqnCNTJMlYuxTPvZYyPXXMjkJhjDX+h1LHrbtVSXu4EQk+FXmDEqZrexmsp/ylovbjOS3vu8vxOb0Gnzbnr0fypOfKIJaOSOJIOVqfKfgmv2H9V5zBeSAQiOZY41Q8HCqOTOJTdqfoalap9ID04ZWTSo5M1nZ4ezJ+WRpoKZTQ6dq0w5cnUJ0GmPxmp0uZUhdbzb1wEIjmWjEbiQNb1VJqdyrrmsqbjgr2Q7ESaCgWUONdbjYVRKo1OZZ3y3NILySHi6mukEUs3YoXpXLKDmKY1lW4/4/gJxOJY0ixxrjQG65Tnlk5jv+a6zbE51lx3JEz9+g4wTFmW8SYQ2rGCfvbn3YzZuUnbt45Os2unhARIgARIgARIgARIgARIgARIgARIgARIgARIYCEQ+D9RZOqPG2fqIQAAAABJRU5ErkJggg==)
      no-repeat -13px -118px;
  }

  .tui-grid-editor-label-icon-radio::before {
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACMCAYAAACeTFAfAAAAAXNSR0IArs4c6QAAC/1JREFUeAHtnV9sFMcdx2fPNiEEqGPFkFYFUkilhiMKwfghNarspC9+KK0gtkUQYLUSD6loqyoqlSoRE8m0VFUUgsoDUisCtMh24YE++KWJE4lgqcGUqDKpVEAhRlXAVZxi4ib1n+v3d7eD1+vdvf179p6/I61n9je/+c3MZ3+emZ3bvVOKgQRIgARIgARIgARIgARIgARIgARIgARIgATmPwFj/jextC3MNTQsmxgZeSmXy20FnMel9pxS1wzDOF/58MO/Md59d7S0LUpnbXQsy3Ubz2afzU1N/V7lcmss4umkYdw0MpnvVw0OvjUtZMqJAB3LpCJOpSYn/4LRyZMJMnOqouLbUZxrx44dj0xMTJysrKzcfebMmX87XZigsiRsXrp06RGM1Ccxeu/evHlzoHZmgnagHPVl+pORyu5UVR98oOSwBtHJ66KMVe433dLS8iCc6jz0myWWc79l3fSSsDk0NPSgTP9wqmaJ5dytfic5HQtUZE3lOv05UcNUmS/jlOch6+joEN6ncTxjqkl82pSbomBREjbhTJk7d+6cRpxvp8TmuW9/8a0YrLvp0sYI9N2gLQbsrUHLDA4Ovooy22zltplym9jfaRI2L1++/Cr6N6Odci5yf60qsp5wM9Ld3Y0ZIXxobW31XMdoy/v3749Uz+HDh33VM/7EE6MAt1TXq2M9DSJfi+7HmB7uIT/UdHjfSBknfIEv4/7nu0bHiv8KV4YxWW4jFobFa+Cw0c7CaaTSOmYZfcrYRoAjFoCMr19/EOusAzY29+8InRwM+1mvVF29+rK9DM8LBDhigYPsqI9/8ske33eG2CiVMkGdCNsCr6HMjx3KHenp6fmJg7yoaGBg4DWsD2fZxBrwSF1dXSibcbSTI5Z56UqxQSpbA7iL60GV1juuc9lstgV5U0W9yEEBTpXB3VqP3LXpbDjVuU2bNrUgDmUzjnbSsfTVQFyKj3TMDdE3UZ3sEfXjeA6j1X8Rhw6yeYl9pjfhXM/AmfpXrFjx3KpVqyLZjNpO7mNZLqd8TFNVU/OkrJ8gfh8X6Z4cyjCu5NdUyIvyUY5UJU6Ej3JkD6xX4qhOJTbFieBUW9HWXomjOpXYTKKdYpeBBEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABAITCP3YDF5m9HzRYXh4+O3m5uamwC2yFujKOdeRUa2qxZDnmuIJP+pzrscwWtWRxvjqQWvxWPdSPIXws4qKitbJyck10gGkbyLdjScTfo0XTe5F6VTS9v22LTHHunHjhlq2bFk053JzLEMNo4NZ1WpIHD24OZaC/YcyWfXLb8VSDy76s3CiP+Cxlup169YtXr58eb7td+/eVdevX/8cz1V9CgfbCecK9Qp/0vaDgE70eazR0dHG3t7eviAN8qWbU7XQ+60v3UhKuVo1NhVLPXLRFy1adH7Lli2P1tfXL66pqVF4Hit/SFpkkic6ohu02UnbD9qeREcs3ZjQI5fbiKUNu8VtRrB+udXz0YdKDeFwC683+aoHF30pRqp/iuPg6U43a3k5ngRVFy5c+Bgj19f9TotJ2/dssEtmYiPW2rVrlT5qa2sbXeqf3+LVj+HxTBwRg6ypZPrTTvU/PIn+878r9ZU/Fw5Ji0yC6IiulClIiv+12/cqEca+lz23vFBv6bgZK0u5OJccTuF1J+FsGUarNllT6ZwDg0odtnzXiE7/6smChujeunWrFWcHdBmv2G7fS1fygtovZs8pP7ERy6myhSrDtLZaL9SFwckPZ5OwykQXZdbM1nKW2O07a01Lg9qfLuk/Rcfyz4qaAQjQsQLACquKqeqmbCnosPsxnZqOrTLRlTLTud4pu31vbaWC2i9mzymfjuVEJWYZpqpu2afSZl/JKrUfX2DzZXyVmRySFpkOoitl9Hmx2G6/mH5Q+8XsOeXTsZyoxCyTHXXZ/JStBAmLQF0W6v/6TuGQtMgkiI7oSpmCpPhfu32vEmHse9lzy6NjuZGJUS77URhVdvb393+mncvJvOSJjuj63cMSO0nbd2prMZmvDT4nI8U+K7SXwZejBq/LbePSbtx+HtcGqd2u/TxgPbI7jvXQgvhIJ/jFNuHSsQAioGMJOtklNz+EbsPItFpksviWdVLMH0InYl/ay0ACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACZUEAX2o/64eUyqJjZdiJijT1acOGDR/h50EyDQ0NF/EbMuYLU2nqwcJpa+jHZvKIzuWeUuPqPaSrPJCNI7debTPe99DxlYURK2cqXslkMu1dXV2RbfqqOCGlffv2PXD79u3frVy58gdHjx79IqFq5sRstPcKxVl6cp1qSnW4tj6jOuNwKpv9jXh26T08OdlZXV196Pjx4+O2/NCnsPlH2N5hN4BnqM7gWaoX7PIo53CqTtS1E/HHsPNSFFvzrWz0R5O/pg4pQ11x7JjIJT+BgAtShaNjZGTkr21tbU/FVcWSJUtehBMNWe3JucitsqhpOHAT2v9TsSOxnEe1OZ/KR3eszca4qlTt6JR91CjIJT/ZsHFqauoipsn1cVRz4sSJT2FnDw497Uq8x5THUYVqb2+vhqE3cOiliMRvmPJY6phrI9EdS3ogU6JMedaQzBRorSGfxmgi66wG/FrV1VmZIQWY8vpgN/+L7RLLeUhTjsXGxsaOYZRaZc2Uc5FbZWlOR1tjWXsuU94N9T38n2/MT40JTYG6SlxwGQkPYY3VGecaS9vHgvoXWPs8KrGWxRWba7VY12txtS0uO3oojsee3CVOqIuYGr+ZwIJd6btCGaXwH96OUcp5bRdPb2glAoF4pkLdgMKWQixbC9qkNZZRCsdBjFL1dCorGaYjEeDOeyR8LEwCJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACaSMQ71s66L1+k6YYCLwMEXvdM+r0+zs8IX62ZEY9Pk/27t27BK+pjdnV3eR2vbSdx/uWDnovb9EUg+BHp5gNH/lF2wEbfnR8VOWtgtfn818FgH+6WqumnMtXBEi+VV4O6dgdCy9jdng5juSJTuLw2gypw8txDuJHlhJvx65dux7CO5DPoy3yU5d92rnMWN6wzkq+jFxIl00wkuqJ/BcC2MtW+yVzKmulXbkOnM5oB85L4lS6GVYngmwQ3zXxPL6G6U9Ii7PhN+1VE5YGw4jLJiTmWELI6lxz4lT6Ms10rpI6lW6CzbnkZ3wX4yhLp5I+J+pYUgGA5iROfLEulXgFvZgv0WLdqSnbt2//BkaqvyFPnOpzjFxPnz179h9OummXxb7GSjuQpNovI5Y5/eWdCvUslnNzJEuq2jmzS8cqAXrbNChrrKdRrUyDMxb0JWhKyaqgYyWMWu4KUUX+7g9xfk1lTn9N5nneucrtrrAUjvUOfvNYIM5tMNQ7+HK4krfj1KlTn+HGRe4AZyzUzbvAvHNJvtPm6dwCY+2pIOA2IpkjWir6wEaSAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmUnoARpkq8cJp/8yZoWbwO5qu+pO0HbTf1gxMI/dO9eEEgUG14FDeQftL26+rqAv1zDAwM+PqnCNTJMlYuxTPvZYyPXXMjkJhjDX+h1LHrbtVSXu4EQk+FXmDEqZrexmsp/ylovbjOS3vu8vxOb0Gnzbnr0fypOfKIJaOSOJIOVqfKfgmv2H9V5zBeSAQiOZY41Q8HCqOTOJTdqfoalap9ID04ZWTSo5M1nZ4ezJ+WRpoKZTQ6dq0w5cnUJ0GmPxmp0uZUhdbzb1wEIjmWjEbiQNb1VJqdyrrmsqbjgr2Q7ESaCgWUONdbjYVRKo1OZZ3y3NILySHi6mukEUs3YoXpXLKDmKY1lW4/4/gJxOJY0ixxrjQG65Tnlk5jv+a6zbE51lx3JEz9+g4wTFmW8SYQ2rGCfvbn3YzZuUnbt45Os2unhARIgARIgARIgARIgARIgARIgARIgARIgARIYCEQ+D9RZOqPG2fqIQAAAABJRU5ErkJggg==)
      no-repeat -113px -35px;
  }

  .tui-grid-editor-label-icon-radio-checked::before {
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACMCAYAAACeTFAfAAAAAXNSR0IArs4c6QAAC/1JREFUeAHtnV9sFMcdx2fPNiEEqGPFkFYFUkilhiMKwfghNarspC9+KK0gtkUQYLUSD6loqyoqlSoRE8m0VFUUgsoDUisCtMh24YE++KWJE4lgqcGUqDKpVEAhRlXAVZxi4ib1n+v3d7eD1+vdvf179p6/I61n9je/+c3MZ3+emZ3bvVOKgQRIgARIgARIgARIgARIgARIgARIgARIgATmPwFj/jextC3MNTQsmxgZeSmXy20FnMel9pxS1wzDOF/58MO/Md59d7S0LUpnbXQsy3Ubz2afzU1N/V7lcmss4umkYdw0MpnvVw0OvjUtZMqJAB3LpCJOpSYn/4LRyZMJMnOqouLbUZxrx44dj0xMTJysrKzcfebMmX87XZigsiRsXrp06RGM1Ccxeu/evHlzoHZmgnagHPVl+pORyu5UVR98oOSwBtHJ66KMVe433dLS8iCc6jz0myWWc79l3fSSsDk0NPSgTP9wqmaJ5dytfic5HQtUZE3lOv05UcNUmS/jlOch6+joEN6ncTxjqkl82pSbomBREjbhTJk7d+6cRpxvp8TmuW9/8a0YrLvp0sYI9N2gLQbsrUHLDA4Ovooy22zltplym9jfaRI2L1++/Cr6N6Odci5yf60qsp5wM9Ld3Y0ZIXxobW31XMdoy/v3749Uz+HDh33VM/7EE6MAt1TXq2M9DSJfi+7HmB7uIT/UdHjfSBknfIEv4/7nu0bHiv8KV4YxWW4jFobFa+Cw0c7CaaTSOmYZfcrYRoAjFoCMr19/EOusAzY29+8InRwM+1mvVF29+rK9DM8LBDhigYPsqI9/8ske33eG2CiVMkGdCNsCr6HMjx3KHenp6fmJg7yoaGBg4DWsD2fZxBrwSF1dXSibcbSTI5Z56UqxQSpbA7iL60GV1juuc9lstgV5U0W9yEEBTpXB3VqP3LXpbDjVuU2bNrUgDmUzjnbSsfTVQFyKj3TMDdE3UZ3sEfXjeA6j1X8Rhw6yeYl9pjfhXM/AmfpXrFjx3KpVqyLZjNpO7mNZLqd8TFNVU/OkrJ8gfh8X6Z4cyjCu5NdUyIvyUY5UJU6Ej3JkD6xX4qhOJTbFieBUW9HWXomjOpXYTKKdYpeBBEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABAITCP3YDF5m9HzRYXh4+O3m5uamwC2yFujKOdeRUa2qxZDnmuIJP+pzrscwWtWRxvjqQWvxWPdSPIXws4qKitbJyck10gGkbyLdjScTfo0XTe5F6VTS9v22LTHHunHjhlq2bFk053JzLEMNo4NZ1WpIHD24OZaC/YcyWfXLb8VSDy76s3CiP+Cxlup169YtXr58eb7td+/eVdevX/8cz1V9CgfbCecK9Qp/0vaDgE70eazR0dHG3t7eviAN8qWbU7XQ+60v3UhKuVo1NhVLPXLRFy1adH7Lli2P1tfXL66pqVF4Hit/SFpkkic6ohu02UnbD9qeREcs3ZjQI5fbiKUNu8VtRrB+udXz0YdKDeFwC683+aoHF30pRqp/iuPg6U43a3k5ngRVFy5c+Bgj19f9TotJ2/dssEtmYiPW2rVrlT5qa2sbXeqf3+LVj+HxTBwRg6ypZPrTTvU/PIn+878r9ZU/Fw5Ji0yC6IiulClIiv+12/cqEca+lz23vFBv6bgZK0u5OJccTuF1J+FsGUarNllT6ZwDg0odtnzXiE7/6smChujeunWrFWcHdBmv2G7fS1fygtovZs8pP7ERy6myhSrDtLZaL9SFwckPZ5OwykQXZdbM1nKW2O07a01Lg9qfLuk/Rcfyz4qaAQjQsQLACquKqeqmbCnosPsxnZqOrTLRlTLTud4pu31vbaWC2i9mzymfjuVEJWYZpqpu2afSZl/JKrUfX2DzZXyVmRySFpkOoitl9Hmx2G6/mH5Q+8XsOeXTsZyoxCyTHXXZ/JStBAmLQF0W6v/6TuGQtMgkiI7oSpmCpPhfu32vEmHse9lzy6NjuZGJUS77URhVdvb393+mncvJvOSJjuj63cMSO0nbd2prMZmvDT4nI8U+K7SXwZejBq/LbePSbtx+HtcGqd2u/TxgPbI7jvXQgvhIJ/jFNuHSsQAioGMJOtklNz+EbsPItFpksviWdVLMH0InYl/ay0ACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACZUEAX2o/64eUyqJjZdiJijT1acOGDR/h50EyDQ0NF/EbMuYLU2nqwcJpa+jHZvKIzuWeUuPqPaSrPJCNI7debTPe99DxlYURK2cqXslkMu1dXV2RbfqqOCGlffv2PXD79u3frVy58gdHjx79IqFq5sRstPcKxVl6cp1qSnW4tj6jOuNwKpv9jXh26T08OdlZXV196Pjx4+O2/NCnsPlH2N5hN4BnqM7gWaoX7PIo53CqTtS1E/HHsPNSFFvzrWz0R5O/pg4pQ11x7JjIJT+BgAtShaNjZGTkr21tbU/FVcWSJUtehBMNWe3JucitsqhpOHAT2v9TsSOxnEe1OZ/KR3eszca4qlTt6JR91CjIJT/ZsHFqauoipsn1cVRz4sSJT2FnDw497Uq8x5THUYVqb2+vhqE3cOiliMRvmPJY6phrI9EdS3ogU6JMedaQzBRorSGfxmgi66wG/FrV1VmZIQWY8vpgN/+L7RLLeUhTjsXGxsaOYZRaZc2Uc5FbZWlOR1tjWXsuU94N9T38n2/MT40JTYG6SlxwGQkPYY3VGecaS9vHgvoXWPs8KrGWxRWba7VY12txtS0uO3oojsee3CVOqIuYGr+ZwIJd6btCGaXwH96OUcp5bRdPb2glAoF4pkLdgMKWQixbC9qkNZZRCsdBjFL1dCorGaYjEeDOeyR8LEwCJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACaSMQ71s66L1+k6YYCLwMEXvdM+r0+zs8IX62ZEY9Pk/27t27BK+pjdnV3eR2vbSdx/uWDnovb9EUg+BHp5gNH/lF2wEbfnR8VOWtgtfn818FgH+6WqumnMtXBEi+VV4O6dgdCy9jdng5juSJTuLw2gypw8txDuJHlhJvx65dux7CO5DPoy3yU5d92rnMWN6wzkq+jFxIl00wkuqJ/BcC2MtW+yVzKmulXbkOnM5oB85L4lS6GVYngmwQ3zXxPL6G6U9Ii7PhN+1VE5YGw4jLJiTmWELI6lxz4lT6Ms10rpI6lW6CzbnkZ3wX4yhLp5I+J+pYUgGA5iROfLEulXgFvZgv0WLdqSnbt2//BkaqvyFPnOpzjFxPnz179h9OummXxb7GSjuQpNovI5Y5/eWdCvUslnNzJEuq2jmzS8cqAXrbNChrrKdRrUyDMxb0JWhKyaqgYyWMWu4KUUX+7g9xfk1lTn9N5nneucrtrrAUjvUOfvNYIM5tMNQ7+HK4krfj1KlTn+HGRe4AZyzUzbvAvHNJvtPm6dwCY+2pIOA2IpkjWir6wEaSAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmUnoARpkq8cJp/8yZoWbwO5qu+pO0HbTf1gxMI/dO9eEEgUG14FDeQftL26+rqAv1zDAwM+PqnCNTJMlYuxTPvZYyPXXMjkJhjDX+h1LHrbtVSXu4EQk+FXmDEqZrexmsp/ylovbjOS3vu8vxOb0Gnzbnr0fypOfKIJaOSOJIOVqfKfgmv2H9V5zBeSAQiOZY41Q8HCqOTOJTdqfoalap9ID04ZWTSo5M1nZ4ezJ+WRpoKZTQ6dq0w5cnUJ0GmPxmp0uZUhdbzb1wEIjmWjEbiQNb1VJqdyrrmsqbjgr2Q7ESaCgWUONdbjYVRKo1OZZ3y3NILySHi6mukEUs3YoXpXLKDmKY1lW4/4/gJxOJY0ixxrjQG65Tnlk5jv+a6zbE51lx3JEz9+g4wTFmW8SYQ2rGCfvbn3YzZuUnbt45Os2unhARIgARIgARIgARIgARIgARIgARIgARIgARIYCEQ+D9RZOqPG2fqIQAAAABJRU5ErkJggg==)
      no-repeat -89px -35px;
  }

  .tui-grid-editor-datepicker-layer {
    margin-top: -4px;
    position: absolute;
    z-index: 100;
  }

  .tui-grid-editor-datepicker-layer * {
    box-sizing: border-box;
  }

  .tui-grid-container .tui-calendar-month .tui-calendar-body,
  .tui-grid-container .tui-calendar-year .tui-calendar-body {
    width: 220px;
  }

  .tui-grid-row-header-draggable {
    text-align: center;
    cursor: move; /* fallback if grab cursor is unsupported */
    cursor: grab;
  }

  .tui-grid-row-header-draggable span {
    display: inline-block;
    width: 1px;
    height: 1px;
    margin: 1px;
    line-height: 0;
    background: #5a6268;
  }

  .tui-grid-floating-row {
    z-index: 15;
    background: #fff;
    border: 1px solid #ddd;
    color: #5a6268;
    min-width: 200px;
    position: absolute;
    box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.08);
    border-radius: 3px;
    overflow: hidden;
  }

  .tui-grid-floating-cell {
    display: inline-block;
  }

  .tui-grid-floating-tree-cell {
    padding: 0 10px;
  }

  .tui-grid-floating-tree-cell-content {
    margin-left: 10px;
    vertical-align: middle;
  }

  .tui-grid-floating-tree-cell .tui-grid-tree-icon {
    position: relative;
    margin-top: -14px;
    display: inline-block;
  }

  .tui-grid-floating-line {
    position: absolute;
    height: 1px;
    background: #00a9ff;
    display: none;
    z-index: 15;
  }

  .tui-grid-cell.dragging {
    opacity: 0.5;
  }

  .tui-grid-cell.parent-cell {
    background-color: rgba(0, 169, 255, 0.15);
  }

  .tui-grid-container .tui-grid-context-menu {
    position: absolute;
    z-index: 15;
    width: auto;
    min-width: 197px;
    color: #333;
    box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.08);
    border: 1px solid #ccc;
    padding: 5px 0;
    background-color: #fff;
  }

  .tui-grid-context-menu .menu-item {
    position: relative;
    height: 32px;
    line-height: 32px;
    padding: 0 14px;
    cursor: pointer;
  }

  .tui-grid-context-menu .menu-item:hover {
    background-color: #d4e9f2;
  }

  .tui-grid-context-menu .menu-item.disabled {
    color: #ccc;
  }

  .tui-grid-context-menu .has-submenu::after {
    position: absolute;
    right: 10px;
    content: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAICAQAAACb+P2wAAAANklEQVQI12MoWlkUWsQAggxFzkUfi2IhTIYim6L3RRkQJkORcdHroioEswSmIBOmLQ6iDW4YAA8qHUEC0QE+AAAAAElFTkSuQmCC);
  }

  .tui-grid-context-menu .menu-item.separator {
    height: 1px;
    background: #ccc;
    margin: 5px 0;
  }

  .tui-grid-context-menu span {
    display: inline-block;
  }
`;

    const TuiGridThemeStyle = css `
  .tui-grid-border-line-top {
    border-top: 1px solid var(--vuerd-color-table);
  }
  .tui-grid-no-scroll-x .tui-grid-border-line-bottom {
    border-bottom: 1px solid var(--vuerd-color-table);
  }
  .tui-grid-frozen-border {
    background-color: var(--vuerd-color-table);
  }
  .tui-grid-container ::-webkit-scrollbar {
    background-color: #fff0;
  }
  .tui-grid-container ::-webkit-scrollbar-thumb {
    background-color: var(--vuerd-color-scrollbar-thumb);
  }
  .tui-grid-container ::-webkit-scrollbar-thumb:hover {
    background-color: var(--vuerd-color-scrollbar-thumb-active);
  }
  .tui-grid-container {
    scrollbar-3dlight-color: var(--vuerd-color-scrollbar-thumb);
    scrollbar-darkshadow-color: var(--vuerd-color-scrollbar-thumb);
    scrollbar-track-color: var(--vuerd-color-scrollbar-thumb);
    scrollbar-shadow-color: var(--vuerd-color-scrollbar-thumb);
    scrollbar-face-color: var(--vuerd-color-scrollbar-thumb);
    scrollbar-highlight-color: var(--vuerd-color-scrollbar-thumb);
    scrollbar-arrow-color: var(--vuerd-color-scrollbar-thumb);
  }
  .tui-grid-border-line-bottom {
    border-bottom: 1px solid var(--vuerd-color-table);
  }
  .tui-grid-content-area {
    border-color: var(--vuerd-color-table);
    background-color: var(--vuerd-color-table);
  }
  .tui-grid-scrollbar-y-inner-border {
    background-color: #fff0;
  }
  .tui-grid-scrollbar-y-outer-border {
    background-color: #fff0;
  }
  .tui-grid-scrollbar-right-top {
    background-color: #fff0;
    border-color: #fff0;
  }
  .tui-grid-scrollbar-right-bottom {
    background-color: #fff0;
    border-color: #fff0;
  }
  .tui-grid-scrollbar-left-bottom {
    background-color: #fff0;
    border-color: #fff0;
  }
  .tui-grid-scrollbar-frozen-border {
    background-color: #fff0;
    border-color: #fff0;
  }
  .tui-grid-height-resize-handle {
    background-color: #fff0;
    border-color: #fff0;
  }
  .tui-grid-pagination {
    background-color: transparent;
    border-color: transparent;
  }
  .tui-grid-layer-selection {
    background-color: var(--vuerd-color-focus);
    border-color: var(--vuerd-color-focus);
  }
  .tui-grid-header-area {
    background-color: var(--vuerd-color-table);
    border-color: var(--vuerd-color-table);
  }
  .tui-grid-body-area {
    background-color: var(--vuerd-color-table);
  }
  .tui-grid-summary-area {
    background-color: var(--vuerd-color-table);
    border-color: var(--vuerd-color-table);
  }
  .tui-grid-has-summary-top .tui-grid-body-area {
    border-color: var(--vuerd-color-table);
  }
  .tui-grid-cell {
    background-color: var(--vuerd-color-table);
    border-color: var(--vuerd-color-table);
    border-left-width: 0;
    border-right-width: 0;
    border-top-width: 1px;
    border-bottom-width: 1px;
    color: var(--vuerd-color-font);
  }
  .tui-grid-cell-editable {
    background-color: var(--vuerd-color-table);
    color: var(--vuerd-color-font);
  }
  .tui-grid-show-lside-area
    .tui-grid-lside-area
    .tui-grid-header-area
    .tui-grid-table {
    border-right-style: solid;
  }
  .tui-grid-cell-header {
    background-color: var(--vuerd-color-table);
    border-color: var(--vuerd-color-table);
    border-left-width: 1px;
    border-right-width: 1px;
    border-top-width: 1px;
    border-bottom-width: 1px;
    color: var(--vuerd-color-font);
  }
  .tui-grid-show-lside-area
    .tui-grid-lside-area
    .tui-grid-body-area
    .tui-grid-table {
    border-right-style: hidden;
  }
  .tui-grid-cell-row-header {
    background-color: #fff;
    border-color: #eee;
    border-left-width: 0;
    border-right-width: 0;
    border-top-width: 1px;
    border-bottom-width: 1px;
    color: #333;
  }
  .tui-grid-show-lside-area
    .tui-grid-lside-area
    .tui-grid-summary-area
    .tui-grid-table {
    border-right-style: hidden;
  }
  .tui-grid-cell-summary {
    background-color: #fff;
    border-color: #eee;
    border-left-width: 0;
    border-right-width: 0;
    color: #333;
  }
  .tui-grid-cell-required {
    background-color: #fffdeb;
  }
  .tui-grid-cell-disabled {
    background-color: #f9f9f9;
    color: #c1c1c1;
  }
  .tui-grid-cell-invalid.tui-grid-cell {
    background-color: #ffe5e5;
  }
  .tui-grid-cell-header.tui-grid-cell-selected {
    background-color: var(--vuerd-color-table);
    color: var(--vuerd-color-font);
  }
  .tui-grid-cell-row-header.tui-grid-cell-selected {
    background-color: #e5f6ff;
  }
  .tui-grid-layer-focus-border {
    background-color: var(--vuerd-color-focus);
  }
  .tui-grid-layer-editing {
    border-color: var(--vuerd-color-focus);
    background-color: var(--vuerd-color-table);
    padding: 0;
    border: none;
  }
  .tui-grid-layer-focus-deactive .tui-grid-layer-focus-border {
    background-color: #aaa;
  }
  .tui-grid-cell-dummy {
    background-color: #fff;
  }

  .tui-grid-layer-state {
    background-color: var(--vuerd-color-table) !important;
  }
  .tui-grid-layer-state p {
    color: var(--vuerd-color-font) !important;
  }
`;

    const FilterStyle = css `
  .vuerd-filter {
    width: 340px;
    display: flex;
    flex-direction: column;
    padding: 0 10px;
    box-sizing: border-box;
    position: absolute;
    right: 190px;
    color: var(--vuerd-color-font);
    background-color: var(--vuerd-color-menubar);
    opacity: 0.9;
    fill: #fff0;
    z-index: 2;
    padding: 10px;
  }

  .vuerd-filter:hover {
    fill: var(--vuerd-color-font);
  }

  .vuerd-filter .vuerd-filter-header {
    white-space: nowrap;
  }

  .vuerd-filter .vuerd-filter-header .vuerd-button {
    margin-left: 5px;
    float: right;
  }

  .vuerd-filter-item-move {
    transition: transform 0.3s;
  }
`;

    const FilterInputStyle = css `
  .vuerd-filter-input {
    display: inline-flex;
    vertical-align: middle;
    align-items: center;
    margin-right: ${SIZE_COLUMN_MARGIN_RIGHT}px;
    color: var(--vuerd-color-font-active);
    background-color: var(--vuerd-color-menubar);
  }

  input.vuerd-filter-input {
    outline: none;
    border: none;
    opacity: 0.9;
    padding: 1px 0 1px 0;
    height: 17px;
    font-size: ${SIZE_FONT}px;
    font-family: var(--vuerd-font-family);
  }

  div.vuerd-filter-input {
    border-bottom: solid #fff0 1.5px;
    height: ${SIZE_INPUT_EDIT_HEIGHT}px;
    cursor: default;
  }

  .vuerd-filter-input > span {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .vuerd-filter-input.select {
    background-color: var(--vuerd-color-column-select);
  }

  .vuerd-filter-input.active {
    background-color: var(--vuerd-color-column-active);
  }

  .vuerd-filter-input.focus {
    border-bottom: solid var(--vuerd-color-focus) 1.5px;
  }

  .vuerd-filter-input.edit {
    border-bottom: solid var(--vuerd-color-edit) 1.5px;
  }

  .vuerd-filter-input.placeholder {
    color: var(--vuerd-color-font-placeholder);
  }
`;

    const FilterItemStyle = css `
  .vuerd-filter-item {
    height: ${SIZE_COLUMN_HEIGHT}px;
    fill: #fff0;
  }

  .vuerd-filter-item:hover {
    fill: var(--vuerd-color-font);
  }

  .vuerd-filter-item.select {
    background-color: var(--vuerd-color-column-select);
  }

  .vuerd-filter-item.draggable {
    opacity: 0.5;
  }

  .vuerd-filter-item > vuerd-filter-radio-editor,
  .vuerd-filter-item > vuerd-input {
    float: left;
  }
`;

    const FilterRadioEditorStyle = css `
  .vuerd-filter-radio-editor {
    display: inline-flex;
    vertical-align: middle;
    align-items: center;
    position: relative;
  }

  .vuerd-group-value {
    display: inline-flex;
    vertical-align: middle;
    align-items: center;
    margin-right: ${SIZE_COLUMN_MARGIN_RIGHT}px;
    color: var(--vuerd-color-font-active);
    background-color: var(--vuerd-color-menubar);
    border-bottom: solid #fff0 1.5px;
    height: ${SIZE_INPUT_EDIT_HEIGHT}px;
    cursor: default;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .vuerd-group-value.focus {
    border-bottom: solid var(--vuerd-color-focus) 1.5px;
  }

  .vuerd-group-value.edit {
    border-bottom: solid var(--vuerd-color-edit) 1.5px;
  }

  .vuerd-group-value.placeholder {
    color: var(--vuerd-color-font-placeholder);
  }

  .vuerd-group-value.select {
    background-color: var(--vuerd-color-column-select);
  }

  .vuerd-filter-radio-group {
    position: absolute;
    z-index: 1;
    opacity: 0.9;
    top: 20.5px;
    left: 0;
    color: var(--vuerd-color-font);
    background-color: var(--vuerd-color-menubar);
    list-style: none;
    padding: 0;
    margin: 0;
    white-space: nowrap;
  }

  .vuerd-filter-radio-group > li {
    cursor: pointer;
    font-size: ${SIZE_FONT}px;
    display: flex;
    align-items: center;
  }

  .vuerd-filter-radio-group > li:hover,
  .vuerd-filter-radio-group > li.active {
    color: var(--vuerd-color-font-active);
    background-color: var(--vuerd-color-contextmenu-active);
  }

  .vuerd-filter-radio-group > li > input {
    margin: 0 3px 0 0;
    pointer-events: none;
  }

  .vuerd-filter-radio-group > li > label {
    flex-grow: 1;
    padding: 5px 5px 5px 0;
    pointer-events: none;
  }
`;

    const ColumnDataTypeEditorStyle = css `
  .vuerd-grid-column-data-type-editor {
    position: relative;
    width: 100%;
    height: 100%;
  }

  .vuerd-grid-column-data-type-hint {
    position: absolute;
    top: 41px;
    left: 0;
    z-index: 100;
    color: var(--vuerd-color-font-active);
    background-color: var(--vuerd-color-contextmenu);
    opacity: 0.9;
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .vuerd-grid-column-data-type-hint > li {
    padding: 5px;
    cursor: pointer;
    font-size: ${SIZE_FONT}px;
  }

  .vuerd-grid-column-data-type-hint > li:hover,
  .vuerd-grid-data-type-hint.active {
    background-color: var(--vuerd-color-contextmenu-active);
  }

  .vuerd-grid-column-data-type-hint
    > li:hover
    .vuerd-grid-column-data-type-hint-mark,
  .vuerd-grid-data-type-hint.active .vuerd-grid-column-data-type-hint-mark {
    color: var(--vuerd-color-font-active);
  }

  .vuerd-grid-column-data-type-hint-mark {
    color: var(--vuerd-color-edit);
  }

  /* animation flip */
  .vuerd-grid-data-type-hint-move {
    transition: transform 0.2s;
  }
`;

    const ColumnOptionEditorStyle = css `
  .vuerd-grid-column-option-editor {
    position: absolute;
    color: var(--vuerd-color-font-active);
    background-color: var(--vuerd-color-contextmenu);
    opacity: 0.9;
    list-style: none;
    padding: 0;
    margin: 0;
    z-index: 100;
  }

  .vuerd-grid-column-option-editor > li > input {
    outline: none;
    border: none;
    margin-right: 5px;
    cursor: pointer;
  }

  .vuerd-grid-column-option-editor > li {
    display: flex;
    vertical-align: middle;
    align-items: center;
    padding: 5px;
    cursor: pointer;
    font-size: ${SIZE_FONT}px;
  }

  .vuerd-grid-column-option-editor > li:hover,
  .vuerd-grid-column-option-editor > li.active {
    background-color: var(--vuerd-color-contextmenu-active);
  }
`;

    const GridTextEditorStyle = css `
  input.vuerd-grid-input {
    width: 100%;
    height: 100%;
    outline: none;
    font-size: ${SIZE_FONT}px;
    font-family: var(--vuerd-font-family);
    color: var(--vuerd-color-font-active);
    background-color: var(--vuerd-color-table);
    border-top: none !important;
    border-left: none !important;
    border-right: none !important;
    border-bottom: solid var(--vuerd-color-edit) 1.5px !important;
  }
`;

    const GridTextRenderStyle = css `
  .vuerd-grid-text {
    width: 100%;
    height: 100%;
    padding: 7px 6px;
    font-size: ${SIZE_FONT}px;
    font-family: var(--vuerd-font-family);
    color: var(--vuerd-color-font-active);
    border-bottom: solid #fff0 1.5px;
    box-sizing: border-box;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .vuerd-grid-text.placeholder {
    color: var(--vuerd-color-font-placeholder);
  }
`;

    const GridEditorStyle = css `
  .vuerd-grid-editor {
    position: relative;
    height: 100%;
    background-color: var(--vuerd-color-table);
    overflow: hidden;
  }

  .vuerd-grid-container {
    position: relative;
    height: 100%;
    z-index: 1;
  }
`;

    const IndexStyle$1 = [
        TuiGridStyle,
        TuiGridThemeStyle,
        DefaultStyle,
        GridEditorStyle,
        FilterStyle,
        FilterRadioEditorStyle,
        FilterItemStyle,
        FilterInputStyle,
        GridTextRenderStyle,
        GridTextEditorStyle,
        ColumnOptionEditorStyle,
        ColumnDataTypeEditorStyle,
        IconStyle,
    ].join('');

    const GridEditor = (props, ctx) => {
        const { keydown$ } = useKeydown(ctx);
        const gridRef = useGrid(props, ctx, keydown$);
        useGridKeymap(ctx);
        const onCloseFilter = () => {
            const { store, command } = ctx.api;
            const { filterActiveEnd$ } = command.editor;
            store.dispatch(filterActiveEnd$());
        };
        const onOutside = (event) => {
            const el = event.target;
            const { store, command } = ctx.api;
            const { editFilterEnd } = command.editor;
            if (!el.closest('.vuerd-filter')) {
                onCloseFilter();
            }
            if (!el.closest('.vuerd-filter-radio-editor') &&
                !el.closest('.vuerd-filter-input')) {
                store.dispatch(editFilterEnd());
            }
        };
        ctx.focus = () => gridRef.value.focus(0, 'tableName');
        return () => {
            const { filterState } = ctx.api.store.editorState;
            const context = { api: ctx.api, keydown$ };
            return html `
      <vuerd-grid-editor-provider .value=${context}>
        <div
          class="vuerd-grid-editor"
          @mousedown=${onOutside}
          @touchstart=${onOutside}
        >
          <div class="vuerd-grid-container"></div>
          <vuerd-filter
            .visible=${filterState.active}
            @close=${onCloseFilter}
          ></vuerd-filter>
        </div>
      </vuerd-grid-editor-provider>
    `;
        };
    };
    defineComponent('vuerd-grid-editor', {
        observedProps: [
            {
                name: 'width',
                default: 0,
            },
            {
                name: 'height',
                default: 0,
            },
        ],
        styleMap: {
            width: '100%',
            height: '100%',
        },
        style: IndexStyle$1,
        render: GridEditor,
    });

    class GridPanel {
        constructor(props, api) {
            this.el = document.createElement('vuerd-grid-editor');
            this.props = props;
            this.el.api = api;
            this.setViewport();
        }
        setViewport() {
            this.el.width = this.props.width;
            this.el.height = this.props.height;
        }
        beforeFirstUpdate() {
            this.setViewport();
        }
        beforeUpdate() {
            this.setViewport();
        }
        render() {
            return this.el;
        }
    }

    const gridPanelConfig = {
        type: GridPanel,
        icon: {
            prefix: 'fas',
            name: 'list',
        },
        key: '@vuerd/builtin-grid',
        name: 'Grid',
    };
    const gridPanel = () => gridPanelConfig;

    class SQLDDLPanel$1 {
        constructor() {
            this.el = document.createElement('vuerd-sql-ddl');
        }
        render() {
            return this.el;
        }
    }

    const SQLDDLPanelConfig = {
        type: SQLDDLPanel$1,
        icon: {
            prefix: 'mdi',
            name: 'database-export',
            size: 20,
        },
        key: '@vuerd/builtin-sql-ddl',
        name: 'SQL DDL',
    };
    const SQLDDLPanel = () => SQLDDLPanelConfig;

    function useAPI(ctx) {
        const ref = { value: null };
        beforeMount(() => {
            const el = closestElement('vuerd-visualization', ctx);
            if (!el)
                return;
            ref.value = el.api;
        });
        return ref;
    }

    function columnTpl(props, { store: { canvasState: { show, setting }, }, }) {
        const { column } = props;
        const reshapeColumns = setting.columnOrder
            .map(columnType => {
            switch (columnType) {
                case 'columnName':
                    return {
                        columnType,
                        template: html `
              <vuerd-input
                .width=${props.widthName}
                .value=${column.name}
                .active=${props.active}
                placeholder="column"
              ></vuerd-input>
            `,
                    };
                case 'columnDefault':
                    return show.columnDefault
                        ? {
                            columnType,
                            template: html `
                  <vuerd-input
                    .width=${props.widthDefault}
                    .value=${column.default}
                    .active=${props.active}
                    placeholder="default"
                  ></vuerd-input>
                `,
                        }
                        : null;
                case 'columnComment':
                    return show.columnComment
                        ? {
                            columnType,
                            template: html `
                  <vuerd-input
                    .width=${props.widthComment}
                    .value=${column.comment}
                    .active=${props.active}
                    placeholder="comment"
                  ></vuerd-input>
                `,
                        }
                        : null;
                case 'columnDataType':
                    return show.columnDataType
                        ? {
                            columnType,
                            template: html `
                  <vuerd-column-data-type
                    .width=${props.widthDataType}
                    .value=${column.dataType}
                    .active=${props.active}
                  ></vuerd-column-data-type>
                `,
                        }
                        : null;
                case 'columnNotNull':
                    return show.columnNotNull
                        ? {
                            columnType,
                            template: html `
                  <vuerd-column-not-null
                    .columnOption=${column.option}
                  ></vuerd-column-not-null>
                `,
                        }
                        : null;
                case 'columnUnique':
                    return show.columnUnique
                        ? {
                            columnType,
                            template: html `
                  <vuerd-column-unique
                    .columnOption=${column.option}
                  ></vuerd-column-unique>
                `,
                        }
                        : null;
                case 'columnAutoIncrement':
                    return show.columnAutoIncrement
                        ? {
                            columnType,
                            template: html `
                  <vuerd-column-auto-increment
                    .columnOption=${column.option}
                  ></vuerd-column-auto-increment>
                `,
                        }
                        : null;
                default:
                    return null;
            }
        })
            .filter(reshapeColumn => !!reshapeColumn);
        return repeat(reshapeColumns, reshapeColumn => reshapeColumn.columnType, reshapeColumn => reshapeColumn.template);
    }

    const VisualizationColumn = (props, ctx) => {
        const apiRef = useAPI(ctx);
        return () => {
            const { ui } = props.column;
            return html `
      <div
        class=${classMap({
            'vuerd-column': true,
            active: props.active,
        })}
      >
        <vuerd-column-key .ui=${ui}></vuerd-column-key>
        ${columnTpl(props, apiRef.value)}
      </div>
    `;
        };
    };
    defineComponent('vuerd-visualization-column', {
        observedProps: [
            'active',
            'widthName',
            'widthDataType',
            'widthNotNull',
            'widthDefault',
            'widthComment',
            'column',
        ],
        shadow: false,
        render: VisualizationColumn,
    });

    const VisualizationTable = (props, ctx) => {
        const apiRef = useAPI(ctx);
        return () => {
            var _a;
            const { show } = apiRef.value.store.canvasState;
            const { table } = props;
            const widthColumn = table.maxWidthColumn();
            return html `
      <div
        class="vuerd-table"
        style=${styleMap({
            top: `${props.top}px`,
            left: `${props.left}px`,
            width: `${table.width()}px`,
            height: `${table.height()}px`,
            position: 'fixed',
        })}
      >
        <div class="vuerd-table-header">
          <div class="vuerd-table-header-top">
            <div
              class="vuerd-table-header-color"
              style=${styleMap({
            width: `${table.width() + SIZE_TABLE_PADDING * 2}px`,
            backgroundColor: (_a = table.ui.color) !== null && _a !== void 0 ? _a : '',
        })}
            ></div>
          </div>
          <div class="vuerd-table-header-body">
            <vuerd-input
              class="vuerd-table-name"
              .width=${table.ui.widthName}
              .value=${table.name}
              placeholder="table"
            ></vuerd-input>
            ${show.tableComment
            ? html `
                  <vuerd-input
                    class="vuerd-table-comment"
                    .width=${table.ui.widthComment}
                    .value=${table.comment}
                    placeholder="comment"
                  ></vuerd-input>
                `
            : null}
          </div>
        </div>
        <div class="vuerd-table-body">
          ${repeat(props.table.columns, column => column.id, column => html `
                <vuerd-visualization-column
                  .column=${column}
                  .active=${props.columnId === column.id}
                  .widthName=${widthColumn.name}
                  .widthDataType=${widthColumn.dataType}
                  .widthNotNull=${widthColumn.notNull}
                  .widthDefault=${widthColumn.default}
                  .widthComment=${widthColumn.comment}
                ></vuerd-visualization-column>
              `)}
        </div>
      </div>
    `;
        };
    };
    defineComponent('vuerd-visualization-table', {
        observedProps: ['table', 'columnId', 'top', 'left'],
        shadow: false,
        render: VisualizationTable,
    });

    function convertVisualization(store) {
        const { tableState, relationshipState } = store;
        const data = {
            nodes: [],
            links: [],
        };
        const tables = tableState.tables;
        const relationships = relationshipState.relationships;
        tables.forEach(table => {
            data.nodes.push({
                id: table.id,
                name: table.name,
                group: 'table',
            });
            table.columns.forEach(column => {
                data.nodes.push({
                    id: column.id,
                    name: column.name,
                    group: 'column',
                    tableId: table.id,
                });
                data.links.push({
                    source: table.id,
                    target: column.id,
                });
            });
        });
        relationships.forEach(relationship => {
            const { start, end } = relationship;
            if (start.tableId !== end.tableId &&
                isLink(data.links, start.tableId, end.tableId)) {
                data.links.push({
                    source: start.tableId,
                    target: end.tableId,
                });
            }
        });
        return data;
    }
    function isLink(links, startTableId, endTableId) {
        let result = true;
        for (const link of links) {
            if (link.source === startTableId && link.target === endTableId) {
                result = false;
                break;
            }
        }
        return result;
    }
    /**
     * https://observablehq.com/@d3/disjoint-force-directed-graph
     */
    const scale$1 = ordinal(schemeCategory10);
    function onDrag(simulation, callbacks) {
        return drag()
            .on('start', (event, d) => {
            if (!event.active)
                simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
            callbacks.dragStart();
        })
            .on('drag', (event, d) => {
            d.fx = event.x;
            d.fy = event.y;
        })
            .on('end', (event, d) => {
            if (!event.active)
                simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
            callbacks.dragEnd();
        });
    }
    function createVisualization(store, callbacks) {
        const data = convertVisualization(store);
        const links = data.links.map(d => Object.create(d));
        const nodes = data.nodes.map(d => Object.create(d));
        const simulation = forceSimulation(nodes)
            .force('link', forceLink(links).id((d) => d.id))
            .force('charge', forceManyBody())
            .force('x', forceX())
            .force('y', forceY());
        const svg = create$1('svg');
        const link = svg
            .append('g')
            .attr('stroke', '#999')
            .attr('stroke-opacity', 0.6)
            .selectAll('line')
            .data(links)
            .join('line')
            .attr('stroke-width', Math.sqrt(2));
        const node = svg
            .append('g')
            .attr('stroke', '#fff')
            .attr('stroke-width', 1.5)
            .selectAll('circle')
            .data(nodes)
            .join('circle')
            .attr('r', 5)
            .attr('fill', d => scale$1(d.group))
            .call(onDrag(simulation, callbacks));
        node.on('mouseover', (event, d) => {
            const node = data.nodes[d.index];
            let tableId = null;
            let columnId = null;
            if (node.group === 'table') {
                tableId = node.id;
            }
            else if (node.group === 'column' && node.tableId) {
                tableId = node.tableId;
                columnId = node.id;
            }
            callbacks.startPreview(tableId, columnId);
        });
        node.on('mouseleave', () => {
            callbacks.endPreview();
        });
        simulation.on('tick', () => {
            link
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);
            node.attr('cx', d => d.x).attr('cy', d => d.y);
        });
        return svg;
    }

    const VisualizationStyle = css `
  .vuerd-visualization {
    position: relative;
    height: 100%;
    overflow: auto;
    background-color: var(--vuerd-color-visualization);
  }
`;

    const IndexStyle = [
        VisualizationStyle,
        ScrollbarStyle,
        TableStyle,
        InputStyle,
        ColumnStyle,
        ColumnKeyStyle,
        ColumnDataTypeStyle,
        ColumnNotNullStyle,
        ColumnUniqueStyle,
        ColumnAutoIncrementStyle,
    ].join('');

    const HEIGHT = 1200;
    const MARGIN = 20;
    const Visualization = (props, ctx) => {
        const state = observable$1({
            preview: false,
            drag: false,
            table: null,
            columnId: null,
            top: 0,
            left: 0,
        });
        let d3SVG = null;
        const { unmountedGroup } = useUnmounted();
        const dragStart = () => {
            state.drag = true;
        };
        const dragEnd = () => {
            state.drag = false;
        };
        const startPreview = (tableId, columnId) => {
            const { tables } = ctx.api.store.tableState;
            state.preview = true;
            state.table = getData(tables, tableId);
            state.columnId = columnId;
        };
        const endPreview = () => {
            state.preview = false;
        };
        const setViewBox = () => {
            d3SVG === null || d3SVG === void 0 ? void 0 : d3SVG.attr('viewBox', [
                -props.width / 2,
                -HEIGHT / 2,
                props.width,
                HEIGHT,
            ]);
        };
        const onMousemove = (event) => {
            state.top = event.clientY;
            state.left = event.clientX;
        };
        beforeMount(() => {
            d3SVG = createVisualization(ctx.api.store, {
                dragStart,
                dragEnd,
                startPreview,
                endPreview,
            });
            setViewBox();
            unmountedGroup.push(watch(props, propName => {
                if (propName !== 'width')
                    return;
                setViewBox();
            }));
        });
        unmounted(() => {
            d3SVG === null || d3SVG === void 0 ? void 0 : d3SVG.remove();
            d3SVG = null;
        });
        return () => html `
    <div class="vuerd-visualization vuerd-scrollbar" @mousemove=${onMousemove}>
      ${d3SVG.node()}
      ${state.table && !state.drag && state.preview
        ? html `
            <vuerd-visualization-table
              .table=${state.table}
              .columnId=${state.columnId}
              .top=${state.top}
              .left=${state.left + MARGIN}
            ></vuerd-visualization-table>
          `
        : null}
    </div>
  `;
    };
    defineComponent('vuerd-visualization', {
        observedProps: [
            {
                name: 'width',
                default: 0,
            },
            {
                name: 'height',
                default: 0,
            },
        ],
        styleMap: {
            width: '100%',
            height: '100%',
        },
        style: IndexStyle,
        render: Visualization,
    });

    class VisualizationPanel {
        constructor(props, api) {
            this.el = document.createElement('vuerd-visualization');
            this.props = props;
            this.el.api = api;
            this.setViewport();
        }
        setViewport() {
            this.el.width = this.props.width;
            this.el.height = this.props.height;
        }
        beforeFirstUpdate() {
            this.setViewport();
        }
        beforeUpdate() {
            this.setViewport();
        }
        render() {
            return this.el;
        }
    }

    addIcon(createMDI('chart-bubble', mdiChartBubble));
    const visualizationPanelConfig = {
        type: VisualizationPanel,
        icon: {
            prefix: 'mdi',
            name: 'chart-bubble',
            size: 24,
        },
        key: '@vuerd/builtin-visualization',
        name: 'Visualization',
    };
    const visualizationPanel = () => visualizationPanelConfig;

    extension({
        panels: [
            gridPanel(),
            visualizationPanel(),
            SQLDDLPanel(),
            generatorCodePanel(),
        ],
    });

    exports.addIcon = addIcon;
    exports.extension = extension;
    exports.observable = observable$1;
    exports.observer = observer;
    exports.setExportFileCallback = setExportFileCallback;
    exports.setImportFileCallback = setImportFileCallback;
    exports.watch = watch;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
